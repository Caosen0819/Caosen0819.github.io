<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring-事务</title>
      <link href="/2024/07/09/Spring-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/07/09/Spring-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>Spring事务管理有两种方式，一种是xml方式，一种是@transactional注解。一般第二种</p><p>Spring 在初始化时，会通过扫描拦截对事务的方法进行增强。如果目标方法存在事务，Spring 就会创建一个 Bean 对应的代理（Proxy）对象，并进行相关的事务处理操作。</p><p>从这个调用栈中我们看到了熟悉的 CglibAopProxy，另外事务本质上也是一种特殊的切面，在创建的过程中，被 CglibAopProxy 代理。事务处理的拦截器是 TransactionInterceptor，它支撑着整个事务功能的架构，我们来分析下这个拦截器是如何实现事务特性的。</p><h2 id="异常失效原因："><a href="#异常失效原因：" class="headerlink" title="异常失效原因："></a>异常失效原因：</h2><p>—-<strong>抛出异常错误</strong></p><p><strong>1 RuleBasedTransactionAttribute 自身的 rollbackOn()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rollbackOn</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">   <span class="comment">// 层级 1：根据&quot;rollbackRules&quot;及当前捕获异常来判断是否需要回滚</span></span><br><span class="line">   <span class="type">RollbackRuleAttribute</span> <span class="variable">winner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">deepest</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.rollbackRules != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (RollbackRuleAttribute rule : <span class="built_in">this</span>.rollbackRules) &#123;</span><br><span class="line">         <span class="comment">// 当前捕获的异常可能是回滚“异常”的继承体系中的“一员”</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> rule.getDepth(ex);</span><br><span class="line">         <span class="keyword">if</span> (depth &gt;= <span class="number">0</span> &amp;&amp; depth &lt; deepest) &#123;</span><br><span class="line">            deepest = depth;</span><br><span class="line">            winner = rule;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 层级 2：调用父类的 rollbackOn 方法来决策是否需要 rollback</span></span><br><span class="line">   <span class="keyword">if</span> (winner == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.rollbackOn(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> !(winner <span class="keyword">instanceof</span> NoRollbackRuleAttribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在 @Transactional 中配置了 rollbackFor，这个方法就会用捕获到的异常和 rollbackFor 中配置的异常做比较。如果捕获到的异常是 rollbackFor 配置的异常或其子类，就会直接 rollback。在我们的案例中，由于在事务的注解中没有加任何规则，所以这段逻辑处理其实找不到规则（即 winner &#x3D;&#x3D; null），进而走到下一步。</p><p><strong>2 RuleBasedTransactionAttribute 父类 DefaultTransactionAttribute 的 rollbackOn()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rollbackOn</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> (ex <span class="keyword">instanceof</span> RuntimeException || ex <span class="keyword">instanceof</span> Error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果没有在 @Transactional 中配置 rollback 属性，或是捕获到的异常和所配置异常的类型不一致，就会继续调用父类的 rollbackOn() 进行处理。</p><p>而在父类的 rollbackOn() 中，我们发现了一个重要的线索，只有在异常类型为 RuntimeException 或者 Error 的时候才会返回 true，此时，会触发 completeTransactionAfterThrowing 方法中的 rollback 操作，事务被回滚。</p><p><strong>—– public</strong></p><p>当 Bean 初始化之后，开始尝试代理操作，这个过程是从 AbstractAutoProxyCreator 里的 postProcessAfterInitialization 方法开始处理的.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class targetClass) &#123;</span><br><span class="line">   //省略非关键代码</span><br><span class="line">   if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   //省略非关键代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>—– 自调用</strong></p><h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><p>Spring 的事务机制，总结下重点：</p><ul><li>Spring 在事务处理中有一个很重要的属性 Propagation，主要用来配置当前需要执行的方法如何使用事务，以及与其它事务之间的关系。</li><li>Spring 默认的传播属性是 REQUIRED，在有事务状态下执行，如果当前没有事务，则创建新的事务；</li><li>Spring 事务是可以对多个数据源生效，它提供了一个抽象类 AbstractRoutingDataSource，通过实现这个抽象类，我们可以实现自定义的数据库切换。</li></ul><table><thead><tr><th><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。**(** 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 <strong>）</strong></th></tr></thead><tbody><tr><td><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行</td></tr><tr><td><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</td></tr><tr><td><code>Propagation.REQUIRES_NEW</code>：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。**(** 当类A中的 a 方法用默认<code>Propagation.REQUIRED</code>模式，类B中的 b方法加上采用 <code>Propagation.REQUIRES_NEW</code>模式，然后在 a 方法中调用 b方法操作数据库，然而 a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停 a方法的事务 <strong>)</strong></td></tr><tr><td><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</td></tr><tr><td><code>Propagation.NEVER</code>：以非事务的方式运行，如果当前存在事务，则抛出异常。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oauth2-权限校验简单理解篇</title>
      <link href="/2024/05/20/Oauth2-%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E7%90%86%E8%A7%A3%E7%AF%87/"/>
      <url>/2024/05/20/Oauth2-%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E7%90%86%E8%A7%A3%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="对权限校验和token的新理解"><a href="#对权限校验和token的新理解" class="headerlink" title="对权限校验和token的新理解"></a>对权限校验和token的新理解</h1><p>在我们前端页面发出请求的时候，会先发出一个预检请求，看看这个接口是否好用，但不会去检验这个接口是否正确。比如说：发出get请求，对info这个接口进行校验，所以他会先发一个get的预检验去看看你这个接口能不能收到我这个get。如果可以，get请求返回之后会告诉我们前端可以发送，这时候前端发出真正的请求（带着参数的那种）。</p><p>下面简单讲一下权限校验的流程，以防止自己忘记和供大家参考（勿喷）。</p><p>首先我们前端服务启动之后，假设端口是8090，我们输入账号密码点击登陆，这时候前端服务会<br>将其发送到另一个端口，这里涉及跨域了，一般前端会有个简单的处理，然后后端也会有一个允许跨域什么的配置（有可能是在security里面设置或者是自己configuration一个配置文件）。</p><p>假设我们转发到了8201接口，那么请问这个接口是什么服务的接口呢？答案揭晓，一般是网关服务这边借鉴我自己的项目，用的是gateway的。</p><p>然而我们知道gateway服务一般会进行拦截访问校验权限这类工作。那么这个gateway服务，对于这种登陆的接口访问，又会做出什么样子的判断呢？其实对于这类我们会把他列入白名单，所以举个login例子，我在8090端口发出&#x2F;admin&#x2F;login命令，然后遇到gateway网关，网关直接放行，那么我们假设admin端口是8080端口，那这时候request是不是通过转发变成了：8080&#x2F;admin&#x2F;login，然后带一些账号密码这类参数什么的。</p><p>下面很关键。</p><p>一般我们的login命令是不是首先要取得授权啊，你不授权你登陆什么呢。那么这时候就要请出我们的授权服务了，Auth服务。我们可以直接在login的controller里面写调用获取授权的服务。</p><p>那用什么授权呢，举个例子token或者是token的变体。下面用spring security oauth2讲一下这个token怎么获取，又怎么调教。</p><p>其实大家不用吧授权服务想的很难，无非就是自己写了一些接口，你去调用，然后判断，如果对就通过，如果错误就失败。</p><p>那么这边我们举个例子<br>在login函数里面调用这个</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CommonResult restResult = authService.getAccessToken(params);</span><br></pre></td></tr></table></figure><p>然后authService如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(&quot;auth-server&quot;)</span><br><span class="line">public interface AuthService &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(value = &quot;/oauth/token&quot;)</span><br><span class="line">    CommonResult getAccessToken(@RequestParam Map&lt;String, String&gt; parameters);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候通过注解直接跑掉另一个端口服务了。</p><h1 id="Auth服务"><a href="#Auth服务" class="headerlink" title="Auth服务"></a>Auth服务</h1><h2 id="token的生成"><a href="#token的生成" class="headerlink" title="token的生成"></a>token的生成</h2><p>我们需要配置令牌访问的端点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void configure(AuthorizationServerEndpointsConfigurer endpoints)</span><br></pre></td></tr></table></figure><p>在这里我们可以自定义授权方式，比如说微信授权、手机号授权等等。当时我们先讲token的生成</p><p>1、用户发起获取token的请求，请求&#x2F;oauth&#x2F;token接口</p><p>2、首先要过一道关卡是ClientCredentialsTokenEndpointFilter</p><ol><li>通过clientId查询生成一个Authentication对象</li><li>将clientId和clientSecret构造成UsernamePasswordAuthenticationToken,交给ProviderManager，然后ProviderManager代理AuthenticationProvider去认证，最后真正执行的是DaoAuthenticationProvider，通过UserDetailsService.loadUserByUsername向表oauth_client_details查询clientDetails信息</li></ol><p>3、 以上认证客户端信息的逻辑全部通过后，会进入地址&#x2F;oauth&#x2F;token，即TokenEndpoint的postAccessToken方法(当然这个方法我们可以自定义)中。</p><p>4、 postAccessToken方法中会验证Scope，然后验证是否是refreshToken请求等</p><p>5、 AbstractTokenGranter(此时的实现类是ResourceOwnerPasswordTokenGranter)中的grant方法</p><p>6、 之后调用AbstractTokenGranter(此时的实现类ResourceOwnerPasswordTokenGranter)中的grant方法</p><p>7、 grant方法中调用getAccessToken方法，在这个方法中又逐步调用到WebSecurityConfigurerAdapter的AbstractUserDetailsAuthenticationProvider的authenticate方法（<br>非常关键的一点</p><ul><li>先看缓存有没有</li><li>看数据库UserDetails loadedUser &#x3D; this.getUserDetailsService().loadUserByUsername(username);</li></ul><p>），对username与password进行认证</p><p>8、 验证通过后，把得到Authentication认证结果对象包装成OAuth2Authentication认证对象。然后传给DefaultTokenServices类的tokenStore的getAccessToken方法，利用OAuth2Authentication对象中的信息查找tokenStore中是否已经存在token，存在则返回OAuth2AccessToken对象。如果不存在DefaultTokenServices则调用createAccessToken（增强方法就在这里实现，这个方法主要做了五件事情，</p><ul><li>使用UUID生成Token</li><li>判断Token是否过期，如果没过期，就把过期时间设为当前时间加1000s</li><li>设置刷新令牌</li><li>设置权限</li><li>判断是否有增强器，如果有就调用它的enhance方法）</li></ul><p>方法创建OAuth2AccessToken对象。</p><p>9、 然后将OAuth2AccessToken对象包装进响应流返回。</p><h2 id="token刷新"><a href="#token刷新" class="headerlink" title="token刷新"></a>token刷新</h2><p>刷新token（refresh token）的流程与获取token的流程只有8有所区别：</p><p>1.获取token调用的是AbstractTokenGranter中的getAccessToken方法，然后调用tokenStore中的getAccessToken方法获取token。</p><p>2.刷新token调用的是RefreshTokenGranter中的getAccessToken方法，然后使用tokenStore中的refreshAccessToken方法获取token。</p><h2 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h2><p>当我们拿到token之后我们会拿着这个token去访问其他的接口，比如说我们login接口成功返回之后，你马上紧接着就访问info接口，你直接8080&#x2F;admin&#x2F;info这么发过去，首先找到gateway，gateway首先要鉴定一下你这个是不是有权限是不是啊？那么这里就涉及了鉴权服务。<br>这个鉴权服务分为两个部分：</p><p>1、token 检验<br>首先调用下面这个代码，不过readaccesstoken具体的实现我们可以自定义。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OAuth2AccessToken oAuth2AccessToken = this.tokenStore.readAccessToken(accessToken);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总之就去去查你这个token有没有，没有的话，就返回没有token的信息错误。<br>如果有，继续判断是不是过期了，如果过期了，就返回过期的错误信息<br>然后通过这个token去缓存或者数据库里面找到OAuth2Authentication对象，如果没有再次返回无效异常，如果有，那我们就通过token的校验，进入到权限的校验。</p><p>OAuth2AccessToken和OAuth2Authentication是好基友，TokenStore同时存储OAuth2AccessToken和OAuth2Authentication</p><p>2、权限检验</p><p>进来之后如果是白名单，我们就放行，毕竟有些东西确实不需要什么权限。</p><p>跨域的预检也放行，这一点在上面也提到过，预检验，你要是把他拦下来，那就没必要了。</p><p>下面进入真正的检验从request获取token，提取信息组装成一个对象（dto）</p><p>非管理端直接放行，这个意思是，我们的后台服务不是所有人都能进来的，要是你一个用户能进我们的后台那就完蛋了。</p><p>去缓存里面拿到资源规则，然后对比两者的访问路径，要是匹配得上就把相应的权限加到一个集合里面。</p><p>这时候我们就得到访问这个路径需要的权限，那我们就用自己的权限去对比，要是比他高，那就通过，要是不如，那就拒绝。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oauth2-整合篇</title>
      <link href="/2024/05/04/Oauth2-%E6%95%B4%E5%90%88%E7%AF%87/"/>
      <url>/2024/05/04/Oauth2-%E6%95%B4%E5%90%88%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Auth认证服务"><a href="#Auth认证服务" class="headerlink" title="Auth认证服务"></a>Auth认证服务</h1><h2 id="1、AuthorizationServerConfig"><a href="#1、AuthorizationServerConfig" class="headerlink" title="1、AuthorizationServerConfig"></a>1、AuthorizationServerConfig</h2><h3 id="【事先准备】："><a href="#【事先准备】：" class="headerlink" title="【事先准备】："></a>【事先准备】：</h3><h4 id="方法、LoadRolePermissionService-调用—-gt-PermissionServiceImpl"><a href="#方法、LoadRolePermissionService-调用—-gt-PermissionServiceImpl" class="headerlink" title="方法、LoadRolePermissionService  调用—&gt; PermissionServiceImpl"></a>方法、LoadRolePermissionService  调用—&gt; PermissionServiceImpl</h4><p>作用：从数据库中将url-&gt;角色对应关系加载到Redis中</p><ul><li>方法1:listRolePermission </li><li><ul><li>先从数据库获取permissons</li><li>根据roleid从数据库中找权限数据</li><li>根据permissionid从数据库中找数据</li><li>到此为止，构造了每一个permission对应所需要的权限一共后续使用</li><li>简化一下，放入redis</li></ul></li></ul><h3 id="【1】AuthorizationServerConfig-继承—-gt-AuthorizationServerConfigurerAdapter"><a href="#【1】AuthorizationServerConfig-继承—-gt-AuthorizationServerConfigurerAdapter" class="headerlink" title="【1】AuthorizationServerConfig 继承—&gt; AuthorizationServerConfigurerAdapter"></a>【1】AuthorizationServerConfig 继承—&gt; AuthorizationServerConfigurerAdapter</h3><p><strong>作用：配置认证中心，就是授权服务器配置</strong></p><h4 id="方法1：-configure-ClientDetailsServiceConfigurer-clients"><a href="#方法1：-configure-ClientDetailsServiceConfigurer-clients" class="headerlink" title="方法1： configure(ClientDetailsServiceConfigurer clients)"></a>方法1： configure(ClientDetailsServiceConfigurer clients)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line"> * 配置客户端详情，并不是所有的客户端都能接入授权服务</span><br><span class="line"> * 用来配置客户端详情服务（ClientDetailsService），</span><br><span class="line"> * 客户端详情信息在这里进行初始化，</span><br><span class="line"> * 你能够把客户端详情信息写死在这里或者是通过数据库来存储调取详情信息</span><br><span class="line"> </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h5 id="一、重写configure-ClientDetailsServiceConfigurer-clients-方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的，"><a href="#一、重写configure-ClientDetailsServiceConfigurer-clients-方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的，" class="headerlink" title="一、重写configure(ClientDetailsServiceConfigurer clients)方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的，"></a>一、<u>重写configure(ClientDetailsServiceConfigurer clients)方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的</u>，</h5><ol><li>定义两个client_id，及客户端可以通过不同的client_id来获取不同的令牌；</li><li>client_id为test1的令牌有效时间为3600秒，client_id为test2的令牌有效时间为7200秒；</li><li>client_id为test1的refresh_token（下面会介绍到）有效时间为864000秒，即10天，也就是说在这10天内都可以通过refresh_token来换取新的令牌；</li><li>在获取client_id为test1的令牌的时候，scope只能指定为all，a，b或c中的某个值，否则将获取失败；</li><li>只能通过密码模式(password)来获取client_id为test1的令牌，而test2则无限制。</li></ol><h5 id="二、导入方法有以下几种："><a href="#二、导入方法有以下几种：" class="headerlink" title="二、导入方法有以下几种："></a>二、导入方法有以下几种：</h5><ul><li><strong>内存</strong>，自己测试的时候比较推荐，后续数据库啊什么的</li><li><strong>数据库</strong>，使用JdbcClientDetailsService，JdbcClientDetailsService自己是有一个默认的字段的表的，所以程序是从数据库中的oauth_client_details表中加载客户端信息，</li><li>总而言之，就是配置把客户端信息从数据源拿过来。后面需要授权验证，要用到，所以先配。</li></ul><h4 id="方法2：-configure-AuthorizationServerEndpointsConfigurer-endpoints-——"><a href="#方法2：-configure-AuthorizationServerEndpointsConfigurer-endpoints-——" class="headerlink" title="方法2： configure(AuthorizationServerEndpointsConfigurer endpoints)——"></a>方法2： configure(AuthorizationServerEndpointsConfigurer endpoints)——</h4><p>上面和客户端有关，而这个则直接和令牌有关，比如<u>配置授权（authorization）</u>以及<u>令牌（token）的访问端点</u>和<u>令牌服务(token services)</u>，还有一些其他的，比如异常啊什么的，下面有例子。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 配置令牌访问的端点</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>令牌端点可用于以编程方式请求令牌（非常重要，四种方式）,下面是配置的例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">endpoints</span><br><span class="line">        <span class="comment">//设置异常WebResponseExceptionTranslator，用于处理用户名，密码错误、授权类型不正确的异常</span></span><br><span class="line">        .exceptionTranslator(<span class="keyword">new</span> <span class="title class_">OAuthServerWebResponseExceptionTranslator</span>())</span><br><span class="line">        <span class="comment">//授权码模式所需要的authorizationCodeServices</span></span><br><span class="line">        .authorizationCodeServices(authorizationCodeServices())</span><br><span class="line">        <span class="comment">//密码模式所需要的authenticationManager</span></span><br><span class="line">        .authenticationManager(authenticationManager)</span><br><span class="line">        <span class="comment">//令牌管理服务，无论哪种模式都需要</span></span><br><span class="line">        .tokenServices(tokenServices())</span><br><span class="line">        <span class="comment">//添加进入tokenGranter</span></span><br><span class="line">        .tokenGranter(<span class="keyword">new</span> <span class="title class_">CompositeTokenGranter</span>(tokenGranters))</span><br><span class="line">        <span class="comment">//只允许POST提交访问令牌，uri：/oauth/token</span></span><br><span class="line">        .allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br></pre></td></tr></table></figure><h5 id="一、authenticationManager-（建议必须配置）-（密码授权管理器），见文件SecurityConfig这个配置类"><a href="#一、authenticationManager-（建议必须配置）-（密码授权管理器），见文件SecurityConfig这个配置类" class="headerlink" title="一、authenticationManager （建议必须配置）  （密码授权管理器），见文件SecurityConfig这个配置类"></a>一、<u>authenticationManager （建议必须配置）  （密码授权管理器），见文件SecurityConfig这个配置类</u></h5><ul><li>在Spring Security中，AuthenticationManager的默认实现是ProviderManager，而且它不直接自己处理认证请求，而是委托给其所配置的AuthenticationProvider列表，然后会依次使用每一个AuthenticationProvider进行认证，如果有一个AuthenticationProvider认证后的结果不为null，则表示该AuthenticationProvider已经认证成功，之后的AuthenticationProvider将不再继续认证。然后直接以该AuthenticationProvider的认证结果作为ProviderManager的认证结果。如果所有的AuthenticationProvider的认证结果都为null，则表示认证失败，将抛出一个ProviderNotFoundException。<br>校验认证请求最常用的方法是根据请求的用户名加载对应的UserDetails，然后比对UserDetails的密码与认证请求的密码是否一致，一致则表示认证通过。<br>Spring Security内部的DaoAuthenticationProvider就是使用的这种方式。其内部使用UserDetailsService来负责加载UserDetails。在认证成功以后会使用加载的UserDetails来封装要返回的Authentication对象，加载的UserDetails对象是包含用户权限等信息的。认证成功返回的Authentication对象将会保存在当前的SecurityContext中</li></ul><h5 id="二、令牌本身内容的配置（建议必须配置）"><a href="#二、令牌本身内容的配置（建议必须配置）" class="headerlink" title="二、令牌本身内容的配置（建议必须配置）"></a><u>二、令牌本身内容的配置（建议必须配置）</u></h5><h6 id="I、-两种方式，"><a href="#I、-两种方式，" class="headerlink" title="I、 两种方式，"></a><u>I、 两种方式，</u></h6><p>【1】直接在endpoint这里配。</p><p>【2】自己写个bean注入，举个例子：</p><h6 id="I、tokenServices-就在本文件注入-由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里"><a href="#I、tokenServices-就在本文件注入-由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里" class="headerlink" title="I、tokenServices()就在本文件注入,由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里"></a>I、tokenServices()就在本文件注入,由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public AuthorizationServerTokenServices tokenServices() &#123;</span><br><span class="line">    System.out.println(&quot;令牌管理服务的配置&quot;);</span><br><span class="line">    DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">    //客户端端配置策略</span><br><span class="line">    services.setClientDetailsService(clientDetailsService);</span><br><span class="line">    //支持令牌的刷新</span><br><span class="line">    services.setSupportRefreshToken(true);</span><br><span class="line">    //令牌服务</span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    //access_token的过期时间</span><br><span class="line">    services.setAccessTokenValiditySeconds(60 * 60 * 24 * 3);</span><br><span class="line">    //refresh_token的过期时间</span><br><span class="line">    services.setRefreshTokenValiditySeconds(60 * 60 * 24 * 3);</span><br><span class="line"></span><br><span class="line">    //设置令牌增强，使用JwtAccessTokenConverter进行转换</span><br><span class="line">    services.setTokenEnhancer(jwtAccessTokenConverter);</span><br><span class="line">    return services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt-自定义内容。"><a href="#III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt-自定义内容。" class="headerlink" title="III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt+自定义内容。"></a><u>III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt+自定义内容。</u></h6><ul><li><p>把令牌变成jwt格式很简单，按下面2两步操作即可，反正就是</p><ul><li><p>~~~<br>@Configuration<br>public class JWTokenConfig {</p><pre><code>@Beanpublic TokenStore jwtTokenStore() &#123;    return new JwtTokenStore(jwtAccessTokenConverter());&#125;@Beanpublic JwtAccessTokenConverter jwtAccessTokenConverter() &#123;    JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();    accessTokenConverter.setSigningKey(&quot;test_key&quot;); // 签名密钥    return accessTokenConverter;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* ~~~java</span><br><span class="line">      services.setTokenStore(tokenStore);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>自定义的话，同样简单，按下面的操作来做，无非就是先写一些配置，然后把配置注入adapter</p><ul><li>&#96;&#96;&#96;java<br>@Component<br>public class JwtTokenEnhancer implements TokenEnhancer {<br>@Override<br>public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {<br>    SecurityUser securityUser &#x3D; (SecurityUser) authentication.getPrincipal();<br>    Map&lt;String, Object&gt; info &#x3D; new HashMap&lt;&gt;();<br>    &#x2F;&#x2F;把用户ID设置到JWT中<br>    info.put(“id”, securityUser.getId());<br>    info.put(“client_id”,securityUser.getClientId());<br>    ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);<br>    return accessToken;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * ~~~</span><br><span class="line">    tokenEnhancer(enhancerChain)</span><br><span class="line">    ~~~</span><br><span class="line"></span><br><span class="line">##### 三、tokenGranter(new CompositeTokenGranter(tokenGranters))    自定义授权  非常重要</span><br><span class="line"></span><br><span class="line">作用：自定义授权获取token，下面我们来看一看源码是怎么获取token的，在我们发起oauth/token，请求获取token时，实际上是请求Tokenpoint类的postAccessToken或者getacesstoken方法，相当于调用了一个controller方法，根据请求的方法是get还是post，但其实内部还是调用post的方法。</span><br><span class="line"></span><br><span class="line">在TokenEndPoint 获取令牌过程中, 有个这样的步骤:</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">OAuth2AccessToken token = getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">postAccessToken这个方法中，在这个方法的132行调用TokenGranter类的grant方法来获取token，**&lt;u&gt;这个方法也是最重要的&lt;/u&gt;**，通过这个方法我们可以对请求的参数进行校验是否合法，是否给予令牌。</span><br><span class="line"></span><br><span class="line">TokenGranter是一个接口，它有多个实现类，CompositeTokenGranter是其中之一，在grant方法中，会循环遍历所有的授权方式，根据请求参数携带的授权方式码，来匹配对应的授权处理实现类，调用实现类中的grant方法。那么关键点来了，请求参数中携带的是我们**&lt;u&gt;自定义的授权方式码&lt;/u&gt;**，如果要匹配上，那么首先我们要创建自定义的授权处理类，然后把这个授权处理类放入Spring Security默认的授权处理集合中，这样才能循环匹配上，进行下一步。</span><br><span class="line"></span><br><span class="line">和以前的做法一样：创建自定义授权处理类，我们可以继承TokenGranter来实现自定义的身份验证以便获取token，而AbstractTokenGranter是一个继承TokenGranter的实现类，一般我们都会继承这个类进行使用。这一点已经得到验证，可以看下面的流程。</span><br><span class="line"></span><br><span class="line">| 实现类                            | 对应的授权模式  |</span><br><span class="line">| --------------------------------- | --------------- |</span><br><span class="line">| AuthorizationCodeTokenGranter     | 授权码模式      |</span><br><span class="line">| ClientCredentialsTokenGranter     | 客户端模式      |</span><br><span class="line">| ImplicitTokenGranter              | implicit 模式   |</span><br><span class="line">| RefreshTokenGranter               | 刷新 token 模式 |</span><br><span class="line">| ResourceOwnerPasswordTokenGranter | 密码模式        |</span><br><span class="line"></span><br><span class="line">这些类都继承了AbstractTokenGranter</span><br><span class="line"></span><br><span class="line">AbstractTokenGranter   调用-------&gt;getAccessToken --------&gt;getOAuth2Authentication</span><br><span class="line"></span><br><span class="line">根据 client、tokenRequest 从 OAuth2RequestFactory 中创建一个 OAuth2Request, 进而可得到 OAuth2Authentication (存放着用户的认证信息)。</span><br><span class="line"></span><br><span class="line">通过 tokenService 去创建 OAuth2AccessToken (存放着用户的 token信息、过期时间)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### I、————所以，这里加入自定的tokenGrant，也就是要自定义自己的授权方法 去 授权 自定义的令牌——————</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自定义至关重要的一点就是修改getOAuth2Authentication方法 （主要文件见sms文件夹和即可）</span><br><span class="line"></span><br><span class="line">具体修改不讲，修改的流程就是1、组装自定义模式的认证信息 2、用authenticationManager去调用内部自定义的Provider认证这个认证信息，认证规则自然是写在Provider里面。可借鉴 https://blog.csdn.net/m0_38031406/article/details/89316342</span><br><span class="line"></span><br><span class="line">###### II、&lt;u&gt;所以实现方式：继承AbstractTokenGranter + 重写 getOAuth2Authentication方法。&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">@Override</span><br><span class="line">protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) &#123;</span><br><span class="line">    Map&lt;String, String&gt; parameters = new LinkedHashMap&lt;&gt;(tokenRequest.getRequestParameters());</span><br><span class="line">    String mobile = parameters.get(&quot;mobile&quot;);</span><br><span class="line">    String password = parameters.get(&quot;password&quot;);</span><br><span class="line">    //将其中的密码移除</span><br><span class="line">    parameters.remove(&quot;password&quot;);</span><br><span class="line">    //自定义的token类</span><br><span class="line">    Authentication userAuth = new MobilePasswordAuthenticationToken(mobile, password);</span><br><span class="line"></span><br><span class="line">    ((AbstractAuthenticationToken) userAuth).setDetails(parameters);</span><br><span class="line">    //调用AuthenticationManager进行认证，内部会根据MobileAuthenticationToken找到对应的Provider进行认证</span><br><span class="line">    userAuth = authenticationManager.authenticate(userAuth);</span><br><span class="line">    if (userAuth == null || !userAuth.isAuthenticated()) &#123;</span><br><span class="line">        throw new InvalidGrantException(&quot;Could not authenticate mobile: &quot; + mobile);</span><br><span class="line">    &#125;</span><br><span class="line">    OAuth2Request storedOAuth2Request = getRequestFactory().createOAuth2Request(client, tokenRequest);</span><br><span class="line">    return new OAuth2Authentication(storedOAuth2Request, userAuth);</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">这里调用了AuthenticationManager认证，后面回调用自定义的XXXXXAuthenticationProvider</span><br><span class="line"></span><br><span class="line">###### III、注入</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">.tokenGranter(new CompositeTokenGranter(tokenGranters))</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 四、new OAuthServerWebResponseExceptionTranslator()**  也是自己配置的见文件夹Exception</span><br><span class="line"></span><br><span class="line">自定义异常翻译器，针对用户名、密码异常，授权类型不支持的异常进行处理-----**关键是用户**</span><br><span class="line"></span><br><span class="line">##### 五、authorizationCodeServices()就在本文件注入</span><br><span class="line"></span><br><span class="line">##### 六、待续。。。。。。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 方法3： configure(AuthorizationServerSecurityConfigurer security)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * 配置令牌访问的安全约束（）</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证"><a href="#一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证" class="headerlink" title="一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证"></a>一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 客户端异常处理</span></span><br><span class="line"><span class="comment"> * 自定义的客户端认证的过滤器，根据客户端的id、秘钥进行认证</span></span><br><span class="line"><span class="comment"> * 重写这个过滤器用于自定义异常处理</span></span><br><span class="line"><span class="comment"> * 具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;配置令牌访问的安全约束&quot;</span>);</span><br><span class="line">      <span class="comment">//自定义ClientCredentialsTokenEndpointFilter，用于处理客户端id，密码错误的异常</span></span><br><span class="line">        <span class="type">OAuthServerClientCredentialsTokenEndpointFilter</span> <span class="variable">endpointFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OAuthServerClientCredentialsTokenEndpointFilter</span>(security,authenticationEntryPoint);</span><br><span class="line">        endpointFilter.afterPropertiesSet();</span><br><span class="line">        security.addTokenEndpointAuthenticationFilter(endpointFilter);</span><br><span class="line"></span><br><span class="line">        security</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                <span class="comment">//开启/oauth/token_key验证端口权限访问</span></span><br><span class="line">                .tokenKeyAccess(<span class="string">&quot;permitAll()&quot;</span>)</span><br><span class="line">                <span class="comment">//开启/oauth/check_token验证端口认证权限访问</span></span><br><span class="line">                .checkTokenAccess(<span class="string">&quot;permitAll()&quot;</span>);</span><br><span class="line">                <span class="comment">//一定不要添加allowFormAuthenticationForClients，否则自定义的OAuthServerClientCredentialsTokenEndpointFilter不生效</span></span><br><span class="line"><span class="comment">//                .allowFormAuthenticationForClients();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制"><a href="#I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制" class="headerlink" title="I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制"></a>I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制</h6><p><strong>既然如此，我们就去看自定义的AuthenticationEntryPoint</strong>，这里没改，实际中可以改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OAuthServerAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证失败处理器会调用这个方法返回提示信息</span></span><br><span class="line"><span class="comment">     * TODO 实际开发中可以自己定义，此处直接返回JSON数据：客户端认证失败错误提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ResponseUtils.result(response,<span class="keyword">new</span> <span class="title class_">ResultMsg</span>(ResultCode.CLIENT_AUTHENTICATION_FAILED.getCode(),ResultCode.CLIENT_AUTHENTICATION_FAILED.getMsg(),<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="II、endpointFilter-afterPropertiesSet-认证成功怎么办，认真失败怎么办，这里可以自定义哈哈"><a href="#II、endpointFilter-afterPropertiesSet-认证成功怎么办，认真失败怎么办，这里可以自定义哈哈" class="headerlink" title="II、endpointFilter.afterPropertiesSet();认证成功怎么办，认真失败怎么办，这里可以自定义哈哈"></a>II、endpointFilter.afterPropertiesSet();认证成功怎么办，认真失败怎么办，这里可以自定义哈哈</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置AuthenticationEntryPoint主要逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;设置AuthenticationEntryPoint主要逻辑&quot;</span>);</span><br><span class="line">    <span class="comment">//TODO 定制认证失败处理器，开发中可以自己修改</span></span><br><span class="line">    setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">            exception = <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(exception.getMessage(), <span class="keyword">new</span> <span class="title class_">BadClientCredentialsException</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//成功处理器，和父类相同，为空即可。</span></span><br><span class="line">    setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="III、security-addTokenEndpointAuthenticationFilter-endpointFilter"><a href="#III、security-addTokenEndpointAuthenticationFilter-endpointFilter" class="headerlink" title="III、security.addTokenEndpointAuthenticationFilter(endpointFilter);"></a>III、security.addTokenEndpointAuthenticationFilter(endpointFilter);</h6><ul><li>注入 自定义相应异常的过滤链</li></ul><h2 id="2、springconfig"><a href="#2、springconfig" class="headerlink" title="2、springconfig"></a>2、springconfig</h2><h3 id="介绍一个比较完整的securityconfig配置"><a href="#介绍一个比较完整的securityconfig配置" class="headerlink" title="介绍一个比较完整的securityconfig配置"></a>介绍一个比较完整的securityconfig配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//开启判断用户对某个控制层的方法是否具有访问权限的功能</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//注入自定义的UserDetailService</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsServiceImpl userDetailsServiceImpl;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换默认AuthenticationManager中的UserDetailService，使用数据库用户认证方式登录</span></span><br><span class="line">    <span class="comment">//1. 一旦通过 configure 方法自定义 AuthenticationManager实现 就回将工厂中自动配置AuthenticationManager 进行覆盖</span></span><br><span class="line">    <span class="comment">//2. 一旦通过 configure 方法自定义 AuthenticationManager实现 需要在实现中指定认证数据源对象 UserDetailService 实例</span></span><br><span class="line">    <span class="comment">//3. 一旦通过 configure 方法自定义 AuthenticationManager实现 这种方式创建AuthenticationManager对象工厂内部本地一个 AuthenticationManager 对象 不允许在其他自定义组件中进行注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder builder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        builder.userDetailsService(userDetailsServiceImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BCryptPasswordEncoder相关知识：</span></span><br><span class="line"><span class="comment">     * 用户表的密码通常使用MD5等不可逆算法加密后存储，为防止彩虹表破解更会先使用一个特定的字符串（如域名）加密，然后再使用一个随机的salt（盐值）加密。</span></span><br><span class="line"><span class="comment">     * 特定字符串是程序代码中固定的，salt是每个密码单独随机，一般给用户表加一个字段单独存储，比较麻烦。</span></span><br><span class="line"><span class="comment">     * BCrypt算法将salt随机并混入最终加密后的密码，验证时也无需单独提供之前的salt，从而无需单独处理salt问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将自定义AuthenticationManager在工厂中进行暴露,可以在任何位置注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HttpSecurity配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.cors(withDefaults())</span><br><span class="line">                <span class="comment">// 禁用 CSRF</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 指定的接口直接放行</span></span><br><span class="line">                <span class="comment">// swagger</span></span><br><span class="line">                .antMatchers(SecurityConstants.SWAGGER_WHITELIST).permitAll()</span><br><span class="line">                .antMatchers(SecurityConstants.H2_CONSOLE).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, SecurityConstants.SYSTEM_WHITELIST).permitAll()</span><br><span class="line">                <span class="comment">// 其他的接口都需要认证后才能请求</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//添加自定义Filter</span></span><br><span class="line">                .addFilter(<span class="keyword">new</span> <span class="title class_">JwtAuthorizationFilter</span>(authenticationManager(), stringRedisTemplate))</span><br><span class="line">                <span class="comment">// 不需要session（不创建会话）</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                <span class="comment">// 授权异常处理</span></span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                <span class="comment">// json提示用户没有登录不需要用户跳转到登录页面去</span></span><br><span class="line">                .authenticationEntryPoint(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationEntryPoint</span>())</span><br><span class="line">                <span class="comment">// 权限拦截器，提示用户没有当前权限</span></span><br><span class="line">                .accessDeniedHandler(<span class="keyword">new</span> <span class="title class_">JwtAccessDeniedHandler</span>());</span><br><span class="line">        <span class="comment">// 防止H2 web 页面的Frame 被拦截</span></span><br><span class="line">        http.headers().frameOptions().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cors配置优化</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">        org.springframework.web.cors.<span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        configuration.setAllowedOrigins(singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="comment">// configuration.setAllowedOriginPatterns(singletonList(&quot;*&quot;));</span></span><br><span class="line">        configuration.setAllowedHeaders(singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line">        configuration.setExposedHeaders(singletonList(SecurityConstants.TOKEN_HEADER));</span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">false</span>);</span><br><span class="line">        configuration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="鉴权服务"><a href="#鉴权服务" class="headerlink" title="鉴权服务"></a>鉴权服务</h1><p>和授权服务，许多程序都是围绕着配置类进行的，所以我们直接看配置类</p><h2 id="【1】AccessTokenConfig-令牌的一些配置"><a href="#【1】AccessTokenConfig-令牌的一些配置" class="headerlink" title="【1】AccessTokenConfig 令牌的一些配置"></a>【1】AccessTokenConfig 令牌的一些配置</h2><ul><li>和授权服务一致，因为令牌要从授权服务到网关，再到客户端，不管是为了现在的还是后续的操作，最好配置，当然，用不到也可以不配，看你用不用得到。</li></ul><h2 id="【2】JwtAuthenticationManager-token认证管理器"><a href="#【2】JwtAuthenticationManager-token认证管理器" class="headerlink" title="【2】JwtAuthenticationManager token认证管理器"></a>【2】JwtAuthenticationManager token认证管理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 公众号：码猿技术专栏</span></span><br><span class="line"><span class="comment"> * JWT认证管理器，主要的作用就是对携带过来的token进行校验，比如过期时间，加密方式等</span></span><br><span class="line"><span class="comment"> * 一旦token校验通过，则交给鉴权管理器进行鉴权</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Authentication&gt; <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;第六步***来到JWT认证管理器 检验token&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Mono.justOrEmpty(authentication)</span><br><span class="line">            .filter(a -&gt; a <span class="keyword">instanceof</span> BearerTokenAuthenticationToken)</span><br><span class="line">            .cast(BearerTokenAuthenticationToken.class)</span><br><span class="line">            .map(BearerTokenAuthenticationToken::getToken)</span><br><span class="line">            .flatMap((accessToken -&gt; &#123;</span><br><span class="line">                <span class="type">OAuth2AccessToken</span> <span class="variable">oAuth2AccessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.tokenStore.readAccessToken(accessToken);</span><br><span class="line">                <span class="comment">//根据access_token从数据库获取不到OAuth2AccessToken</span></span><br><span class="line">                <span class="keyword">if</span> (oAuth2AccessToken == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;无效的token！&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oAuth2AccessToken.isExpired()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;token已过期！&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">OAuth2Authentication</span> <span class="variable">oAuth2Authentication</span> <span class="operator">=</span> <span class="built_in">this</span>.tokenStore.readAuthentication(accessToken);</span><br><span class="line">                <span class="keyword">if</span> (oAuth2Authentication == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;无效的token！&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.just(oAuth2Authentication);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)).cast(Authentication.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【3】JwtAccessManagerV2——-认证管理器自定义"><a href="#【3】JwtAccessManagerV2——-认证管理器自定义" class="headerlink" title="【3】JwtAccessManagerV2——-认证管理器自定义"></a>【3】JwtAccessManagerV2——-认证管理器自定义</h2><ul><li>作用：认证管理的作用就是获取传递过来的令牌，对其进行解析、验签、过期时间判定。就是作为的鉴权</li><li>获取调用方法【get&#x2F;post…】+uri.getPath()  合成完整路径例如：【uri.getPath()】</li><li>从redis里面获取获取所有的uri-&gt;角色对应关系</li><li>去链接里面找到和自己这次申请链接完全一致的那一个键值对，而这个键值对的值恰恰就是【权限集合】</li><li>把自己的权限先从mono中解析出来，然后匹配，如果超级管理员，放行；如果存在交集，则通过；否则失败</li></ul><p>异常</p><ul><li><p>RequestAuthenticationEntryPoint</p><ul><li>用于处理没有登录或token过期时的自定义返回结果</li></ul></li><li><p>RequestAccessDeniedHandler</p><ul><li>自定义返回结果：没有权限访问时</li></ul></li><li><p>RequestAuthenticationEntryPoint</p><ul><li>用于处理没有登录或token过期时的自定义返回结果</li></ul></li></ul><h2 id="【4】-SecurityConfig-在webflux中使用security"><a href="#【4】-SecurityConfig-在webflux中使用security" class="headerlink" title="【4】 SecurityConfig  在webflux中使用security"></a>【4】 SecurityConfig  在webflux中使用security</h2><h3 id="1、webFluxSecurityFilterChain——把之前的配置整合链路"><a href="#1、webFluxSecurityFilterChain——把之前的配置整合链路" class="headerlink" title="1、webFluxSecurityFilterChain——把之前的配置整合链路"></a>1、webFluxSecurityFilterChain——把之前的配置整合链路</h3><ul><li><strong>这里使用的是webFluxSecurityFilterChain</strong></li><li>http下的功能可以借鉴<a href="http://events.jianshu.io/p/8ad366b97e18">http://events.jianshu.io/p/8ad366b97e18</a></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    SecurityWebFilterChain webFluxSecurityFilterChain(ServerHttpSecurity http) throws Exception&#123;</span><br><span class="line">    //认证过滤器，放入认证管理器tokenAuthenticationManager</span><br><span class="line">    AuthenticationWebFilter authenticationWebFilter = new AuthenticationWebFilter(tokenAuthenticationManager);</span><br><span class="line">    System.out.println(&quot;认证过滤器，放入认证管理器tokenAuthenticationManager&quot;);</span><br><span class="line">    authenticationWebFilter.setServerAuthenticationConverter(new ServerBearerTokenAuthenticationConverter());</span><br><span class="line"></span><br><span class="line">    http</span><br><span class="line">            .httpBasic().disable()</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .authorizeExchange()</span><br><span class="line">            //白名单直接放行</span><br><span class="line">            .pathMatchers(ArrayUtil.toArray(sysConfig.getIgnoreUrls(),String.class)).permitAll()</span><br><span class="line">            //其他的请求必须鉴权，使用鉴权管理器</span><br><span class="line">            .anyExchange().access(accessManager)</span><br><span class="line">            //鉴权的异常处理，权限不足，token失效</span><br><span class="line">            .and().exceptionHandling()</span><br><span class="line">            .authenticationEntryPoint(requestAuthenticationEntryPoint)</span><br><span class="line">            .accessDeniedHandler(requestAccessDeniedHandler)</span><br><span class="line">            .and()</span><br><span class="line">            // 跨域过滤器</span><br><span class="line">            .addFilterAt(corsFilter, SecurityWebFiltersOrder.CORS)</span><br><span class="line">            //token的认证过滤器，用于校验token和认证</span><br><span class="line">            .addFilterAt(authenticationWebFilter, SecurityWebFiltersOrder.AUTHENTICATION);</span><br><span class="line">    return http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一、加入了【2】的自定义令牌认证管理器"><a href="#一、加入了【2】的自定义令牌认证管理器" class="headerlink" title="一、加入了【2】的自定义令牌认证管理器"></a>一、加入了【2】的自定义令牌认证管理器</h4><h4 id="二、加入了【3】的鉴权管理器"><a href="#二、加入了【3】的鉴权管理器" class="headerlink" title="二、加入了【3】的鉴权管理器"></a>二、加入了【3】的鉴权管理器</h4><h3 id="2、白名单放行"><a href="#2、白名单放行" class="headerlink" title="2、白名单放行"></a>2、白名单放行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//白名单直接放行</span><br><span class="line">.pathMatchers(ArrayUtil.toArray(sysConfig.getIgnoreUrls(),String.class)).permitAll()</span><br><span class="line">//其他的请求必须鉴权，使用鉴权管理器</span><br><span class="line">.anyExchange().access(accessManager)</span><br></pre></td></tr></table></figure><h3 id="3、鉴权的异常处理"><a href="#3、鉴权的异常处理" class="headerlink" title="3、鉴权的异常处理"></a>3、鉴权的异常处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//鉴权的异常处理，权限不足，token失效</span><br><span class="line">.and().exceptionHandling()</span><br><span class="line">.authenticationEntryPoint(requestAuthenticationEntryPoint)</span><br><span class="line">.accessDeniedHandler(requestAccessDeniedHandler)</span><br></pre></td></tr></table></figure><h1 id="异常配置"><a href="#异常配置" class="headerlink" title="异常配置"></a>异常配置</h1><h2 id="【1】认证服务的异常"><a href="#【1】认证服务的异常" class="headerlink" title="【1】认证服务的异常"></a>【1】认证服务的异常</h2><ul><li>用户名，密码错误异常、授权类型异常</li><li>客户端ID、秘钥异常</li></ul><h3 id="1、用户名，密码错误异常、授权类型异常"><a href="#1、用户名，密码错误异常、授权类型异常" class="headerlink" title="1、用户名，密码错误异常、授权类型异常"></a>1、用户名，密码错误异常、授权类型异常</h3><p>针对用户名、密码、授权类型错误的异常解决方式比较复杂，需要定制的比较多。</p><h4 id="一、定制提示信息、响应码"><a href="#一、定制提示信息、响应码" class="headerlink" title="一、定制提示信息、响应码"></a>一、定制提示信息、响应码</h4><p>这部分根据自己业务需要定制，举个例子，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    CLIENT_AUTHENTICATION_FAILED(<span class="number">1001</span>,<span class="string">&quot;客户端认证失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    USERNAME_OR_PASSWORD_ERROR(<span class="number">1002</span>,<span class="string">&quot;用户名或密码错误&quot;</span>),</span><br><span class="line"></span><br><span class="line">    UNSUPPORTED_GRANT_TYPE(<span class="number">1003</span>, <span class="string">&quot;不支持的认证模式&quot;</span>),</span><br><span class="line"></span><br><span class="line">    NO_PERMISSION(<span class="number">1005</span>,<span class="string">&quot;无权限访问！&quot;</span>),</span><br><span class="line">    UNAUTHORIZED(<span class="number">401</span>, <span class="string">&quot;系统错误&quot;</span>),</span><br><span class="line"></span><br><span class="line">    INVALID_TOKEN(<span class="number">1004</span>,<span class="string">&quot;无效的token&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="二、自定义WebResponseExceptionTranslator"><a href="#二、自定义WebResponseExceptionTranslator" class="headerlink" title="二、自定义WebResponseExceptionTranslator"></a>二、自定义WebResponseExceptionTranslator</h4><ul><li><p>需要自定义一个异常翻译器，默认的是<strong>DefaultWebResponseExceptionTranslator</strong>，此处必须重写，其中有一个需要实现的方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;T&gt; <span class="title function_">translate</span><span class="params">(Exception e)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure><p>这个方法就是根据传递过来的<strong>Exception</strong>判断不同的异常返回特定的信息，这里需要判断的异常的如下：</p><ul><li><strong>UnsupportedGrantTypeException</strong>：不支持的授权类型异常</li><li><strong>InvalidGrantException</strong>：用户名或者密码错误的异常</li></ul></li><li><p>创建一个<strong>OAuthServerWebResponseExceptionTranslator</strong>实现<strong>WebResponseExceptionTranslator</strong>，代码如下：</p></li><li><p>&#96;&#96;&#96;java<br>public class OAuthServerWebResponseExceptionTranslator implements WebResponseExceptionTranslator{<br>&#x2F;**<br> * 业务处理方法，重写这个方法返回客户端信息<br> <em>&#x2F;<br>@Override<br>public ResponseEntity<ResultMsg> translate(Exception e){<br>    ResultMsg resultMsg &#x3D; doTranslateHandler(e);<br>    return new ResponseEntity&lt;&gt;(resultMsg, HttpStatus.UNAUTHORIZED);<br>}<br><br>&#x2F;</em>*<br> * 根据异常定制返回信息<br> * TODO 自己根据业务封装<br> *&#x2F;<br>private ResultMsg doTranslateHandler(Exception e) {<br>    &#x2F;&#x2F;初始值，系统错误，<br>    ResultCode resultCode &#x3D; ResultCode.UNAUTHORIZED;<br>    &#x2F;&#x2F;判断异常，不支持的认证方式<br>    if(e instanceof UnsupportedGrantTypeException){<br>        resultCode &#x3D; ResultCode.UNSUPPORTED_GRANT_TYPE;<br>        &#x2F;&#x2F;用户名或密码异常<br>    }else if(e instanceof InvalidGrantException){<br>        resultCode &#x3D; ResultCode.USERNAME_OR_PASSWORD_ERROR;<br>    }<br>    return new ResultMsg(resultCode.getCode(),resultCode.getMsg(),null);<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 三、认证服务配置文件中配置</span><br><span class="line"></span><br><span class="line">需要将自定义的异常翻译器**OAuthServerWebResponseExceptionTranslator**在配置文件中配置，很简单，一行代码的事。</span><br><span class="line"></span><br><span class="line">在**AuthorizationServerConfig**配置文件指定，代码如下：</span><br><span class="line"></span><br><span class="line">[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bmgLx4kZ-1662702416690)(C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203102659.png)]</span><br><span class="line"></span><br><span class="line">#### 四、这么配置的原因</span><br><span class="line"></span><br><span class="line">* 我们知道获取令牌的接口为 **/oauth/token**，这个接口定义在**TokenEndpoint#postAccessToken()**（POST请求）方法中，如下图</span><br><span class="line">* [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-F0jcPGjR-1662702416691)(C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203752062.png)]</span><br><span class="line">* 是不是都继承了**OAuth2Exception**，那么尝试在**TokenEndpoint**这个类中找找有没有处理**OAuth2Exception**这个异常的处理器，果然找到了一个 **handleException()** 方法，如下：</span><br><span class="line">* [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LbImISgh-1662702416692)(C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203840232.png)]</span><br><span class="line">* 可以看到，这里的异常翻译器已经使用了我们自定义的**OAuthServerWebResponseExceptionTranslator**。可以看下默认的异常翻译器是啥，代码如下：</span><br><span class="line"></span><br><span class="line">### 2、客户端ID、秘钥异常</span><br><span class="line"></span><br><span class="line">这部分比较复杂，想要理解还是需要些基础的，解决这个异常的方案很多，陈某只是介绍其中一种，下面详细介绍。</span><br><span class="line"></span><br><span class="line">#### 一、定制提示信息、响应码</span><br><span class="line"></span><br><span class="line">这部分根据自己业务需要定制，和第一步一样。</span><br><span class="line"></span><br><span class="line">#### 二、自定义AuthenticationEntryPoint</span><br><span class="line"></span><br><span class="line">这个**AuthenticationEntryPoint**是不是很熟悉，前面的文章已经介绍过了，此处需要自定义来返回定制的提示信息。</span><br><span class="line"></span><br><span class="line">创建**OAuthServerAuthenticationEntryPoint**，实现AuthenticationEntryPoint，重写其中的方法，代码如下：</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  public class OAuthServerAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line">  </span><br><span class="line">      /**</span><br><span class="line">       * 认证失败处理器会调用这个方法返回提示信息</span><br><span class="line">       * TODO 实际开发中可以自己定义，此处直接返回JSON数据：客户端认证失败错误提示</span><br><span class="line">       */</span><br><span class="line">      @Override</span><br><span class="line">      public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException &#123;</span><br><span class="line">          ResponseUtils.result(response,new ResultMsg(ResultCode.CLIENT_AUTHENTICATION_FAILED.getCode(),ResultCode.CLIENT_AUTHENTICATION_FAILED.getMsg(),null));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="三、改造ClientCredentialsTokenEndpointFilter"><a href="#三、改造ClientCredentialsTokenEndpointFilter" class="headerlink" title="三、改造ClientCredentialsTokenEndpointFilter"></a>三、改造ClientCredentialsTokenEndpointFilter</h4><p><strong>ClientCredentialsTokenEndpointFilter</strong>这个过滤器的主要作用就是校验客户端的ID、秘钥，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuthServerClientCredentialsTokenEndpointFilter extends ClientCredentialsTokenEndpointFilter &#123;</span><br><span class="line"></span><br><span class="line">    private final AuthorizationServerSecurityConfigurer configurer;</span><br><span class="line"></span><br><span class="line">    private AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     * @param configurer AuthorizationServerSecurityConfigurer对昂</span><br><span class="line">     * @param authenticationEntryPoint 自定义的AuthenticationEntryPoint</span><br><span class="line">     */</span><br><span class="line">    public OAuthServerClientCredentialsTokenEndpointFilter(AuthorizationServerSecurityConfigurer configurer, AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">        System.out.println(&quot;自定义的客户端认证的过滤器的构造方法&quot;);</span><br><span class="line">        this.configurer = configurer;</span><br><span class="line">        this.authenticationEntryPoint=authenticationEntryPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setAuthenticationEntryPoint(AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">        System.out.println(&quot;setAuthenticationEntryPoint&quot;);</span><br><span class="line">        this.authenticationEntryPoint = authenticationEntryPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 需要重写这个方法，返回AuthenticationManager</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationManager getAuthenticationManager() &#123;</span><br><span class="line">        System.out.println(&quot;getAuthenticationManager&quot;);</span><br><span class="line">        return configurer.and().getSharedObject(AuthenticationManager.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置AuthenticationEntryPoint主要逻辑</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        System.out.println(&quot;设置AuthenticationEntryPoint主要逻辑&quot;);</span><br><span class="line">        //TODO 定制认证失败处理器，开发中可以自己修改</span><br><span class="line">        setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;</span><br><span class="line">            if (exception instanceof BadCredentialsException) &#123;</span><br><span class="line">                exception = new BadCredentialsException(exception.getMessage(), new BadClientCredentialsException());</span><br><span class="line">            &#125;</span><br><span class="line">            authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">        &#125;);</span><br><span class="line">        //成功处理器，和父类相同，为空即可。</span><br><span class="line">        setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个重要的部分需要讲一下，如下：</p><ul><li>构造方法中需要传入第2步自定义的 <strong>OAuthServerAuthenticationEntryPoint</strong></li><li>重写 <strong>getAuthenticationManager()</strong> 方法返回IOC中的AuthenticationManager</li><li>重写<strong>afterPropertiesSet()</strong> 方法，用于自定义认证失败、成功处理器，失败处理器中调用<strong>OAuthServerAuthenticationEntryPoint</strong>进行异常提示信息返回</li></ul><h4 id="四、OAuth配置文件中指定过滤器"><a href="#四、OAuth配置文件中指定过滤器" class="headerlink" title="四、OAuth配置文件中指定过滤器"></a>四、OAuth配置文件中指定过滤器</h4><p>只需要将自定义的过滤器添加到<strong>AuthorizationServerSecurityConfigurer</strong>中，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) &#123;</span><br><span class="line">        System.out.println(&quot;配置令牌访问的安全约束&quot;);</span><br><span class="line">        //自定义ClientCredentialsTokenEndpointFilter，用于处理客户端id，密码错误的异常</span><br><span class="line">        ①OAuthServerClientCredentialsTokenEndpointFilter endpointFilter = new OAuthServerClientCredentialsTokenEndpointFilter(security,authenticationEntryPoint);</span><br><span class="line">       ① endpointFilter.afterPropertiesSet();</span><br><span class="line">        ①security.addTokenEndpointAuthenticationFilter(endpointFilter);</span><br><span class="line"></span><br><span class="line">        security</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                //开启/oauth/token_key验证端口权限访问</span><br><span class="line">                .tokenKeyAccess(&quot;permitAll()&quot;)</span><br><span class="line">                //开启/oauth/check_token验证端口认证权限访问</span><br><span class="line">                .checkTokenAccess(&quot;permitAll()&quot;);</span><br><span class="line">               ② //一定不要添加allowFormAuthenticationForClients，否则自定义的OAuthServerClientCredentialsTokenEndpointFilter不生效</span><br><span class="line">//                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第<strong>①</strong>部分是添加过滤器，其中<strong>authenticationEntryPoint</strong>使用的是第2步自定义的<strong>OAuthServerAuthenticationEntryPoint</strong></p><p>第<strong>②</strong>部分一定要注意：一定要去掉这行代码，具体原因源码解释。</p><h4 id="五、源码追踪"><a href="#五、源码追踪" class="headerlink" title="五、源码追踪"></a>五、源码追踪</h4><h6 id="I、OAuthServerAuthenticationEntryPoint在何时调用？"><a href="#I、OAuthServerAuthenticationEntryPoint在何时调用？" class="headerlink" title="I、OAuthServerAuthenticationEntryPoint在何时调用？"></a>I、OAuthServerAuthenticationEntryPoint在何时调用？</h6><p>OAuthServerAuthenticationEntryPoint这个过滤器继承了 <strong>AbstractAuthenticationProcessingFilter</strong> 这个抽象类，一切的逻辑都在 <strong>doFilter()</strong> 中，陈某简化了其中的关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)</span><br><span class="line">throws IOException, ServletException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //调用子类的attemptAuthentication方法，获取参数并且认证</span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line">&#125;</span><br><span class="line">catch (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">            //一旦认证异常，则调用unsuccessfulAuthentication方法，通过failureHandler处理</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">catch (AuthenticationException failed) &#123;</span><br><span class="line">            //一旦认证异常，则调用unsuccessfulAuthentication方法，通过failureHandler处理</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//认证成功，则调用successHandler处理</span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码在 <strong>unsuccessfulAuthentication()</strong> 这个方法中，代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;</span><br><span class="line">    SecurityContextHolder.clearContext();</span><br><span class="line">    if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">        this.logger.debug(&quot;Authentication request failed: &quot; + failed.toString(), failed);</span><br><span class="line">        this.logger.debug(&quot;Updated SecurityContextHolder to contain null Authentication&quot;);</span><br><span class="line">        this.logger.debug(&quot;Delegating to authentication failure handler &quot; + this.failureHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.rememberMeServices.loginFail(request, response);</span><br><span class="line">    this.failureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="II、自定义的过滤器如何生效的？"><a href="#II、自定义的过滤器如何生效的？" class="headerlink" title="II、自定义的过滤器如何生效的？"></a>II、自定义的过滤器如何生效的？</h6><p>这个就要看 <strong>AuthorizationServerSecurityConfigurer#configure()</strong> 这个方法了，其中有一段代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(var2.hasNext()) &#123;</span><br><span class="line">    Filter filter = (Filter)var2.next();</span><br><span class="line">    http.addFilterBefore(filter, BasicAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，我们自定义的过滤链被加到了BasicAuthenticationFilter里面</p><h6 id="III、为什么不能加-allowFormAuthenticationForClients-？"><a href="#III、为什么不能加-allowFormAuthenticationForClients-？" class="headerlink" title="III、为什么不能加.allowFormAuthenticationForClients()？"></a>III、为什么不能加.allowFormAuthenticationForClients()？</h6><p>还是在 <strong>AuthorizationServerSecurityConfigurer#configure()</strong> 这个方法中，一旦设置了 <strong>allowFormAuthenticationForClients</strong> 为true，则会创建 <strong>ClientCredentialsTokenEndpointFilter</strong>，此时自定义的自然失效了。</p><h2 id="【2】资源服务自定义异常信息"><a href="#【2】资源服务自定义异常信息" class="headerlink" title="【2】资源服务自定义异常信息"></a>【2】资源服务自定义异常信息</h2><p>下面针对上述两种异常分别定制异常提示信息，这个比认证服务定制简单。</p><h3 id="1、自定义返回结果：没有权限访问时"><a href="#1、自定义返回结果：没有权限访问时" class="headerlink" title="1、自定义返回结果：没有权限访问时"></a>1、自定义返回结果：没有权限访问时</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">ServerAccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange, AccessDeniedException denied)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;RequestAccessDeniedHandler&quot;</span>);</span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.OK);</span><br><span class="line">        response.getHeaders().add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        System.out.println(<span class="string">&quot;wuquan2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String body= JSONUtil.toJsonStr(<span class="keyword">new</span> <span class="title class_">ResultMsg</span>(ResultCode.NO_PERMISSION.getCode(),ResultCode.NO_PERMISSION.getMsg(),<span class="literal">null</span>));</span><br><span class="line">        <span class="type">DataBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span>  response.bufferFactory().wrap(body.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、用于处理没有登录或token过期时的自定义返回结果"><a href="#2、用于处理没有登录或token过期时的自定义返回结果" class="headerlink" title="2、用于处理没有登录或token过期时的自定义返回结果"></a>2、用于处理没有登录或token过期时的自定义返回结果</h3><h1 id="令牌配置"><a href="#令牌配置" class="headerlink" title="令牌配置"></a>令牌配置</h1><h2 id="【1】令牌本身的配置"><a href="#【1】令牌本身的配置" class="headerlink" title="【1】令牌本身的配置"></a>【1】令牌本身的配置</h2><ul><li>令牌相关的配置都放在了AccessTokenConfig这个配置类中，代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 令牌的存储策略</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public TokenStore tokenStore() &#123;</span><br><span class="line">        //使用JwtTokenStore生成JWT令牌</span><br><span class="line">        return new JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JwtAccessTokenConverter</span><br><span class="line">     * TokenEnhancer的子类，在JWT编码的令牌值和OAuth身份验证信息之间进行转换。</span><br><span class="line">     * TODO：后期可以使用非对称加密</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAccessTokenConverter jwtAccessTokenConverter()&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = new JwtAccessTokenEnhancer();</span><br><span class="line">        // 设置秘钥</span><br><span class="line">        converter.setSigningKey(TokenConstant.SIGN_KEY);</span><br><span class="line">        /*</span><br><span class="line">         * 设置自定义得的令牌转换器，从map中转换身份信息</span><br><span class="line">         * fix(*)：修复刷新令牌无法获取用户详细信息的问题</span><br><span class="line">         */</span><br><span class="line">        converter.setAccessTokenConverter(new JwtEnhanceAccessTokenConverter());</span><br><span class="line">        return converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JWT令牌增强，继承JwtAccessTokenConverter</span><br><span class="line">     * 将业务所需的额外信息放入令牌中，这样下游微服务就能解析令牌获取</span><br><span class="line">     */</span><br><span class="line">    public static class JwtAccessTokenEnhancer extends JwtAccessTokenConverter &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 重写enhance方法，在其中扩展</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) &#123;</span><br><span class="line">            Object principal = authentication.getUserAuthentication().getPrincipal();</span><br><span class="line">            if (principal instanceof SecurityUser)&#123;</span><br><span class="line">                //获取userDetailService中查询到用户信息</span><br><span class="line">                SecurityUser user=(SecurityUser)principal;</span><br><span class="line">                //将额外的信息放入到LinkedHashMap中</span><br><span class="line">                LinkedHashMap&lt;String,Object&gt; extendInformation=new LinkedHashMap&lt;&gt;();</span><br><span class="line">                //设置用户的userId</span><br><span class="line">                extendInformation.put(TokenConstant.USER_ID,user.getUserId());</span><br><span class="line">                //添加到additionalInformation</span><br><span class="line">                ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(extendInformation);</span><br><span class="line">            &#125;</span><br><span class="line">            return super.enhance(accessToken, authentication);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>1、JwtAccessTokenConverter</strong></li></ul><p>令牌增强类，用于JWT令牌和OAuth身份进行转换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public JwtAccessTokenConverter jwtAccessTokenConverter()&#123;</span><br><span class="line">    JwtAccessTokenConverter converter = new JwtAccessTokenEnhancer();</span><br><span class="line">    // 设置秘钥</span><br><span class="line">    converter.setSigningKey(TokenConstant.SIGN_KEY);</span><br><span class="line">    /*</span><br><span class="line">     * 设置自定义得的令牌转换器，从map中转换身份信息</span><br><span class="line">     * fix(*)：修复刷新令牌无法获取用户详细信息的问题</span><br><span class="line">     */</span><br><span class="line">    converter.setAccessTokenConverter(new JwtEnhanceAccessTokenConverter());</span><br><span class="line">    return converter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>2、TokenStore</strong></li></ul><p>令牌的存储策略，这里使用的是JwtTokenStore，使用JWT的令牌生成方式，其实还有以下两个比较常用的方式</p><ul><li><ul><li>RedisTokenStore：将令牌存储到Redis中，此种方式相对于内存方式来说性能更好</li><li>JdbcTokenStore：将令牌存储到数据库中，需要新建从对应的表，有兴趣的可以尝试</li></ul></li><li><p><strong>3</strong>、<strong>SIGN_KEY</strong></p></li></ul><p>JWT签名的秘钥，这里使用的是对称加密，资源服务中也要使用相同的秘钥进行校验和解析JWT令牌。</p><h2 id="【2】令牌管理服务的配置"><a href="#【2】令牌管理服务的配置" class="headerlink" title="【2】令牌管理服务的配置"></a>【2】令牌管理服务的配置</h2><p><strong>这个放在了AuthorizationServerConfig这个配置类中，代码如下：</strong></p><ul><li><strong>使用的是DefaultTokenServices这个实现类，其中可以配置令牌相关的内容，比如access_token、refresh_token的过期时间，默认时间分别为12小时、30天。</strong></li><li><strong>最重要的一行代码当然是设置令牌增强，使用JWT方式生产令牌，如下：services.setTokenEnhancer(jwtAccessTokenConverter);</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> AuthorizationServerTokenServices <span class="title function_">tokenServices</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;令牌管理服务的配置&quot;</span>);</span><br><span class="line">    <span class="type">DefaultTokenServices</span> <span class="variable">services</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTokenServices</span>();</span><br><span class="line">    <span class="comment">//客户端端配置策略</span></span><br><span class="line">    services.setClientDetailsService(clientDetailsService);</span><br><span class="line">    <span class="comment">//支持令牌的刷新</span></span><br><span class="line">    services.setSupportRefreshToken(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//令牌服务</span></span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    <span class="comment">//access_token的过期时间</span></span><br><span class="line">    services.setAccessTokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//refresh_token的过期时间</span></span><br><span class="line">    services.setRefreshTokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置令牌增强，使用JwtAccessTokenConverter进行转换</span></span><br><span class="line">    services.setTokenEnhancer(jwtAccessTokenConverter);</span><br><span class="line">    <span class="keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【3】、令牌访问端点添加tokenServices"><a href="#【3】、令牌访问端点添加tokenServices" class="headerlink" title="【3】、令牌访问端点添加tokenServices"></a>【3】、令牌访问端点添加tokenServices</h2><h1 id="前置知识：security"><a href="#前置知识：security" class="headerlink" title="前置知识：security"></a>前置知识：security</h1><h2 id="security的核心，Spring-Security使用了springSecurityFilterChain作为了安全过滤的入口"><a href="#security的核心，Spring-Security使用了springSecurityFilterChain作为了安全过滤的入口" class="headerlink" title="security的核心，Spring Security使用了springSecurityFilterChain作为了安全过滤的入口"></a>security的核心，Spring Security使用了springSecurityFilterChain作为了安全过滤的入口</h2><h2 id="【1】Spring-Security过滤器"><a href="#【1】Spring-Security过滤器" class="headerlink" title="【1】Spring Security过滤器"></a>【1】Spring Security过滤器</h2><h3 id="1、核心过滤器概述"><a href="#1、核心过滤器概述" class="headerlink" title="1、核心过滤器概述"></a>1、核心过滤器概述</h3><p>从控制台打印过滤器可见</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.security.web.util.matcher.AnyRequestMatcher@<span class="number">1</span>,</span><br><span class="line">[</span><br><span class="line">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@184de357,</span><br><span class="line">    org.springframework.security.web.context.SecurityContextPersistenceFilter@521ba38f,</span><br><span class="line">    org.springframework.security.web.header.HeaderWriterFilter@77bb916f,</span><br><span class="line">    org.springframework.security.web.csrf.CsrfFilter@76b305e1,</span><br><span class="line">    org.springframework.security.web.authentication.logout.LogoutFilter@17c53dfb,</span><br><span class="line">    org.springframework.security.web.savedrequest.RequestCacheAwareFilter@2086d469,</span><br><span class="line">    org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter<span class="meta">@b1d19ff</span>,</span><br><span class="line">    org.springframework.security.web.authentication.AnonymousAuthenticationFilter<span class="meta">@efe49ab</span>,</span><br><span class="line">    org.springframework.security.web.session.SessionManagementFilter@5a48d186,</span><br><span class="line">    org.springframework.security.web.access.ExceptionTranslationFilter@273aaab7</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>SecurityContextPersistenceFilter 两个主要职责：请求来临时，创建SecurityContext安全上下文信息，请求结束时清空SecurityContextHolder。</li><li>HeaderWriterFilter (文档中并未介绍，非核心过滤器) 用来给http响应添加一些Header,比如X-Frame-Options, X-XSS-Protection*，X-Content-Type-Options.</li><li>CsrfFilter 在spring4这个版本中被默认开启的一个过滤器，用于防止csrf攻击，了解前后端分离的人一定不会对这个攻击方式感到陌生，前后端使用json交互需要注意的一个问题。</li><li>LogoutFilter 顾名思义，处理注销的过滤器</li><li>UsernamePasswordAuthenticationFilter 这个会重点分析，表单提交了username和password，被封装成token进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。</li><li>RequestCacheAwareFilter (文档中并未介绍，非核心过滤器) 内部维护了一个RequestCache，用于缓存request请求</li><li>SecurityContextHolderAwareRequestFilter 此过滤器对ServletRequest进行了一次包装，使得request具有更加丰富的API</li><li>AnonymousAuthenticationFilter 匿名身份过滤器，这个过滤器个人认为很重要，需要将它</li><li>UsernamePasswordAuthenticationFilter 放在一起比较理解，spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。</li><li>SessionManagementFilter 和session相关的过滤器，内部维护了一个SessionAuthenticationStrategy，两者组合使用，常用来防止session-fixation protection attack，以及限制同一用户开启多个会话的数量</li><li>ExceptionTranslationFilter 直译成异常翻译过滤器，还是比较形象的，这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理，具体是那些类下面详细介绍</li><li>FilterSecurityInterceptor 这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的</li></ul><h2 id="【2】Spring-Security核心过滤器解析"><a href="#【2】Spring-Security核心过滤器解析" class="headerlink" title="【2】Spring Security核心过滤器解析"></a>【2】Spring Security核心过滤器解析</h2><h3 id="1、SecurityContextPersistenceFilter"><a href="#1、SecurityContextPersistenceFilter" class="headerlink" title="1、SecurityContextPersistenceFilter"></a>1、SecurityContextPersistenceFilter</h3><p>SecurityContextPersistenceFilter的两个主要作用便是请求来临时，创建SecurityContext安全上下文信息和请求结束时清空SecurityContextHolder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILTER_APPLIED</span> <span class="operator">=</span> <span class="string">&quot;__spring_security_scpf_applied&quot;</span>;</span><br><span class="line">   <span class="comment">//安全上下文存储的仓库</span></span><br><span class="line">   <span class="keyword">private</span> SecurityContextRepository repo;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">SecurityContextPersistenceFilter</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//HttpSessionSecurityContextRepository是SecurityContextRepository接口的一个实现类</span></span><br><span class="line">      <span class="comment">//使用HttpSession来存储SecurityContext</span></span><br><span class="line">      <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">HttpSessionSecurityContextRepository</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">      <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">      <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// ensure that filter is only applied once per request</span></span><br><span class="line">         chain.doFilter(request, response);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">      <span class="comment">//包装request，response</span></span><br><span class="line">      <span class="type">HttpRequestResponseHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpRequestResponseHolder</span>(request,</span><br><span class="line">            response);</span><br><span class="line">      <span class="comment">//从Session中获取安全上下文信息</span></span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> repo.loadContext(holder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//请求开始时，设置安全上下文信息，这样就避免了用户直接从Session中获取安全上下文信息</span></span><br><span class="line">         SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">         chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">//请求结束后，清空安全上下文信息</span></span><br><span class="line">         <span class="type">SecurityContext</span> <span class="variable">contextAfterChainExecution</span> <span class="operator">=</span> SecurityContextHolder</span><br><span class="line">               .getContext();</span><br><span class="line">         SecurityContextHolder.clearContext();</span><br><span class="line">         repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">               holder.getResponse());</span><br><span class="line">         request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">         <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;SecurityContextHolder now cleared, as request processing completed&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、SecurityContextPersistenceFilter"><a href="#2、SecurityContextPersistenceFilter" class="headerlink" title="2、SecurityContextPersistenceFilter"></a>2、SecurityContextPersistenceFilter</h3><p>内部调用了authenticationManager完成认证，根据认证结果执行successfulAuthentication或者unsuccessfulAuthentication，无论成功失败，一般的实现都是转发或者重定向等处理，不再细究AuthenticationSuccessHandler和AuthenticationFailureHandler，有兴趣的朋友，可以去看看两者的实现类。</p><h3 id="2-3-AnonymousAuthenticationFilter"><a href="#2-3-AnonymousAuthenticationFilter" class="headerlink" title="2.3 AnonymousAuthenticationFilter"></a>2.3 AnonymousAuthenticationFilter</h3><p>匿名认证过滤器，可能有人会想：匿名了还有身份？我自己对于Anonymous匿名身份的理解是Spring Security为了整体逻辑的统一性，即使是未通过认证的用户，也给予了一个匿名身份。而AnonymousAuthenticationFilter该过滤器的位置也是非常的科学的，它位于常用的身份认证过滤器（如UsernamePasswordAuthenticationFilter、BasicAuthenticationFilter、RememberMeAuthenticationFilter）之后，意味着只有在上述身份过滤器执行完毕后，SecurityContext依旧没有用户信息，AnonymousAuthenticationFilter该过滤器才会有意义—-基于用户一个匿名身份。</p><h3 id="2-4-ExceptionTranslationFilter"><a href="#2-4-ExceptionTranslationFilter" class="headerlink" title="2.4 ExceptionTranslationFilter"></a>2.4 ExceptionTranslationFilter</h3><p>ExceptionTranslationFilter异常转换过滤器位于整个springSecurityFilterChain的后方，用来转换整个链路中出现的异常，将其转化，顾名思义，转化以意味本身并不处理。一般其只处理两大类异常：AccessDeniedException访问异常和AuthenticationException认证异常。</p><p>这个过滤器非常重要，因为它将Java中的异常和HTTP的响应连接在了一起，这样在处理异常时，我们不用考虑密码错误该跳到什么页面，账号锁定该如何，只需要关注自己的业务逻辑，抛出相应的异常便可。如果该过滤器检测到AuthenticationException，则将会交给内部的AuthenticationEntryPoint去处理，如果检测到AccessDeniedException，需要先判断当前用户是不是匿名用户，如果是匿名访问，则和前面一样运行AuthenticationEntryPoint，否则会委托给AccessDeniedHandler去处理，而AccessDeniedHandler的默认实现，是AccessDeniedHandlerImpl。所以ExceptionTranslationFilter内部的AuthenticationEntryPoint是至关重要的，顾名思义：认证的入口点。</p><h3 id="2-5-FilterSecurityInterceptor"><a href="#2-5-FilterSecurityInterceptor" class="headerlink" title="2.5 FilterSecurityInterceptor"></a>2.5 FilterSecurityInterceptor</h3><p>我们已经有了认证，有了请求的封装，有了Session的关联，还缺一个：由什么控制哪些资源是受限的，这些受限的资源需要什么权限，需要什么角色…这一切和访问控制相关的操作，都是由FilterSecurityInterceptor完成的。</p><p>FilterSecurityInterceptor的工作流程可以理解如下：FilterSecurityInterceptor从SecurityContextHolder中获取Authentication对象，然后比对用户拥有的权限和资源所需的权限。前者可以通过Authentication对象直接获得，而后者则需要引入我们之前一直未提到过的两个类：SecurityMetadataSource，AccessDecisionManager。理解清楚决策管理器的整个创建流程和SecurityMetadataSource的作用需要花很大一笔功夫，这里，暂时只介绍其大概的作用</p><p>cationFilter该过滤器才会有意义—-基于用户一个匿名身份。</p><h3 id="2-4-ExceptionTranslationFilter-1"><a href="#2-4-ExceptionTranslationFilter-1" class="headerlink" title="2.4 ExceptionTranslationFilter"></a>2.4 ExceptionTranslationFilter</h3><p>ExceptionTranslationFilter异常转换过滤器位于整个springSecurityFilterChain的后方，用来转换整个链路中出现的异常，将其转化，顾名思义，转化以意味本身并不处理。一般其只处理两大类异常：AccessDeniedException访问异常和AuthenticationException认证异常。</p><p>这个过滤器非常重要，因为它将Java中的异常和HTTP的响应连接在了一起，这样在处理异常时，我们不用考虑密码错误该跳到什么页面，账号锁定该如何，只需要关注自己的业务逻辑，抛出相应的异常便可。如果该过滤器检测到AuthenticationException，则将会交给内部的AuthenticationEntryPoint去处理，如果检测到AccessDeniedException，需要先判断当前用户是不是匿名用户，如果是匿名访问，则和前面一样运行AuthenticationEntryPoint，否则会委托给AccessDeniedHandler去处理，而AccessDeniedHandler的默认实现，是AccessDeniedHandlerImpl。所以ExceptionTranslationFilter内部的AuthenticationEntryPoint是至关重要的，顾名思义：认证的入口点。</p><h3 id="2-5-FilterSecurityInterceptor-1"><a href="#2-5-FilterSecurityInterceptor-1" class="headerlink" title="2.5 FilterSecurityInterceptor"></a>2.5 FilterSecurityInterceptor</h3><p>我们已经有了认证，有了请求的封装，有了Session的关联，还缺一个：由什么控制哪些资源是受限的，这些受限的资源需要什么权限，需要什么角色…这一切和访问控制相关的操作，都是由FilterSecurityInterceptor完成的。</p><p>FilterSecurityInterceptor的工作流程可以理解如下：FilterSecurityInterceptor从SecurityContextHolder中获取Authentication对象，然后比对用户拥有的权限和资源所需的权限。前者可以通过Authentication对象直接获得，而后者则需要引入我们之前一直未提到过的两个类：SecurityMetadataSource，AccessDecisionManager。理解清楚决策管理器的整个创建流程和SecurityMetadataSource的作用需要花很大一笔功夫，这里，暂时只介绍其大概的作用</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-IOC</title>
      <link href="/2024/04/11/Spring-IOC%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/04/11/Spring-IOC%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>在功能上，SpringBoot的容器启动过程基本遵循了Spring的标准启动过程，但是在具体实现上，SpringBoot提供了一些特殊的机制来简化Spring容器的配置和启动。</strong></p><p><strong>首先，SpringBoot自动配置了很多常用的第三方库和框架，使得在大多数情况下，开发者不需要手动配置就能够使用这些库和框架。其次，SpringBoot提供了一些基础设施和约定来简化Spring的配置，例如默认的目录结构、默认的配置文件名、默认的属性配置等，这些都能够减少开发者的配置工作。最后，SpringBoot提供了一些自定义扩展机制，例如通过@ConfigurationProperties注解来绑定配置文件属性到Java对象，通过SpringApplication类的addListeners()方法来添加自定义的启动监听器等等，这些扩展机制能够让开发者更加方便地自定义和扩展SpringBoot的功能。</strong></p><p><strong>总的来说，SpringBoot并没有改变Spring的核心机制和启动过程，但是它在具体实现上提供了很多便利和简化，让开发者能够更加快速地开发和部署应用程序</strong></p><p>总体分成两个阶段；</p><ul><li>一、refresh之前</li><li>二、调用refresh()方法刷新容器</li></ul><h2 id="一、初始化流程"><a href="#一、初始化流程" class="headerlink" title="一、初始化流程"></a>一、初始化流程</h2><ol><li>创建并实例化一个 ApplicationContextInitializer 列表，用于对 Spring 应用上下文进行初始化。ApplicationContextInitializer 是 Spring 4.1 引入的一个新特性，允许用户在容器启动之前，对 Spring 应用上下文进行一些额外的初始化工作。</li><li>创建并实例化一个 ResourceLoader 对象，用于加载配置文件。ResourceLoader 是一个接口，它定义了资源加载的基本方法。Spring 容器默认使用 DefaultResourceLoader 作为 ResourceLoader 实现类。</li><li>创建并实例化一个 PropertyResolver 对象，用于解析配置文件中的属性。PropertyResolver 也是一个接口，它定义了属性解析的基本方法。Spring 容器默认使用 PropertySourcesPlaceholderConfigurer 作为 PropertyResolver 实现类。</li><li>加载和解析配置文件，将解析后的配置信息封装成一个 Environment 对象。Environment 是 Spring 中用于描述应用环境的一个抽象概念，它包含了各种配置属性和属性值。</li><li>将解析后的配置信息封装成一个 ConfigurableEnvironment 对象，并将其设置到容器中。ConfigurableEnvironment 是 Environment 的一个子接口，它定义了一些额外的操作，如添加属性、激活配置文件等。</li><li>创建并实例化一个 BeanFactoryPostProcessor 列表，用于在 BeanFactory 加载 Bean 定义之后，对 Bean 定义进行进一步的处理。BeanFactoryPostProcessor 是一个接口，它提供了在 BeanFactory 加载 Bean 定义之后，修改 Bean 定义的机会。</li><li>创建并实例化一个 BeanPostProcessor 列表，用于在 Bean 实例化之后，对 Bean 进行进一步的处理。BeanPostProcessor 是一个接口，它提供了在 Bean 实例化之后，修改 Bean 实例的机会。</li><li>注册并加载 BeanFactory 中的 Bean 定义。在这个阶段，Spring 容器会扫描指定的包，查找标注了 @Component、@Service、@Repository、@Controller 等注解的 Bean，将其封装成 BeanDefinition 对象，注册到 BeanFactory 中。</li><li>调用 BeanFactoryPostProcessor 的 postProcessBeanFactory() 方法，对 BeanFactory 中的 Bean 定义进行进一步的处理。</li><li>注册并加载 BeanFactoryPostProcessor 中的 Bean 定义。BeanFactoryPostProcessor 可以通过实现 BeanDefinitionRegistryPostProcessor 接口，向 BeanFactory 中注册新的 Bean 定义。</li><li>初始化并注册 ConversionService。ConversionService 是 Spring 中用于类型转换的一个组件，它可以将一个对象转换成另一个类型的对象。在这个阶段，Spring 容器会注册一些默认的转换器。</li><li>初始化并注册 LoadTimeWeaver。LoadTimeWeaver 是 Spring 中用于支持动态类加载和增强的一个组件。它可以将类的字节码在运行时进行增强，从而实现 AOP 等功能。</li><li>初始化并注册 Resource</li></ol><p><strong>中间第8步解析过程如下：</strong></p><p>这个步骤主要是用来解析用户传入的 Spring 配置类，解析成一个 BeanDefinition 然后注册到容器中，主要源码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span><br><span class="line">@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) &#123;</span><br><span class="line">// 解析传入的配置类，实际上这个方法既可以解析配置类，也可以解析 Spring bean 对象</span><br><span class="line">AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">// 判断是否需要跳过，判断依据是此类上有没有 @Conditional 注解</span><br><span class="line">if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));</span><br><span class="line">// 处理类上的通用注解</span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">if (qualifiers != null) &#123;</span><br><span class="line">for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">if (Primary.class == qualifier) &#123;</span><br><span class="line">abd.setPrimary(true);</span><br><span class="line">&#125;</span><br><span class="line">else if (Lazy.class == qualifier) &#123;</span><br><span class="line">abd.setLazyInit(true);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">abd.addQualifier(new AutowireCandidateQualifier(qualifier));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 封装成一个 BeanDefinitionHolder</span><br><span class="line">for (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">customizer.customize(abd);</span><br><span class="line">&#125;</span><br><span class="line">BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);</span><br><span class="line">// 处理 scopedProxyMode</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line"> </span><br><span class="line">// 把 BeanDefinitionHolder 注册到 registry</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「扫描」在XML/注解/JavaConfig 中需要被Spring管理的Bean信息</span><br><span class="line"></span><br><span class="line">随后，会将这些信息封装成BeanDefinition，最后会把这些信息放到一个beanDefinitionMap中</span><br><span class="line">那么BeanDefintiions是什么勒？</span><br><span class="line"></span><br><span class="line">BeanDefintiions其实就是对Bean的一些元数据定义</span><br><span class="line">包括parenName 父类名称 baenClassName：类名，scope bean的作用域。Abstract是否是抽象的等信息。</span><br><span class="line">通过 BeanDefinitionReader获取到BeanDefinition之后 。我们在通过BeanDefinitionRegistry将beanDefinition注册到BeanFacory中。存储在BeanFactory的一个conCurrentHashMap中。key为beanName,Value就是BeanDefinition元数据。</span><br><span class="line">Spring通过BeanDefinationReader将配置元信息加载到内存生成相应的BeanDefination之后，就将其注册到BeanDefinationRegistry中，BeanDefinationRegistry就是一个存放BeanDefination的大篮子，它也是一种键值对的形式，通过特定的Bean定义的id，映射到相应的BeanDefination</span><br></pre></td></tr></table></figure><p><strong>接着会遍历这个beanDefinitionMap，执行BeanFactoryPostProcessor这个Bean工厂后置处理器的逻辑，比如替换<code>$</code>占位符</strong></p><p><img src="https://img-blog.csdnimg.cn/690f5df98811421ab1dc6e1495375d71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ0Nxd2Fz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h2 id="三、refresh-容器刷新流程-最重要"><a href="#三、refresh-容器刷新流程-最重要" class="headerlink" title="三、refresh()容器刷新流程(最重要)"></a>三、refresh()容器刷新流程(最重要)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、prepareRefresh()刷新前的预处理：</span><br><span class="line"></span><br><span class="line">（1）initPropertySources()：初始化一些属性设置，子类自定义个性化的属性设置方法；</span><br><span class="line">（2）getEnvironment().validateRequiredProperties()：检验属性的合法性</span><br><span class="line">（3）earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;()：保存容器中的一些早期的事件；</span><br><span class="line">2、obtainFreshBeanFactory()：获取在容器初始化时创建的BeanFactory：</span><br><span class="line"></span><br><span class="line">（1）refreshBeanFactory()：刷新BeanFactory，设置序列化ID；</span><br><span class="line">（2）getBeanFactory()：返回初始化中的GenericApplicationContext创建的BeanFactory对象，即【DefaultListableBeanFactory】类型</span><br><span class="line">3、prepareBeanFactory(beanFactory)：BeanFactory的预处理工作，向容器中添加一些组件：</span><br><span class="line"></span><br><span class="line">（1）设置BeanFactory的类加载器、设置表达式解析器等等</span><br><span class="line">（2）添加BeanPostProcessor【ApplicationContextAwareProcessor】</span><br><span class="line">（3）设置忽略自动装配的接口：EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware；</span><br><span class="line">（4）注册可以解析的自动装配类，即可以在任意组件中通过注解自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext</span><br><span class="line">（5）添加BeanPostProcessor【ApplicationListenerDetector】</span><br><span class="line">（6）添加编译时的AspectJ；</span><br><span class="line">（7）给BeanFactory中注册的3个组件：environment【ConfigurableEnvironment】、systemProperties【Map&lt;String, Object&gt;】、systemEnvironment【Map&lt;String, Object&gt;】</span><br><span class="line">4、postProcessBeanFactory(beanFactory)：子类重写该方法，可以实现在BeanFactory创建并预处理完成以后做进一步的设置</span><br><span class="line"></span><br><span class="line">5、invokeBeanFactoryPostProcessors(beanFactory)：在BeanFactory标准初始化之后执行BeanFactoryPostProcessor的方法，即BeanFactory的后置处理器：</span><br><span class="line"></span><br><span class="line">（1）先执行BeanDefinitionRegistryPostProcessor： postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class="line"></span><br><span class="line">① 获取所有的实现了BeanDefinitionRegistryPostProcessor接口类型的集合</span><br><span class="line">② 先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor</span><br><span class="line">③ 再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor</span><br><span class="line">④ 最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors        </span><br><span class="line">（2）再执行BeanFactoryPostProcessor的方法：postProcessor.postProcessBeanFactory(beanFactory)</span><br><span class="line"></span><br><span class="line">① 获取所有的实现了BeanFactoryPostProcessor接口类型的集合</span><br><span class="line">② 先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor</span><br><span class="line">③ 再执行实现了Ordered顺序接口的BeanFactoryPostProcessor</span><br><span class="line">④ 最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor</span><br><span class="line">6、registerBeanPostProcessors(beanFactory)：向容器中注册Bean的后置处理器BeanPostProcessor，它的主要作用是干预Spring初始化bean的流程，从而完成代理、自动注入、循环依赖等功能</span><br><span class="line"></span><br><span class="line">（1）获取所有实现了BeanPostProcessor接口类型的集合：</span><br><span class="line">（2）先注册实现了PriorityOrdered优先级接口的BeanPostProcessor；</span><br><span class="line">（3）再注册实现了Ordered优先级接口的BeanPostProcessor；</span><br><span class="line">（4）最后注册没有实现任何优先级接口的BeanPostProcessor；</span><br><span class="line">（5）最r终注册MergedBeanDefinitionPostProcessor类型的BeanPostProcessor：beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">（6）给容器注册一个ApplicationListenerDetector：用于在Bean创建完成后检查是否是ApplicationListener，如果是，就把Bean放到容器中保存起来：applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">此时容器中默认有6个默认的BeanProcessor(无任何代理模式下)：【ApplicationContextAwareProcessor】、【ConfigurationClassPostProcessorsAwareBeanPostProcessor】、【PostProcessorRegistrationDelegate】、【CommonAnnotationBeanPostProcessor】、【AutowiredAnnotationBeanPostProcessor】、【ApplicationListenerDetector】</span><br><span class="line"></span><br><span class="line">7、initMessageSource()：初始化MessageSource组件，主要用于做国际化功能，消息绑定与消息解析：</span><br><span class="line"></span><br><span class="line">（1）看BeanFactory容器中是否有id为messageSource 并且类型是MessageSource的组件：如果有，直接赋值给messageSource；如果没有，则创建一个DelegatingMessageSource；</span><br><span class="line">（2）把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource；</span><br><span class="line">8、initApplicationEventMulticaster()：初始化事件派发器，在注册监听器时会用到：</span><br><span class="line"></span><br><span class="line">（1）看BeanFactory容器中是否存在自定义的ApplicationEventMulticaster：如果有，直接从容器中获取；如果没有，则创建一个SimpleApplicationEventMulticaster</span><br><span class="line">（2）将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件就可以直接自动注入</span><br><span class="line">9、onRefresh()：留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑</span><br><span class="line"></span><br><span class="line">10、registerListeners()：注册监听器：将容器中所有的ApplicationListener注册到事件派发器中，并派发之前步骤产生的事件：</span><br><span class="line"></span><br><span class="line"> （1）从容器中拿到所有的ApplicationListener</span><br><span class="line">（2）将每个监听器添加到事件派发器中：getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">（3）派发之前步骤产生的事件applicationEvents：getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">11、finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；</span><br><span class="line"></span><br><span class="line">（1）获取容器中的所有beanDefinitionName，依次进行初始化和创建对象</span><br><span class="line">（2）获取Bean的定义信息RootBeanDefinition，它表示自己的BeanDefinition和可能存在父类的BeanDefinition合并后的对象</span><br><span class="line">（3）如果Bean满足这三个条件：非抽象的，单实例，非懒加载，则执行单例Bean创建流程：    </span><br><span class="line">（4）所有Bean都利用getBean()创建完成以后，检查所有的Bean是否为SmartInitializingSingleton接口的，如果是；就执行afterSingletonsInstantiated()；</span><br><span class="line">12、finishRefresh()：发布BeanFactory容器刷新完成事件：</span><br><span class="line"></span><br><span class="line">（1）initLifecycleProcessor()：初始化和生命周期有关的后置处理器：默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】，如果没有，则创建一个DefaultLifecycleProcessor()加入到容器；</span><br><span class="line">（2）getLifecycleProcessor().onRefresh()：拿到前面定义的生命周期处理器（LifecycleProcessor）回调onRefresh()方法</span><br><span class="line">（3）publishEvent(new ContextRefreshedEvent(this))：发布容器刷新完成事件；</span><br><span class="line">（4）liveBeansView.registerApplicationContext(this);</span><br></pre></td></tr></table></figure><p>可以看到这个方法里面调用了很多的方法，我们从开始说起：</p><ul><li><p>首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；</p></li><li><p>接着往下看prepareRefresh();这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。</p></li><li><p>下一步ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();这个就很重要了，这一步是把配置文件解析成一个个BeanDefinition，并且注册到BeanFactory中，注意**<u>这里只是注册进去，并没有实例化</u>**。先继续往下看，等会展开这个方法详细解读</p></li><li><p>然后是prepareBeanFactory(beanFactory);这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看</p></li><li><p>postProcessBeanFactory(beanFactory);<strong><u>方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。</u></strong></p></li><li><p>接下来是invokeBeanFactoryPostProcessors(beanFactory);<u><strong>这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</strong></u></p></li><li><p>然后是registerBeanPostProcessors(beanFactory);这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。然后回到refresh()方法中继续往下看</p></li><li><p>initMessageSource();方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下</p></li><li><p>initApplicationEventMulticaster();方法初始化当前 ApplicationContext 的事件广播器继续往下</p></li><li><p>onRefresh();<u>方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下</u></p></li><li><p>registerListeners();方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下</p></li><li><h5 id="重点到了：finishBeanFactoryInitialization-beanFactory-初始化所有的-singleton-beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说"><a href="#重点到了：finishBeanFactoryInitialization-beanFactory-初始化所有的-singleton-beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说" class="headerlink" title="重点到了：finishBeanFactoryInitialization(beanFactory);初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说"></a>重点到了：finishBeanFactoryInitialization(beanFactory);<u>初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说</u></h5></li><li><p>finishRefresh();方法是最后一步，广播事件，ApplicationContext 初始化完成</p></li></ul><h3 id="我们重点来看ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory-和finishBeanFactoryInitialization-beanFactory-这两个方法"><a href="#我们重点来看ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory-和finishBeanFactoryInitialization-beanFactory-这两个方法" class="headerlink" title="我们重点来看ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();和finishBeanFactoryInitialization(beanFactory);这两个方法"></a>我们重点来看<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code>和<code>finishBeanFactoryInitialization(beanFactory);</code>这两个方法</h3><p>先说<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</code>; 这一步上面简单介绍过了，作用是把配置文件解析成一个个BeanBeanDefinition，并且注册到BeanFactory中，点进去源码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">return beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法中第一步refreshBeanFactory();方法的作用是关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等，然后getBeanFactory();就是返回刚刚创建的 BeanFactory(其实就是DefaultListableBeanFactory)，我们进入refreshBeanFactory();方法，在AbstractRefreshableApplicationContext类中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">if (hasBeanFactory()) &#123;</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line">synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">this.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException ex) &#123;</span><br><span class="line">throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个refreshBeanFactory()方法首先如果 ApplicationContext 中已经加载过 BeanFactory<br>了，销毁所有 Bean，关闭 BeanFactory；这里指的是当前ApplicationContext 是否有 BeanFactory。<br>然后createBeanFactory();初始化一个DefaultListableBeanFactory，这个DefaultListableBeanFactory是很重的一个类，为什么重要呢？可以看文章开头的BeanFactory继承图，DefaultListableBeanFactory是位于最下面的，他往上能走完BeanFactory继承图所有，所以他可以说是功能最大的BeanFactory。<br>beanFactory.setSerializationId(getId());方法用于 BeanFactory 的序列化<br>customizeBeanFactory(beanFactory);方法设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用，这个等会细说<br>loadBeanDefinitions(beanFactory);这个方法很重要：加载 Bean定义 到 BeanFactory 中，也是等会细说<br>下面看customizeBeanFactory(beanFactory);方法，这个方法作用：是否允许 Bean 覆盖、是否允许循环引用，这是什么意思呢？这就要说到BeanDefinition了，这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中，下面贴出来开头我说的大神的关于BeanDefinition接口的代码注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">AttributeAccessor</span>, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们可以看到，默认只提供 sington 和 prototype 两种，</span></span><br><span class="line">   <span class="comment">// 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span></span><br><span class="line">   <span class="comment">// 不过，它们属于基于 web 的扩展。</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 比较不重要，直接跳过吧</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_APPLICATION</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_SUPPORT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_INFRASTRUCTURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span></span><br><span class="line">   <span class="comment">// 一句话就是：继承父 Bean 的配置信息而已</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setParentName</span><span class="params">(String parentName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取父 Bean</span></span><br><span class="line">   String <span class="title function_">getParentName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setBeanClassName</span><span class="params">(String beanClassName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取 Bean 的类名称</span></span><br><span class="line">   String <span class="title function_">getBeanClassName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 bean 的 scope</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(String scope)</span>;</span><br><span class="line"></span><br><span class="line">   String <span class="title function_">getScope</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setLazyInit</span><span class="params">(<span class="type">boolean</span> lazyInit)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isLazyInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span></span><br><span class="line">   <span class="comment">// 是 depends-on=&quot;&quot; 属性设置的值。</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setDependsOn</span><span class="params">(String... dependsOn)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该 Bean 的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span></span><br><span class="line">   <span class="comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setAutowireCandidate</span><span class="params">(<span class="type">boolean</span> autowireCandidate)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 是否可以注入到其他 Bean 中</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAutowireCandidate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setPrimary</span><span class="params">(<span class="type">boolean</span> primary)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是 primary 的</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrimary</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span></span><br><span class="line">   <span class="comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   String <span class="title function_">getFactoryBeanName</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的 工厂方法名称</span></span><br><span class="line">   String <span class="title function_">getFactoryMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   ConstructorArgumentValues <span class="title function_">getConstructorArgumentValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   MutablePropertyValues <span class="title function_">getPropertyValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span></span><br><span class="line">   <span class="comment">// 常用于作为 父bean 用于继承，其实也很少用......</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAbstract</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getRole</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getResourceDescription</span><span class="params">()</span>;</span><br><span class="line">   BeanDefinition <span class="title function_">getOriginatingBeanDefinition</span><span class="params">()</span>;</span><br><span class="line">&#125;BeanDefinition 的覆盖问题就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 <span class="literal">null</span>，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</span><br><span class="line">循环引用：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</span><br><span class="line">默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</span><br></pre></td></tr></table></figure><p>再看loadBeanDefinitions(beanFactory) 方法，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。先贴上源码：AbstractXmlApplicationContext类中</p><pre><code>@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;    // Create a new XmlBeanDefinitionReader for the given BeanFactory.    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);  // Configure the bean definition reader with this context&#39;s  // resource loading environment.  beanDefinitionReader.setEnvironment(this.getEnvironment());  beanDefinitionReader.setResourceLoader(this);  beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));  // Allow a subclass to provide custom initialization of the reader,  // then proceed with actually loading the bean definitions.  initBeanDefinitionReader(beanDefinitionReader);  loadBeanDefinitions(beanDefinitionReader);</code></pre><p>}<br>这个源码中我们重点看loadBeanDefinitions(beanDefinitionReader);，再点进去源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">Resource[] configResources = getConfigResources();</span><br><span class="line"><span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configResources);</span><br><span class="line">&#125;</span><br><span class="line">String[] configLocations = getConfigLocations();</span><br><span class="line"><span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configLocations);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段源码中我么可以看到2个reader.loadBeanDefinitions()方法，其实两个最终都到了：AbstractBeanDefinitionReader类中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">counter += loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里面，for循环每一个文件是一个resource，最终返回 counter，表示总共加载了多少的 BeanDefinition。<br>进入loadBeanDefinitions(resource);方法，看源码：<br>XmlBeanDefinitionReader类中的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">&#125;</span><br><span class="line">  Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">  <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">    currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">        <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">      <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">        inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">        <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中可以看到try代码块中一开始是根据外层循环调用的每一个Resource解析成一个InputStream 然后根据这个输入流解析；<br>这段源码的核心在doLoadBeanDefinitions(inputSource, encodedResource.getResource());继续进源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line"><span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line"><span class="string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="string">&quot; in XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line"><span class="string">&quot;XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line"><span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line"><span class="string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line"><span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法里面可以看到doLoadDocument(inputSource, resource);方法是将 xml 文件(输入流和Resource)转换为 Document 对象，然后继续进源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"><span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个BeanDefinitionDocumentReader，然后spring通过BeanDefinitionDocumentReader 会进行委托bean定义的创建；<br>继续这个方法里面看：documentReader.registerBeanDefinitions(doc, createReaderContext(resource));点进去：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line"><span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的doRegisterBeanDefinitions(root);方法就是从 xml 根节点开始解析文件，经过很多的步骤，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，可以看到上面有个 for 循环的(loadBeanDefinitions(resource);是在for循环里面的)，进入doRegisterBeanDefinitions(root);方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line"><span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line"><span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line"><span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line"><span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line"><span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line"><span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line"><span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line"><span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">          profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">          logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">              <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">  postProcessXml(root);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中可以看到BeanDefinitionDocumentReader最终是创建了一个BeanDefinitionParserDelegate ，把bean定义的创建委托给了BeanDefinitionParserDelegate 进行创建，这就是委托模式的提现。<br>同时也可以看到这段代码中先把this.delegate给了一个parent，然后又创建了一个Delegate，然后执行最后又把这个parent给回去了this.delegate，这是为了处理<beans>标签嵌套<beans>的问题，其实是个类似递归的操作。这里大家可以debugger试试嵌套的情况就明白了。</p><h5 id="再看preProcessXml-root-，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式-模板方法模式不了解的可以看我的这篇文章-，同理postProcessXml-root-也一样，就是在Bean定义创建前后提供扩展点。"><a href="#再看preProcessXml-root-，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式-模板方法模式不了解的可以看我的这篇文章-，同理postProcessXml-root-也一样，就是在Bean定义创建前后提供扩展点。" class="headerlink" title="再看preProcessXml(root)，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式(模板方法模式不了解的可以看我的这篇文章)，同理postProcessXml(root)也一样，就是在Bean定义创建前后提供扩展点。"></a>再看preProcessXml(root)，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式(模板方法模式不了解的可以看我的这篇文章)，同理postProcessXml(root)也一样，就是在Bean定义创建前后提供扩展点。</h5><p>那继续进入parseBeanDefinitions(root, this.delegate);看重点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line"><span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是循环解析Element 的每一个节点，一般我们的普通bean都是走parseDefaultElement(ele, delegate);默认的解析流程。<br>但是这里有个else的自定义解析，这个很多人都忽略了，其实如果我们xml的配置文件中定义了<a href="aop:config">aop:config</a> 标签，他就会走这个自定义解析，然后解析aop内容，后续会在分析AOP源码，可以看这篇文章)说<a href="aop:config">aop:config</a>的时候讲这里。<br>这里我们还是走普通的beand解析逻辑parseDefaultElement(ele, delegate)，跟进去看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// recurse</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法见名知意，解析默认的Element，是4个if分支，第一个是解析import类型的，第二个是alias的，第三个是bean的(也就是我们普通bean默认的)，第四个是beans，也就是嵌套的(这里这个嵌套的就回到上面doRegisterBeanDefinitions方法了，也就是为什么说上面其实类似递归的原因)<br>这里我们只分析普通bean的解析处理，进入processBeanDefinition(ele, delegate);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register the final decorated instance.</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send registration event.</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码首先通过delegate创建一个bean定义的持有者BeanDefinitionHolder，<strong>这一步其实BeanDefinition也在里面已经创建出来了</strong>。进入delegate.parseBeanDefinitionElement(ele)看</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line"><span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"><span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"><span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line"><span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line"><span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line"><span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">!<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">aliases.add(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line"><span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">error(ex.getMessage(), ele);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这段代码中有一个parseBeanDefinitionElement(ele, beanName, containingBean)，<strong>返回了一个AbstractBeanDefinition，这个方法里面实际是创建了一个GenericBeanDefinition</strong>，这里就不跟进去看了，代码篇幅太长了，这个里面很简单没啥绕的逻辑，大家跟着点点就能看到了。创建完GenericBeanDefinition之后设置了Class属性、构造器等等一些创建Bean实例需要的东西之后就返回了。</p><p>然后回到processBeanDefinition(ele, delegate);看BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());，由于这个时候<strong>已经创建了BeanDefinition</strong>并且有持有者BeanDefinitionHolder进行注册，所以继续跟进</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line"><span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">      <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显继续跟进到registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());，这里是一个接口调用，肯定是到了DefaultListableBeanFactory，但是在这个接口调用时我们需要注意的是第二个参数，从BeanDefinitionHolder中获取到了BeanDefinition对象，这个就是创建Bean定义持有者的时候顺带获取的BeanDefinition，通过上面的解析我们知道这个时候BeanDefinition已经创建好了，然后跟进这个方法进去：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line"><span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line"><span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line"><span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line"><span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Still in startup registration phase</span></span><br><span class="line"><span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (existingDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">clearByTypeCache();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法里面就可以看到经过一系列验证等等操作，最后把BeanDefinition放入了beanDefinitionMap，到这里bean定义就完成并注册到org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap里面了</p><p>然后我们回到refresh() 方法，就是文章前部分的那个refresh() 方法…TvT<br>再贴一下refresh() 方法的源码吧，方便阅读：<br>我直接贴大神带注释的代码吧，看起来更方便一点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">   <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">  prepareRefresh();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">  <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">  <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">  <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">  <span class="comment">// 这块待会会展开说</span></span><br><span class="line">  prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">     <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">     <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">     postProcessBeanFactory(beanFactory);</span><br><span class="line">     <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span></span><br><span class="line">     invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">     <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">     <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span></span><br><span class="line">     registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">     initMessageSource();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">     initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span></span><br><span class="line">     <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">     onRefresh();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">     registerListeners();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 重点，重点，重点</span></span><br><span class="line">     <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">     <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">     finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span></span><br><span class="line">     finishRefresh();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">     <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">              <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">     <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">     destroyBeans();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">     cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 把异常往外抛</span></span><br><span class="line">     <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">     <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">     resetCommonCaches();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="到此为止，ConfigurableListableBeanFactory-beanFactory-x3D-obtainFreshBeanFactory-结束"><a href="#到此为止，ConfigurableListableBeanFactory-beanFactory-x3D-obtainFreshBeanFactory-结束" class="headerlink" title="到此为止，ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();结束"></a>到此为止，ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();结束</h4><hr><h3 id="下面我们来看finishBeanFactoryInitialization-beanFactory"><a href="#下面我们来看finishBeanFactoryInitialization-beanFactory" class="headerlink" title="下面我们来看finishBeanFactoryInitialization(beanFactory)"></a>下面我们来看finishBeanFactoryInitialization(beanFactory)</h3><p>到这一步为止BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些<strong>特殊的 Bean，如 ‘environment’、‘systemProperties’ 等</strong>。剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。点进去看源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">  <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">  <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在这段代码中：首先初始化名字为 “conversionService” 的 Bean，为什么是conversionService 呢？原因是注册这个bean之后，类似于前端传给后端的非基础类型和基础类型的包装类之外，其他的就可以考虑采用ConversionService来进行类型等的转换，初始化这个 “conversionService” 实在上面源码中的beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));进行的。然后直接跳过来到beanFactory.preInstantiateSingletons();这个方法，这里开始初始化。点进去：<br>DefaultListableBeanFactory这个类中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">  <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="type">boolean</span> isEagerInit;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li><p>迭代所有的BeanDefinitionNames集合，挨个初始化所有非懒加载的单例类。</p></li><li><p>BeanDefinitionNames是在注册BeanDefinitionMap时同时注册的集合。该集合，主要用在<strong>这里</strong>进行迭代初始化Spring Bean，并且也方便一些类似获取BeanDefinitionName的方法使用。</p></li><li><p>初始化的时候还对FactoryBean进行判断，因为默认FactoryBean默认是惰性初始化，如果实现SmartFactoryBean设置isEagerInit为true，则代表该类需要急切的进行初始化，会即刻开始初始化FactoryBean里getObject返回的类。</p></li><li><p>关于getMergedLocalBeanDefinition和getBean：Spring通过getBean来完成类的初始化并添加到Spring容器内（即Spring的一级缓存：单例池里面），而在初始化时需要当前类的相关信息：即BeanDefinition，而BeanDefinition是可以存在父子关系（并非真的继承，而是BeanDefinition可以设置父BeanDefinition），所以Spring通过getMergedLocalBeanDefinition来获取当前类的完整信息。</p></li></ol><p>getBean-》doGetBean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">// 1.转换beanName，主要处理别名、以&amp;开头的name</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.尝试从单例缓存中获取bean实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line"><span class="comment">// 3. 获取bean实例</span></span><br><span class="line"><span class="comment">// 3.1 缓存中已存在bean实例</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 省略日志输出代码...</span></span><br><span class="line"><span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 省略父工厂处理相关代码...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 省略dependsOn相关代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2 创建单例bean</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.3 创建原型bean实例</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.4 根据scope创建bean实例</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="comment">// 省略异常处理代码...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略其他代码.</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>}</p><p><strong>在可以看到上面有四种情况：缓存中存在bean实例、创建单例bean、创建原型bean、根据scope创建bean，都调用了getObjectForBeanInstance()方法，接下来我们就点进去看看。</strong></p><p><em><strong>getObjectForBeanInstance是从bean实例中获取对象（本章重点，获取实例中的对象）</strong></em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 如果是工厂引用(即name以&amp;开头)，但该实例又不是FactoryBean类型，则抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果该实例不是FactoryBean类型，或者是工厂引用都直接返回该实例</span></span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 尝试从缓存中加载bean</span></span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 把初始bean实例强转为FactoryBean</span></span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line"><span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否是用户自定义的beanDefinition(默认是false)</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line"><span class="comment">// 重点方法，跟进去</span></span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>从FactoryBean中获取对象：getObjectFromFactoryBean()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;</span><br><span class="line"><span class="comment">// 1. 单例模式</span></span><br><span class="line"><span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 真正获取对象的方法(重点方法)</span></span><br><span class="line">object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line"><span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;</span><br><span class="line">object = alreadyThere;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 调用bean的后置处理器(有兴趣的可以点进去看下，后面的章节会单独讲述)</span></span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 2. 原型模式</span></span><br><span class="line"><span class="comment">// 真正获取对象的方法(重点方法)</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>真正从FactoryBean中获取对象的逻辑：doGetObjectFromFactoryBean()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">Object object;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 权限验证</span></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> getAccessControlContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 终于看到你了！</span></span><br><span class="line">object = factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName, ex.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not accept a null value for a FactoryBean that&#x27;s not fully</span></span><br><span class="line"><span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line"><span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(</span><br><span class="line">beanName, <span class="string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">object = <span class="keyword">new</span> <span class="title class_">NullBean</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终发现其实获取对象的方法，就是一行调用FactoryBean的getObject()方法。</p><h4 id="在上面的方法中有个bean的实例化过程我们必须知道"><a href="#在上面的方法中有个bean的实例化过程我们必须知道" class="headerlink" title="在上面的方法中有个bean的实例化过程我们必须知道"></a>在上面的方法中有个bean的实例化过程我们必须知道</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//推断当前Beandefinition的beanClass</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 准备方法重写 包括lookup-method和replaced-method的处理，本文暂不展开</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 第一次调用后置处理器：初始化Bean之前，InstantiationAwareBeanPostProcessor,</span></span><br><span class="line">      <span class="comment">// 根据BeanDefinition获取到了对应的class类</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//创建Bean</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">      <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">      <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>}</p><p>docreatebean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">//从未完成的 FactoryBean 实例中移除</span></span><br><span class="line">instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//实例化对象(仅仅是生成对象，并非添加到spring单例池中，即目前并没有成为Spring Bean)，</span></span><br><span class="line"><span class="comment">//并且第二次调用 后置处理器 determineConstructorsFromBeanPostProcessors</span></span><br><span class="line"> instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> ... </span><br><span class="line">     ...  </span><br><span class="line">     ...   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先通过createBeanInstance方法调用后置处理器推断其构造函数，并反射创建BeanDefinition对应的实例。<strong>实例化 Bean</strong></p><p><strong>注意此时只是创建了类对象，但还没有添加到Spring的单例池中，即还没有加入到Spring容器内部。</strong><br><strong>可以理解为此时只是完成了类对象的声明：即类似于A a&#x3D;null</strong></p><p>添加到Spring的单例池是在getSingleton（）的addSingleton中。</p><p><a href="https://blog.csdn.net/qq_38289451/article/details/121965628">https://blog.csdn.net/qq_38289451/article/details/121965628</a></p><p>createBeanInstance() 方法是 spring 实例化 bean 的核心代码，它根据不同的情况会调用四种实例化方法</p><ul><li>obtainFromSupplier() ：通过 Supplier 实例化</li><li>instantiateUsingFactoryMethod()：通过工厂方法实例化</li><li>autowireConstructor()：用合适的构造函数实例化</li><li>instantiateBean()：用无参构造函数实例化</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;</span><br><span class="line">    </span><br><span class="line">// 确认需要创建的bean实例的类可以实例化</span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">// 确保class不为空，并且访问权限是public</span><br><span class="line">if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot; + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ----------1，通过Supplier实例化------------</span><br><span class="line"> */</span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">if (instanceSupplier != null) &#123;</span><br><span class="line">return obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">/**</span><br><span class="line"> * ----------2，通过工厂方法实例化------------</span><br><span class="line"> */</span><br><span class="line">if (mbd.getFactoryMethodName() != null) &#123;</span><br><span class="line">return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> * ----------3，用合适的构造函数实例化------------</span><br><span class="line"> *</span><br><span class="line"> *  一个类可能有多个构造器，所以Spring得根据参数个数、类型确定需要调用的构造器。</span><br><span class="line"> *  在使用构造器创建实例后，Spring会将解析过后确定下来的构造器或工厂方法保存在缓存中，</span><br><span class="line"> *  避免再次创建相同bean时再次解析</span><br><span class="line"> */</span><br><span class="line">// 标记下，防止重复创建同一个bean</span><br><span class="line">boolean resolved = false;</span><br><span class="line">// 是否需要自动装配，构造有参数的需要</span><br><span class="line">boolean autowireNecessary = false;</span><br><span class="line">// 如果没有参数</span><br><span class="line">if (args == null) &#123;</span><br><span class="line">synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">// 一个类中有多个构造函数，每个构造函数都有不同的参数，所以调用前需要先根据参数锁定构造函数或对应的工厂方法</span><br><span class="line">if (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class="line">resolved = true;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 有构造参数的或者工厂方法</span><br><span class="line">if (resolved) &#123;</span><br><span class="line">// 构造器有参数</span><br><span class="line">if (autowireNecessary) &#123;</span><br><span class="line">// 构造函数自动注入</span><br><span class="line">return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// 使用默认构造函数构造</span><br><span class="line">return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从bean后置处理器中为自动装配寻找构造方法</span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 找出最合适的默认构造方法</span><br><span class="line">ctors = mbd.getPreferredConstructors();</span><br><span class="line">if (ctors != null) &#123;</span><br><span class="line">// 构造函数自动注入</span><br><span class="line">return autowireConstructor(beanName, mbd, ctors, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> * ----------4，使用默认构造函数构造------------</span><br><span class="line"> */</span><br><span class="line">return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="新增ObjectFactory到第三级缓存"><a href="#新增ObjectFactory到第三级缓存" class="headerlink" title="新增ObjectFactory到第三级缓存"></a>新增ObjectFactory到第三级缓存</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">    throws BeanCreationException &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        //允许后置处理器重新定义beanDefinition</span><br><span class="line">synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">if (!mbd.postProcessed) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//第三次调用后置处理器 MergedBeanDefinitionPostProcessors</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否允许循环依赖，默认是允许的，可以通过代码修改的一般只有allowCircularReferences的值</span><br><span class="line">boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">if (earlySingletonExposure) &#123;</span><br><span class="line">if (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">&quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// getEarlyBeanReference里面包含了又一次后置处理器的调用，SmartInstantiationAwareBeanPostProcessor </span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="属性填充：populateBean"><a href="#属性填充：populateBean" class="headerlink" title="属性填充：populateBean"></a>属性填充：populateBean</h4><p>然后做一些处理比如循环依赖等，直到看到populateBean(beanName, mbd, instanceWrapper);这个代码，这一步负责属性装配，很重要，因为前面的实例只是实例化了，并没有设值，这里就是设值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//填充属性（即自动注入） 完成第五次和第六次后置处理器的调用</span></span><br><span class="line">        <span class="comment">// InstantiationAwareBeanPostProcessor.after</span></span><br><span class="line">        <span class="comment">// hasInstantiationAwareBeanPostProcessors</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">//完成第七次和第八次后置处理器的调用，</span></span><br><span class="line">        <span class="comment">//判断当前Bean，是否是BeanNameAware、BeanClassLoaderAware、BeanFactoryAware并分别设置相关内容</span></span><br><span class="line">        <span class="comment">//applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line">        <span class="comment">//applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">populateBean方法完成属性填充，跟进</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在设置属性之前，让任何 InstantiationAwareBeanPostProcessors 有机会修改 bean 的状态。例如，这可用于支持字段注入样式。</span></span><br><span class="line">  <span class="comment">//扩展点，又一次调用后置处理器，</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果后置处理器修改了Beandefinition，则判断是否已经修改过了属性值的相关配置</span></span><br><span class="line">   <span class="comment">//如果修改了，则按照器byName或byType的方式直接完成装载</span></span><br><span class="line">   <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">      <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   [] filteredPds = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">         pvs = mbd.getPropertyValues();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">//利用后置处理器，处理属性的获取</span></span><br><span class="line">            <span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">                  filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">               &#125;</span><br><span class="line">               pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">      <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">         filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      &#125;</span><br><span class="line">      checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//根据PropertyValues完成属性填充</span></span><br><span class="line">      applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>populateBean里面再次调用后置处理器，spring在这里提供了一个扩展点，允许开发者在属性填充这个阶段修改Bean的状态（使用后置处理器的方式）。并且可能直接依据byName和byType装载属性值。</p><p>我们知道，使用自动装载这一功能时，我们可以使用@Autowired和@Resource。这两个注解的功能也不一样。那么解析的方式也应当不一样。</p><h3 id="factorybean和beanfactory"><a href="#factorybean和beanfactory" class="headerlink" title="factorybean和beanfactory"></a>factorybean和beanfactory</h3><p>在我们的开发工作中应该都见过或使用过FactoryBean这个类，也许你会看成了BeanFactory这个类。FactoryBean和BeanFactory虽然长的很像，但是他们的作用确实完全不像。这里你可以想象一下，你会在什么样的场景下使用FactoryBean这个接口？FactoryBean是一个工厂Bean，可以生成某一个类型Bean实例，它最大的一个作用是：可以让我们自定义Bean的创建过程。BeanFactory是Spring容器中的一个基本类也是很重要的一个类，在BeanFactory中可以创建和管理Spring容器中的Bean，它对于Bean的创建有一个统一的流程。下面我们先看一下FactoryBean中有什么东西：</p><p>背景<br>假设我们有这种需求，像Mybaits需要将这些接口注入到Spring容器中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface OneTestDao &#123;</span><br><span class="line">    @Select(&quot;SELECT name FROM user WHERE id = 1&quot;)</span><br><span class="line">    String query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface TwoTestDao &#123;</span><br><span class="line">    @Select(&quot;SELECT name FROM user WHERE id = 2&quot;)</span><br><span class="line">    String query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先我们想将我们的自己的Bean(比如代理对象)注入到Spring容器中，有什么方式呢？</p><p>一般都是通过Spring扫描Resouce资源然后解析为BeanDefinition，才能从getBean时解析BeanDefinition实例化对象放入此单例缓存中.但是我们这里的是接口，没法直接注入到Spring容器中。</p><p>不过Spring提供了一些扩展接口来供我们在Bean加载、初始化、加载完提供了一些接口，供我们扩展。<br>比如BeanFactoryPostProcessor</p><p>从测试结果中得知，我们虽然配置的是<code>MapperFactoryBean</code>的实列，但是根据id拿到的是<code>getObject</code>方法创建的对象。其实在容器中创建的对象仍然是<code>MapperFactoryBean</code>的实列，只是在获取的时候会判断这个结果对象是不是派生于<code>FactoryBean</code>，如果是的话则返回<code>getObject</code>方法创建的对象，并且这个对象并不是容器初始化时创建的，而是使用<code>context.getBean()</code>方法时才创建。当然了，如果你确实想要获取<code>FactoryBean</code>实例，你需要这样写: <em><code>MapperFactoryBean mapper = context.getBean(&quot;&amp;mapper&quot;, MapperFactoryBean.class);</code></em> 只需要在bean的名字ID前加上&amp;符号。</p><p>非常重要：想知道factory流程，请结合</p><p><a href="https://blog.csdn.net/weixin_30881367/article/details/98567729?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mapperfactorybean%E7%9A%84%E4%BD%9C%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-98567729.nonecase&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_30881367/article/details/98567729?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mapperfactorybean%E7%9A%84%E4%BD%9C%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-98567729.nonecase&amp;spm=1018.2226.3001.4187</a></p><p><a href="https://blog.csdn.net/Roger_CX/article/details/120739214?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168111515116800192294702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168111515116800192294702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-120739214-null-null.142%5Ev82%5Ekoosearch_v1,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=FactoryBean%E4%BD%9C%E7%94%A8&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/Roger_CX/article/details/120739214?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168111515116800192294702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168111515116800192294702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-120739214-null-null.142^v82^koosearch_v1,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=FactoryBean%E4%BD%9C%E7%94%A8&amp;spm=1018.2226.3001.4187</a></p><p><strong>FactoryBean是一个能生产或修饰对象生成的工厂Bean</strong>。一个Bean如果实现了FactoryBean接口，那么<strong>根据该Bean的名称获取到的实际上是getObject返回的对象</strong>，而不是这个Bean自身实例，如果<strong>要获取这个Bean自身实例，那么需要在名称前面加上’&amp;’符号</strong>。</p><p>创建bean的两种方式：</p><p>第一种，单例在Spring容器初始化之前， 就已经创建了bean，且整个应用只有一个。</p><p>第二种，多例在用到对象的时候，才创建对象，当我们在A类中需要用到B类时，通过@Autowired注解注入用到时。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oauth2-异常配置总结</title>
      <link href="/2024/03/21/Oauth2-%E5%BC%82%E5%B8%B8%E9%85%8D%E7%BD%AE%E7%AF%87/"/>
      <url>/2024/03/21/Oauth2-%E5%BC%82%E5%B8%B8%E9%85%8D%E7%BD%AE%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="异常配置"><a href="#异常配置" class="headerlink" title="异常配置"></a>异常配置</h1><h2 id="【1】认证服务的异常"><a href="#【1】认证服务的异常" class="headerlink" title="【1】认证服务的异常"></a>【1】认证服务的异常</h2><ul><li>用户名，密码错误异常、授权类型异常</li><li>客户端ID、秘钥异常</li></ul><h3 id="1、用户名，密码错误异常、授权类型异常"><a href="#1、用户名，密码错误异常、授权类型异常" class="headerlink" title="1、用户名，密码错误异常、授权类型异常"></a><strong>1、用户名，密码错误异常、授权类型异常</strong></h3><p>针对用户名、密码、授权类型错误的异常解决方式比较复杂，需要定制的比较多。</p><h4 id="一、定制提示信息、响应码"><a href="#一、定制提示信息、响应码" class="headerlink" title="一、定制提示信息、响应码"></a><strong>一、定制提示信息、响应码</strong></h4><p>这部分根据自己业务需要定制，举个例子，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    CLIENT_AUTHENTICATION_FAILED(<span class="number">1001</span>,<span class="string">&quot;客户端认证失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    USERNAME_OR_PASSWORD_ERROR(<span class="number">1002</span>,<span class="string">&quot;用户名或密码错误&quot;</span>),</span><br><span class="line"></span><br><span class="line">    UNSUPPORTED_GRANT_TYPE(<span class="number">1003</span>, <span class="string">&quot;不支持的认证模式&quot;</span>),</span><br><span class="line"></span><br><span class="line">    NO_PERMISSION(<span class="number">1005</span>,<span class="string">&quot;无权限访问！&quot;</span>),</span><br><span class="line">    UNAUTHORIZED(<span class="number">401</span>, <span class="string">&quot;系统错误&quot;</span>),</span><br><span class="line"></span><br><span class="line">    INVALID_TOKEN(<span class="number">1004</span>,<span class="string">&quot;无效的token&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="二、自定义WebResponseExceptionTranslator"><a href="#二、自定义WebResponseExceptionTranslator" class="headerlink" title="二、自定义WebResponseExceptionTranslator"></a><strong>二、自定义WebResponseExceptionTranslator</strong></h4><ul><li><p>需要自定义一个异常翻译器，默认的是<strong>DefaultWebResponseExceptionTranslator</strong>，此处必须重写，其中有一个需要实现的方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;T&gt; <span class="title function_">translate</span><span class="params">(Exception e)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure><p>这个方法就是根据传递过来的<strong>Exception</strong>判断不同的异常返回特定的信息，这里需要判断的异常的如下：</p><ul><li><strong>UnsupportedGrantTypeException</strong>：不支持的授权类型异常</li><li><strong>InvalidGrantException</strong>：用户名或者密码错误的异常</li></ul></li><li><p>创建一个<strong>OAuthServerWebResponseExceptionTranslator</strong>实现<strong>WebResponseExceptionTranslator</strong>，代码如下：</p></li><li><p>&#96;&#96;&#96;java<br>public class OAuthServerWebResponseExceptionTranslator implements WebResponseExceptionTranslator{<br>&#x2F;**<br> * 业务处理方法，重写这个方法返回客户端信息<br> <em>&#x2F;<br>@Override<br>public ResponseEntity<ResultMsg> translate(Exception e){<br>    ResultMsg resultMsg &#x3D; doTranslateHandler(e);<br>    return new ResponseEntity&lt;&gt;(resultMsg, HttpStatus.UNAUTHORIZED);<br>}<br><br>&#x2F;</em>*<br> * 根据异常定制返回信息<br> * TODO 自己根据业务封装<br> *&#x2F;<br>private ResultMsg doTranslateHandler(Exception e) {<br>    &#x2F;&#x2F;初始值，系统错误，<br>    ResultCode resultCode &#x3D; ResultCode.UNAUTHORIZED;<br>    &#x2F;&#x2F;判断异常，不支持的认证方式<br>    if(e instanceof UnsupportedGrantTypeException){<br>        resultCode &#x3D; ResultCode.UNSUPPORTED_GRANT_TYPE;<br>        &#x2F;&#x2F;用户名或密码异常<br>    }else if(e instanceof InvalidGrantException){<br>        resultCode &#x3D; ResultCode.USERNAME_OR_PASSWORD_ERROR;<br>    }<br>    return new ResultMsg(resultCode.getCode(),resultCode.getMsg(),null);<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### **三、认证服务配置文件中配置**</span><br><span class="line"></span><br><span class="line">需要将自定义的异常翻译器**OAuthServerWebResponseExceptionTranslator**在配置文件中配置，很简单，一行代码的事。</span><br><span class="line"></span><br><span class="line">在**AuthorizationServerConfig**配置文件指定，代码如下：</span><br><span class="line"></span><br><span class="line">[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-x0dh3IeZ-1662780344834)(C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203102659.png)]</span><br><span class="line"></span><br><span class="line">#### **四、这么配置的原因**</span><br><span class="line"></span><br><span class="line">* 我们知道获取令牌的接口为 **/oauth/token**，这个接口定义在**TokenEndpoint#postAccessToken()**（POST请求）方法中，如下图</span><br><span class="line">* [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AiZNlL02-1662780344835)(C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203752062.png)]</span><br><span class="line">* 是不是都继承了**OAuth2Exception**，那么尝试在**TokenEndpoint**这个类中找找有没有处理**OAuth2Exception**这个异常的处理器，果然找到了一个 **handleException()** 方法，如下：</span><br><span class="line">* [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eHeizoig-1662780344836)(C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203840232.png)]</span><br><span class="line">* 可以看到，这里的异常翻译器已经使用了我们自定义的**OAuthServerWebResponseExceptionTranslator**。可以看下默认的异常翻译器是啥，代码如下：</span><br><span class="line"></span><br><span class="line">### **2、客户端ID、秘钥异常**</span><br><span class="line"></span><br><span class="line">这部分比较复杂，想要理解还是需要些基础的，解决这个异常的方案很多，陈某只是介绍其中一种，下面详细介绍。</span><br><span class="line"></span><br><span class="line">#### **一、定制提示信息、响应码**</span><br><span class="line"></span><br><span class="line">这部分根据自己业务需要定制，和第一步一样。</span><br><span class="line"></span><br><span class="line">#### **二、自定义AuthenticationEntryPoint**</span><br><span class="line"></span><br><span class="line">这个**AuthenticationEntryPoint**是不是很熟悉，前面的文章已经介绍过了，此处需要自定义来返回定制的提示信息。</span><br><span class="line"></span><br><span class="line">创建**OAuthServerAuthenticationEntryPoint**，实现AuthenticationEntryPoint，重写其中的方法，代码如下：</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  public class OAuthServerAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line">  </span><br><span class="line">      /**</span><br><span class="line">       * 认证失败处理器会调用这个方法返回提示信息</span><br><span class="line">       * TODO 实际开发中可以自己定义，此处直接返回JSON数据：客户端认证失败错误提示</span><br><span class="line">       */</span><br><span class="line">      @Override</span><br><span class="line">      public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException &#123;</span><br><span class="line">          ResponseUtils.result(response,new ResultMsg(ResultCode.CLIENT_AUTHENTICATION_FAILED.getCode(),ResultCode.CLIENT_AUTHENTICATION_FAILED.getMsg(),null));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="三、改造ClientCredentialsTokenEndpointFilter"><a href="#三、改造ClientCredentialsTokenEndpointFilter" class="headerlink" title="三、改造ClientCredentialsTokenEndpointFilter"></a><strong>三、改造ClientCredentialsTokenEndpointFilter</strong></h4><p><strong>ClientCredentialsTokenEndpointFilter</strong>这个过滤器的主要作用就是校验客户端的ID、秘钥，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuthServerClientCredentialsTokenEndpointFilter extends ClientCredentialsTokenEndpointFilter &#123;</span><br><span class="line"></span><br><span class="line">    private final AuthorizationServerSecurityConfigurer configurer;</span><br><span class="line"></span><br><span class="line">    private AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     * @param configurer AuthorizationServerSecurityConfigurer对昂</span><br><span class="line">     * @param authenticationEntryPoint 自定义的AuthenticationEntryPoint</span><br><span class="line">     */</span><br><span class="line">    public OAuthServerClientCredentialsTokenEndpointFilter(AuthorizationServerSecurityConfigurer configurer, AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">        System.out.println(&quot;自定义的客户端认证的过滤器的构造方法&quot;);</span><br><span class="line">        this.configurer = configurer;</span><br><span class="line">        this.authenticationEntryPoint=authenticationEntryPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setAuthenticationEntryPoint(AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">        System.out.println(&quot;setAuthenticationEntryPoint&quot;);</span><br><span class="line">        this.authenticationEntryPoint = authenticationEntryPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 需要重写这个方法，返回AuthenticationManager</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationManager getAuthenticationManager() &#123;</span><br><span class="line">        System.out.println(&quot;getAuthenticationManager&quot;);</span><br><span class="line">        return configurer.and().getSharedObject(AuthenticationManager.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置AuthenticationEntryPoint主要逻辑</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        System.out.println(&quot;设置AuthenticationEntryPoint主要逻辑&quot;);</span><br><span class="line">        //TODO 定制认证失败处理器，开发中可以自己修改</span><br><span class="line">        setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;</span><br><span class="line">            if (exception instanceof BadCredentialsException) &#123;</span><br><span class="line">                exception = new BadCredentialsException(exception.getMessage(), new BadClientCredentialsException());</span><br><span class="line">            &#125;</span><br><span class="line">            authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">        &#125;);</span><br><span class="line">        //成功处理器，和父类相同，为空即可。</span><br><span class="line">        setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个重要的部分需要讲一下，如下：</p><ul><li>构造方法中需要传入第2步自定义的 <strong>OAuthServerAuthenticationEntryPoint</strong></li><li>重写 <strong>getAuthenticationManager()</strong> 方法返回IOC中的AuthenticationManager</li><li>重写<strong>afterPropertiesSet()</strong> 方法，用于自定义认证失败、成功处理器，失败处理器中调用<strong>OAuthServerAuthenticationEntryPoint</strong>进行异常提示信息返回</li></ul><h4 id="四、OAuth配置文件中指定过滤器"><a href="#四、OAuth配置文件中指定过滤器" class="headerlink" title="四、OAuth配置文件中指定过滤器"></a><strong>四、OAuth配置文件中指定过滤器</strong></h4><p>只需要将自定义的过滤器添加到<strong>AuthorizationServerSecurityConfigurer</strong>中，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) &#123;</span><br><span class="line">        System.out.println(&quot;配置令牌访问的安全约束&quot;);</span><br><span class="line">        //自定义ClientCredentialsTokenEndpointFilter，用于处理客户端id，密码错误的异常</span><br><span class="line">        ①OAuthServerClientCredentialsTokenEndpointFilter endpointFilter = new OAuthServerClientCredentialsTokenEndpointFilter(security,authenticationEntryPoint);</span><br><span class="line">       ① endpointFilter.afterPropertiesSet();</span><br><span class="line">        ①security.addTokenEndpointAuthenticationFilter(endpointFilter);</span><br><span class="line"></span><br><span class="line">        security</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                //开启/oauth/token_key验证端口权限访问</span><br><span class="line">                .tokenKeyAccess(&quot;permitAll()&quot;)</span><br><span class="line">                //开启/oauth/check_token验证端口认证权限访问</span><br><span class="line">                .checkTokenAccess(&quot;permitAll()&quot;);</span><br><span class="line">               ② //一定不要添加allowFormAuthenticationForClients，否则自定义的OAuthServerClientCredentialsTokenEndpointFilter不生效</span><br><span class="line">//                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第<strong>①</strong>部分是添加过滤器，其中<strong>authenticationEntryPoint</strong>使用的是第2步自定义的<strong>OAuthServerAuthenticationEntryPoint</strong></p><p>第<strong>②</strong>部分一定要注意：一定要去掉这行代码，具体原因源码解释。</p><h4 id="五、源码追踪"><a href="#五、源码追踪" class="headerlink" title="五、源码追踪"></a><strong>五、源码追踪</strong></h4><h6 id="I、OAuthServerAuthenticationEntryPoint在何时调用？"><a href="#I、OAuthServerAuthenticationEntryPoint在何时调用？" class="headerlink" title="I、OAuthServerAuthenticationEntryPoint在何时调用？"></a><strong>I、OAuthServerAuthenticationEntryPoint在何时调用？</strong></h6><p>OAuthServerAuthenticationEntryPoint这个过滤器继承了 <strong>AbstractAuthenticationProcessingFilter</strong> 这个抽象类，一切的逻辑都在 <strong>doFilter()</strong> 中，陈某简化了其中的关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)</span><br><span class="line">throws IOException, ServletException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //调用子类的attemptAuthentication方法，获取参数并且认证</span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line">&#125;</span><br><span class="line">catch (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">            //一旦认证异常，则调用unsuccessfulAuthentication方法，通过failureHandler处理</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">catch (AuthenticationException failed) &#123;</span><br><span class="line">            //一旦认证异常，则调用unsuccessfulAuthentication方法，通过failureHandler处理</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//认证成功，则调用successHandler处理</span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码在 <strong>unsuccessfulAuthentication()</strong> 这个方法中，代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;</span><br><span class="line">    SecurityContextHolder.clearContext();</span><br><span class="line">    if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">        this.logger.debug(&quot;Authentication request failed: &quot; + failed.toString(), failed);</span><br><span class="line">        this.logger.debug(&quot;Updated SecurityContextHolder to contain null Authentication&quot;);</span><br><span class="line">        this.logger.debug(&quot;Delegating to authentication failure handler &quot; + this.failureHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.rememberMeServices.loginFail(request, response);</span><br><span class="line">    this.failureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="II、自定义的过滤器如何生效的？"><a href="#II、自定义的过滤器如何生效的？" class="headerlink" title="II、自定义的过滤器如何生效的？"></a><strong>II、自定义的过滤器如何生效的？</strong></h6><p>这个就要看 <strong>AuthorizationServerSecurityConfigurer#configure()</strong> 这个方法了，其中有一段代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(var2.hasNext()) &#123;</span><br><span class="line">    Filter filter = (Filter)var2.next();</span><br><span class="line">    http.addFilterBefore(filter, BasicAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，我们自定义的过滤链被加到了BasicAuthenticationFilter里面</p><h6 id="III、为什么不能加-allowFormAuthenticationForClients-？"><a href="#III、为什么不能加-allowFormAuthenticationForClients-？" class="headerlink" title="III、为什么不能加.allowFormAuthenticationForClients()？"></a><strong>III、为什么不能加.allowFormAuthenticationForClients()？</strong></h6><p>还是在 <strong>AuthorizationServerSecurityConfigurer#configure()</strong> 这个方法中，一旦设置了 <strong>allowFormAuthenticationForClients</strong> 为true，则会创建 <strong>ClientCredentialsTokenEndpointFilter</strong>，此时自定义的自然失效了。</p><h2 id="【2】资源服务自定义异常信息"><a href="#【2】资源服务自定义异常信息" class="headerlink" title="【2】资源服务自定义异常信息"></a><strong>【2】资源服务自定义异常信息</strong></h2><p>下面针对上述两种异常分别定制异常提示信息，这个比认证服务定制简单。</p><h3 id="1、自定义返回结果：没有权限访问时"><a href="#1、自定义返回结果：没有权限访问时" class="headerlink" title="1、自定义返回结果：没有权限访问时"></a><strong>1、自定义返回结果：没有权限访问时</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">ServerAccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange, AccessDeniedException denied)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;RequestAccessDeniedHandler&quot;</span>);</span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.OK);</span><br><span class="line">        response.getHeaders().add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        System.out.println(<span class="string">&quot;wuquan2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String body= JSONUtil.toJsonStr(<span class="keyword">new</span> <span class="title class_">ResultMsg</span>(ResultCode.NO_PERMISSION.getCode(),ResultCode.NO_PERMISSION.getMsg(),<span class="literal">null</span>));</span><br><span class="line">        <span class="type">DataBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span>  response.bufferFactory().wrap(body.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、用于处理没有登录或token过期时的自定义返回结果"><a href="#2、用于处理没有登录或token过期时的自定义返回结果" class="headerlink" title="2、用于处理没有登录或token过期时的自定义返回结果"></a><strong>2、用于处理没有登录或token过期时的自定义返回结果</strong></h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oauth2-令牌配置篇</title>
      <link href="/2024/03/09/Oauth2-%E4%BB%A4%E7%89%8C%E9%85%8D%E7%BD%AE%E7%AF%87/"/>
      <url>/2024/03/09/Oauth2-%E4%BB%A4%E7%89%8C%E9%85%8D%E7%BD%AE%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="令牌配置"><a href="#令牌配置" class="headerlink" title="令牌配置"></a>令牌配置</h1><h2 id="【1】令牌本身的配置"><a href="#【1】令牌本身的配置" class="headerlink" title="【1】令牌本身的配置"></a>【1】令牌本身的配置</h2><ul><li>令牌相关的配置都放在了AccessTokenConfig这个配置类中，代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 令牌的存储策略</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public TokenStore tokenStore() &#123;</span><br><span class="line">        //使用JwtTokenStore生成JWT令牌</span><br><span class="line">        return new JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JwtAccessTokenConverter</span><br><span class="line">     * TokenEnhancer的子类，在JWT编码的令牌值和OAuth身份验证信息之间进行转换。</span><br><span class="line">     * TODO：后期可以使用非对称加密</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAccessTokenConverter jwtAccessTokenConverter()&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = new JwtAccessTokenEnhancer();</span><br><span class="line">        // 设置秘钥</span><br><span class="line">        converter.setSigningKey(TokenConstant.SIGN_KEY);</span><br><span class="line">        /*</span><br><span class="line">         * 设置自定义得的令牌转换器，从map中转换身份信息</span><br><span class="line">         * fix(*)：修复刷新令牌无法获取用户详细信息的问题</span><br><span class="line">         */</span><br><span class="line">        converter.setAccessTokenConverter(new JwtEnhanceAccessTokenConverter());</span><br><span class="line">        return converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JWT令牌增强，继承JwtAccessTokenConverter</span><br><span class="line">     * 将业务所需的额外信息放入令牌中，这样下游微服务就能解析令牌获取</span><br><span class="line">     */</span><br><span class="line">    public static class JwtAccessTokenEnhancer extends JwtAccessTokenConverter &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 重写enhance方法，在其中扩展</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) &#123;</span><br><span class="line">            Object principal = authentication.getUserAuthentication().getPrincipal();</span><br><span class="line">            if (principal instanceof SecurityUser)&#123;</span><br><span class="line">                //获取userDetailService中查询到用户信息</span><br><span class="line">                SecurityUser user=(SecurityUser)principal;</span><br><span class="line">                //将额外的信息放入到LinkedHashMap中</span><br><span class="line">                LinkedHashMap&lt;String,Object&gt; extendInformation=new LinkedHashMap&lt;&gt;();</span><br><span class="line">                //设置用户的userId</span><br><span class="line">                extendInformation.put(TokenConstant.USER_ID,user.getUserId());</span><br><span class="line">                //添加到additionalInformation</span><br><span class="line">                ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(extendInformation);</span><br><span class="line">            &#125;</span><br><span class="line">            return super.enhance(accessToken, authentication);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>1、JwtAccessTokenConverter</strong></li></ul><p>令牌增强类，用于JWT令牌和OAuth身份进行转换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public JwtAccessTokenConverter jwtAccessTokenConverter()&#123;</span><br><span class="line">    JwtAccessTokenConverter converter = new JwtAccessTokenEnhancer();</span><br><span class="line">    // 设置秘钥</span><br><span class="line">    converter.setSigningKey(TokenConstant.SIGN_KEY);</span><br><span class="line">    /*</span><br><span class="line">     * 设置自定义得的令牌转换器，从map中转换身份信息</span><br><span class="line">     * fix(*)：修复刷新令牌无法获取用户详细信息的问题</span><br><span class="line">     */</span><br><span class="line">    converter.setAccessTokenConverter(new JwtEnhanceAccessTokenConverter());</span><br><span class="line">    return converter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>2、TokenStore</strong></li></ul><p>令牌的存储策略，这里使用的是JwtTokenStore，使用JWT的令牌生成方式，其实还有以下两个比较常用的方式</p><ul><li><ul><li>RedisTokenStore：将令牌存储到Redis中，此种方式相对于内存方式来说性能更好</li><li>JdbcTokenStore：将令牌存储到数据库中，需要新建从对应的表，有兴趣的可以尝试</li></ul></li><li><p><strong>3</strong>、<strong>SIGN_KEY</strong></p></li></ul><p>JWT签名的秘钥，这里使用的是对称加密，资源服务中也要使用相同的秘钥进行校验和解析JWT令牌。</p><h2 id="【2】令牌管理服务的配置"><a href="#【2】令牌管理服务的配置" class="headerlink" title="【2】令牌管理服务的配置"></a>【2】令牌管理服务的配置</h2><p><strong>这个放在了AuthorizationServerConfig这个配置类中，代码如下：</strong></p><ul><li><strong>使用的是DefaultTokenServices这个实现类，其中可以配置令牌相关的内容，比如access_token、refresh_token的过期时间，默认时间分别为12小时、30天。</strong></li><li><strong>最重要的一行代码当然是设置令牌增强，使用JWT方式生产令牌，如下：services.setTokenEnhancer(jwtAccessTokenConverter);</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> AuthorizationServerTokenServices <span class="title function_">tokenServices</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;令牌管理服务的配置&quot;</span>);</span><br><span class="line">    <span class="type">DefaultTokenServices</span> <span class="variable">services</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTokenServices</span>();</span><br><span class="line">    <span class="comment">//客户端端配置策略</span></span><br><span class="line">    services.setClientDetailsService(clientDetailsService);</span><br><span class="line">    <span class="comment">//支持令牌的刷新</span></span><br><span class="line">    services.setSupportRefreshToken(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//令牌服务</span></span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    <span class="comment">//access_token的过期时间</span></span><br><span class="line">    services.setAccessTokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//refresh_token的过期时间</span></span><br><span class="line">    services.setRefreshTokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置令牌增强，使用JwtAccessTokenConverter进行转换</span></span><br><span class="line">    services.setTokenEnhancer(jwtAccessTokenConverter);</span><br><span class="line">    <span class="keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【3】、令牌访问端点添加tokenServices"><a href="#【3】、令牌访问端点添加tokenServices" class="headerlink" title="【3】、令牌访问端点添加tokenServices"></a>【3】、令牌访问端点添加tokenServices</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oauth2-鉴权服务篇</title>
      <link href="/2024/03/07/Oauth2-%E9%89%B4%E6%9D%83%E6%9C%8D%E5%8A%A1%E7%AF%87/"/>
      <url>/2024/03/07/Oauth2-%E9%89%B4%E6%9D%83%E6%9C%8D%E5%8A%A1%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="鉴权服务"><a href="#鉴权服务" class="headerlink" title="鉴权服务"></a>鉴权服务</h1><p>和授权服务，许多程序都是围绕着配置类进行的，所以我们直接看配置类</p><h2 id="【1】AccessTokenConfig-令牌的一些配置"><a href="#【1】AccessTokenConfig-令牌的一些配置" class="headerlink" title="【1】AccessTokenConfig  令牌的一些配置"></a><strong>【1】AccessTokenConfig</strong>  令牌的一些配置</h2><ul><li>和授权服务一致，因为令牌要从授权服务到网关，再到客户端，不管是为了现在的还是后续的操作，最好配置，当然，用不到也可以不配，看你用不用得到。</li></ul><h2 id="【2】JwtAuthenticationManager-token认证管理器"><a href="#【2】JwtAuthenticationManager-token认证管理器" class="headerlink" title="【2】JwtAuthenticationManager token认证管理器"></a><strong>【2】JwtAuthenticationManager token认证管理器</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 公众号：码猿技术专栏</span></span><br><span class="line"><span class="comment"> * JWT认证管理器，主要的作用就是对携带过来的token进行校验，比如过期时间，加密方式等</span></span><br><span class="line"><span class="comment"> * 一旦token校验通过，则交给鉴权管理器进行鉴权</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Authentication&gt; <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;第六步***来到JWT认证管理器 检验token&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Mono.justOrEmpty(authentication)</span><br><span class="line">            .filter(a -&gt; a <span class="keyword">instanceof</span> BearerTokenAuthenticationToken)</span><br><span class="line">            .cast(BearerTokenAuthenticationToken.class)</span><br><span class="line">            .map(BearerTokenAuthenticationToken::getToken)</span><br><span class="line">            .flatMap((accessToken -&gt; &#123;</span><br><span class="line">                <span class="type">OAuth2AccessToken</span> <span class="variable">oAuth2AccessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.tokenStore.readAccessToken(accessToken);</span><br><span class="line">                <span class="comment">//根据access_token从数据库获取不到OAuth2AccessToken</span></span><br><span class="line">                <span class="keyword">if</span> (oAuth2AccessToken == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;无效的token！&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oAuth2AccessToken.isExpired()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;token已过期！&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">OAuth2Authentication</span> <span class="variable">oAuth2Authentication</span> <span class="operator">=</span> <span class="built_in">this</span>.tokenStore.readAuthentication(accessToken);</span><br><span class="line">                <span class="keyword">if</span> (oAuth2Authentication == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;无效的token！&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.just(oAuth2Authentication);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)).cast(Authentication.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【3】JwtAccessManagerV2——-认证管理器自定义"><a href="#【3】JwtAccessManagerV2——-认证管理器自定义" class="headerlink" title="【3】JwtAccessManagerV2——-认证管理器自定义"></a><strong>【3】JwtAccessManagerV2——-认证管理器自定义</strong></h2><ul><li>作用：认证管理的作用就是获取传递过来的令牌，对其进行解析、验签、过期时间判定。就是作为的鉴权</li><li>获取调用方法【get&#x2F;post…】+uri.getPath()  合成完整路径例如：【uri.getPath()】</li><li>从redis里面获取获取所有的uri-&gt;角色对应关系</li><li>去链接里面找到和自己这次申请链接完全一致的那一个键值对，而这个键值对的值恰恰就是【权限集合】</li><li>把自己的权限先从mono中解析出来，然后匹配，如果超级管理员，放行；如果存在交集，则通过；否则失败</li></ul><p>异常</p><ul><li><p>RequestAuthenticationEntryPoint</p><ul><li>用于处理没有登录或token过期时的自定义返回结果</li></ul></li><li><p>RequestAccessDeniedHandler</p><ul><li>自定义返回结果：没有权限访问时</li></ul></li><li><p>RequestAuthenticationEntryPoint</p><ul><li>用于处理没有登录或token过期时的自定义返回结果</li></ul></li></ul><h2 id="【4】-SecurityConfig-在webflux中使用security"><a href="#【4】-SecurityConfig-在webflux中使用security" class="headerlink" title="【4】 SecurityConfig  在webflux中使用security"></a><strong>【4】 SecurityConfig  在webflux中使用security</strong></h2><h3 id="1、webFluxSecurityFilterChain——把之前的配置整合链路"><a href="#1、webFluxSecurityFilterChain——把之前的配置整合链路" class="headerlink" title="1、webFluxSecurityFilterChain——把之前的配置整合链路"></a><strong>1、webFluxSecurityFilterChain——把之前的配置整合链路</strong></h3><ul><li><strong>这里使用的是webFluxSecurityFilterChain</strong></li><li>http下的功能可以借鉴<a href="http://events.jianshu.io/p/8ad366b97e18">http://events.jianshu.io/p/8ad366b97e18</a></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    SecurityWebFilterChain webFluxSecurityFilterChain(ServerHttpSecurity http) throws Exception&#123;</span><br><span class="line">    //认证过滤器，放入认证管理器tokenAuthenticationManager</span><br><span class="line">    AuthenticationWebFilter authenticationWebFilter = new AuthenticationWebFilter(tokenAuthenticationManager);</span><br><span class="line">    System.out.println(&quot;认证过滤器，放入认证管理器tokenAuthenticationManager&quot;);</span><br><span class="line">    authenticationWebFilter.setServerAuthenticationConverter(new ServerBearerTokenAuthenticationConverter());</span><br><span class="line"></span><br><span class="line">    http</span><br><span class="line">            .httpBasic().disable()</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .authorizeExchange()</span><br><span class="line">            //白名单直接放行</span><br><span class="line">            .pathMatchers(ArrayUtil.toArray(sysConfig.getIgnoreUrls(),String.class)).permitAll()</span><br><span class="line">            //其他的请求必须鉴权，使用鉴权管理器</span><br><span class="line">            .anyExchange().access(accessManager)</span><br><span class="line">            //鉴权的异常处理，权限不足，token失效</span><br><span class="line">            .and().exceptionHandling()</span><br><span class="line">            .authenticationEntryPoint(requestAuthenticationEntryPoint)</span><br><span class="line">            .accessDeniedHandler(requestAccessDeniedHandler)</span><br><span class="line">            .and()</span><br><span class="line">            // 跨域过滤器</span><br><span class="line">            .addFilterAt(corsFilter, SecurityWebFiltersOrder.CORS)</span><br><span class="line">            //token的认证过滤器，用于校验token和认证</span><br><span class="line">            .addFilterAt(authenticationWebFilter, SecurityWebFiltersOrder.AUTHENTICATION);</span><br><span class="line">    return http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一、加入了【2】的自定义令牌认证管理器"><a href="#一、加入了【2】的自定义令牌认证管理器" class="headerlink" title="一、加入了【2】的自定义令牌认证管理器"></a><strong>一、加入了【2】的自定义令牌认证管理器</strong></h4><h4 id="二、加入了【3】的鉴权管理器"><a href="#二、加入了【3】的鉴权管理器" class="headerlink" title="二、加入了【3】的鉴权管理器"></a><strong>二、加入了【3】的鉴权管理器</strong></h4><h3 id="2、白名单放行"><a href="#2、白名单放行" class="headerlink" title="**2、白名单放行 **"></a>**2、白名单放行 **</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//白名单直接放行</span><br><span class="line">.pathMatchers(ArrayUtil.toArray(sysConfig.getIgnoreUrls(),String.class)).permitAll()</span><br><span class="line">//其他的请求必须鉴权，使用鉴权管理器</span><br><span class="line">.anyExchange().access(accessManager)</span><br></pre></td></tr></table></figure><h3 id="3、鉴权的异常处理"><a href="#3、鉴权的异常处理" class="headerlink" title="3、鉴权的异常处理"></a><strong>3、鉴权的异常处理</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//鉴权的异常处理，权限不足，token失效</span><br><span class="line">.and().exceptionHandling()</span><br><span class="line">.authenticationEntryPoint(requestAuthenticationEntryPoint)</span><br><span class="line">.accessDeniedHandler(requestAccessDeniedHandler)</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oauth2-前置知识篇-Security</title>
      <link href="/2024/03/04/Oauth2-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%AF%87-springsecurity/"/>
      <url>/2024/03/04/Oauth2-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%AF%87-springsecurity/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识：security"><a href="#前置知识：security" class="headerlink" title="前置知识：security"></a>前置知识：security</h1><h2 id="security的核心，Spring-Security使用了springSecurityFilterChain作为了安全过滤的入口"><a href="#security的核心，Spring-Security使用了springSecurityFilterChain作为了安全过滤的入口" class="headerlink" title="security的核心，Spring Security使用了springSecurityFilterChain作为了安全过滤的入口"></a>security的核心，Spring Security使用了springSecurityFilterChain作为了安全过滤的入口</h2><h2 id="【1】Spring-Security过滤器"><a href="#【1】Spring-Security过滤器" class="headerlink" title="【1】Spring Security过滤器"></a>【1】Spring Security过滤器</h2><h3 id="1、核心过滤器概述"><a href="#1、核心过滤器概述" class="headerlink" title="1、核心过滤器概述"></a>1、核心过滤器概述</h3><p>从控制台打印过滤器可见</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.security.web.util.matcher.AnyRequestMatcher@<span class="number">1</span>,</span><br><span class="line">[</span><br><span class="line">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@184de357,</span><br><span class="line">    org.springframework.security.web.context.SecurityContextPersistenceFilter@521ba38f,</span><br><span class="line">    org.springframework.security.web.header.HeaderWriterFilter@77bb916f,</span><br><span class="line">    org.springframework.security.web.csrf.CsrfFilter@76b305e1,</span><br><span class="line">    org.springframework.security.web.authentication.logout.LogoutFilter@17c53dfb,</span><br><span class="line">    org.springframework.security.web.savedrequest.RequestCacheAwareFilter@2086d469,</span><br><span class="line">    org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter<span class="meta">@b1d19ff</span>,</span><br><span class="line">    org.springframework.security.web.authentication.AnonymousAuthenticationFilter<span class="meta">@efe49ab</span>,</span><br><span class="line">    org.springframework.security.web.session.SessionManagementFilter@5a48d186,</span><br><span class="line">    org.springframework.security.web.access.ExceptionTranslationFilter@273aaab7</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>SecurityContextPersistenceFilter 两个主要职责：请求来临时，创建SecurityContext安全上下文信息，请求结束时清空SecurityContextHolder。</li><li>HeaderWriterFilter (文档中并未介绍，非核心过滤器) 用来给http响应添加一些Header,比如X-Frame-Options, X-XSS-Protection*，X-Content-Type-Options.</li><li>CsrfFilter 在spring4这个版本中被默认开启的一个过滤器，用于防止csrf攻击，了解前后端分离的人一定不会对这个攻击方式感到陌生，前后端使用json交互需要注意的一个问题。</li><li>LogoutFilter 顾名思义，处理注销的过滤器</li><li>UsernamePasswordAuthenticationFilter 这个会重点分析，表单提交了username和password，被封装成token进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。</li><li>RequestCacheAwareFilter (文档中并未介绍，非核心过滤器) 内部维护了一个RequestCache，用于缓存request请求</li><li>SecurityContextHolderAwareRequestFilter 此过滤器对ServletRequest进行了一次包装，使得request具有更加丰富的API</li><li>AnonymousAuthenticationFilter 匿名身份过滤器，这个过滤器个人认为很重要，需要将它</li><li>UsernamePasswordAuthenticationFilter 放在一起比较理解，spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。</li><li>SessionManagementFilter 和session相关的过滤器，内部维护了一个SessionAuthenticationStrategy，两者组合使用，常用来防止session-fixation protection attack，以及限制同一用户开启多个会话的数量</li><li>ExceptionTranslationFilter 直译成异常翻译过滤器，还是比较形象的，这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理，具体是那些类下面详细介绍</li><li>FilterSecurityInterceptor 这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的</li></ul><h2 id="【2】Spring-Security核心过滤器解析"><a href="#【2】Spring-Security核心过滤器解析" class="headerlink" title="【2】Spring Security核心过滤器解析"></a>【2】Spring Security核心过滤器解析</h2><h3 id="1、SecurityContextPersistenceFilter"><a href="#1、SecurityContextPersistenceFilter" class="headerlink" title="1、SecurityContextPersistenceFilter"></a>1、SecurityContextPersistenceFilter</h3><p>SecurityContextPersistenceFilter的两个主要作用便是请求来临时，创建SecurityContext安全上下文信息和请求结束时清空SecurityContextHolder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILTER_APPLIED</span> <span class="operator">=</span> <span class="string">&quot;__spring_security_scpf_applied&quot;</span>;</span><br><span class="line">   <span class="comment">//安全上下文存储的仓库</span></span><br><span class="line">   <span class="keyword">private</span> SecurityContextRepository repo;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">SecurityContextPersistenceFilter</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//HttpSessionSecurityContextRepository是SecurityContextRepository接口的一个实现类</span></span><br><span class="line">      <span class="comment">//使用HttpSession来存储SecurityContext</span></span><br><span class="line">      <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">HttpSessionSecurityContextRepository</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">      <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">      <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// ensure that filter is only applied once per request</span></span><br><span class="line">         chain.doFilter(request, response);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">      <span class="comment">//包装request，response</span></span><br><span class="line">      <span class="type">HttpRequestResponseHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpRequestResponseHolder</span>(request,</span><br><span class="line">            response);</span><br><span class="line">      <span class="comment">//从Session中获取安全上下文信息</span></span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> repo.loadContext(holder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//请求开始时，设置安全上下文信息，这样就避免了用户直接从Session中获取安全上下文信息</span></span><br><span class="line">         SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">         chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">//请求结束后，清空安全上下文信息</span></span><br><span class="line">         <span class="type">SecurityContext</span> <span class="variable">contextAfterChainExecution</span> <span class="operator">=</span> SecurityContextHolder</span><br><span class="line">               .getContext();</span><br><span class="line">         SecurityContextHolder.clearContext();</span><br><span class="line">         repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">               holder.getResponse());</span><br><span class="line">         request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">         <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;SecurityContextHolder now cleared, as request processing completed&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、SecurityContextPersistenceFilter"><a href="#2、SecurityContextPersistenceFilter" class="headerlink" title="2、SecurityContextPersistenceFilter"></a>2、SecurityContextPersistenceFilter</h3><p>内部调用了authenticationManager完成认证，根据认证结果执行successfulAuthentication或者unsuccessfulAuthentication，无论成功失败，一般的实现都是转发或者重定向等处理，不再细究AuthenticationSuccessHandler和AuthenticationFailureHandler，有兴趣的朋友，可以去看看两者的实现类。</p><h3 id="2-3-AnonymousAuthenticationFilter"><a href="#2-3-AnonymousAuthenticationFilter" class="headerlink" title="2.3 AnonymousAuthenticationFilter"></a>2.3 AnonymousAuthenticationFilter</h3><p>匿名认证过滤器，可能有人会想：匿名了还有身份？我自己对于Anonymous匿名身份的理解是Spring Security为了整体逻辑的统一性，即使是未通过认证的用户，也给予了一个匿名身份。而AnonymousAuthenticationFilter该过滤器的位置也是非常的科学的，它位于常用的身份认证过滤器（如UsernamePasswordAuthenticationFilter、BasicAuthenticationFilter、RememberMeAuthenticationFilter）之后，意味着只有在上述身份过滤器执行完毕后，SecurityContext依旧没有用户信息，AnonymousAuthenticationFilter该过滤器才会有意义—-基于用户一个匿名身份。</p><h3 id="2-4-ExceptionTranslationFilter"><a href="#2-4-ExceptionTranslationFilter" class="headerlink" title="2.4 ExceptionTranslationFilter"></a>2.4 ExceptionTranslationFilter</h3><p>ExceptionTranslationFilter异常转换过滤器位于整个springSecurityFilterChain的后方，用来转换整个链路中出现的异常，将其转化，顾名思义，转化以意味本身并不处理。一般其只处理两大类异常：AccessDeniedException访问异常和AuthenticationException认证异常。</p><p>这个过滤器非常重要，因为它将Java中的异常和HTTP的响应连接在了一起，这样在处理异常时，我们不用考虑密码错误该跳到什么页面，账号锁定该如何，只需要关注自己的业务逻辑，抛出相应的异常便可。如果该过滤器检测到AuthenticationException，则将会交给内部的AuthenticationEntryPoint去处理，如果检测到AccessDeniedException，需要先判断当前用户是不是匿名用户，如果是匿名访问，则和前面一样运行AuthenticationEntryPoint，否则会委托给AccessDeniedHandler去处理，而AccessDeniedHandler的默认实现，是AccessDeniedHandlerImpl。所以ExceptionTranslationFilter内部的AuthenticationEntryPoint是至关重要的，顾名思义：认证的入口点。</p><h3 id="2-5-FilterSecurityInterceptor"><a href="#2-5-FilterSecurityInterceptor" class="headerlink" title="2.5 FilterSecurityInterceptor"></a>2.5 FilterSecurityInterceptor</h3><p>我们已经有了认证，有了请求的封装，有了Session的关联，还缺一个：由什么控制哪些资源是受限的，这些受限的资源需要什么权限，需要什么角色…这一切和访问控制相关的操作，都是由FilterSecurityInterceptor完成的。</p><p>FilterSecurityInterceptor的工作流程可以理解如下：FilterSecurityInterceptor从SecurityContextHolder中获取Authentication对象，然后比对用户拥有的权限和资源所需的权限。前者可以通过Authentication对象直接获得，而后者则需要引入我们之前一直未提到过的两个类：SecurityMetadataSource，AccessDecisionManager。理解清楚决策管理器的整个创建流程和SecurityMetadataSource的作用需要花很大一笔功夫，这里，暂时只介绍其大概的作用</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-MySQL45</title>
      <link href="/2024/02/02/%E5%85%AB%E8%82%A1-MySQL45/"/>
      <url>/2024/02/02/%E5%85%AB%E8%82%A1-MySQL45/</url>
      
        <content type="html"><![CDATA[<p>建议锁的范围比事务大</p><h4 id="执行一个MYSQL查询语句会发生什么？"><a href="#执行一个MYSQL查询语句会发生什么？" class="headerlink" title="执行一个MYSQL查询语句会发生什么？"></a>执行一个MYSQL查询语句会发生什么？</h4><blockquote><p><strong>连接器</strong></p><p>**查询缓存:**对于更新比较频繁的表，查询缓存的命中率很低的，在MYSQL8被移除。</p><p><strong>分析器：</strong>包括<font color='red'><u><em><strong>词法分析和语法分析</strong></em></u></font>，语法分析就是分析符不符合语法要求，如果没有问题会构造出SQL 语法树</p><p><strong>优化器</strong>：优化器就是确定一个执行效率高的<font color='red'><u><em><strong>执行方案</strong></em></u></font>，比如选择索引、连接表的顺序等等</p><p><strong>执行器</strong>：</p></blockquote><h4 id="执行一个MYSQL更新操作有什么不同？"><a href="#执行一个MYSQL更新操作有什么不同？" class="headerlink" title="执行一个MYSQL更新操作有什么不同？"></a>执行一个MYSQL更新操作有什么不同？</h4><blockquote><p>更新操作还会涉及两个表的操作，<font color='red'><u><em><strong>一个是redo log（解决崩溃恢复） 一个是binlog（备份）</strong></em></u></font></p><p>这两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p><img src="/../images/MySQL45-1/image-20231028134812838.png" alt="image-20231028134812838"></p><p>write pos 是当前记录的位置,checkpoint 是当前要擦除的位置</p><p>我们举一个例子来演示一下（<font color='red'><u><em><strong>两阶段提交</strong></em></u></font>）：</p><ol><li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，<font color='red'><u><em><strong>此时 redo log 处于 prepare 状态</strong></em></u></font>。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的<font color='red'><u><em><strong>提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态</strong></em></u></font>，更新完成。</li></ol></blockquote><p>这两个日志的配合是使用两阶段提交</p><p><img src="/../images/MySQL45-1/image-20230805142953314.png"></p><blockquote><p><font color='green'><strong>三个时机，4个状态</strong></font></p><p><font color='green'><strong>1、如果在prepare状态前崩溃，那其实是一致的情况，redolog和binlog里面都没有。</strong></font></p><p><font color='green'><strong>2、如果在第一次提交和binlog提交中间崩溃，我们拿到redolog XID去binlog找，没找到，回滚就可以</strong></font></p><p><font color='green'><strong>3、如果在binlog和第二次提交中间崩溃，那我们拿XID去binlog找，是可以找到的，就不需要回滚。</strong></font></p><p><font color='green'><strong>4、第二次提交之后崩溃，那这个是最好的了，因为redolog和binlog里面都有</strong></font></p></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h2><p><img src="/../images/MySQL45-1/image-20240109120737217.png" alt="image-20240109120737217"></p><p>执行流程：(<font color='red'><u><em><strong>所以回表不是只回表一次，而是多次</strong></em></u></font>)</p><blockquote><ol><li>在 k 索引树上找到 k&#x3D;3 的记录，取得 ID &#x3D; 300； </li><li>再到 ID 索引树查到 ID&#x3D;300 对应的 R3； </li><li>在 k 索引树取下一个值 k&#x3D;5，取得 ID&#x3D;500； </li><li>再回到 ID 索引树查到 ID&#x3D;500 对应的 R4；</li><li>在 k 索引树取下一个值 k&#x3D;6，不满足条件，循环结束。</li></ol></blockquote><p><font color='red'><u><em><strong>为什么有时候会选错索引？（两个原因）</strong></em></u></font></p><blockquote><p><font color='green'><u><em><strong>MySQL在真正执行之前只能根据统计信息来估算记录数。</strong></em></u></font>这个统计信息就是基数（随机采样得到一个页的平均值，然后乘以页数）</p><p><font color='green'><u><em><strong>第二个原因是优化器，优化器还要估计执行这个语句本身要扫描多少行？</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>用 delete 命令把整个表的数据删除呢容量不变小？</strong></em></u></font></p><blockquote><p>数据页都会 被标记为可复用。但是磁盘上，文件不会变小</p><p><font color='red'><u><em><strong>所以需要重建，重建现在基本上都是OnlineDDL，algorithm是copy的时候就是需要临时表，还会丢数据，inplace则是在innodb层开一个临时空间去做，这个允许dml操作（DML写锁会退化成DML读锁）</strong></em></u></font></p></blockquote><p><font color='red'><u>**count(字段)&lt;count(主键 id)&lt;count(1)&lt;count( * )**</u></font></p><blockquote><ol><li>server 层要什么就给什么； 2. InnoDB 只给必要的值； 3. 现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。</li></ol></blockquote><p><font color='red'><u><em><strong>Order By怎么工作？</strong></em></u></font></p><blockquote><p><font color='green'><u><em><strong>order by分两种排序，一种是全字段排序，一种是rowid排序。后者要比前者多一次访问主键索引。MySQL 的一个设计思想：如果内存够，就要多利用内存，也就是全字段排序，尽量减少磁盘访 问。</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>为什么有时候查询一条语句也很慢？</strong></em></u></font></p><blockquote><p>有可能在等锁的释放，</p><p>也有可能全表扫描，然后行数靠后</p></blockquote><p><font color='red'><u><em><strong>全表扫描会不会把数据库内存打爆</strong></em></u></font></p><blockquote><p>不会</p><p>因为mysql是边读边发，他有一个net_buffer，16k大小，不会在server 端保存完整的结果集，如果接收不及时，就堵住MySQL的查询过程，但是绝对不会打爆内存，而且innodb有lru这种内存淘汰策略。</p></blockquote><p><font color='red'><u><em><strong>能不能用join，怎么用</strong></em></u></font></p><blockquote><ol><li>如果可以使用被驱动表的索引，join 语句还是有其优势的； </li><li>在使用 join 的时候，应该让小表做驱动表。</li></ol></blockquote><p><strong>全局锁</strong></p><blockquote><p>典型的使用场景就是做全库的逻辑备份，加了全局锁就是只能读（DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句）</p><p>这样就保证了数据的一致性 和完整性 </p><ul><li>语法</li></ul><p>1、加全局锁</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure><p>2、数据备份</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pxxx db_name <span class="operator">-</span><span class="operator">&gt;</span> xxx.sql;</span><br></pre></td></tr></table></figure><p>3、释放锁</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>unlock tables;</span><br></pre></td></tr></table></figure><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog）</p><p>我们可以在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份。</p><p><font color='red'><u><em><strong>一般用于备份，但是备份也可以开启事务做，但是需要引擎支持可重复读这种隔离级别。</strong></em></u></font>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot -pxxx db_name -&gt; xxx.sql;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-面试范围</title>
      <link href="/2024/02/02/%E5%85%AB%E8%82%A1-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2024/02/02/%E5%85%AB%E8%82%A1-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1、JUC"><a href="#1、JUC" class="headerlink" title="1、JUC"></a><strong>1、JUC</strong></h1><p>多线程一定比单线程快吗？</p><p>那如何减少上下文切换？</p><p>并发三个特性</p><p>乐观锁和悲观锁？</p><p>cas？</p><p>volatile？</p><p><font color='red'><u><em><strong>volatile怎么保证有序性和可见性？</strong></em></u></font></p><p><font color='red'><u><em><strong>synchronized怎么保证原子性、可见性、有序性。？</strong></em></u></font></p><p><font color='red'><u><em><strong>有了synchronized还要volatile？synchronized是锁，性能消耗大+有阻塞。</strong></em></u></font></p><p><font color='red'><u><em><strong>有了cas还要volatile？cas只有原子性，没有有序和内存可见。</strong></em></u></font></p><p><font color='red'><u><em><strong>synchronized和volatile区别？作用的地方，有无阻塞，性能消耗，有无原子性</strong></em></u></font></p><p><font color='blue'><u><em><strong>重排序</strong></em></u></font></p><p>Synchronized</p><p><font color='red'><u><em><strong>锁升级</strong></em></u></font></p><p><font color='red'><u><em><strong>为什么叫重量级锁</strong></em></u></font>：synchronized的互斥是内核的互斥量，mutex。而想要申请这个互斥量，就要切换到内核态。</p><p>锁（LOCK接口）</p><p>synchronized和lock有什么区别</p><p>AQS</p><p>常见的实验工具类</p><p>Synchronized与AQS对比</p><p>Synchronized底层的同步队列为cxq和entryList， 等待队列为waitSet</p><p>ReentrantLock原理</p><blockquote><p><strong>公平锁和非公平锁区别？</strong></p><p><font color='green'><u><em><strong>加入的时候怎么加入的？</strong></em></u></font></p></blockquote><p>死锁</p><p><font color='red'><u><em><strong>怎么破坏死锁：</strong></em></u></font></p><p>4、原子操作的实现原理</p><p>处理器如何实现原子操作？</p><p>总线锁：使用LOCK 信号，其他请求都被阻塞，独占共享内存</p><p>缓存锁：所谓缓存锁定是指内存被缓存在处理器的缓存中，当他执行锁操作写回内存的时候，而是修改内部的内存地址，并允许他缓存一致性保证操作原子性。</p><p>Java怎么实现原子操作</p><p>锁–JVM实现锁的方式其实都用到了循环CAS</p><p>循环CAS –版本号解决ABA</p><p>JAVA内存模型？</p><p>重排</p><p>顺序一致性</p><h2 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a><font color='red'><u><em><strong>happens-before 原则</strong></em></u></font></h2><p>ThreadLocal</p><p><font color='red'><u><em><strong>threadlocal的使用场景</strong></em></u></font></p><p><font color='red'><u><strong>内存泄漏：</strong></u></font></p><p><font color='red'><u><em><strong>怎么解决</strong></em></u></font></p><p><font color='red'><u><strong>弱引用是原罪吗？</strong></u></font></p><p>四种引用？</p><h2 id="线程池和线程"><a href="#线程池和线程" class="headerlink" title="线程池和线程"></a>线程池和线程</h2><p><strong>线程安全的方案</strong></p><p>线程池？</p><p><font color='red'><u><em><strong>处理流程：</strong></em></u></font></p><p><font color='red'><u><em><strong>怎么确认系统的最佳线程数</strong></em></u></font></p><p><font color='red'><u><strong>如何设定线程池的大小？</strong></u></font></p><p><font color='red'><u><em><strong>线程池的使用场景</strong></em></u></font></p><blockquote><p><font color='blue'><u><em><strong>数据分批导入导出</strong></em></u></font></p><p><font color='blue'><u><em><strong>分批查询汇总</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>怎么限制接口可以访问的线程数？限流？</strong></em></u></font></p><p><font color='red'><u><em><strong>线程池创建线程</strong></em></u></font>有两种方式：</p><blockquote><p><font color='red'><u><em><strong>线程池的类型</strong></em></u></font></p><p><font color='red'><u><em><strong>核心参数</strong></em></u></font></p></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><font color='red'><u><em><strong>怎么创建线程</strong></em></u></font></p><p><font color='red'><u><strong>runnable和callable有什么区别？</strong></u></font></p><p><font color='blue'><u><em><strong>怎么退出线程？</strong></em></u></font></p><p><font color='red'><u><em><strong>怎么减少线程上下文切换</strong></em></u></font></p><blockquote><p><font color='blue'><u><em><strong>上下文切换：保存当前线程的线程信息，加载下一个线程的线程信息。</strong></em></u></font></p><p><font color='blue'><u><em><strong>减少的方法：无锁编程和cas</strong></em></u></font></p></blockquote><p><font color='blue'><u><em><strong>线程有哪些状态，怎么转换</strong></em></u></font></p><p><strong>sleep和wait有什么不同</strong></p><p><strong>启动的时候可以run方法吗</strong></p><p><strong>如何设计一个能够根据任务的优先级来执行的线程池？</strong></p><p><strong>怎么给线程命名：</strong></p><h1 id="2、JVM"><a href="#2、JVM" class="headerlink" title="2、JVM"></a>2、JVM</h1><p>JVM内存结构</p><p><strong>对象的创建</strong></p><p><strong>对象的内存布局</strong></p><p><strong>对象的访问定位方式</strong></p><p>内存溢出异常</p><p>类加载机制</p><p><font color='red'><u><em><strong>类加载什么时候加载类</strong></em></u></font></p><p>类加载器</p><p>双亲委派：</p><p><strong>双亲委派好处</strong></p><p>打破双亲委派</p><p>线程安全的方式</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><strong>1、如何判断对象死亡？</strong></p><p> GC Root</p><p><strong>2、垃圾回收算法</strong></p><p>3、三色标记法</p><h4 id="说一下JVM的分代回收"><a href="#说一下JVM的分代回收" class="headerlink" title="说一下JVM的分代回收"></a>说一下JVM的分代回收</h4><p><img src="/../images/%E5%85%AB%E8%82%A1-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20231117194042634.png" alt="image-20231117194042634"></p><h2 id="3、垃圾回收器"><a href="#3、垃圾回收器" class="headerlink" title="3、垃圾回收器"></a>3、垃圾回收器</h2><p>CMS收集器</p><p>Cms 参数配置？</p><p>G1垃圾回收器</p><p>G1年轻代比以前垃圾回收器快，为什么？</p><p>G1的SATB算法为什么比CMS的增量标记算法快（原因之一）：</p><p>ZGC</p><p>JVM调优参数</p><p><font color='red'><u><em><strong>堆内存默认设置为操作系统的一半，初识堆大小和最大堆大小建议一样</strong></em></u></font></p><p>jar包启动的时候java和 -jar直接可以去配置jvm的参数</p><p>JVM调优的参数有哪些？</p><blockquote><p><font color='green'><u><em><strong>内存管理：JVM-Xms，-Xmx，新生代晋级老年代的阈值（MaxTenuringThreshold，默认15），新生代大小（Xmn），永久代大小（PermSize），线程栈大小（Xss），垃圾回收器（UseParallelGC，UseConcMarkSweepGC），内存OOM导出快照（HeapDumpOnOutOfMemoryError），新生代和老年代的比例（newRadio），eden区和幸存者区的大小比例（SurvivorRatio），（）</strong></em></u></font></p><p>CMSFullGCsBeforeCompaction：进行过几<strong>次Full GC（标记清除）之后进行一次标记整理算法</strong></p><p>CMSInitialtingOccupancyfraction 什么时候触发cms 默认92 or 68</p><p>CMSScavengeBeforeRemark：默认不开启 ,开启之后是每次CMS之前都要有一次young gc</p><p>InitiatingHeapOccupancyPercent：老年代占用空间超过整堆比，45%</p><p><font color='blue'><u><em><strong>MaxGCPauseMillis：G1指定时间</strong></em></u></font></p></blockquote><h2 id="FullGC怎么排查"><a href="#FullGC怎么排查" class="headerlink" title="FullGC怎么排查"></a>FullGC怎么排查</h2><blockquote><p><font color='red'><u><em><strong>如果出现FullGC，请求和响应会变得特别慢，系统也变得很卡。</strong></em></u></font></p><p><font color='red'><u><em><strong>先用top找到java进程pid，然后用jstat（jstat -gcutil  pid）去看看是否发生了GC，尤其看，【老年代】OC，OU和，FGC确实一直在慢慢变多，那就说明FULLGC了，那我们就去解决</strong></em></u></font></p><p>内存：</p><blockquote><p> <font color='green'><strong>1、可以获得内存的快照dump（jmap -dump或者启动的时候就加上参数-XX：heapdumpOnOutOfMemeryERROR）</strong></font></p><p> <font color='green'><strong>2、visualVM去加载， memory analyzer</strong></font></p></blockquote><p>Cpu：</p><blockquote><p><font color='green'><strong>然后就排查CPU消耗，用top找到进程pid，用top -H和jps找到线程id，找到占比高的用jstack看看堆栈情况</strong></font></p></blockquote></blockquote><h2 id="FULL-GC的原因"><a href="#FULL-GC的原因" class="headerlink" title="FULL GC的原因"></a>FULL GC的原因</h2><p><font color='red'><u><em><strong>内存泄漏时分配的内存没有正常回收【没有关闭的数据库连接】，内存溢出时内存不够用了</strong></em></u></font></p><h2 id="CPU标高的排查"><a href="#CPU标高的排查" class="headerlink" title="CPU标高的排查"></a>CPU标高的排查</h2><p><font color='blue'><u><em><strong>top或者pidstat命令找到cpu明显过高的进程id，然后用进程id去找到线程id（ps H -eo pid,tid,%cpu | grep进程id），最后jstack 一下定位到该线程就可以</strong></em></u></font></p><h2 id="JVM调优工具"><a href="#JVM调优工具" class="headerlink" title="JVM调优工具"></a>JVM调优工具</h2><blockquote><p><font color='red'><u><em><strong>命令：</strong></em></u></font></p><p>jps + jstack 查看进程内线程的堆栈信息</p><p>jmap -dump 生成一个内存快照的信息</p><p>jstat ：JVM性能监测工具。 显示伊甸区 幸存者区、老年区的比例，还有gc压力</p><p><font color='red'><u><em><strong>可视化工具：</strong></em></u></font></p><p>jconsole</p><p>visualVM，eclipse memory analyzer</p></blockquote><h1 id="3、kafka"><a href="#3、kafka" class="headerlink" title="3、kafka"></a>3、kafka</h1><h2 id="使用场景和作用"><a href="#使用场景和作用" class="headerlink" title="使用场景和作用"></a>使用场景和作用</h2><blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><font color='green'><strong>1、日志收集</strong></font></p><p><font color='green'><strong>2、消息队列</strong></font></p><p><font color='green'><strong>3、用户活动和运营指标追踪</strong></font></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><font color='green'><strong>1、削峰解耦，假设A系统每秒就处理1000个请求，那A去Kafka里面慢慢自己拉取就可以了，不会一股脑全部打到A系统上</strong></font></p><p><font color='green'><strong>2、高性能，有4点</strong></font></p><p><font color='green'><strong>3、高可用，持久化，两点，一个broker一个副本机制</strong></font></p><p><font color='green'><strong>4、可扩展，加机器</strong></font></p></blockquote><h2 id="Kafka高性能的设计"><a href="#Kafka高性能的设计" class="headerlink" title="Kafka高性能的设计"></a><strong>Kafka高性能的设计</strong></h2><h2 id="Kafka的高可用了解过吗"><a href="#Kafka的高可用了解过吗" class="headerlink" title="Kafka的高可用了解过吗"></a>Kafka的高可用了解过吗</h2><h2 id="消息保证消息不丢失？可靠性"><a href="#消息保证消息不丢失？可靠性" class="headerlink" title="消息保证消息不丢失？可靠性"></a>消息保证消息不丢失？可靠性</h2><h2 id="重复消费问题怎么解决？"><a href="#重复消费问题怎么解决？" class="headerlink" title="重复消费问题怎么解决？"></a>重复消费问题怎么解决？</h2><h2 id="怎么保证顺序性-？"><a href="#怎么保证顺序性-？" class="headerlink" title="怎么保证顺序性 ？"></a>怎么保证顺序性 ？</h2><blockquote></blockquote><h2 id="Kafka文件存储机制"><a href="#Kafka文件存储机制" class="headerlink" title="Kafka文件存储机制"></a>Kafka文件存储机制</h2><h2 id="Kafka数据清理机制"><a href="#Kafka数据清理机制" class="headerlink" title="Kafka数据清理机制"></a>Kafka数据清理机制</h2><h2 id="消息堆积？怎么办？-（-消费者如何提高吞吐量）"><a href="#消息堆积？怎么办？-（-消费者如何提高吞吐量）" class="headerlink" title="消息堆积？怎么办？ （ 消费者如何提高吞吐量）"></a>消息堆积？怎么办？ （ 消费者如何提高吞吐量）</h2><h2 id="Kafka选举机制："><a href="#Kafka选举机制：" class="headerlink" title="Kafka选举机制："></a>Kafka选举机制：</h2><p><font color='blue'><u><em><strong>broker（控制器）选leader</strong></em></u></font></p><ul><li><font color='blue'><u><em><strong>由controller节点控制，决策是：ISR中存活，并且排在AR列表前面的优先，同时必须在isr里面。</strong></em></u></font></li></ul><p><font color='blue'><u><em><strong>消费者选Leader</strong></em></u></font></p><h2 id="Kafka分区机制"><a href="#Kafka分区机制" class="headerlink" title="Kafka分区机制"></a><font color='red'><u><em><strong>Kafka分区机制</strong></em></u></font></h2><p>2生产者</p><p><strong>Zookeeper</strong>的作用</p><h2 id="kafka分区策略"><a href="#kafka分区策略" class="headerlink" title="kafka分区策略"></a>kafka分区策略</h2><h2 id="kafka消费者"><a href="#kafka消费者" class="headerlink" title="kafka消费者"></a>kafka消费者</h2><p>0、重平衡</p><p><font color='red'><u><em><strong>当消费者的数量或者订阅主题的数量发生变化的时候会发生重平衡。</strong></em></u></font></p><p><font color='red'><u><em><strong>首先1、暂停所有消费者消费，2、重新计算分区分配方案，3、通知消费者、4、重新分配分区、5、重新启动消费。</strong></em></u></font></p><p><font color='blue'><u><em><strong>分区方案还是那三个【Range、RoundRobin、Sticky】</strong></em></u></font></p><h2 id="1、Kafka-消费方式（pull拉）"><a href="#1、Kafka-消费方式（pull拉）" class="headerlink" title="1、Kafka 消费方式（pull拉）"></a>1、Kafka 消费方式（pull拉）</h2><p><font color='blue'><u><em><strong>为什么pull</strong></em></u></font></p><p>消费者初始化流程和详细消费过程</p><p>消费者分区的分配</p><p>offset</p><h1 id="4、MySQL"><a href="#4、MySQL" class="headerlink" title="4、MySQL"></a>4、MySQL</h1><p>建议锁的范围比事务大</p><h5 id="执行一个MYSQL查询语句会发生什么？"><a href="#执行一个MYSQL查询语句会发生什么？" class="headerlink" title="执行一个MYSQL查询语句会发生什么？"></a>执行一个MYSQL查询语句会发生什么？</h5><h5 id="执行一个MYSQL更新操作有什么不同？"><a href="#执行一个MYSQL更新操作有什么不同？" class="headerlink" title="执行一个MYSQL更新操作有什么不同？"></a>执行一个MYSQL更新操作有什么不同？</h5><h5 id="这两种日志有以下三点不同。"><a href="#这两种日志有以下三点不同。" class="headerlink" title="这两种日志有以下三点不同。"></a>这两种日志有以下三点不同。</h5><h5 id="两阶段提交？"><a href="#两阶段提交？" class="headerlink" title="两阶段提交？"></a>两阶段提交？</h5><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h2><p><font color='red'><u><em><strong>什么是回表</strong></em></u></font></p><p><font color='red'><u><em><strong>为什么有时候会选错索引？（两个原因）</strong></em></u></font></p><p><font color='red'><u><em><strong>用 delete 命令把整个表的数据删除呢容量不变小？</strong></em></u></font></p><blockquote><p>数据页都会 被标记为可复用。但是磁盘上，文件不会变小</p><p><font color='red'><u><em><strong>所以需要重建，重建现在基本上都是OnlineDDL，algorithm是copy的时候就是需要临时表，还会丢数据，inplace则是在innodb层开一个临时空间去做，这个允许dml操作（DML写锁会退化成DML读锁）</strong></em></u></font></p></blockquote><p><font color='red'><u>**count(字段)&lt;count(主键 id)&lt;count(1)&lt;count( * )**</u></font></p><p><font color='red'><u><em><strong>Order By怎么工作？</strong></em></u></font></p><p><font color='red'><u><em><strong>为什么有时候查询一条语句也很慢？</strong></em></u></font></p><p><font color='red'><u><em><strong>全表扫描会不会把数据库内存打爆</strong></em></u></font></p><p><font color='red'><u><em><strong>能不能用join，怎么用</strong></em></u></font></p><p><font color='red'><u><em><strong>层高，二层，三层</strong></em></u></font></p><p><font color='red'><u><em><strong>Q1：MySQL主要有哪些存储引擎，分别适合哪些应⽤场景？</strong></em></u></font></p><blockquote></blockquote><p>首先来了解一下InnoDB的体系架构？</p><h2 id="1、后台线程"><a href="#1、后台线程" class="headerlink" title="1、后台线程"></a>1、后台线程</h2><blockquote><p>主要有：</p><p><font color='red'><u><em><strong>master thread</strong></em></u></font>：最重要的，脏页刷新、合并insert buffer，undo 页的回收，redolog buffer。不过后来脏页回收放到了单独的线程，也就是page thread</p><p>IO thread: 负责异步io的回调</p><p>purge thread: 负责undolog清理</p><p>page clean thread：负责脏页刷新</p></blockquote><h5 id="2、内存"><a href="#2、内存" class="headerlink" title="2、内存"></a>2、内存</h5><p>内存方面就是缓冲池、lrulist freelist flushlist、redo log buffer 三块，还有一些额外内存池（为了数据结构的内存申请服务）</p><h5 id="1、缓冲池"><a href="#1、缓冲池" class="headerlink" title="1、缓冲池"></a>1、缓冲池</h5><h5 id="2、List（内存淘汰策略）？"><a href="#2、List（内存淘汰策略）？" class="headerlink" title="2、List（内存淘汰策略）？"></a>2、List（内存淘汰策略）？</h5><p><font color='red'><u><em><strong>（脏页刷时机）？</strong></em></u></font></p><h5 id="3、Redo-log-buffer？"><a href="#3、Redo-log-buffer？" class="headerlink" title="3、Redo log buffer？"></a>3、Redo log buffer？</h5><p>刷回时机？</p><h5 id="4、额外的缓冲池"><a href="#4、额外的缓冲池" class="headerlink" title="4、额外的缓冲池"></a>4、额外的缓冲池</h5><h5 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h5><p>有哪些主要的关键特性？</p><p>分别展开讲讲？（重要）</p><h5 id="提问？如何定位慢查询？"><a href="#提问？如何定位慢查询？" class="headerlink" title="提问？如何定位慢查询？"></a><font color='red'><u><em><strong>提问？如何定位慢查询？</strong></em></u></font></h5><blockquote><p><font color='green'><strong>1、可以用普罗米修斯、skywalking这些工具</strong></font></p><p><font color='green'><strong>2、或者开启慢查询日志。set global slow_query_1o9&#x3D;1；</strong></font></p></blockquote><h6 id="接着问？执行很慢？怎么分析？"><a href="#接着问？执行很慢？怎么分析？" class="headerlink" title="接着问？执行很慢？怎么分析？"></a><font color='red'><u><em><strong>接着问？执行很慢？怎么分析？</strong></em></u></font></h6><h5 id="1、二进制日志binlog？"><a href="#1、二进制日志binlog？" class="headerlink" title="1、二进制日志binlog？"></a>1、二进制日志binlog？</h5><h5 id="2、redolog？"><a href="#2、redolog？" class="headerlink" title="2、redolog？"></a>2、redolog？</h5><p>MySQL的InnoDB存储引擎？？</p><h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><p><font color='red'><u><em><strong>什么是索引</strong></em></u></font></p><p><font color='red'><u><em><strong>where a&#x3D;1 and b &gt;1 and c&#x3D;1;</strong></em></u></font></p><p><font color='red'><u><em><strong>添加索引的原则</strong></em></u></font></p><p><font color='red'><u><em><strong>索引失效情况；</strong></em></u></font></p><p><strong>mysql优化</strong></p><p><strong>explain（三个最重要写）</strong></p><blockquote><p><font color='red'><u><em><strong>type字段：</strong></em></u></font></p><p><font color='green'><strong>system：表只有一行记录</strong></font></p><p><font color='green'><strong>const：主键或者唯一索引的等值查询，最多就匹配一次，匹配的条件是常量</strong></font></p><p><font color='green'><strong>eq_ref：也是基于主键和唯一索引，不过匹配的不是常量而是某个表的列，比如主键关联</strong></font></p><p><font color='green'><strong>ref：非主键和非唯一的等值匹配</strong></font></p><p><font color='green'><strong>range：用到了索引，无论是主键、唯一还是普通索引都可以，他是范围查找的</strong></font></p><p><font color='green'><strong>index：它确实跟索引有关但不是通过索引树去查找，而是扫描全索引的叶子节点，其实是另外一种的全部扫描，只不过它扫全部的索引叶子节点，</strong></font></p><p><font color='green'><strong>all：扫描聚集索引（通常是主键索引）的所有叶子节点</strong></font></p><p><strong>Const 和eq_ref 的区别</strong>：<font color='green'><strong>两个都是在用到了主键索引或唯一索引的情况下出现，不同的是Const 的where 条件是常量，eq_ref 的where 条件是其他表的某个列，需要对这个列进行转义才能拿到匹配条件的值，也可以简单的理解为，eq_ref 一般为关联查询。</strong></font></p><p><font color='red'><u><em><strong>possible_keys，key，key_len（重要）</strong></em></u></font></p><p>possible_keys: 可能使用到的索引 。<br>Key: 实际使用的索引。如果为空，则说明没有使用索引。<br>key_len： 使用到的索引key的长度，如果为联合索引则显示已命中的联合索引长度之和（如：联合索引为a+b+c ，如果索引命中了a+b ，那么长度就为a+b的索引长度，通常可以通过key_len 来分析联合索引所命中的情况）。</p><p>关于possible_keys 和key的三种关系场景：<br>1）possible_keys !&#x3D;null&amp;&amp; key!&#x3D;null ，这是正常使用到了索引的情况。<br>2）possible_keys !&#x3D;null&amp;&amp; key&#x3D;&#x3D;null ,这种情况一般说明通过索引并不能提升多少效率，一般而言是表的数据量很少，或者是索引的字段离散性不高，执行计划发现用索引和扫表差不多。<br>3）possible_keys &#x3D;&#x3D;null&amp;&amp; key!&#x3D;null , 这种情况一般为where条件没有命中索引，但是查询的列是索引字段，也就是查询的列命中覆盖索引情况。</p><p><font color='red'><u><em><strong>Extra列（重要）</strong></em></u></font></p><p><font color='red'><u><em><strong>Extra 可以说是对整个SQL做了一个概括性的总结，包括你用了什么索引、排序方式、使用了临时表包含不适合在其他列显示，但是十分重要的信息</strong></em></u></font></p><p><strong>1.Using index</strong>：使用覆盖索引</p><p><strong>2.Using where</strong>：就是一个普通的where语句查询且没有用到索引。</p><p><strong>3.Using index condition</strong>：查询的列不完全被索引覆盖，回表</p></blockquote><p><strong>MySQL为什么有时候会选错索引？</strong></p><p>解决方法？</p><p> <strong>怎么给字符串字段加索引？</strong></p><p><strong>对于函数操作，不管有没有改变有序性，都不走索引。</strong></p><p><strong>超大分页优化？</strong></p><p>innodb最常见的索引？</p><h2 id="1、B-树索引"><a href="#1、B-树索引" class="headerlink" title="1、B+树索引"></a>1、B+树索引</h2><p><font color='red'><u><em><strong>为什么不用b树?</strong></em></u></font></p><p><font color='red'><u><em><strong>为什么不用红黑树?</strong></em></u></font></p><p><font color='red'><u><em><strong>为什么不用跳表？</strong></em></u></font></p><p><font color='red'><u><em><strong>讲一讲索引？</strong></em></u></font></p><p>1、聚集索引</p><p>2、辅助索引</p><p>3、B+树索引的管理</p><p>4、B+树索引的使用优化【重要】</p><p>5、自适应哈希索引</p><p>InnoDB中的哈希用的字典进行查找，冲突用链表解决，哈希函数用除法散列</p><p>自适应哈希索引就是用的这种方法。</p><p>6、全文检索</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁机制是用于管理对共享资源的并发访问，保证数据的完整性和一致性。</p><h2 id="1、锁的类型"><a href="#1、锁的类型" class="headerlink" title="1、锁的类型"></a>1、锁的类型</h2><p>1、全局锁</p><blockquote><p>语句？</p></blockquote><p>2、表级锁</p><p>3、行锁【事务提交回滚的时候释放】</p><blockquote><p><strong>两阶段锁协议</strong>：</p><blockquote><p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</strong></p></blockquote><blockquote><p><img src="/../images/%E5%85%AB%E8%82%A1-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20230805221422216.png" alt="image-20230805221422216"></p></blockquote><h2 id="2、一致性非锁定读（快照读）"><a href="#2、一致性非锁定读（快照读）" class="headerlink" title="2、一致性非锁定读（快照读）"></a>2、一致性非锁定读（快照读）</h2><p>一致性非锁定读是指InnoDb通过多版本控制（MVCC）的方式读一个我能看到的数据。</p><h2 id="3、一致性锁定读（当前读）"><a href="#3、一致性锁定读（当前读）" class="headerlink" title="3、一致性锁定读（当前读）"></a>3、一致性锁定读（当前读）</h2><p>有时候用户需要些显式的对读操作进行加锁保证一致性。 <font color='red'><u><em><strong>select for share mode， for update还有update也是当前读</strong></em></u></font></p></blockquote><blockquote><h2 id="5、锁问题（并发事务带来的问题）"><a href="#5、锁问题（并发事务带来的问题）" class="headerlink" title="5、锁问题（并发事务带来的问题）"></a>5、锁问题（并发事务带来的问题）</h2><p>1、什么是脏读 or 不可重复读 or 幻读？</p><p>2、怎么解决</p><p>解决脏读</p><p>解决不可重复读</p><p>解决幻读innoDB的解决方法：</p><ul><li><font color='green'><strong>行锁是加在索引上的</strong></font></li></ul><p> 幻读完全避免了吗？</p></blockquote><h2 id="6、死锁"><a href="#6、死锁" class="headerlink" title="6、死锁"></a>6、死锁</h2><h2 id="7、锁升级"><a href="#7、锁升级" class="headerlink" title="7、锁升级"></a>7、锁升级</h2><p>会出现从行锁升级到表锁的情况吗？</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>1、认识事务</p><p><font color='red'><u><em><strong>什么是事务：多条sql语句，要么成功，要么失败</strong></em></u></font></p><p>1、四个特性：acid，举个例子。</p><p>2、事务的实现</p><p>事务的隔离性由锁机制来实现。</p><p>原子性、一致性、持久性通过redo log和undo log完成</p><p>redo log保证持久性</p><p>undo log保证事务的原子性，一致性</p><h3 id="1、redo-log"><a href="#1、redo-log" class="headerlink" title="1、redo log"></a>1、redo log</h3><h3 id="2、undo-log"><a href="#2、undo-log" class="headerlink" title="2、undo log"></a>2、undo log</h3><blockquote><p>undo log最主要的作用有两点：</p></blockquote><p>rr：事务第一次读的时候创建readview</p><p>rc：每次查询都会创建一个readview</p><p>mvcc是快照读，update是当前读，但是要注意两阶段锁协议</p><h1 id="5、Redis"><a href="#5、Redis" class="headerlink" title="5、Redis"></a>5、Redis</h1><h1 id="1、Redis数据结构"><a href="#1、Redis数据结构" class="headerlink" title="1、Redis数据结构"></a>1、Redis数据结构</h1><p>我在项目中用到的数据结构有String、Hash。</p><p>String我主要用于三类。 1）库存和订单数量，2）还有一些策略对象、活动对象，这种读多写少，没有频繁变化的对象。3）分布式锁。</p><p>Hashmap 我主要用于活动剩余的奖品数量和还有用户剩余次数。本身奖品是一个对象，可以用String+JSON的格式，但是奖品数量这个属性频繁变化，我就把他抽出来放到HashMap里面了。</p><blockquote><p>Redis的对象都是RedisObject，RedisObject里面有<font color='blue'><u><em><strong>type encoding ptr</strong></em></u></font>。</p><p>简单动态字符串</p><p><font color='green'><strong>如果是String类型，且这个字符串保存的是整数型，那就会把encoding设置成int，然后ptr用来存储整数。如果是一个字符串且小于32字节，就是embstr的SDS，如果是大于32字节就是RAW格式的SDS，embstr分配一次<font color='red'><u><em><strong>连续</strong></em></u></font>的内存空间，RAW格式要分配两次分别保存RedisObeject和SDS。(SDS包括字符串长度、分配的空间、sds类型、字节数组。)</strong></font>。</p><p>SDS 由长度（<code>len</code>）、内存空间大小（<code>alloc</code>）、字符串类型（<code>flags</code>）和存储的字节数组（<code>buf</code>），四个部分组成</p></blockquote><blockquote><p>List是<strong>quicklist</strong><font color='red'><u><em><strong>（其实就是双向链表 + 压缩列表）</strong></em></u></font>，<font color='red'><u><em><strong>链表的每个节点就是一个压缩列表，压缩列表是一个连续的内存块组成的顺序性数据结。链表的形式减少用于解决连锁更新的问题。</strong></em></u></font></p></blockquote><blockquote><p><font color='green'><strong>HashMap是压缩列表和哈希表。哈希冲突用链式哈希解决。</strong></font></p></blockquote><blockquote><p><font color='green'><strong>SET 是整数集合（元素个数少于512）、哈希表。整数集合就是一块连续的数组</strong></font></p></blockquote><blockquote><p><font color='red'><u><em><strong>ZSET是压缩列表或跳表。</strong></em></u></font></p><p><font color='green'><strong>跳表是在链表基础，对节点分层，每一个节点里面保存了 score 和 member，所有的节点都按照 score 排序，而当 score 相同时，会再按照 member 的字典顺序进行排序。跳表的相邻两层的节点数量最理想的比例是 2:1。实际上在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong></font></p><p><font color='red'><u><em><strong>查找从顶层链表的头部元素开始，然后遍历该链表，如果next的值大于我们要找的就从下一层找结果</strong></em></u></font></p><p><font color='red'><strong>为什么用跳表不用平衡树？</strong></font></p><p>这个问题，Redis的作者回答过，主要是三点：</p><blockquote><p><font color='green'><strong>内存小，平衡树非叶子节点要放两个指针，跳表1.33个</strong></font></p></blockquote><blockquote><p><font color='green'><strong>对范围查找友好，平衡树红黑树，这些你要按照中序遍历的方式找，但是跳表，你找到一个较小的值之后，直接在最底层往右遍历就好了</strong></font></p></blockquote><blockquote><p><font color='green'><strong>实现简单，平衡树的插入删除可能发生子树的调整，跳表的插入删除只需要修改相邻节点的指针</strong></font></p></blockquote><p><font color='blue'><u><em><strong>跳表的空间复杂度是 O(n)，时间logn</strong></em></u></font></p></blockquote><p>​</p><h1 id="2、Redis线程模型"><a href="#2、Redis线程模型" class="headerlink" title="2、Redis线程模型"></a>2、Redis线程模型</h1><h2 id="2、线程模型是怎么样的？是不是单线程"><a href="#2、线程模型是怎么样的？是不是单线程" class="headerlink" title="2、线程模型是怎么样的？是不是单线程"></a>2、线程模型是怎么样的？是不是单线程</h2><p>其实redis的单线程是先初始化后一直走一个循环处理。初始化的时候就做了三件事情：</p><p><img src="/../images/%E5%85%AB%E8%82%A1-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20231023173508951.png" alt="image-20231023173508951"></p><ul><li>创建一个 epoll 对象，就是我们的io多路复用的实现</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来，注册accept处理函数。</li></ul><p>做完这些之前之后就要真正处理用户请求，他会调用 epoll_wait 函数等待事件的到来，交给事件分发器。</p><ul><li>若发现 listen socket 上有新连接到达，就调用我们刚刚注册的那个accept函数，并追加这个client socket到epoll中进行管理</li><li>若发现其它 socket 上的读写请求，那就调用相应的读事件处理，和写事件处理。</li></ul><p>当然这里6.0以后引入了多线程，那接收数据、解析数据、写回数据都交给了io线程组，和主线程无关了。</p><h2 id="3、为什么这么快？高性能"><a href="#3、为什么这么快？高性能" class="headerlink" title="3、为什么这么快？高性能"></a>3、为什么这么快？高性能</h2><p>讲一下io多路复用</p><h2 id="4、采用单线程原因"><a href="#4、采用单线程原因" class="headerlink" title="4、采用单线程原因"></a>4、采用单线程原因</h2><h2 id="5、引入多线程原因"><a href="#5、引入多线程原因" class="headerlink" title="5、引入多线程原因"></a>5、引入多线程原因</h2><p>内存问题比较好解决，因此Redis的瓶颈原因为网络IO</p><h1 id="3、Redis持久化"><a href="#3、Redis持久化" class="headerlink" title="3、Redis持久化"></a>3、Redis持久化</h1><p><font color='red'><u><em><strong>Redis宕机数据会丢失么？</strong></em></u></font></p><blockquote></blockquote><h2 id="1、AOF"><a href="#1、AOF" class="headerlink" title="1、AOF"></a>1、AOF</h2><blockquote><p><font color='green'><strong>每执行一条写操作命令，就以命令的形式追加的方式写入到一个文件里，不过是先写到aof缓冲里面，然后在写回aof文件</strong></font></p><p><font color='red'><u><em><strong>AOF写回策略几种？</strong></em></u></font></p><p><font color='red'><u><em><strong>AOF 日志过大，会触发什么机制？</strong></em></u></font></p><p><font color='red'><u><em><strong>为什么先执行命令，再把数据写入日志呢？</strong></em></u></font></p></blockquote><h2 id="2、RDB快照"><a href="#2、RDB快照" class="headerlink" title="2、RDB快照"></a>2、RDB快照</h2><h2 id="3、混合持久化"><a href="#3、混合持久化" class="headerlink" title="3、混合持久化"></a>3、混合持久化</h2><h2 id="4、Redis主从同步-主从切换"><a href="#4、Redis主从同步-主从切换" class="headerlink" title="4、Redis主从同步+主从切换"></a>4、Redis主从同步+主从切换</h2><h2 id="哨兵模式（怎么保证redis的高可用？）"><a href="#哨兵模式（怎么保证redis的高可用？）" class="headerlink" title="哨兵模式（怎么保证redis的高可用？）"></a>哨兵模式（怎么保证redis的高可用？）</h2><p><strong>怎么监控？怎么主从切换</strong></p><p><strong>主从切换会数据丢失</strong>？<strong>如何应对主从数据不一致？</strong></p><p><strong>怎么判断 Redis 某个节点是否正常工作？</strong></p><h2 id="5、Redis-过期删除与内存淘汰"><a href="#5、Redis-过期删除与内存淘汰" class="headerlink" title="5、Redis 过期删除与内存淘汰"></a>5、Redis 过期删除与内存淘汰</h2><p>Redis过期策略</p><p>Redis 持久化时，对过期键会如何处理的？</p><p>Redis 主从模式中，对过期键会如何处理？</p><h2 id="2、Redis-内存淘汰"><a href="#2、Redis-内存淘汰" class="headerlink" title="2、Redis 内存淘汰"></a>2、Redis 内存淘汰</h2><p>LRU 算法和 LFU 算法有什么区别？</p><h2 id="6、Redis缓存设计"><a href="#6、Redis缓存设计" class="headerlink" title="6、Redis缓存设计"></a>6、Redis缓存设计</h2><h2 id="热Key"><a href="#热Key" class="headerlink" title="热Key"></a>热Key</h2><p><font color='red'><u><em><strong>怎么发现热key？</strong></em></u></font></p><p><font color='red'><u><em><strong>怎么解决热Key？</strong></em></u></font></p><h2 id="1、如何避免缓存雪崩？"><a href="#1、如何避免缓存雪崩？" class="headerlink" title="1、如何避免缓存雪崩？"></a>1、如何避免缓存雪崩？</h2><h2 id="2、缓存击穿"><a href="#2、缓存击穿" class="headerlink" title="2、缓存击穿"></a>2、缓存击穿</h2><h2 id="3、缓存穿透"><a href="#3、缓存穿透" class="headerlink" title="3、缓存穿透"></a>3、缓存穿透</h2><blockquote><p><font color='red'><u><em><strong>3.2、怎么实现布隆过滤器</strong></em></u></font></p></blockquote><h2 id="4、说说常见的缓存更新策略？-x2F-怎么保证数据一致性"><a href="#4、说说常见的缓存更新策略？-x2F-怎么保证数据一致性" class="headerlink" title="4、说说常见的缓存更新策略？&#x2F;怎么保证数据一致性"></a>4、说说常见的缓存更新策略？&#x2F;怎么保证数据一致性</h2><blockquote><p>常见的缓存更新策略共有3种：</p><blockquote><p>旁路缓存策略</p></blockquote><blockquote><p>读穿 &#x2F; 写穿</p></blockquote></blockquote><p><strong>分布式锁怎么实现</strong></p><h1 id="6、Java基础"><a href="#6、Java基础" class="headerlink" title="6、Java基础"></a>6、Java基础</h1><p><strong>jre和jdk</strong></p><p><strong>本地缓存和分布式缓存</strong></p><p><strong>多级缓存</strong></p><p>FIFO LRU LFU</p><p><strong>类和类之间的关系？</strong></p><p><strong>反射</strong></p><p><font color='red'><u><em><strong>Error和Exception</strong></em></u></font></p><p><strong>BIO NIO AIO</strong></p><p><strong>String StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？</strong></p><p><strong>equals与&#x3D;&#x3D;的区别</strong></p><p><strong>深拷贝和浅拷贝</strong></p><p><strong>字符型常量和字符串常量的区别</strong></p><blockquote></blockquote><p><strong>自动装箱和自动拆箱</strong></p><p><strong>请说出作用域public，private，protected，以及不写时的区别。</strong></p><p><font color='red'><u><em><strong>创建几个对象？</strong></em></u></font></p><blockquote><p>1、String a&#x3D;”123”;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、<span class="title class_">String</span> a=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>、<span class="title class_">String</span> a=<span class="string">&quot;123&quot;</span>+<span class="string">&quot;456&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>、<span class="title class_">String</span> a=<span class="string">&quot;123&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;456&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h2 id="讲讲Java的代理"><a href="#讲讲Java的代理" class="headerlink" title="讲讲Java的代理"></a>讲讲Java的代理</h2><blockquote><blockquote><p><strong>二者区别</strong></p></blockquote></blockquote><p><strong>为什么Java不能多继承？</strong></p><blockquote><p>会出现方法冲突和变量冲突</p></blockquote><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="Arraylist底层原理"><a href="#Arraylist底层原理" class="headerlink" title="Arraylist底层原理"></a>Arraylist底层原理</h2><h2 id="Linkedlist"><a href="#Linkedlist" class="headerlink" title="Linkedlist"></a>Linkedlist</h2><h2 id="ArrayList-与-LinkedList区别"><a href="#ArrayList-与-LinkedList区别" class="headerlink" title="ArrayList 与 LinkedList区别?"></a>ArrayList 与 LinkedList区别?</h2><blockquote><h2 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h2><blockquote><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能</p><p><code>ArrayDeque</code> 是<font color='green'><strong>基于可变长的数组和双指针来实现</strong></font>，而 <code>LinkedList</code> 则通过链表来实现。</p><p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p></blockquote><p><font color='red'><u><em><strong>LinkedList和ArrayList存储了一定数据，循环查询了上亿次</strong></em></u></font></p><blockquote><p><font color='green'><strong>array底层是数组，读取的时候会将相邻的数据读进来，而linked是分散，要找到才读，而且array是随机读，link是遍历到该位置，所以array快。</strong></font></p></blockquote></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><p><font color='blue'><u><em><strong>如何实现数组和arraylist之间的转换</strong></em></u></font></p><h2 id="hashmap和hashset"><a href="#hashmap和hashset" class="headerlink" title="hashmap和hashset"></a><font color='red'><u><em><strong>hashmap和hashset</strong></em></u></font></h2><h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2></blockquote><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p><font color='red'><u><em><strong>HASHMAP为什么用红黑树</strong></em></u></font></p><blockquote><h2 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h2><p><font color='red'><u><em><strong>为什么阈值是8</strong></em></u></font></p></blockquote><blockquote><h2 id="hashmap扩容过程"><a href="#hashmap扩容过程" class="headerlink" title="hashmap扩容过程"></a>hashmap扩容过程</h2><h2 id="HashMap-多线程操作导致死循环问题（1-7会，1-8是在树操作）"><a href="#HashMap-多线程操作导致死循环问题（1-7会，1-8是在树操作）" class="headerlink" title="HashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）"></a>HashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）</h2><h2 id="HashMap-为什么线程不安全？"><a href="#HashMap-为什么线程不安全？" class="headerlink" title="HashMap 为什么线程不安全？"></a>HashMap 为什么线程不安全？</h2><h2 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h2><p><strong>loadFactor 负载因子</strong></p><h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><h2 id="hashmap的key规范"><a href="#hashmap的key规范" class="headerlink" title="hashmap的key规范"></a>hashmap的key规范</h2><p><font color='red'><u><em><strong>Hashcode和equals</strong></em></u></font></p></blockquote><h1 id="线程安全容器"><a href="#线程安全容器" class="headerlink" title="线程安全容器"></a><font color='red'><u><em><strong>线程安全容器</strong></em></u></font></h1><blockquote><h2 id="1、ConcurrentHashMap"><a href="#1、ConcurrentHashMap" class="headerlink" title="1、ConcurrentHashMap"></a>1、<strong>ConcurrentHashMap</strong></h2><h2 id="2、CopyOnWriteArrayList（读多写少）"><a href="#2、CopyOnWriteArrayList（读多写少）" class="headerlink" title="2、CopyOnWriteArrayList（读多写少）"></a>2、CopyOnWriteArrayList（读多写少）</h2><h2 id="3、BlockingQueue"><a href="#3、BlockingQueue" class="headerlink" title="3、BlockingQueue"></a>3、BlockingQueue</h2></blockquote><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><font color='red'><u><em><strong>线程池</strong></em></u></font></h1><blockquote><p><font color='red'><u><em><strong>创建线程池的方式</strong></em></u></font></p><blockquote><p>为什么不推荐？我</p></blockquote><blockquote><p> <font color='red'><u><em><strong>线程池的类型</strong></em></u></font></p></blockquote><h2 id="3、CompletableFuture"><a href="#3、CompletableFuture" class="headerlink" title="3、CompletableFuture"></a>3、CompletableFuture</h2><p><code>CompletableFuture</code>是对<code>Future</code>的扩展和增强。<code>CompletableFuture</code>实现了<code>Future</code>接口，并在此基础上进行了丰富的扩展，完美弥补了<code>Future</code>的局限性，<strong>同时<code>CompletableFuture</code>实现了对任务编排的能力</strong></p></blockquote><h2 id="元素排序-Comparable-和-Comparator-有什么区别？"><a href="#元素排序-Comparable-和-Comparator-有什么区别？" class="headerlink" title="元素排序 Comparable 和 Comparator 有什么区别？"></a>元素排序 Comparable 和 Comparator 有什么区别？</h2><blockquote><p>Comparable：实现 Comparable 接口并重写 compareTo 方法就可以实现某个类的排序了，它支持 Collections.sort 和 Arrays.sort 的排序。compareTo 方法接收的参数 p 是要对比的对象，排序规则是用当前对象和要对比的对象进行比较，然后返回一个 int 类型的值。正序从小到大的排序规则是：使用当前的对象值减去要对比对象的值；而倒序从大到小的排序规则刚好相反：是用对比对象的值减去当前对象的值。</p><p>Comparator 除了可以通过创建自定义比较器外，还可以通过<a href="https://so.csdn.net/so/search?q=%E5%8C%BF%E5%90%8D%E7%B1%BB&spm=1001.2101.3001.7020">匿名类</a>的方式，更快速、便捷的完成自定义比较器的功能，具体的代码实现如下：</p><p><font color='red'><u><em><strong>Comparable 必须由自定义类内部实现排序方法，而 Comparator 是外部定义并实现排序的</strong></em></u></font></p></blockquote><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><font color='red'><u><em><strong>Linux常用命令</strong></em></u></font>：<font color='blue'><u><em><strong>cat, pwd, ls、TOP，mpstat，chattr -i +i不可修改删除，lsattr,chmod 777 (读写执行)</strong></em></u></font></p><blockquote><p><strong>lsof -i:9080</strong> 可以查看9080端口正在运行的程序 </p><p>kill -9 PID 是操作系统从内核级别强制杀死一个进程.</p><p>kill -15 PID 可以理解为操作系统发送一个通知告诉应用主动关闭.如果在准备过程中遇到阻塞，那么这个kill-15可能被忽略，所以就失效了</p><p><strong>查看机器的负载情况linux</strong></p><blockquote><p>Top htop mpstat vmstat</p></blockquote></blockquote><p><font color='red'><u><em><strong>查日志的命令</strong></em></u></font>：cat tail head</p><p><font color='red'><u><em><strong>怎么排查项目故障</strong></em></u></font>：</p><h1 id="Spirng"><a href="#Spirng" class="headerlink" title="Spirng"></a>Spirng</h1><p><font color='red'><u><em><strong>springboot和spring</strong></em></u></font></p><p><font color='red'><u><em><strong>怎么加一个starter</strong></em></u></font></p><p><font color='red'><u><em><strong>@Transactional（Spring默认JDK，Springboot默认cglib【性能好、不用依赖接口对代码侵入性弱】）</strong></em></u></font></p><blockquote><p><font color='green'><strong>是一个事务注解，底层是AOP，Spring AOP底层用的动态代理，所以Spring 会创建一个代理对象来包装该方法，并在方法执行前和后添加代码，以启动和提交、回滚事务。在写代码的时候一般单表查询我们不需要加，如果是多个写操作，那就得用上这个，也得防止失效</strong></font></p><p><font color='green'><strong>他可以用于<code>接口</code>、<code>类</code>、<code>方法</code>。把注解放到类上，那所有的public方法都配置了相同的事务配置信息，作用于方法，那方法的事务会覆盖类的事务配置信息</strong></font>。</p><p><font color='red'><u><em><strong>使用Transcantional需要注意的点</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>1、@Transactional 只能应用到 public 方法才有效</strong></em></u></font></p><p><font color='red'><u><em><strong>5、final、static（不可重写）</strong></em></u></font></p><p><font color='red'><u><em><strong>2、异常类型不匹配：或者异常被吃掉了</strong></em></u></font></p><p><font color='red'><u><em><strong>3、自调用失效this：</strong></em></u></font></p><p><font color='red'><u><em><strong>4、多线程，</strong></em></u></font></p></blockquote><p><font color='green'>**我们说同一个事务，是指同一个数据库连接。继承AbstractRoutingDataSource，重写determineTargetDataSource。这个方法是核心，你会调用determineCurrentLookupKey，他就用来决定切换到哪一个数据源**</font></p><p><font color='red'><u><em><strong>Spring事务基于Spring AOP，Spring AOP底层用的动态代理，动态代理有两种方式：</strong></em></u></font></p><blockquote><p>基于接口代理(JDK代理)</p></blockquote><blockquote><ul><li>基于接口代理，凡是类的方法<strong>非public</strong>修饰，或者用了<strong>static、finanl</strong>关键字修饰（不能重写），</li></ul><p>基于CGLib代理(子类代理)</p><ul><li>基于子类代理，凡是类的方法使用了private、static、final修饰，那这些方法都不能被Spring AOP增强 由于是继承关系，无法代理final的类和方法(无法继承)，或是private的方法(对子类不可见)。</li></ul></blockquote><p>————————————————</p><p>这个注解有几个核心的字段，</p><p><font color='green'><strong>事务的隔离级别</strong></font></p><p><code>isolation</code> ：事务的隔离级别，默认值为 <code>Isolation.DEFAULT</code>。</p><table><thead><tr><th>Isolation.DEFAULT：使用底层数据库默认的隔离级别。</th></tr></thead><tbody><tr><td>Isolation.READ_UNCOMMITTED</td></tr><tr><td>Isolation.READ_COMMITTED</td></tr><tr><td>Isolation.REPEATABLE_READ</td></tr><tr><td>Isolation.SERIALIZABLE</td></tr></tbody></table><p><font color='green'><strong>传播机制</strong></font></p><blockquote><table><thead><tr><th><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。**(** 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 <strong>）</strong></th></tr></thead><tbody><tr><td><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行</td></tr><tr><td><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</td></tr><tr><td><code>Propagation.REQUIRES_NEW</code>：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。**(** 当类A中的 a 方法用默认<code>Propagation.REQUIRED</code>模式，类B中的 b方法加上采用 <code>Propagation.REQUIRES_NEW</code>模式，然后在 a 方法中调用 b方法操作数据库，然而 a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停 a方法的事务 <strong>)</strong></td></tr><tr><td><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</td></tr><tr><td><code>Propagation.NEVER</code>：以非事务的方式运行，如果当前存在事务，则抛出异常。</td></tr></tbody></table></blockquote><p><font color='green'><strong>是否为只读</strong></font></p><blockquote><p>默认情况下是false，如果你的事务确实只有查询的需求，那就可以这里设置为true；</p></blockquote></blockquote><blockquote><p><font color='red'><u><em><strong>注解是什么作用?</strong></em></u></font><br>注解其实就是一些标记，有了标记之后，我们就可以在解析的时候得到这个标记，然后做一些特别的处理，这就是注解的作用，注解就是标记，可以给编译器用，也可以写入class，可以通过反射得到。</p><blockquote><p><font color='red'><u><em><strong>spring常用的注解</strong></em></u></font></p></blockquote><blockquote><p>@Component(“foo”) &#x2F;&#x2F; 声明一个 Foo 类型的 Bean，其 beanName 为 “foo”<br>@Named(“a”) &#x2F;&#x2F; &#x3D;&#x3D; @Component(“a”)<br>@ManagedBean &#x2F;&#x2F; &#x3D;&#x3D; @Component<br>@Configuration &#x2F;&#x2F; 声明一个配置类，其本身也视为一个 Bean<br>@Bean &#x2F;&#x2F;注解用于注解在工厂方法上，标明该方法返回的对象需要作为一个 Bean 交由 Spring 管理。<br>@Lazy 懒加载：延迟单例 Bean 的加载时机，在不被其他非懒加载 Bean 依赖的情况下，不在 AbstractApplicationContext.refresh 执行过程中随其他单例 Bean 提前实例化，而是等到被从 Spring 容器获取时再初始化</p></blockquote><blockquote><p>@PostConstruct &#x2F;&#x2F;被 @PostConstruct 注解的方法会在 Bean 初始化后调用</p></blockquote><blockquote><hr></blockquote><blockquote><p><font color='red'><u><em><strong>Spring Web常用的注解</strong></em></u></font></p></blockquote><blockquote><p>1、@Controller &amp; @Service &amp; @Repository<br>2、@RequestMapping：<br>@Controller<br>@RequestMapping(“&#x2F;example”) &#x2F;&#x2F; 当放在类上时，等同于定义公共路径前缀<br>@RequestMapping(<br>        path &#x3D; {“&#x2F;method1”, “&#x2F;method”}, &#x2F;&#x2F; 支持同时映射多个路径<br>        method &#x3D; RequestMethod.GET<br>    )<br>public String method1() {<br>  &#x2F;&#x2F; 处理 &#x2F;example&#x2F;method1 或 &#x2F;example&#x2F;method 的 get 请求<br>  return “view1”;<br>}<br>@RequestParam、@PathVariable、@RequestBody不同</p></blockquote><p><font color='red'><u><em><strong>AOP是什么？</strong></em></u></font></p><p><font color='red'><u><em><strong>有没有用过AOP</strong></em></u></font></p><p><font color='red'><u><em><strong>aop的实现方式</strong></em></u></font></p><p><font color='red'><u><em><strong>aop失效的原因和解决方法</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>失效原因：1、自调用。2、final。static。3 public</strong></em></u></font></p></blockquote><blockquote><p><font color='blue'><u><em><strong>解决方法：在方法a中获取当前代理对象p, 执行p.a()可使得事务生效</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>aop用那种动态代理</strong></em></u></font></p><p><font color='red'><u><em><strong>IOC</strong></em></u></font></p><blockquote><p><font color='green'><u><em><strong>Spring有几种容器，讲讲</strong></em></u></font></p></blockquote><blockquote><ol><li><strong>BeanFactory</strong>: BeanFactory是Spring框架最基本的IOC容器。</li><li><strong>ApplicationContext</strong>: ApplicationContext是BeanFactory的子接口，提供了更多的企业级功能，如国际化处理、事件传播、应用层面的异常处理等。它对BeanFactory进行了扩展，是Spring中最常用的IOC容器。</li><li><strong>ClassPathXmlApplicationContext</strong>: ClassPathXmlApplicationContext是从类路径下加载配置文件的容器，通过XML文件配置来管理Bean。</li><li><strong>FileSystemXmlApplicationContext</strong>: FileSystemXmlApplicationContext从文件系统中加载配置文件的容器，同样也是通过XML文件配置来管理Bean。</li><li><strong>AnnotationConfigApplicationContext</strong>: AnnotationConfigApplicationContext是通过Java类配置来管理Bean的容器，不需要XML配置文件，而是通过注解来完成Bean的定义和依赖注入。</li></ol></blockquote><p><font color='red'><u>**BeanFactory和FactoryBean，ApplicationContext的区别？ **</u></font></p><blockquote></blockquote><p><font color='red'><u><em><strong>Bean的生命周期？</strong></em></u></font></p><p><font color='red'><u><em><strong>创建Bean的方式</strong></em></u></font></p><p><font color='red'><u><em><strong>依赖注入Bean的方式</strong></em></u></font></p><p><font color='red'><u><em><strong>为什么依赖注入不适合用字段注入？</strong></em></u></font></p><p><font color='red'><u><em><strong>Bean的循环依赖？</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>为什么三层？</strong></em></u></font></p></blockquote><p>![<img src="/../images/%E5%85%AB%E8%82%A1-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/b892927da91c1058a04184035a05e02a.png" alt="在这里插入图片"></p><p><font color='red'><u><em><strong>可以直接调用bean.init的进行初始化吗？</strong></em></u></font></p><blockquote></blockquote><p><font color='red'><u><em><strong>Autowire和Resourse</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>Springboot启动流程</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>容器初始化流程</strong></em></u></font></p><p><font color='red'><u><em><strong>Spring用到的设计模式</strong></em></u></font></p><p><font color='red'><u><em><strong>Springboot自动装配？</strong></em></u></font></p><p><font color='red'><u><em><strong>Bean是线程安全的吗？</strong></em></u></font></p><blockquote></blockquote><p><font color='red'><u><em><strong>Spring MVC的工作流程如下：</strong></em></u></font></p></blockquote><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><blockquote><p><font color='blue'><u><em><strong>Mybatis怎么传多个参数：</strong></em></u></font></p><p><font color='blue'><u><em><strong>MyBatis中${} 和 #{} 有什么区别</strong></em></u></font></p></blockquote><h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><p><font color='red'><u><em><strong>git rebase 和 git merge</strong></em></u></font></p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><strong>1、进程和线程的区别</strong></p><p><strong>2、死锁</strong></p><h1 id="7、计算机网络"><a href="#7、计算机网络" class="headerlink" title="7、计算机网络"></a>7、计算机网络</h1><p>输入网址到显示？</p><p>TCP和UDP的区别？</p><p>tcp三次握手，四次挥手，TCP三次握手过程丢失问题</p><p>为什么三次，两次四次不行吗</p><p><strong>已经建立的tcp，收到syn会发生什么</strong></p><p>新的syn首先看看端口是不是一样，如果不一样的话，就建立新的连接，老的那个如果一直不发消息就会触发tcp保活机制</p><p>如果相同（可能就是宕机重传），其实会返回一个challenge ack，携带正确的序列号的确认号的ack报文，这时候客户端确认号收到这个，发现不是自己期望收到的，就会返回rst，这样，服务器就释放了连接</p><h4 id="如果timewait状态收到syn？会怎么样？"><a href="#如果timewait状态收到syn？会怎么样？" class="headerlink" title="如果timewait状态收到syn？会怎么样？"></a>如果timewait状态收到syn？会怎么样？</h4><p>还是先看序列号时间戳吧，如果确实合法，那应该会重新进入三次握手阶段，</p><p>如果不合法，就会返回一个和第四次挥手一样的ack，这时候服务端收到发现不是自己的，就回复一个rst报文</p><h4 id="Tcp连接，断电和进程崩溃有什么区别？没有保活机制"><a href="#Tcp连接，断电和进程崩溃有什么区别？没有保活机制" class="headerlink" title="Tcp连接，断电和进程崩溃有什么区别？没有保活机制"></a>Tcp连接，断电和进程崩溃有什么区别？没有保活机制</h4><p>客户端主机崩溃，没有保活机制，那就无法感知到，一直处于establish</p><p>进程崩溃，内核还是会发送fin完成4次挥手</p><h4 id="客户端主机宕机，又迅速重启"><a href="#客户端主机宕机，又迅速重启" class="headerlink" title="客户端主机宕机，又迅速重启"></a>客户端主机宕机，又迅速重启</h4><p><strong>只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</strong></p><h4 id="拔掉网线tcp连接还在吗"><a href="#拔掉网线tcp连接还在吗" class="headerlink" title="拔掉网线tcp连接还在吗"></a>拔掉网线tcp连接还在吗</h4><p>在的，tcp连接信息是存储于内核的一个结构体，网线断了，但是结构体不会改变</p><ul><li>拔掉网线后，有数据传输；</li><li>如果在重传前网线插回去了，那我觉得应该什么事情都没发生</li><li>如果没插回去，那么就超时重传几次之后，认为此连接死亡，就断开连接，即使后面插回来了，客户端向服务端发送请求，也不是连接的状态，那么服务端就会返回rst</li><li>拔掉网线后，没有数据传输</li><li>如果开启了保活机制，那就探测几次，如果有工作就重制保活时间，如果客户端没有正常工作，就断开连接</li><li>如果没有开启保活机制，就一直连着</li></ul><p>为什么有MLS</p><p>msl是报文最大生存时间，ip头有一个ttl字段，这个字段代表可以经历的最大路由数</p><p>msl大于等于ttl消耗为0的时间，默认60</p><blockquote><p><strong>为什么需要这个timewait状态</strong></p><p>1<font color='red'><u><em><strong>、也是为了防止接收历史连接中的第三次挥手</strong></em></u></font>。这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失。</strong></p><p>2、也就是说，TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p></blockquote><blockquote><p><font color='red'><u><em><strong>为什么4次？</strong></em></u></font></p><p>服务端可能还有数据要发给客户端，所以需要先处理自己的最后流程，然后给客户端发送一个fin报文，也就是说，第二次握手和第三次握手大概率是不同步的。</p><p><font color='red'><u><em><strong>特定情况下，可以变成三次，刚刚好没有数据。</strong></em></u></font></p><p><font color='red'><u><em><strong>第一次挥手丢失，会发生什么？</strong></em></u></font></p><p>客户端收不到来自服务端的ack报文，那么就会触发超时重传，这个次数是由tcp_orphan_retries决定的</p><p><font color='red'><u><em><strong>第二次挥手丢失，会发生什么？</strong></em></u></font></p><p>ACK 报文是不会重传的,所以首先客户端还是会触发超时重传，这个次数是由tcp_orphan_retries决定的</p><p><font color='red'><u><em><strong>第三次丢失，会发生什么？</strong></em></u></font></p><p>相当于服务端一直收不到来自客户端的ack，那么服务端会触发超时重传,次数达到后还没收到，断开连接。</p><p>而客户端已经进入了fin_wait2状态，一直等，如果超过设定的时间tcp_fin_timeout ，断开连接。</p><p><font color='red'><u><em><strong>第四次丢失，会发生什么？</strong></em></u></font></p><p>服务端一直收不到，那么触发超时重传，这时候因为客户端已经是timewait状态，所以每一次重传都会重置2msl定时器，超过时间就close，而服务端同样的重传几次之后close</p></blockquote><blockquote><p><strong>如果建立了连接，结果客户端故障了，不发送消息，但是服务端一直establish</strong></p><p>tcp搞了个保活机制，隔一段时间发送探测报文，没有得到相应则认为tcp死亡，</p><p>但是，这个保活机制时间太长了，我们自己在应用层实现一个心跳机制，一般web服务软件都会提供keepalive-timeout状态</p><p><strong>如果服务器的进程崩溃了，那发生什么</strong></p><p>其实连接信息是由内核维护的，所以服务端的内核还是会发送fin报文进行四次挥手</p></blockquote><h4 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h4><blockquote><table><thead><tr><th>1XX 代表提示信息</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>2XX 这个就是成功的状态吗</td><td>200 普通的正常的成功</td><td></td><td></td><td></td></tr><tr><td>3XX 代表重定向</td><td>301 永久重定向</td><td>302 临时重定向</td><td>304 缓存重定向</td><td></td></tr><tr><td>4XX 代表客户端的报文错误</td><td>400 比较笼统的</td><td>404 没找到</td><td></td><td></td></tr><tr><td>5XX 代表服务器端端报文错误</td><td>500 同样比较笼统</td><td>503 请稍后再访问</td><td></td><td></td></tr></tbody></table></blockquote><p><a href="http://get和post区别/">HTTP://Get和Post区别</a></p><p>HTTP？</p><p>优点 缺点</p><p><strong>HTTP1.1改进</strong></p><p>HTTP2优化</p><p>http3</p><p>https和http的区别</p><p>rsa</p><p><strong>UDP和TCP可以共用一个端口，因为是完全独立的两个软件模块</strong></p><h3 id="8、TCP四次挥手"><a href="#8、TCP四次挥手" class="headerlink" title="8、TCP四次挥手"></a>8、TCP四次挥手</h3><p><img src="/../images/%E5%85%AB%E8%82%A1-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20230803130523828.png" alt="image-20230803130523828"></p><h3 id="9、可靠性保证方法"><a href="#9、可靠性保证方法" class="headerlink" title="9、可靠性保证方法"></a>9、可靠性保证方法</h3><blockquote><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p><font color='red'><u><em><strong>重传分为超时重传和快速重传两种。</strong></em></u></font></p><p><font color='red'><u><em><strong>超时重传：超过时间进行重传，时间RTO</strong></em></u></font></p><p><font color='red'><u><em><strong>快速重传：收到三个相同的 ACK 报文时，重传丢失的报文段。这里的问题在于传一个还是传所有，这里引入了SACK和DSACK机制</strong></em></u></font></p><p>SACK：服务端把已经收到的数据信息驾到tcp头部的选项里面，告诉发送发我收到了哪些</p><p>后面又出现了D-SACK：这是用来告诉发送方哪些被重复接受了了</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>操作系统开辟的一个缓存空间，发送方在收到ACK应答之前，在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除</p><p>TCP头部里面既有一个字段叫窗口大小，就是用来告诉发送端自己还有多少缓冲区可以使用，所以窗口大小一般由接收方决定</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>网络发生拥塞，那么tcp就会降低自己的发送量，防止网络负担加重</p><p>慢启动 一开始是1，就是可以传1个mss，然后收到应答变成2，4，8，16…..</p><p>拥塞避免 触碰到<font color='green'><u><em><strong>慢启动门限</strong></em></u></font>就是用拥塞避免，变成线性的，收到一个ack cwnd增加1&#x2F;cwnd（拥塞窗口）</p><p>如果网络发生了拥塞，也就是重传。重传分两种，如果是超时重传，就慢启动门限变成cwnd&#x2F;2，cwnd&#x3D;1重新开始慢启动</p><p>如果是快速重传，拥塞窗口和慢启动门限都设置为拥塞窗口的一半，然后拥塞窗口+3，继续发送重复的，如果收到新数据的ACK，快速恢复结束，进入拥塞避免。</p><p>握手优化就是调整重传次数、半连接队列，全连接队列</p><p>挥手就是调整：重传次数、FINwait2状态时间、</p><p>传输速度的话就是调整：接收方缓冲区大小、发送方缓冲区大小、窗口大小，打开缓冲区动态调节。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>避免发送方的数据填满接收方</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-JUC</title>
      <link href="/2023/11/08/%E5%85%AB%E8%82%A1-JUC/"/>
      <url>/2023/11/08/%E5%85%AB%E8%82%A1-JUC/</url>
      
        <content type="html"><![CDATA[<p>多线程一定比单线程快吗？<font color='red'><u><em><strong>不一定，因为还有线程上下文切换的消耗</strong></em></u></font></p><p>那如何减少上下文切换？<font color='red'><u><em><strong>无锁并发、CAS</strong></em></u></font></p><h1 id="1、并发机制的底层原理"><a href="#1、并发机制的底层原理" class="headerlink" title="1、并发机制的底层原理"></a>1、并发机制的底层原理</h1><p><font color='blue'><u><em><strong>内存可见性：一个线程修改了共享变量的值,其他线程能够立即得知这个修改</strong></em></u></font></p><p><font color='blue'><u><em><strong>有序性指的是：程序执行的顺序按照代码的先后顺序执行。</strong></em></u></font></p><p><font color='blue'><u><em><strong>原子性是指：在一个操作多个步骤时，要么所有操作都被执行，要么所有操作都不执行。</strong></em></u></font></p><h3 id="0、乐观锁和悲观锁"><a href="#0、乐观锁和悲观锁" class="headerlink" title="0、乐观锁和悲观锁"></a>0、乐观锁和悲观锁</h3><p><strong>悲观锁：</strong></p><blockquote><p><font color='red'><u><em><strong>共享资源每次被访问的时候就会被修改，所以每次在获取资源操作的时候都会上锁。</strong></em></u></font>Synchronized、Reentrantlock 数据库的锁<font color='green'><strong>Synchronized、Reentrantlock 数据库的锁</strong></font></p></blockquote><p><strong>乐观锁：</strong></p><blockquote><p><font color='red'><u><em><strong>认为共享资源每次被访问的时候不会被修改</strong></em></u></font>，只是在修改的时候去验证数据有没有被其它线程修改了。<font color='green'><strong>悲观锁常见的就是CAS算法</strong></font></p></blockquote><h3 id="0、CAS"><a href="#0、CAS" class="headerlink" title="0、CAS"></a>0、CAS</h3><blockquote><p>【<font color='red'><u><em><strong>cas实际在操作系统层面是加锁的</strong></em></u></font>】</p><p><font color='blue'><strong>CAS是将指定内存地址A的内容与所给的旧值B相比，如果相等，则将其内容替换为指令中提供的新值C；如果不相等，进入自旋（称为自旋锁），直到当前值与更新前的值一致为止，或者达到最大次数。</strong></font></p><p><font color='blue'><strong>jdk提供的CAS方案是unsafe类的cas的本地方法，这个本地方法会调cmpxchg方法，它是在汇编层级，会禁止变量两侧的指令优化，然后使用cmpxchg指令比较并更新变量值(原子性)，这个指令是硬件上的的数据，保证CAS的原子性。锁总线，如果是多核则加一个lock锁定(缓存锁、MESI)</strong></font></p><p><font color='green'><strong>硬件层间不能保证有序和内存可见，只能保证原子，但是加了LOCK就可以保证有序可见了</strong></font></p><p>缺点：</p><p><font color='red'><u><em><strong>是一次性只能保证一个共享变量的原子性</strong></em></u></font></p><p><font color='red'><u><em><strong>如果一直循环会浪费cpu资源</strong></em></u></font></p><p><font color='red'><u><strong>ABA的解决方法就是在变量前面加上版本号</strong></u></font></p></blockquote><p>很关键的一点：cas只能保证原子性，而volatile保证可见性和有序性。所以aqs的volatile修饰的state变量使用cas‘方式修改的。</p><h3 id="1、volatile"><a href="#1、volatile" class="headerlink" title="1、volatile"></a>1、volatile</h3><blockquote><p><font color='blue'><u><em><strong>volatile具备可见性、有序性但是不具备原子性。他的内存语义是，当写一个volatile变量，jmm会把该线程对应的本地内存中共享变量刷新到主内存,读一个volatile变量，jmm会把该线程对应的本地内存置为无效，然后从主内存里面读，他的实现依赖于一个内存屏障，然后我们讲一下怎么用到这个内存屏障。</strong></em></u></font></p><p><font color='red'><u><em><strong>我们知道单线程下，由于asifserial的存在，指令执行结果是具备顺序一致性。但是在多线程环境下，重排序会导致各个线程看到的全局执行顺序不一致。</strong></em></u></font></p><ul><li><strong>1、编译器重排序：</strong> 例如将循环内重复调用的操作提前到循环外执行；</li><li><strong>2、处理器系统重排序：</strong> 例如指令并行技术将多条指令重叠执行，或者使用分支预测技术提前执行分支的指令，并把计算结果放到重排列缓冲区（Reorder Buffer）的硬件缓存中，当程序真的进入分支后直接使用缓存中的结算结果；</li><li><strong>3、存储器系统重排序：</strong> 例如写缓冲区（发消息不等直接写到storebuffer，收消息不看直接返回，然后放到invalid queue）和失效队列机制，即是可见性问题，从内存的角度也是指令重排问题。</li></ul><p>解决办法就是<font color='green'><u>*** Memory Barrier（内存屏障）***</u></font>。借助内存屏障可以很好地保证了顺序一致性。</p><p>JMM就是有4种屏障，（cpu三种，读屏障，写屏障，全屏障）</p><blockquote><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul></blockquote><p>然而这4种内存屏障只是抽象层面的，实际上这四种内存屏障在不同平台下的具体映射的指令是不一样的，而这也恰恰是 JVM 跨平台的优势所在。</p><p>我们举一个x86作为例子，只有 StoreLoad 才有具体的指令对应，在x86处理器里面，像mfence lock都可以实现这个而这个StoreLoad的要求，实际上HotSpot关于volatile的实现就是使用的lock前缀指令：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lock addl $0x0,(%rsp)</span><br></pre></td></tr></table></figure><p>1）加缓存锁（其实是mesi协议），把当前这个处理器缓存的数据写会系统内存。（总线锁、缓存锁）<strong>缓存锁其实是一种实现的效果</strong>，它是通过<strong>缓存一致性协议</strong>来实现的。但是这个MESI一开始是强数据一致性的，但是后来为了加快速度，引入了store buffer 和 invalid queue，就变成了弱数据一致性。</p><p><a href="https://zhuanlan.zhihu.com/p/584787272?utm_id=0">https://zhuanlan.zhihu.com/p/584787272?utm_id=0</a></p><p>2）写回内存的操作会使其他cpu缓存该内存地址的数据无效。（这个用的是 嗅探机制）</p></blockquote><p>修改、独占、共享、无效</p><p>缓存一致性原则：</p><p>S to M，Shared的状态下，某个CPU发起了对该缓存行的原子性 read-modify-write 操作，但需要发出 Invalid 消息，并等待一系列的 Invalidate Acknowledge 反馈后才能对缓存行修改；</p><p><img src="/../images/Java%E5%B9%B6%E5%8F%91/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQWxhbjA1MTc=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><hr><p>为什么不保证原子性：</p><p>在执行内存屏障之前，不同 CPU 依旧可以对同一个缓存行持有，一个 CPU 对同一个缓存行的修改不能让另一个 CPU 及时感知，因此出现并发冲突。这里我看到一篇博客，他的意思是刚刚好计算的过程在寄存器执行。<font color='red'><u><em><strong>同时加锁，总线仲裁</strong></em></u></font></p><p><a href="https://blog.csdn.net/qq_38322527/article/details/119937531">https://blog.csdn.net/qq_38322527/article/details/119937531</a></p><p><font color='red'><u><em><strong>volatile怎么保证有序性和可见性？</strong></em></u></font></p><p>可见性：读，把自己置为无效，然后读内存；写，会刷回住内存</p><p>有序性：禁止指令重排序【内存屏障】</p><p><font color='red'><u><em><strong>synchronized怎么保证原子性、可见性、有序性。？</strong></em></u></font></p><p>原子性：加锁后只能由一个线程访问，别人访问不了</p><p>可见性：释放锁，会把此变量刷回住内存</p><p>有序性：同一时间只能由一个线程访问。</p><p><font color='red'><u><em><strong>有了synchronized还要volatile？synchronized是锁，性能消耗大+有阻塞。</strong></em></u></font></p><p><font color='red'><u><em><strong>有了cas还要volatile？cas只有原子性，没有有序和内存可见。</strong></em></u></font></p><p><font color='red'><u><em><strong>synchronized和volatile区别？作用的地方，有无阻塞，性能消耗，有无原子性</strong></em></u></font></p><hr><p><font color='blue'><u><em><strong>重排序</strong></em></u></font></p><ul><li><strong>1、编译器重排序：</strong> 例如将循环内重复调用的操作提前到循环外执行；</li><li><strong>2、处理器系统重排序：</strong> 例如指令并行技术将多条指令重叠执行，或者使用分支预测技术提前执行分支的指令，并把计算结果放到重排列缓冲区（Reorder Buffer）的硬件缓存中，当程序真的进入分支后直接使用缓存中的结算结果；</li><li><strong>3、存储器系统重排序：</strong> 例如写缓冲区和失效队列机制，即是可见性问题，从内存的角度也是指令重排问题。</li></ul><p>编译器方面有这么一个规定</p><p><img src="/../images/%E5%B9%B6%E5%8F%91/image-20230919132522971.png" alt="image-20230919132522971"></p><p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</p><p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p><p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p><h3 id="2、Synchronized"><a href="#2、Synchronized" class="headerlink" title="2、Synchronized"></a>2、Synchronized</h3><p><font color='red'><u><em><strong>它是一种互斥锁。有三种使用方法：普通方法（锁是类实例对象）、静态方法（锁是当前类的Class对象）、方法块（括号里的对象）。方法和代码块具体实现是不一样的，一个是monitorenter和monitorexit；一个是ACC_SYNCHRONIZED。</strong></em></u></font></p><blockquote><p>方法级的同步是隐式，JVM可以从方法表里面检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor， 然后再执行方法，方法完成释放monitor。</p><p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p><p> 具体的位置可以看markword，就是堆里面对象有对象头、实例数据、对其填充。对象头里面有markword，对象类型指针，这个markword里面就存了这个指向monitor的指针。</p><p>monitor由ObjectMonitor实现，他有三个关键的东西，owner、waitset、entrylist，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</p></blockquote><p><font color='red'><u><em><strong>锁升级</strong></em></u></font></p><p><font color='blue'><u><em><strong>而Java1.6为了减少性能消耗，引入了“偏向锁”“轻量级锁”。</strong></em></u></font></p><p><strong>偏向锁</strong>（101）</p><blockquote><p>偏向锁是用于没有竞争的时候。</p><p>他的加锁过程是：把markword后三位改成101，然后通过CAS的方式把markword的线程id改为自己就好就代表自己获得了锁，后续如果再次获取锁，直接去markword里面线程id是不是自己的就可以了。</p><p>他会有一个撤销的情况，是因为有其他线程来竞争，会出现两种形式：</p><p>1、线程没执行完，那就升级轻量级继续执行。</p><p>2、线程执行完了那么我们就尝试重偏向。</p></blockquote><p><strong>轻量级锁</strong>（000）</p><blockquote><p>轻量级锁由偏向锁升级而来，适用少量线程交替执行。</p><p>他的加锁过程是：</p><p>1 在当前线程的栈帧中创建锁记录<br>2 将锁对象中的markword复制到锁记录中<br>3 通过CAS方式将markword替换成指向锁记录的指针，把Markword中的锁标志位设为000。</p><p>4、如果失败会自旋再次CAS去获取锁。若失败的次数过多，则轻量级锁会膨胀为重量级锁。</p><p>解锁过程：通过CAS操作把Mark Word 和锁记录替换回来，如果失败了，那能是因为其他线程自旋太多次导致升级为重量级锁，那就释放锁并唤醒阻塞的线程竞争锁</p></blockquote><p><strong>重量级锁</strong>（010）</p><blockquote><p>重量级锁是轻量级锁受到激烈竞争时，为防止cpu被自旋的线程浪费膨胀而来，因此重量级锁肯定是应付大量线程同时访问同步块的情景。让申请锁失败的线程阻塞后，cpu的负担会减小不少，因此数据的吞吐量也就上来了。</p></blockquote><p><font color='red'><u><em><strong>为什么叫重量级锁</strong></em></u></font>：synchronized的互斥是内核的互斥量，mutex。而想要申请这个互斥量，就要切换到内核态。</p><h3 id="3、锁（LOCK接口）"><a href="#3、锁（LOCK接口）" class="headerlink" title="3、锁（LOCK接口）"></a><strong>3、锁（LOCK接口）</strong></h3><p><img src="/../images/Java%E5%B9%B6%E5%8F%91/image-20231022145201049.png" alt="image-20231022145201049"></p><p><strong>锁的内存语义</strong></p><p>释放锁的时候，JMM把该线程对应的本地内存中的共享变量刷新到主内存，加锁的时候把该线程对应的本地内存置为无效。</p><p><strong>锁内存语义的实现</strong></p><p>编译器<strong>不会对volatile读与其后的任意内存操作重排序</strong>，<strong>不会对volatile写与其前的任意操作重排序</strong>。CAS同时具有volatile读和写的内存语义，编译器<strong>不会对CAS前和后的任意内存操作重排序</strong>，其是通过底层处理器缓存锁定实现原子性的。</p><h4 id="0、synchronized和lock有什么区别"><a href="#0、synchronized和lock有什么区别" class="headerlink" title="0、synchronized和lock有什么区别"></a>0、synchronized和lock有什么区别</h4><blockquote><p><font color='green'><strong>语法层面：synchronized是c++实现。Lock是一个接口，java语言实现的。用法上，synchronized是关键字，自动加锁解锁。</strong></font><font color='green'><strong>lock接口需要你先new出一个lock，然后手动的加锁解锁。</strong></font></p><p><font color='green'><strong>功能层面：lock相比synchronized更加灵活。多了很多功能，公平锁、可打断、可超时</strong></font></p><p><font color='green'><strong>性能方面：竞争不激烈，差不多。在竞争激烈时，Lock能提供更好的性能。</strong></font></p></blockquote><h4 id="1、AQS"><a href="#1、AQS" class="headerlink" title="1、AQS"></a>1、AQS</h4><blockquote><p>本质是一个抽象类，用来构造锁或其他同步组件的基础框架。</p><p>AQS有3个比较关键的东西，<font color='red'><u><em><strong>一个是volatile的state变量，一个是同步队列。一个owner</strong></em></u></font></p><p><strong>state</strong>表示同步状态（volatile）</p><p><strong>同步队列</strong>是一个双向列表，获取失败的线程会被构造成一个节点通过CAS的方式加入到这个队列尾部。一个节点保存着线程的引用，状态，前驱节点，后继结点。</p><p><font color='red'><u><strong>AQS资源共享方式：两种</strong></u></font></p><p><strong>1、独占式：</strong></p><blockquote><p>独占式就是同一时间只有一个线程能获取到同步状态。首先调用tryAcquire，获取失败构造节点通过加入队列尾部进入一个自旋的过程，停止的条件是前驱节点是头结点且成功获取同步状态。释放同步状态的时候会调用tryRelease，唤醒后面的后继结点。</p></blockquote><p><strong>2、共享式</strong></p><blockquote><p>共享式就是在同一时间能有多个线程同时获取到同步状态，在共享式获取的自旋过程中，成功获取的条件是tryAcquireShared这个结果大于等于0。释放的时候也会唤醒后续节点，他有一个和独占式比较大的区别就是释放的时候通过循环和CAS保证。</p></blockquote><p><strong>常见的实现工具类：</strong></p><blockquote><p><strong>信号量</strong>：<font color='green'><strong>保证共享资源在同一时刻 N 个线程中只有 N个线程能获取到.</strong></font></p><p>应用场景：<font color='green'><strong>流量控制，比如数据库连接数可能只有10个，那你就可以用信号量保证同时只能有10个能连接数据库</strong></font></p></blockquote><blockquote><p><strong>CountDownLatch</strong> （倒计时器，共享锁）：<font color='green'><strong>一次性的，让一个或多个线程，等待其他一组线程完成操作，再继续执行。</strong></font></p></blockquote><blockquote><p><font color='green'><strong>应用场景：汇总查询</strong></font></p></blockquote><blockquote><p><strong>CyclicBarrier</strong>（循环屏障）：<font color='green'><strong>让一组线程相互之间等待，达到一个共同点，再继续执行。某种需求中，旅游有很多旅游组，只有大家都到了，我们才能进行下一个目的地</strong></font></p></blockquote></blockquote><h3 id="Synchronized与AQS对比"><a href="#Synchronized与AQS对比" class="headerlink" title="Synchronized与AQS对比"></a>Synchronized与AQS对比</h3><p>Synchronized底层的同步队列为cxq和entryList， 等待队列为waitSet<br>AQS 同步队列为CLH， 条件队列为Condition</p><table><thead><tr><th>Synchronized</th><th>AQS</th><th></th></tr></thead><tbody><tr><td>wait</td><td>await</td><td></td></tr><tr><td>notify</td><td>signal</td><td></td></tr><tr><td>nofifyAll</td><td>signalAll</td><td></td></tr></tbody></table><p>wait : 把当前线程放入waitSet，调用park<br>await: 把当前线程放入条件队列，调用park<br>notify: 从waitSet中哪一个线程等待对象出来放入entrySet或者cxq。<br>signal: 从条件队列的队头里把一个node节点放入CLH队列末尾。</p><h4 id="2、ReentrantLock原理"><a href="#2、ReentrantLock原理" class="headerlink" title="2、ReentrantLock原理"></a>2、ReentrantLock原理</h4><blockquote><p><font color='red'><u><em><strong>他是LOCK接口的一个实现，他有一个内部类Sync，这个类继承了AQS，所以我们也说重入锁依赖AQS，AQS使用一个整形的volatile变量（state）来维护同步状态。用CAS对state进行原子操作。state&#x3D;0表示初始状态可以占有锁，state&#x3D;1表示已有线程占有，大于1是重入锁。具体加锁的流程，就是sync调用lock，lock去调用acquire函数，acquire调用tryacquire，这里就分一下公平锁和非公平锁。</strong></em></u></font></p><p><strong>公平锁和非公平锁区别？</strong></p><p><font color='red'><u><em><strong>Sync有公平锁 和非公平锁，公平锁和非公平锁区别: 非公平锁在tryacquire的时候，里面有一个步骤是获取同步状态，如果这个同步状态是0的话，说明现在没人拿，我可以去直接去拿，公平锁这里会多一个判断hasQueuedPredecessors，会先看看自己是不是排队的第一个，如果不是的话，我就不抢占state了。如果state等于当前线程，说明当前线程已经持有锁的，触发可重入功能。如果没拿到就那就把这个线程和等待状态等信息狗造成一个节点加入同步队列，并且阻塞。</strong></em></u></font></p><p><font color='green'><u><em><strong>加入的时候怎么加入的？</strong></em></u></font></p><p><font color='blue'><u><em><strong>新的节点的Pre指向尾结点，然后用cas的方式让尾结点指向新节点，最后尾结点更新。</strong></em></u></font></p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p><font color='green'><strong><code>Condition</code>提供了与<code>Object#wait</code>和<code>Object#notify</code>相同的功能，一般和lock搭配使用。他其实是一个条件队列。await的时候会释放锁，signal会回到AQS的同步队列。</strong></font></p><p><a href="https://zhuanlan.zhihu.com/p/629921197">https://zhuanlan.zhihu.com/p/629921197</a></p></blockquote><h4 id="4、死锁"><a href="#4、死锁" class="headerlink" title="4、死锁"></a>4、死锁</h4><p>多个进程互相请求对方已经持有的资源。</p><blockquote><p>互斥条件：一个资源只能被一个线程拿</p><p>请求和保持：线程自己拿了不主动释放</p><p>不可剥夺：资源拿了不被动释放</p><p>循环等待：你等我，我等你</p></blockquote><p><font color='red'><u><em><strong>怎么破坏死锁：</strong></em></u></font></p><blockquote><p>总体：破坏四个条件</p><p>破坏互斥：用读锁</p><p>破坏请求和保持：让某个直接拿到所有的资源</p><p>不可剥夺：强制剥夺</p><p>破坏循环等待：确定好所有线程的顺序</p></blockquote><p>死锁的检测：</p><ul><li>可以依赖JPS和JSTACK。用jps拿到java进程的id，然后jstack分析堆栈信息。</li><li>也可以用可视化工具virtualVM</li></ul><h3 id="4、原子操作的实现原理"><a href="#4、原子操作的实现原理" class="headerlink" title="4、原子操作的实现原理"></a>4、原子操作的实现原理</h3><h4 id="1、处理器如何实现原子操作？"><a href="#1、处理器如何实现原子操作？" class="headerlink" title="1、处理器如何实现原子操作？"></a>1、处理器如何实现原子操作？</h4><p>总线锁：使用LOCK 信号，其他请求都被阻塞，独占共享内存</p><p>缓存锁：所谓缓存锁定是指内存被缓存在处理器的缓存中，当他执行锁操作写回内存的时候，而是修改内部的内存地址，并允许他缓存一致性保证操作原子性。</p><h4 id="2、Java怎么实现原子操作"><a href="#2、Java怎么实现原子操作" class="headerlink" title="2、Java怎么实现原子操作"></a>2、Java怎么实现原子操作</h4><p>锁–JVM实现锁的方式其实都用到了循环CAS</p><p>循环CAS –版本号解决ABA</p><h1 id="2、JAVA内存模型"><a href="#2、JAVA内存模型" class="headerlink" title="2、JAVA内存模型"></a>2、JAVA内存模型</h1><h2 id="1、定义理解"><a href="#1、定义理解" class="headerlink" title="1、定义理解"></a>1、定义理解</h2><p>为了提高性能，计算机会加入高级缓存、然后允许各种重排序，这种优化会破坏内存可见性问题、有序性问题，所以，<code>Java</code> 语言在遵循内存模型的基础上推出了 <code>JMM</code> 规范。比如说：<font color='red'><u><em><strong>把内存分成主内存和线程私有内存，定义了线程和主内存之间的抽象关系，还有线程之间如何通信和线程之间的同步问题</strong></em></u></font>:<font color='red'><u><em><strong>。所以要想理解JMM，可能还需要去了解重排序、as if serial、顺序一致性、happens-before</strong></em></u></font>。</p><h2 id="2、重排序"><a href="#2、重排序" class="headerlink" title="2、重排序"></a>2、重排序</h2><blockquote><p>重排序可以分成三类</p><ul><li><strong>1、编译器重排序：</strong> 例如将循环内重复调用的操作提前到循环外执行；</li><li><strong>2、处理器系统重排序：</strong> 例如指令并行技术将多条指令重叠执行，或者使用分支预测技术提前执行分支的指令，并把计算结果放到重排列缓冲区（Reorder Buffer）的硬件缓存中，当程序真的进入分支后直接使用缓存中的结算结果；</li><li><strong>3、存储器系统重排序：</strong> 例如写缓冲区和失效队列机制，即是可见性问题，从内存的角度也是指令重排问题。</li></ul><p>编译器方面有这么一个规定</p><p><font color='red'><u><em><strong>那重排序的原则是什么？</strong></em></u></font></p><blockquote><p>as-if-serial : 单线程 无论你怎么排，你结果不能给我变了。但是在多线程是会出问题的。</p></blockquote><p><font color='blue'><u><em><strong>如何解决重排序问题</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>内存屏障</strong></em></u></font></p></blockquote></blockquote><h2 id="3、顺序一致性"><a href="#3、顺序一致性" class="headerlink" title="3、顺序一致性"></a>3、顺序一致性</h2><blockquote><p><font color='red'><u><em><strong>有个理想的模式叫做顺序一致性内存模型，一个线程中的操作完全是顺序的，所有线程只能看到一个单一的操作顺序。</strong></em></u></font></p><p><font color='red'><u><em><strong>如果程序的执行结果和顺序一致性模型相同，那么就叫做具备顺序一致性。</strong></em></u></font></p><p>JMM对于正确同步的 程序是保证顺序一致性的，虽然一个线程内部可能做了重排序，但是结果是不变的。</p><p>但是对于未同步的程序只提供最小安全保障：读到的值要么是之前写入的，要么是默认值。</p><p>如果你想要达到正确同步，那么就可以使用（synchronized、volatile、final）</p></blockquote><h2 id="4、happens-before-原则"><a href="#4、happens-before-原则" class="headerlink" title="4、happens-before 原则"></a>4、<font color='red'><u><em><strong>happens-before 原则</strong></em></u></font></h2><blockquote><p>他是高级的语言层面的一组规范。<font color='blue'><u><em><strong>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</strong></em></u></font></p><p>包括什么程序规则、锁规则、volatile规则、依赖规则</p><p>不过这里我们要强调的一点是：<strong>程序规则和指令重排并不冲突，如果我们要显示的禁止重排序，就需要显示的建立遵循happens-before的代码，比如synchronized、volatile、lock</strong>。所以我们说happensbefore是给程序员提供的</p></blockquote><h1 id="3、ThreadLocal"><a href="#3、ThreadLocal" class="headerlink" title="3、ThreadLocal"></a>3、ThreadLocal</h1><p><font color='red'><u><em><strong>threadlocal的使用场景</strong></em></u></font></p><blockquote><p>配置信息存储。mybatis分页插件pagehelper使用。cpu核数等等。</p><p>日志跟踪和调试。</p><p>全局用户信息</p><p>数据库连接，每个线程维护自己的数据库连接</p></blockquote><p><font color='red'><u><em><strong>threadlocal是一个用来解决多线程线程安全问题的方法，他给每个线程创建一个独立的线程副本解决共享变量的访问冲突的问题。</strong></em></u></font></p><p><font color='red'><u><strong>内存泄漏：</strong></u></font></p><p><font color='green'><strong>threadlocal会有两类引用，一个是外界的强引用，一个是entry key的弱引用。如果外界对他进行了回收【&#x3D; null】那强引用就没了，下次gc的时候就会被回收，会被gc清理掉,而 value 不会被清理掉，因为thread到threadlocalmap到entry到value这个链路是和线程同样的生命周期，线程不回收，引用一直存在，发生内存泄漏。</strong></font></p><p>threadlocal需要理解这张图片，线程里面有一个ThreadLocalMap，map的每一个Entry的key是threadlocal的弱引用，value是指向一个值的强引用。然后ThreadLocal的set方法，是先获取当前线程的ThreadLocalMap，然后调用ThreadLocalMap的set方法。</p><p><img src="/../images/Java%E5%B9%B6%E5%8F%91/image-20231027153110006.png" alt="image-20231027153110006"></p><p><font color='red'><u><em><strong>怎么解决</strong></em></u></font></p><p><font color='green'><strong>用完threadlocal后，手动remove一下。</strong></font></p><p><font color='red'><u><strong>弱引用是原罪吗？</strong></u></font></p><blockquote><p>不是，如果在某种情况下，栈帧跳出后，对threadlocal没有引用了，变量名立即回收了，按理来说threadlocal也要回收，是强引用的话，还有一个key的强引用，key是在entry里面，entry在map里面，map又是属于线程的，所以等同于和Thread生命周期绑定了。只有线程结束的时候才可以释放，如果线程生命周期比较短的话，那线程销毁的时候value也会收回。如果线程周期比较长的话，那么内存泄露的问题就会比较严重。其实设计者也考虑到到key被收到时导致内存泄漏问题，在调用ThreadLocal中set、remove、rehash时会扫描key为null的entry，并将value置为null，避免内存泄漏</p></blockquote><blockquote><p><font color='green'><strong>强引用(Strongly Reference)</strong></font><br>指代码中普遍存在的赋值行为，如：Object o &#x3D; new Object()，只要强引用关系还在，对象就永远不会被回收。<br><font color='green'><strong>软引用(Soft Reference)</strong></font><br>还有用处，但是非必须存活的对象，JVM会在内存溢出前对其进行回收，例如：<font color='red'><u><em><strong>缓存</strong></em></u></font>。<br><font color='green'><strong>弱引用(Weak Reference)</strong></font><br>非必须存活的对象，引用关系比软引用还弱，不管内存是否够用，下次GC一定回收。<br><font color='green'><strong>虚引用(Phantom Reference)</strong></font><br>也称“幽灵引用”、，最弱的引用关系，完全不影响对象的回收，等同于没有引用，虚引用的唯一的目的是对象被回收时会收到一个系统通知。</p></blockquote><hr><h1 id="4、线程池和线程"><a href="#4、线程池和线程" class="headerlink" title="4、线程池和线程"></a>4、线程池和线程</h1><p><strong>线程安全的方案</strong></p><blockquote><p>1、锁</p><p>2、cas</p><p>3、threadlocal</p><p>4、读写分离</p></blockquote><p><font color='red'><u><em><strong>线程池就是管理线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</strong></em></u></font></p><p><font color='red'><u><em><strong>处理流程：</strong></em></u></font></p><p>1）先看核心线程池，有没有都在执行任务。如果不是都在执行，就创建一个工作线程执行任务，否则就看工作列表。</p><p>2）线程池判断工作列表有没有满，如果没有满，就把新提交的任务存到这个工作队列里面，</p><p>3）如果满了判断线程池里面的线程是否都在工作状态，如果没有就创建一个新的救济线程执行，如果满了，就交给饱和策略。</p><p><font color='red'><u><em><strong>核心线程没有生存时间，救济线程是有生存时间（KeepAliveTime 生存时间、unit时间单位）</strong></em></u></font></p><p><font color='red'><u><em><strong>怎么确认系统的最佳线程数</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>1、先用用公式估计：</strong></em></u></font></p><p><font color='green'><strong>IO密集型，就设置成2*cpu核数+ 1</strong></font></p><p><font color='green'><strong>cpu密集型任务，就避免线程上下文切换，可以设置成cpu+1</strong></font></p><p><font color='red'><u><em><strong>2、其次压测一下：</strong></em></u></font></p><p><font color='green'><strong>最佳线程数 &#x3D; CPU 核心数 ∗（1+WT（线程等待时间）&#x2F;ST（线程计算时间）*目标cpu利用率</strong></font></p><p><font color='red'><strong>3、最后在上线进行调整</strong></font></p></blockquote><p><font color='red'><u><strong>如何设定线程池的大小？</strong></u></font></p><blockquote><p>最佳线程数 &#x3D; CPU 核心数 ∗（1+WT（线程等待时间）&#x2F;ST（线程计算时间）</p><p>反正和cpu核数和线程等待时间计算时间有关。</p></blockquote><p><font color='red'><u><em><strong>线程池的使用场景</strong></em></u></font></p><blockquote><p><font color='blue'><u><em><strong>数据分批导入导出</strong></em></u></font></p><p><font color='blue'><u><em><strong>分批查询汇总</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>怎么限制接口可以访问的线程数？限流？</strong></em></u></font></p><blockquote><p><font color='blue'><u><em><strong>令牌桶，那个信号量可以实现这个</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>线程池创建线程</strong></em></u></font>有两种方式：</p><blockquote><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造方法来创建（推荐）。xx</strong></p><p><strong>方式二： <code>Executors的工厂方法：比如Executors.newCachedThreadPool()</code>（不推荐）。</strong></p><p>两种方法都在concurrent包下面。</p><p>为什么不推荐？我觉得就是Executors提供的创建的几个线程池都有点局限性，都有不足的地方。</p><p>然后像Fixed和Single用的<font color='red'><u><em><strong>工作队列最大时Integer.MAX_VALUE</strong></em></u></font>，可能会堆积大量的请求,导致OOM</p><p>还有<font color='red'><u><em><strong>cached和Schedule最大的线程数量是Integer.MAX_VALUE</strong></em></u></font>，可能堆积大量的线程，导致OOM</p><p><font color='red'><u><em><strong>线程池的类型</strong></em></u></font></p><blockquote><p>FixedThreadPool，没有救济的线程，只有核心线程。阻塞队列是LinkedBlockingQueue，默认大小是Integer的MaxValue</p><p>SingleThreadExecutor，核心线程和最大线程就1个。阻塞队列是LinkedBlockingQueue，默认大小是Integer的MaxValue</p><p>CachedThreadPool：这个是没有核心线程数，全都是救济线程。阻塞队列是SynchronousQueue</p><p>ScheduledThreadPool：这个是定时执行任务，阻塞队列是DelayedWorkQueue</p></blockquote><p><font color='red'><u><em><strong>核心参数</strong></em></u></font></p><blockquote><p>corePoolSize</p><p>maximumPoolSize</p><p>keepAliveTime：多余线程的存活时间</p><p>unit</p><p>workQueue</p><p>handler 拒绝策略</p><p>threadFactory 线程工厂</p></blockquote></blockquote><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><font color='red'><u><em><strong>怎么创建线程</strong></em></u></font></p><blockquote><p><font color='green'><strong>1、继承Thread、2、实现runnbale接口，3、实现callable接口，4、还有线程池（也是项目中的创建方法）</strong></font></p></blockquote><p><font color='red'><u><strong>runnable和callable有什么区别？</strong></u></font></p><table><thead><tr><th></th><th>callable</th><th>runnable</th></tr></thead><tbody><tr><td></td><td>有返回值的配合futuretask获得线程执行结果</td><td>无返回值</td></tr><tr><td></td><td>callable方法抛出异常</td><td>runnable不抛异常</td></tr><tr><td>实现方法</td><td>call</td><td>Run</td></tr></tbody></table><p><font color='blue'><u><em><strong>怎么退出线程？</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>1、Interrupt，一种温和的方式，会把线程的中断状态位设置为true，告诉他他自己应该在合适的时间中断</strong></em></u></font></p><table><thead><tr><th>isInterrupted</th><th>检查线程的中断标记位，</th><th></th></tr></thead><tbody><tr><td>interrupted</td><td>返回当前线程的中断标记位，同时清除中断标记，改为false</td><td></td></tr></tbody></table><p><font color='red'><u><em><strong>如果调用interrupt的时候正处于阻塞的状态，那就抛出一个异常，提前终止阻塞。</strong></em></u></font></p><p><font color='red'><u><em><strong>如果正常进行，那就是简单的把中断状态改成true，后面如果遇到wait、sleep就抛异常，不进行阻塞</strong></em></u></font></p><p><font color='red'><u><em><strong>2、退出标记，while循环</strong></em></u></font></p><p><font color='red'><u><em><strong>3、stop</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>怎么减少线程上下文切换</strong></em></u></font></p><blockquote><p><font color='blue'><u><em><strong>上下文切换：保存当前线程的线程信息，加载下一个线程的线程信息。</strong></em></u></font></p><p><font color='blue'><u><em><strong>减少的方法：无锁编程和cas</strong></em></u></font></p></blockquote><p><font color='blue'><u><em><strong>线程有哪些状态，怎么转换</strong></em></u></font></p><p>new runnable blocked waiting timewaiting terminated</p><p><img src="/../images/JUC/image-20240113135657239.png" alt="image-20240113135657239"></p><p><strong>wait和sleep有什么不同</strong></p><blockquote><p><font color='red'><u><em><strong>都会让出cpu</strong></em></u></font></p><p><font color='green'><strong>sleep是线程类的方法。wait是object的方法。</strong></font></p><p><font color='green'><strong>sleep可以任何地方用，wait只能在同步方法或同步块里面用</strong></font>（<font color='blue'><u><em><strong>为什么？就是因为wait要释放锁，同步方法和同步块可以保证它获取到了锁</strong></em></u></font>）</p><p><font color='green'><strong>sleep是不释放锁。wait会释放锁</strong></font></p><p><font color='green'><strong>sleep到了时间会继续执行，wait会进入等待队列，</strong></font></p></blockquote><p><strong>启动的时候可以run方法吗</strong></p><blockquote><p>调用run，就是调用普通方法。不会启动线程</p></blockquote><p><strong>如何设计一个能够根据任务的优先级来执行的线程池？</strong></p><blockquote><p>队伍队列用一个优先级的队列</p></blockquote><p><strong>怎么给线程命名：</strong></p><blockquote><p>1、自己实现 <code>ThreadFactory</code>。</p></blockquote><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a><strong>Future</strong></h3><p>主线程处理一些耗时的任务的时候，可以把这个交给子线程，然后子线程解决后返回结果给主线程。</p><p>future就是一个用于处理异步任务的接口，futuretask实现了runnable和future，他有三个状态，未启动、启动、完成。如果在未启动和启动的时候执行get方法，就会阻塞调用get方法的线程。</p><p>颜屹钧：钧的话，本来想取一个君子的君，代表那种不轻言放弃、凛然正义的君子，但是君是属于水，就换成了钧，钧的话，本身就有尊贵的意思，然后还可以通“均”，这个均就有均衡的意思，各个方面都不差。</p><p>颜屹琛：琛，属金，本身是宝玉的意思，和小宝、66的瑾和瑜是一类意思，而且取得人少。</p><p>颜屹正。正属于金，反过来还刚好是正义。希望孩子刚正不阿，笔画也少点，寓意肯定是极好的。</p><p>颜屹心：取自“钧是人也,或从其大体,或从其小体,何也”–《孟子》。这句话的意思是：孟子说，同样是人，有的人注重身体重要部分，有的人注重身体次要部分。这是因为眼睛、耳朵等器官不会思考，容易被外物所蒙蔽，而心这个器官则有思考的能力，一思考就会有所得，不思考就得不到。所以，如果首先把心这个身体的重要部分树立起来，其他次要部分就不会被引入迷途，这样便可以成为君子。刚刚好，嫂子说过希望孩子有想法，前面那个屹也能对上树立，也蛮适合。不过这个“心”有一个问题，有人说属于金，有人说属于火。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-mysql技术内幕</title>
      <link href="/2023/11/08/%E5%85%AB%E8%82%A1-mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
      <url>/2023/11/08/%E5%85%AB%E8%82%A1-mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/</url>
      
        <content type="html"><![CDATA[<p><font color='red'><u><em><strong>层高</strong></em></u></font></p><blockquote><ul><li>根节点指针数<br>B+树的非叶子节点仅保存索引字段和指针，假设主键为bigint类型，InnoDB 的bigint占用8个字节，指针占用6个字节，8+6&#x3D;14，所以我们可以得出，一个page能存放的指针个数为16k&#x2F;(8+6)约等于1170</li><li>每个指针对应第二层的行记录数<br> 再来说说一个page能存储多少条行记录，常规的互联网项目单条行记录大小约为1k，那么一个page能存储的行记录数为16k&#x2F;1k&#x3D;16<br> 所以一个2层高的b+树能存储的行记录数大约为1170*16&#x3D;18720<br>3层为1170*1170<em>16约等于*<em>2190w</em></em></li></ul></blockquote><p><font color='red'><u><em><strong>Q1：MySQL主要有哪些存储引擎，分别适合哪些应⽤场景？</strong></em></u></font></p><blockquote><p>①MyISAM，是5.5版本之前的默认存储引擎，⽀持表级锁，不⽀持事务和外 键，</p><p>②InnoDB，MySQL⽬前的默认存储引擎，⽀持⾏级锁、事务和外键，</p><p>③Memory，所有的数据都保存在内存中，访问速度快</p></blockquote><p>首先来了解一下InnoDB的体系架构：</p><h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><p><img src="/../images/mysql-Technology/image-20231004235405057.png" alt="image-20231004235405057"></p><p><font color='red'><u><em><strong>我觉的用一句话概括，就是由很多内存块组成的内存池维护一系列后台线程，然后这些后台线程去负责最重要的工作。主要是内存和后台线程。</strong></em></u></font></p><h2 id="1、后台线程"><a href="#1、后台线程" class="headerlink" title="1、后台线程"></a>1、后台线程</h2><blockquote><p>主要有：</p><p><font color='red'><u><em><strong>master thread</strong></em></u></font>：最重要的，脏页刷新、合并insert buffer，undo 页的回收，redolog buffer。不过后来脏页回收放到了单独的线程，也就是page thread</p><p>IO thread: 负责异步io的回调</p><p>purge thread: 负责undolog清理</p><p>page clean thread：负责脏页刷新</p></blockquote><h3 id="1、master-thread"><a href="#1、master-thread" class="headerlink" title="1、master thread"></a>1、master thread</h3><p>本质是一个循环</p><p>每秒都会进行一次操作：重做日志缓冲刷新、合并insertbuffer，脏页刷新被放到了page clean 线程</p><p>每十秒会进行的操作：重做日志缓冲刷新、合并insertbuffer、脏页刷新被放到了page clean 线程、删除无用的undo 页</p><h2 id="2、内存"><a href="#2、内存" class="headerlink" title="2、内存"></a>2、内存</h2><p>内存方面就是缓冲池、lrulist freelist flushlist、redo log buffer 三块，还有一些额外内存池（为了数据结构的内存申请服务）</p><h3 id="1、缓冲池"><a href="#1、缓冲池" class="headerlink" title="1、缓冲池"></a>1、缓冲池</h3><p><font color='red'><u><em><strong>本质就是一块内存，缓冲池里面有数据页、索引页、undo 页、insert buffer、自适应哈希索引、锁信息、数据字典。</strong></em></u></font></p><p>所以修改操作，基本都现修改缓冲池里面的数据，然后按照一定刷回机制磁盘。</p><h3 id="2、List"><a href="#2、List" class="headerlink" title="2、List"></a>2、List</h3><p>缓冲池是通过改进的LRU算法（在原本的基础上加了midpoint，新加入的页放到这里，默认<font color='red'><u><em><strong>5&#x2F;8</strong></em></u></font>）进行管理的，方法就是LRUlist、freelist flushlist。如果缓冲池不能放新的，就把lru里面末尾的释放掉。<font color='red'><u><em><strong>处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部；否则不变。</strong></em></u></font></p><p>改进lru的原因：有可能新页仅仅是这次查询需要用到，并不是真正的热点数据，这样反而有可能将真正的热点数据淘汰。</p><p>flushlist就是脏页列表，就像上面说的，用checkpoint机制刷新</p><p>一页16k</p><p>说了这么多checkpoint，什么是checkpoint？（当前要刷回的位置）</p><h4 id="1、checkpoint"><a href="#1、checkpoint" class="headerlink" title="1、checkpoint"></a>1、checkpoint</h4><p>解决问题：</p><ul><li>缩短数据库恢复时间？</li></ul><p>即使发生宕机， 因为checkpoint之前多页已经刷新回磁盘，所以只需要对checkpoint之后对进行恢复</p><ul><li>缓冲池不够时，可以将脏页刷回磁盘？</li></ul><p>缓冲池不够用的时候，根据lru找lru末尾的页，如果是脏页，就强制执行checkpoint，讲脏页刷新回磁盘</p><ul><li>重做日志不可用，刷新脏页。</li></ul><p>重做日志两个文件是循环使用，为了不让他一直无限变大，不可用是指重做日志已经不被需要了可以被覆盖。如果宕机，数据库恢复操作不需要这部分的重做日志就可以覆盖重用。如果此时重做日志还需要用，就必须强制产生checkpoint将讲缓冲池的页至少刷新到当前重做日志的位置</p><p>所以总归checkpoint做的事情就是把脏页刷回磁盘。<font color='red'><u><em><strong>（脏页刷时机）？</strong></em></u></font></p><blockquote><p><font color='red'><u><strong>1. redo log 写满。会造成mysql不接受更新。</strong></u></font><br><font color='red'><u><strong>2. 内存不足。</strong></u></font><br><font color='red'><u><em><strong>3. 空闲时间，认为目前压力不大。（主流）</strong></em></u></font><br><font color='red'><u><em><strong>4. Mysql关闭时。</strong></em></u></font></p><p><font color='red'><u><em><strong>5、脏页数量太多</strong></em></u></font></p><p>一个是脏页比例，一个是 redo log 写盘速度去计算刷盘的速度。</p></blockquote><p>这里有两种checkpoint，分别是：</p><blockquote><p>sharp checkpoint</p><p>fuzzy checkpoint</p></blockquote><blockquote><p>sharp checkpoint就是在<font color='red'><u><em><strong>数据库关闭的时候全部刷新到磁盘</strong></em></u></font></p><p>fuzzy checkpoint是刷新部分脏页？刷新到时机如下：</p><p>master thread checkpoint（空闲）</p><p>flushlrulist checkpoint：这饿是lru列表需要有100个空闲的页，否则移除lru末尾的页，如果有脏页就checkpoint（内存不足）</p><p>async sycn flush checkpoint：这个是<font color='red'><u>**重做日志文件不可用的情况，需要强制将一些刷新回磁盘  **</u></font>（redo）</p><p>dirty page too much：这个是脏页数量太多了，强制checkpoint ，脏页的比例达到75%</p></blockquote><h3 id="3、Redo-log-buffer"><a href="#3、Redo-log-buffer" class="headerlink" title="3、Redo log buffer"></a>3、Redo log buffer</h3><p>这个是innodb独有的，重做日志信息 -&gt;Redo log buffer -〉 重做日志文件，为重做日志文件服务，重做日志文件本身是为了数据库的恢复功能，但是同样的，为了缓解和磁盘的差距，我们给他加一个buffer。</p><p>刷回时机：</p><blockquote><p><font color='red'><u><em><strong>master thread 每秒</strong></em></u></font></p><p><font color='red'><u><em><strong>每个事务提交的时候，有个参数，1代表完全同步，0代表不写磁盘，2表示写到page cache里面，具体刷回靠操作系统</strong></em></u></font></p><p><font color='red'><u><em><strong>重做日志缓冲 剩余空间小于1&#x2F;2</strong></em></u></font></p><p><font color='red'><u><em><strong>正常关闭</strong></em></u></font></p></blockquote><h3 id="4、额外的缓冲池"><a href="#4、额外的缓冲池" class="headerlink" title="4、额外的缓冲池"></a>4、额外的缓冲池</h3><p>对于一些数据结构本身的内存分配服务</p><h1 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h1><p>前三个最重要：</p><blockquote><p>1、插入缓冲</p><p>2、两次写</p><p>3、自适应哈希</p><p>4、异步io</p><p>5、刷新邻接页</p></blockquote><h2 id="1、插入缓冲"><a href="#1、插入缓冲" class="headerlink" title="1、插入缓冲"></a>1、插入缓冲</h2><h3 id="1、insert-buffer"><a href="#1、insert-buffer" class="headerlink" title="1、insert buffer"></a>1、insert buffer</h3><blockquote><p>数据插入的时候还是按照主键的位置存放的，但是这个表如果有辅助索引，那么这条记录也会插入辅助索引，但是这时候他就不是顺序插入了，而是离散的插入。我们在对非聚集索引的插入的时候不会实时的插入，而是先判断有没有在缓冲池里面，有的话直接插入，没有的话，先构造一个searchkey，放到一个insert buffer里面。后面再以一定的频率进行insertbuffer和非聚集索页子节点的merge操作。</p><p><strong>changebuffer的存在让普通索引优于唯一索引。</strong>普通索引和唯一索引的查询效率差不多，对于已经在内存的数据更新也差不多。但是对于没有在内存的数据更新操作差很多，因为唯一索引为了保证唯一性，会把数据从磁盘读到内存，这一步是数据库成本最高的操作之一。</p><p>insert buffer 升级为了 change buffer，对插入更新删除操作都准备了缓冲</p><h3 id="2、insert-buffer的内部实现"><a href="#2、insert-buffer的内部实现" class="headerlink" title="2、insert buffer的内部实现"></a>2、insert buffer的内部实现</h3><p>全局唯一的b+树的形式，负责对<font color='red'><u><em><strong>所有表</strong></em></u></font>的辅助索引进行insert buffer，存放在共享表空间，就是ibdata1。但是我们知道，我们可以有独立表ibdata，但是恢复的时候最好用共享表里面的。</p><p>因为是树，所以有非叶子结点和叶子结点。</p><p>非叶子结点放的是searchkey，所以插入非聚集索引的时候，如果不在缓冲池，那么要加入这颗唯一的insertbuffer，实现构造一个searchkey，我想通过这个searchkey找到我要插入的位置，然后再构造一个叶子结点，放进去。</p><h3 id="3、Merge-insert-buffer"><a href="#3、Merge-insert-buffer" class="headerlink" title="3、Merge insert buffer"></a>3、Merge insert buffer</h3><p>所以后面就是合并操作，合并的时机：</p><p><font color='red'><u><em><strong>1、master thread</strong></em></u></font></p><p><font color='red'><u><em><strong>2、辅助索引页被读到缓冲池里去</strong></em></u></font>，<font color='green'><strong>然后这个是要执行正常的查询语句了，就去检查这个insert buffer bitmap，确认这个该辅助索引是不是在insert buffer b+书里面，如果有，就把树里面的记录查到辅助索引里面。</strong></font></p></blockquote><h2 id="2、两次写"><a href="#2、两次写" class="headerlink" title="2、两次写"></a>2、两次写</h2><p><font color='red'><u><em><strong>doublewrite的目的是为了数据的可靠性。</strong></em></u></font></p><blockquote><p>具体实现的话，是依赖于两个部分，一个是<font color='red'><u><em><strong>内存中的doublewrite buffer</strong></em></u></font>，2m。另一部分是磁盘里的<font color='red'><u><em><strong>共享表空间里面有一个连续的128页</strong></em></u></font>，也是2m。</p><p>流程分三步。</p><p><font color='red'><u><em><strong>1、我先不直接写磁盘，我先复制到这个内存的doublewrite buffer里面</strong></em></u></font></p><p><font color='red'><u><em><strong>2、然后分两次写入，每次1m写入共享表空间的物理磁盘，（顺序写）</strong></em></u></font></p><p><font color='red'><u><em><strong>3、然后马上调用fsync函数，同步磁盘。（离散写）</strong></em></u></font></p><p>所以，如果写的时候崩溃了，那就把这个共享表空间里面的副本拿出来配合redo log进行恢复。</p></blockquote><p><img src="/../images/mysql-Technology/image-20231021153343267.png" alt="image-20231021153343267"></p><h2 id="3、自适应哈希"><a href="#3、自适应哈希" class="headerlink" title="3、自适应哈希"></a>3、自适应哈希</h2><p>InnoDB会自动为某些访问频率非常高的页建立哈希索引，而哈希索引比起b+树更快，所以也是一种提高性能手段。</p><p>但是有一个<font color='blue'><u><em><strong>比较大的痛点就是他只能用于做 等值查询，如果遇到范围查到，就无能为力。</strong></em></u></font></p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>文件包括mysql文件和innodb文件</p><p>1、参数文件</p><p>2、日志文件、</p><p>3、socket文件</p><p>4、pid文件</p><p>5、mysql表结构文件</p><p>6、存储引擎文件</p><p>我们这里只讲几个</p><h2 id="2、日志文件"><a href="#2、日志文件" class="headerlink" title="2、日志文件"></a>2、日志文件</h2><p>日志文件有错误日志、慢查询日志、查询日志、二进制日志，我们着重可以讲一下二进制日志</p><h5 id="提问？如何定位慢查询？"><a href="#提问？如何定位慢查询？" class="headerlink" title="提问？如何定位慢查询？"></a><font color='red'><u><em><strong>提问？如何定位慢查询？</strong></em></u></font></h5><blockquote><p><font color='green'><strong>1、可以用普罗米修斯、skywalking这些工具</strong></font></p><p><font color='green'><strong>2、或者开启慢查询日志。set global slow_query_1o9&#x3D;1；</strong></font></p></blockquote><h6 id="接着问？执行很慢？怎么分析？"><a href="#接着问？执行很慢？怎么分析？" class="headerlink" title="接着问？执行很慢？怎么分析？"></a><font color='red'><u><em><strong>接着问？执行很慢？怎么分析？</strong></em></u></font></h6><blockquote><p><font color='red'><u><em><strong>表结构的优化：分库分表、读写分离</strong></em></u></font></p><p><font color='red'><u><em><strong>如果是sql语句的优化：explain命令去分析sql语句，看看能不能优化。主要是加索引和有没有命中索引（看key possible key）</strong></em></u></font></p><p><font color='red'><u><em><strong>参数方面：缓冲池的大小，最大连接数</strong></em></u></font></p></blockquote><p><img src="/../images/mysql-Technology/image-20231115150005784.png" alt="image-20231115150005784"></p><p>extra：mrr优化等等</p><p><img src="/../images/mysql-Technology/image-20231115150305270.png" alt="image-20231115150305270"></p><p>ref range 都有where</p><p>index是没有where，<font color='green'><strong>索引全扫描</strong></font></p><h3 id="1、二进制日志"><a href="#1、二进制日志" class="headerlink" title="1、二进制日志"></a>1、二进制日志</h3><blockquote><p><font color='red'><u><em><strong>它是server层 的日志，记录了对mysql数据库更改的所有操作。</strong></em></u></font><font color='red'><u><em><strong>主要用于备份恢复和主从同步：</strong></em></u></font>不包括selectshow这类操作</p><p>过程主要是：</p><p><font color='red'><u><em><strong>他的写入逻辑是：事务执行过程中，先把日志写到 binlog cache、事务提交的时候，再把 binlog cache 写到 binlog 文件中。</strong></em></u></font></p><p>这个刷盘的机制就依赖于sync_binlog这个参数</p><ul><li>sync_binlog &#x3D; 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li><li>sync_binlog &#x3D; 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li><li>sync_binlog &#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li></ul><p><font color='red'><u><em><strong>还有个需要关注的点就是它落盘的形式，就是怎么记录的？</strong></em></u></font></p><p>这个是依赖于binlog——format这个参数，他就是记录二进制的格式，有三种、statement、row、mixed。</p><p>statement就是最简单的sql语句，但是他有个很大的问题就是如果用到了uuid rand udf这些函数或触发器，或者索引选择的问题，那么会导致主从不一致，那我们可以用row的格式，row的话就是记录表的行修改情况。同样的他也有一个很大问题就是要求的容量比较大。那还有一种mixed格式就是混用，正常情况下我按照statement记录sql语句，但是在uuid rand udf这些特殊情况我用row的格式进行记录。</p><blockquote><p>了解：</p></blockquote><blockquote><p>恢复：某些数据需要二进制日志。比如数据库全备文件恢复之后，通过二进制进行point-in-time的恢复</p><p>复制；主从同步，那canal也是通过这种方式去监听binlog</p><p>审计：用户通过二进制的信息判断是否有对数据库进行注入的攻击</p></blockquote></blockquote><h3 id="2、表结构定义文件"><a href="#2、表结构定义文件" class="headerlink" title="2、表结构定义文件"></a>2、表结构定义文件</h3><p>这个文件的后缀是.frm，每个文件都会有这个一个frm文件，记录了该表的表结构定义</p><h3 id="3、Innodb存储引擎文件"><a href="#3、Innodb存储引擎文件" class="headerlink" title="3、Innodb存储引擎文件"></a>3、Innodb存储引擎文件</h3><h4 id="1、表空间文件"><a href="#1、表空间文件" class="headerlink" title="1、表空间文件"></a>1、表空间文件</h4><p>首当其冲的就是表空间文件，情况下我们会放到ibdata那个文件里面，但是我们可以通过设置一个参数去产生一个自己表的独立表空间，然后这些<font color='red'><u><em><strong>独立的表空间记录该表的数据，索引信息，其余的还是放在共享表空间里面。</strong></em></u></font></p><h4 id="2、redolog"><a href="#2、redolog" class="headerlink" title="2、redolog"></a>2、redolog</h4><blockquote><p>他是引擎层的文件，它为了防止断电导致数据丢失的问题。他的使用流程是：当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改记录到redolog buffer里面，然后按照一定的机制刷回redolog文件。这里两段式提交， redo log 和 binlog 的数据一致性。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p><p><font color='red'><u><em><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。</strong></em></u></font></p><p>主要有下面几个时机：</p><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。</li></ul><p>由参数 <code>innodb_flush_log_at_trx_commit</code> 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：</p><ul><li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li><li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li><li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看<a href="https://xiaolincoding.com/os/6_file_system/pagecache.html">这篇 (opens new window)</a>），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li></ul></blockquote><h1 id="索引前的准备知识"><a href="#索引前的准备知识" class="headerlink" title="索引前的准备知识"></a>索引前的准备知识</h1><p><a href="https://baijiahao.baidu.com/s?id=1709211669369376612&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1709211669369376612&amp;wfr=spider&amp;for=pc</a></p><p><strong>这里我们首先要问三个重要的问题去扒一扒MySQL的InnoDB存储引擎</strong></p><ol><li><strong>MySQL的记录是怎么存储的？</strong></li><li><strong>页内记录到底是怎么维护的？</strong></li><li><strong>页内查询过程是怎样的</strong></li></ol><h3 id="穿上第一件：Page页面"><a href="#穿上第一件：Page页面" class="headerlink" title="穿上第一件：Page页面"></a>穿上第一件：Page页面</h3><p>MySQL管理数据的一个单位叫Page页面，数据都是存在页面里的<strong>。</strong>那咱们想要知道数据是怎么存，就<strong>需要了解页面长什么样子</strong>。</p><p>直接爆照：</p><p><img src="/../images/mysql-Technology/42a98226cffc1e171d3b202cf4e9e50a728de9ae.jpeg" alt="img"></p><p>页头（Page Header）：存一些统计信息，记录页面的控制信息，共占56字节，包括页面空间使用情况、页的左右兄弟页面指针（<strong>这个就是双向链表，把左右兄弟页面的指针给拿到了</strong>）等。</p><p>虚记录：分为最大虚记录与最小虚记录，<strong>它俩把这页里面存储的数据的范围框住了。</strong>那怎么比较谁大谁小？用的是主键去比较：最大虚记录比页内最大主键还大，最小虚记录比页内最小主键还小<strong>。</strong>那主键到底是怎么存的呢？InnoDB用的是聚簇索引——<strong>数据和主键存到一起、数据和索引存到一起，数据按主键顺序存储。</strong></p><p>记录堆：<strong>这部分就是存储记录的区域</strong>，分为有效记录和已删除记录。已被删除的记录构成一个链表，叫做自由空间链表<strong>，</strong>如图蓝色已经被删除的数据，<strong>用一个链表把它们连起来</strong>。</p><p>未分配空间：页面未使用的存储空间，除了用了一部分的橙色的区域和已删除的蓝色的数据，剩下的就是未分配空间了，<strong>后面有新的数据插入，往里放就行了</strong>。</p><p>Slot：<strong>这一块对数据检索非常有用</strong>，卖个关子，后面详细说。</p><p>页尾（Page Tailer）：页面的最后部分，占8个字节，主要存储页面的校验信息。<strong>这一页如果写坏了，数据不对了，通过校验位可以检查出来。</strong></p><p>好了，到这里一个页面咱们了解了，了解数据大概是怎么分布的，<strong>那接下来需要考虑哪些点呢？</strong>我们接下来研究一下——页面记录是怎么维护的</p><h3 id="穿上第二件"><a href="#穿上第二件" class="headerlink" title="穿上第二件"></a>穿上第二件</h3><p><img src="/../images/mysql-Technology/c9fcc3cec3fdfc032a5c874b6446949da5c2269b.jpeg" alt="img"></p><p><strong>那这个数据在里边到底是怎么存的</strong>？换个说法——数据的顺序是怎么保证的？<strong>到底是物理有序，还是逻辑有序？</strong></p><p>我们再回顾一下大学的知识——<strong>物理有序写入不友好，查询友好；逻辑有序查询不友好，插入友好</strong>，两者优缺点互补。</p><p>再回到正题，了解了这两种不同存储方式的特性，反观页面是怎么做的。</p><p>先看下面这幅图，思考一下插入主键为10，9，8的数据，是按物理有序存储还是逻辑有序存储：</p><p><img src="/../images/mysql-Technology/e850352ac65c103892bb2f180b68801ab27e89a2.jpeg" alt="img"></p><p>数据插入是写入IO，数据查询是读IO，不管是写还是读，在分析存储的时候，无非是这四种：顺序写、随机写、顺序读、随机读。<strong>如果是顺序写，数据会有各种移动，写入性能肯定非常糟糕</strong>。但是没办法，<strong>优化写入的手段十分有限，不过呢我们却有很多办法优化读</strong>。</p><p><strong>所以想都不用想，页内数据存储的顺序就是逻辑有序</strong>。</p><p>重新梳理一下，<font color='red'><u><em><strong>Page与Page之间由双向链表连接，页内是用小的链表连起来的：</strong></em></u></font></p><p><img src="/../images/mysql-Technology/9825bc315c6034a8191108a4766a5a5d082376a2.jpeg" alt="img"></p><p>我们再来重新画一下这棵树：</p><p><img src="/../images/mysql-Technology/80cb39dbb6fd5266c5d8021702618422d5073647.jpeg" alt="img"></p><p>这里要注意，每个Page的索引的每个节点，也就是树的每个节点，它也是一个Page。<strong>既然是个Page，也会有页头，也会有双向链表</strong>，如图蓝色与紫色相间那部分节点数据。</p><p><strong>接下来咱分析一下它的插入策略。</strong></p><p>蓝色部分已删除的空间（记录堆）怎么办呢？<strong>我们得想办法尽量把它们利用上</strong>，这个换谁做数据库设计都要这么设计<strong>。</strong></p><p>其实，插入策略就是先使用自由空间链表，再使用未使用空间，<strong>把数据库“空洞”给补上。</strong>不过呢，自由空间链表的空间也不能完全利用上，比如旧的数据占25个字节，新的数据假设都只有20个字节，<strong>那剩下这5个字节基本也利用不上，这样一来就会产生越来越多的“碎片”</strong>。经过长时间的插入删除插入删除以后，我们就得考虑给数据库做一次收缩，比如通过两次主从表的双向同步，<strong>把所有表数据重新插一遍</strong>。</p><p><strong>我们接下来研究一下——页内查询是怎么做的？</strong></p><h3 id="穿上第三件：Slot槽"><a href="#穿上第三件：Slot槽" class="headerlink" title="穿上第三件：Slot槽"></a>穿上第三件：Slot槽</h3><p><strong>页内的数据是遍历还是二分查找？</strong></p><p>无论数据是物理连续还是逻辑有序，都不能二分查找，都得用遍历的办法。如果我们设计一款数据库，通过索引找到数据在哪个Page里面，要是Page这一层通过遍历的方式，那效率实在是太低了，所以数据库肯定不能这样设计。</p><p>遍历不行，那就使用二分查找吧，提高一下效率。那MySQL是怎么做的呢？看看这张图：</p><p><img src="/../images/mysql-Technology/3b87e950352ac65c1fead4dc4c8ba11892138a30.jpeg" alt="img"></p><p>如图，最小虚记录和最大虚记录之间形成一个链表，这时候Slot区就派上用场了，每个Slot槽指向链表中的某一个位置，每个槽的大小一样，可以理解为一个指针，<strong>这样我们只需要用一个算法把每个子链表的长度拆成差不多大小就行了</strong>。</p><p>在查找的时候，先基于Sn、S0找到指向的最大最小虚记录，在Slot区进行二分：<strong>先找到Sn和S0的中间位置，中间找到某个Slot，然后再一步步进行比较，通过几次二分后找到具体的子链表，最后，在子链表内进行遍历找到最终的记录</strong>。这样我们借助Slot区实现了一个近似二分查找的方法。这特别像Java里面的跳表结构，一次查找跳一次，再一次查找再跳一次，效率就特别高了</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><font color='red'><u><em><strong>什么是索引</strong></em></u></font></p><blockquote><p><font color='green'><strong>官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书 前面的目录，能加快数据库的查询速度。</strong></font></p></blockquote><p><font color='red'><u><em><strong>where a&#x3D;1 and b &gt;1 and c&#x3D;1;</strong></em></u></font></p><blockquote><p>假如创建一个（a,b,c)的联合索引，那么它的索引树是这样的：</p><p><img src="/../images/mysql-Technology/867078-20200703134853993-1354025866.png" alt="img"></p><p><font color='red'><u><em><strong>(a,b,c)联合索引 where a &#x3D; ‘xxx’ b is null c &#x3D; ‘xxx’怎么走索引</strong></em></u></font></p><p>is null是一个比例，可以优化成a&#x3D; c&#x3D; b&#x3D;</p></blockquote><p><font color='red'><u><em><strong>添加索引的原则</strong></em></u></font></p><blockquote><p>1、<font color='green'><strong>对查询频次较⾼。为常作为查询条件、经常需要排序、分组和联合操作的字段建⽴索引</strong></font></p><p><font color='green'><strong>2、数据量较⼤的表创建索引</strong></font></p><p><font color='green'><strong>3、区分度要高</strong></font></p><p><font color='green'><strong>4、限制索引数量</strong></font>：本身需要维护</p><p>5、<font color='green'><strong>利⽤最左前缀</strong></font>：如果索引字段值过⻓，会降低索引的执⾏效率。</p><p><font color='green'><strong>6、尽量联合索引</strong></font>，联合索引的效率⾼于多个独⽴索引。</p></blockquote><p><font color='red'><u><em><strong>索引失效情况；</strong></em></u></font></p><blockquote><p><font color='green'><strong>1、违反最左前缀原则：</strong></font></p><p><font color='green'><strong>2、范围查找右边的会失效</strong></font></p><p><font color='green'><strong>3、在索引列有函数操作，包括显示的函数和隐式的类型转换</strong></font></p><p><font color='green'><strong>4、优化器觉得全局更快，索引也会失效</strong></font></p><p><font color='green'><strong>5、like %在前面</strong></font></p><p><font color='green'><strong>6、or前后没有索引</strong></font></p><p><strong>7、in会导致索引失效吗</strong></p><p>当in的条件命中的数量很少时，是走索引的；但是当in的条件命中的数量超过30%时，索引失效，走全表扫描；</p><p><font color='green'><strong>8、is not null和!&#x3D;会失效</strong></font></p></blockquote><p><strong>mysql优化</strong></p><blockquote><p><font color='red'><u><em><strong>表结构的优化：分库分表、读写分离</strong></em></u></font></p><p><font color='red'><u><em><strong>如果是sql语句的优化：explain命令去分析sql语句，看看能不能优化。主要就是有没有索引和有没有命中索引</strong></em></u></font></p><p><font color='red'><u><em><strong>参数方面：缓冲池的大小，刷盘策略，最大连接数</strong></em></u></font></p></blockquote><p><strong>explain（三个最重要写）</strong></p><blockquote><p><font color='red'><u><em><strong>type字段：</strong></em></u></font></p><p><font color='green'><strong>system：表只有一行记录</strong></font></p><p><font color='green'><strong>const：主键或者唯一索引的等值查询，最多就匹配一次，匹配的条件是常量</strong></font></p><p><font color='green'><strong>eq_ref：也是基于主键和唯一索引，不过匹配的不是常量而是某个表的列，比如主键关联</strong></font></p><p><font color='green'><strong>ref：非主键和非唯一的等值匹配</strong></font></p><p><font color='green'><strong>range：用到了索引，无论是主键、唯一还是普通索引都可以，他是范围查找的</strong></font></p><p><font color='green'><strong>index：它确实跟索引有关但不是通过索引树去查找，而是扫描全索引的叶子节点，其实是另外一种的全部扫描，只不过它扫全部的索引叶子节点，</strong></font></p><p><font color='green'><strong>all：扫描聚集索引（通常是主键索引）的所有叶子节点</strong></font></p><p><strong>Const 和eq_ref 的区别</strong>：<font color='green'><strong>两个都是在用到了主键索引或唯一索引的情况下出现，不同的是Const 的where 条件是常量，eq_ref 的where 条件是其他表的某个列，需要对这个列进行转义才能拿到匹配条件的值，也可以简单的理解为，eq_ref 一般为关联查询。</strong></font></p><p><font color='red'><u><em><strong>possible_keys，key，key_len（重要）</strong></em></u></font></p><p>possible_keys: 可能使用到的索引 。<br>Key: 实际使用的索引。如果为空，则说明没有使用索引。<br>key_len： 使用到的索引key的长度，如果为联合索引则显示已命中的联合索引长度之和（如：联合索引为a+b+c ，如果索引命中了a+b ，那么长度就为a+b的索引长度，通常可以通过key_len 来分析联合索引所命中的情况）。</p><p>关于possible_keys 和key的三种关系场景：<br>1）possible_keys !&#x3D;null&amp;&amp; key!&#x3D;null ，这是正常使用到了索引的情况。<br>2）possible_keys !&#x3D;null&amp;&amp; key&#x3D;&#x3D;null ,这种情况一般说明通过索引并不能提升多少效率，一般而言是表的数据量很少，或者是索引的字段离散性不高，执行计划发现用索引和扫表差不多。<br>3）possible_keys &#x3D;&#x3D;null&amp;&amp; key!&#x3D;null , 这种情况一般为where条件没有命中索引，但是查询的列是索引字段，也就是查询的列命中覆盖索引情况。</p><p><font color='red'><u><em><strong>Extra列（重要）</strong></em></u></font></p><p><font color='red'><u><em><strong>Extra 可以说是对整个SQL做了一个概括性的总结，包括你用了什么索引、排序方式、使用了临时表包含不适合在其他列显示，但是十分重要的信息</strong></em></u></font></p><p><strong>1.Using index</strong>：使用覆盖索引</p><p><strong>2.Using where</strong>：就是一个普通的where语句查询且没有用到索引。</p><p><strong>3.Using index condition</strong>：查询的列不完全被索引覆盖，回表</p></blockquote><p><strong>MySQL为什么有时候会选错索引？</strong></p><blockquote><p>优化器是找到一个最优的方案，以最小的代价去执行。</p><p><font color='green'><strong>1)我们是根据基数来估计行数，那基数是怎么得到的？</strong></font>是通过采样统计。InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了基数。</p><p><font color='green'><strong>2)还有一个问题就是优化器还要判断，执行这个语句本身要扫描多少行，</strong></font></p><p>解决方法？</p><p><font color='green'><strong>1）forceindex</strong></font></p><p><font color='green'><strong>2）修改语句，引导 MySQL 使用我们期望的索引</strong></font></p><p>3）新建索引</p></blockquote><p> <strong>怎么给字符串字段加索引？</strong></p><blockquote><p><font color='green'><strong>1、前缀索引。</strong></font>这里要关注的区分度，就是前缀索引是几个字符的时候区分度较大，又能节省空间，这个可能需要用到count函数去比较一下。</p><p>Ps：用前缀索引就用不上覆盖索引对查询性能的优化了，都要回表</p><p>其他方法？</p><p><font color='green'><strong>2、倒序存储</strong></font></p><p><font color='green'><strong>3、hash</strong></font></p><p>差别在于，空间，查询效率，区间查找</p></blockquote><p><strong>对于函数操作，不管有没有改变有序性，都不走索引。</strong></p><blockquote><p>由于上面这条规则， 所以一些在索引字段上面做隐式转换和隐式编码转换，也不走索引。P：在mysql里面字符串和数字的隐式转换是<font color='red'><u><em><strong>字符串转成数字</strong></em></u></font>，字符编码从少的往多的转。</p></blockquote><p><strong>超大分页优化</strong></p><blockquote><p><font color='red'><u>**子查询+ 覆盖索引 + where 语句 **</u></font></p><p>先通过覆盖索引得到id，然后对id排序，那这个id和原来的表做关联查询</p></blockquote><p>innodb最常见的索引就是：</p><p><font color='red'><u><em><strong>b+树索引 （b+树只能找到数据行所在的页，然后把页读到内存里面，进行查找）</strong></em></u></font></p><p><font color='red'><u><em><strong>哈希索引（自动生成）</strong></em></u></font></p><p><font color='red'><u><em><strong>全文索引</strong></em></u></font></p><h2 id="1、B-树索引"><a href="#1、B-树索引" class="headerlink" title="1、B+树索引"></a>1、B+树索引</h2><p><font color='red'><u><em><strong>为什么不用b树?</strong></em></u></font></p><p><font color='green'><strong>b树的非叶子节点会保存数据，b+树不会，所以b树能保存的指针就好了，这样树的高度就会变大。</strong></font></p><p><font color='red'><u><em><strong>为什么不用红黑树?</strong></em></u></font></p><p><font color='green'><strong>红黑树是一个二叉树，这个高度肯定是不如b+树这样的多叉树，然后我们时间消耗上，就是这个磁盘io很关键。</strong></font></p><blockquote><p>b+树是为了磁盘或其他直接存取辅助设备设计的一种多叉平衡查找树</p><p>b+树的所有记录结点都是按照键值的大小顺序存放到同一层的叶子结点，他们之间通过叶子结点指针进行连接，中间的都是searchkey</p></blockquote><p><font color='red'><u><em><strong>为什么不用跳表？</strong></em></u></font></p><p><font color='green'><strong>b+树一个节点是一个page，每个节点16k，这样能放很多的索引，他的层高比较低，查询次数少，就减少了磁盘io的操作。跳表式链表结构，一个数据一个基点，这样层数会比较高，io性能就比较低。举个例子，b+树三层就可以存储2kw的数据，存储2kw&#x3D;2^24的数据需要24层，这个差距还是很大的。</strong></font></p><h3 id="1、操作"><a href="#1、操作" class="headerlink" title="1、操作"></a>1、操作</h3><h4 id="1、插入"><a href="#1、插入" class="headerlink" title="1、插入"></a>1、插入</h4><p><img src="/../images/mysql-Technology/image-20231005201534270.png" alt="image-20231005201534270"></p><h4 id="2、旋转"><a href="#2、旋转" class="headerlink" title="2、旋转"></a>2、旋转</h4><p>旋转发生在leaf page已经满了，但是左右兄弟还没有满，这时候会把记录平移到兄弟结点上面，左兄弟优先</p><h4 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h4><p><img src="/../images/mysql-Technology/image-20231005202324173.png" alt="image-20231005202324173"></p><h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><p>b+树可以分成聚集索引、辅助索引，这两个到区别就是叶子结点放的到底是不是一行信息</p><h4 id="1、聚集索引"><a href="#1、聚集索引" class="headerlink" title="1、聚集索引"></a>1、聚集索引</h4><blockquote><p><font color='red'><u><em><strong>聚集索引就是按照主键构造的索引b+树，所以叶子结点存放的就是整张表的数据</strong></em></u></font>，叶子结点也叫做数据页。非叶子结点的索引页存放的仅仅是键值和指向数据页的偏移量。</p><p>选取规则：主键 -》唯一-》rowid</p></blockquote><h4 id="2、辅助索引"><a href="#2、辅助索引" class="headerlink" title="2、辅助索引"></a>2、辅助索引</h4><blockquote><p><font color='red'><u><em><strong>辅助索引的叶子结点不包含行记录的全部数据。叶子结点包含键值和书签，书签用来告诉引擎哪里能找到真正的行数据。</strong></em></u></font>由于innodb是索引组织表，所以辅助索引的书签就是行记录的聚集索引键。所以辅助索引就是包含了索引那列的值和主键的值。</p></blockquote><h3 id="3、B-树索引的管理"><a href="#3、B-树索引的管理" class="headerlink" title="3、B+树索引的管理"></a>3、B+树索引的管理</h3><blockquote><h4 id="1、索引管理"><a href="#1、索引管理" class="headerlink" title="1、索引管理"></a>1、索引管理</h4><p>创建和删除可以通过两种方法。一种是alter table。另一种是create&#x2F;drop index。</p><p>查看：show index from XX</p><h4 id="4、Online-DDL"><a href="#4、Online-DDL" class="headerlink" title="4、Online DDL"></a><font color='red'><u><em><strong>4、Online DDL</strong></em></u></font></h4><p>允许在辅助索引创建的同时，还允许insert update等DML操作</p><p>有三种算法：</p><p>copy：<font color='green'><strong>需要临时表，</strong></font>执行insert update delete这些操作的时候，<font color='red'><u><em><strong>先把操作日志写入一个缓存里面，然后，索引建立后重做表上面</strong></em></u></font></p><p>replace ：replace就是<font color='green'><strong>不需要临时表。</strong></font></p><p>instant ：<font color='green'><strong>直接对元数据进行修改</strong></font>，无需拷贝数据也无需重建整表</p><h4 id="5、cardinality值"><a href="#5、cardinality值" class="headerlink" title="5、cardinality值"></a><font color='red'><u><em><strong>5、cardinality值</strong></em></u></font></h4><p>他是一个统计信息，优化器会根据这个值来判断我们用不用索引，表示索引中唯一值的数据的估计值，如果是性别这种，重复的非常多，我们叫低选择性，不适合做索引。反之高选择性就比较适合，尤其是在高选择性属性字段里面取出一小部分数据，那就更有必要了。</p><ul><li><strong>统计的方式</strong>？</li></ul><p>所以我们用的是<font color='red'><u><em><strong>采样</strong></em></u></font>的方法（<font color='red'><u><em><strong>（对8或20个叶子结点进行采样预估，取出平均值）</strong></em></u></font>）。cardinality值的<font color='red'><u><em><strong>更新</strong></em></u></font>发生在insert和update操作，但是肯定不是每一次inser tupdate都去更新，具体策略如下：</p><p>1、表中1&#x2F;16数据发生了变化</p><p>2、计数器超过20亿</p></blockquote><h3 id="4、B-树索引的使用"><a href="#4、B-树索引的使用" class="headerlink" title="4、B+树索引的使用"></a>4、B+树索引的使用</h3><blockquote><h4 id="1、联合索引"><a href="#1、联合索引" class="headerlink" title="1、联合索引"></a>1、联合索引</h4><p>本质也是一颗二叉树，之前是a,b,c,d现在是（a,b）(c,d)</p><p>第一个好处：对于联合查询和单列的第一列的查询都可以用联合查询</p><p>第二个好处：一句对第二个键值进行了排序处理，可以缩短某些情况的查询时间</p><h4 id="2、覆盖索引"><a href="#2、覆盖索引" class="headerlink" title="2、覆盖索引"></a>2、覆盖索引</h4><p>覆盖索引的意思是，从辅助索引中就直接可以得到想要查询的记录，不需要回表。</p><p>第一个好处是：辅助索引本身不包括整行记录，所以大小远小于聚集索引，减少io操作</p><p>第二个好处是：对于某些统计问题，存储引擎并不会通过聚集索引，辅助索引远远小于聚集索引，</p><h4 id="4、MRR优化（多范围读取、只支持非聚集索引）（离散读变成顺序读）"><a href="#4、MRR优化（多范围读取、只支持非聚集索引）（离散读变成顺序读）" class="headerlink" title="4、MRR优化（多范围读取、只支持非聚集索引）（离散读变成顺序读）"></a>4、MRR优化（多范围读取、只支持非聚集索引）<font color='red'><u><em><strong>（离散读变成顺序读）</strong></em></u></font></h4><p>工作方式：</p><ul><li>把辅助索引读出来放到一个缓存里面</li><li>把缓存中根据rowid进行排序</li><li>然后根据rowid去找数据</li></ul><p>他适用于某些范围查找，</p><p>而且还可以对某些范围查找进行拆分，变成成键值对的等值查找。直接就过滤了一些不符合条件的数据。</p><p>好处：</p><ul><li>数据访问更加顺序，</li><li>减少缓冲池页的替换</li></ul><h4 id="5、索引下推ICP优化（只支持非聚集索引）"><a href="#5、索引下推ICP优化（只支持非聚集索引）" class="headerlink" title="5、索引下推ICP优化（只支持非聚集索引）"></a>5、索引下推ICP优化（只支持非聚集索引）</h4><p>原本我们通过索引进行查询的时候，首先根据索引查找记录，然后根据where条件过滤记录。ICP是在取出索引的同时，判断是否可以进行where条件的过滤，也就是讲where的部分过滤操作放到了存储引擎层。<font color='red'><u><em><strong>联合索引</strong></em></u></font></p><p>场景：</p><p>假设表TB1上有索引IDX_C1_C2_C3(C1,C2,C3)，对于查询SELECT * FROM TB1 WHERE C1&#x3D;’XXX’ AND C3&#x3D;’XXX’</p><p>在MySQL 5.6版本以前，由于缺少C2的过滤条件，Innodb存储引擎层只能使用索引IDX_C1_C2_C3按照C1&#x3D;’XXX’条件找出所有满足条件的索引记录，再根据这些索引记录去聚集索引中查找，将找到的表数据返回给MySQL Server层，然后由MySQL Server层使用C3&#x3D;’XXX’条件进行过滤得到最终结果。</p><p>假设满足C1&#x3D;’XXX’条件的数据行为100000条，而满足C1&#x3D;’XXX’ AND C3&#x3D;’XXX’的数据行为100条，则：</p><p>1、回表100000次，给server层传100000条数据</p><p>2、回表100次，Innodb存储引擎层向MySQL Server层传递100行数据。</p><h4 id="6、索引合并"><a href="#6、索引合并" class="headerlink" title="6、索引合并"></a>6、索引合并</h4><p>•Using intersect：使用交集算法，当查询条件使用AND连接时，系统可能会使用多个索引分<br>别检素每个条件，然后找出所有索引结果的交集。<br>•Using union：使用井集算法，当查询条件使用OR连接时，每个条件可能利用不同的索引。<br>系统会分别查找每个索引，然后合并结果。<br>•Using sort union：使用排序联合算法，在需要对结果进行排序的查询中，如果不同的排序<br>条件各自有索引，系统可以先分别检泰每个索引，然后合并并排序这些结果。</p></blockquote><h3 id="5、自适应哈希索引"><a href="#5、自适应哈希索引" class="headerlink" title="5、自适应哈希索引"></a>5、自适应哈希索引</h3><p>InnoDB中的哈希用的字典进行查找，冲突用链表解决，哈希函数用除法散列</p><p>自适应哈希索引就是用的这种方法。</p><h3 id="6、全文检索"><a href="#6、全文检索" class="headerlink" title="6、全文检索"></a>6、全文检索</h3><blockquote><p>全文检索一般使用倒排索引。</p><h5 id="1、倒排索引"><a href="#1、倒排索引" class="headerlink" title="1、倒排索引"></a>1、倒排索引</h5><p>它在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关键数组实现，其拥有两种表现形式：<br>inverted file index：其表现形式为{单词，单词所在文档的ID}<br>full inverted index：其表现形式为{单词，(单词所在文档的ID，在文档中的具体位置)}</p><h5 id="2、InnoDB全文检索的实现"><a href="#2、InnoDB全文检索的实现" class="headerlink" title="2、InnoDB全文检索的实现"></a>2、InnoDB全文检索的实现</h5><p><font color='red'><u><strong>InnoDB全文索引有3个非常重要的东西，一个是辅助表，一个是FTS Index Cache、一个是FTS DOUCUMENT id</strong></u></font></p><h6 id="1、Auxiliary-Table（辅助表）"><a href="#1、Auxiliary-Table（辅助表）" class="headerlink" title="1、Auxiliary Table（辅助表）"></a><strong>1、Auxiliary Table（辅助表）</strong></h6><p><font color='red'><u><em><strong>辅助表是把文档，分词然后规范化后的结果，</strong></em></u></font></p><p><font color='red'><u><em><strong>辅助表的话采用“full inverted index”的方式有两个列：</strong></em></u></font></p><p><font color='red'><u><em><strong>一个是word字段。在word字段上有设有索引，另一个是ilist字段，（DocumentId,Position）</strong></em></u></font></p><h6 id="2、FTS-INDEX-Cache（全文检索缓存）"><a href="#2、FTS-INDEX-Cache（全文检索缓存）" class="headerlink" title="2、FTS INDEX Cache（全文检索缓存）"></a><strong>2、FTS INDEX Cache（全文检索缓存）</strong></h6><p>他是一个红黑树的结构：<font color='red'><u><em><strong>我执行插入操作，插入的数据已经更新了对应的表，但是我们的辅助表可能还没更新，这个更新还停留在FTS cache里面</strong></em></u></font>。如果没插一次就更新这是不合理的，那具体同步到辅助表的时机：</p><p>1、在我进行全文检索查询的时候，我把FTS INDEX cache里的word字段合并到辅助表，然后查询。有点类似于insert buffer</p><p>2、数据库关闭的时候会同步</p><p>3、cache满了</p><p>数据库宕机时：一些FTS InDEX Cache中的数据库可能未被同步到磁盘上。那么下次重启时，当用户对表进行全文检索（查询或者插入操作）时，InnoDB会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入到FTS Index Cache中</p><p>对于InnoDB来说，其总是在事务提交时将分词写入到FTS Index Cache。</p><h6 id="3、FTS-DOUCUMENT-ID"><a href="#3、FTS-DOUCUMENT-ID" class="headerlink" title="3、FTS DOUCUMENT ID"></a>3、FTS DOUCUMENT ID</h6><p><font color='red'><u><em><strong>为了支持全文检索，我们每一行数据必须有一个列与word进行映射：</strong></em></u></font></p><ul><li>在InnoDB中这个列<strong>被命名为FTS_DOC_ID</strong>，他是自动创建的</li><li>其<strong>类型必须是</strong>bigint unsigned not null</li><li>并且InnoDB自动会在该列上加入一个<strong>名为FTS_DOC_ID_INDEX的unique index索引</strong></li><li><strong>用户也可以在建表时自动添加FTS_DOC_ID，以及相应的Unique Index</strong></li></ul><p>Deleted auxiliary table<br>文档中分词的插入操作是在事务提交时完成的，然而对于删除操作，其在事务提交时不删除磁盘Auxiliary Table中的记录，而只是删除FTS Index Cache中的记录。对于Auxiliary Table中被删除的记录，InnoDB会记录其FTS Document ID，并将其保存在Deleted auxiliary table中</p><p>由于文档的DML操作实际并不删除索引中的数据，相反还会在对应的DELETED表中插入记录，因此随着应用程序的允许，索引会变得非常大，即使索引列中的有些数据已经被删除，查询也不会使用到。为了，InnoDB存储引擎提供了一种方式，允许用户手动地将已删除的记录从索引中彻底删除，该命令就是OPTIMIZE TABLE</p></blockquote><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁机制是用于管理对共享资源的并发访问，保证数据的完整性和一致性。</p><h2 id="1、锁的类型"><a href="#1、锁的类型" class="headerlink" title="1、锁的类型"></a>1、锁的类型</h2><h3 id="1、全局锁"><a href="#1、全局锁" class="headerlink" title="1、全局锁"></a>1、全局锁</h3><blockquote><p><font color='red'><u><em><strong>典型的使用场景就是做全库的逻辑备份</strong></em></u></font></p><ul><li>一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态</li></ul><p><font color='red'><u><em><strong>两种方法<br>flush tables with read lock;<br>mysqldump -single-tranctions<br>single-transaction只适用于支持事务引擎的库，如果支持的话建议用single-transactions，否则用flush table with read lock</strong></em></u></font></p></blockquote><h3 id="2、表级锁"><a href="#2、表级锁" class="headerlink" title="2、表级锁"></a>2、表级锁</h3><blockquote><p>表级锁，主要分为4类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li><li>自增锁</li></ul></blockquote><h4 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h4><p>表锁就是对表加锁，分读锁和写锁，读琐和读锁是兼容，读锁和写锁、写锁和写锁是不兼容的。</p><h4 id="2、元数据锁"><a href="#2、元数据锁" class="headerlink" title="2、元数据锁"></a>2、元数据锁</h4><blockquote><p>再来说说<strong>元数据锁</strong>（MDL）,<font color='red'><u><em><strong>它 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。我们不需要显示的使用 MDL，会自动给这个表加上 MDL：</strong></em></u></font></p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul></blockquote><blockquote><p>MDL 不需要显示调用，那它是在什么时候释放的?</p></blockquote><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><h4 id="3、意向锁"><a href="#3、意向锁" class="headerlink" title="3、意向锁"></a>3、意向锁</h4><blockquote><p><font color='red'><u><strong>我觉得意向锁主要还是解决行锁和表锁之间的冲突问题</strong></u></font></p><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul></blockquote><p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加行级独占锁。</p><p><img src="/../images/mysql-Technology/20e0f35589584352bd15e817668a0886.png" alt="img"></p><p><img src="/../images/mysql-Technology/6e6b275c2d6d4dfcbbb338be4f61bee9.png" alt="img"></p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><h4 id="4、自增锁"><a href="#4、自增锁" class="headerlink" title="4、自增锁"></a>4、自增锁</h4><blockquote><p><font color='red'><u><em><strong>主键设置成自增之后，会自动给主键赋递增的值，5.7保存在内存里面，但是8.0以后保存在redo log里面</strong></em></u></font></p><p>然后这里有两种方式。一种是，AUTO-INC 锁<strong>，</strong>不是一个事务提交后才释放，而是在<font color='red'><u><em><strong>执行完插入语句后就会立即释放。</strong></em></u></font></p><p>后面提供了一种轻量级锁，<font color='red'><u><em><strong>申请完就释放</strong></em></u></font>，但是伴随着两个问题：1、自增主键不是连续的。2、主库和从库不一致。</p><p><font color='red'><u><em><strong>自增逐渐不连续的原因：唯一键的冲突、事务回滚、批量插入</strong></em></u></font></p><p><font color='red'><u><em><strong>主库存库不一致的原因：批量插入</strong></em></u></font></p><p>所以后面InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>，并且提供了一个参数，叫innodb autoinc lock mode</p><ul><li>当 innodb_autoinc_lock_mode &#x3D; 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li><li>当 innodb_autoinc_lock_mode &#x3D; 2，就采用轻量级锁，<font color='green'><u><em><strong>申请自增主键后就释放锁</strong></em></u></font>，并不需要等语句执行后才释放。</li><li>当 innodb_autoinc_lock_mode &#x3D; 1：</li><li>普通 insert 语句，自增锁在申请之后就马上释放；</li><li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放<font color='red'><u><em><strong>（因为“不知道要预先申请多少个 id）</strong></em></u></font></li><li>原因如下：</li></ul><p>session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后<strong>两个 session 同时执行向表 t2 中插入数据</strong>。</p><p>如果 innodb_autoinc_lock_mode &#x3D; 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：</p><ul><li>session B 先插入了两个记录，(1,1,1)、(2,2,2)；</li><li>然后，session A 来申请自增 id 得到 id&#x3D;3，插入了（3,5,5)；</li><li>之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</li></ul><p>可以看到，<strong>session B 的 insert 语句，生成的 id 不连续</strong>。</p><p>当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format&#x3D;statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。</p><p>但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在<strong>从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致</strong>。</p><p>要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。</p><p>所以，<strong>当 innodb_autoinc_lock_mode &#x3D; 2 时，并且 binlog_format &#x3D; row，既能提升并发性，又不会出现数据一致性问题</strong>。</p></blockquote><h3 id="3、行锁【事务提交回滚的时候释放】"><a href="#3、行锁【事务提交回滚的时候释放】" class="headerlink" title="3、行锁【事务提交回滚的时候释放】"></a>3、行锁【事务提交回滚的时候释放】</h3><blockquote><p><strong>MySQL 的行锁是在引擎层由各个引擎自己实现的。</strong></p></blockquote><blockquote><p><font color='red'><u><em><strong>InnoDB有三种行锁的算法：Record Lock：记录锁、Gap Lock：间隙锁，锁定一个范围，但不包括记录本身，Next-Key Lock（临建锁）：Record Lock + Gap Lock 左开右闭</strong></em></u></font></p><p><font color='red'><u><em><strong>InnoDB就是用Next-Key去解决幻读问题（同一事务下，连续执行两次相同的sql语句，两次得到的数据数量不是一样的）间隙锁在可重复读才生效</strong></em></u></font></p><p>加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。 </p><ol><li>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭 区间。 </li><li>原则 2：查找过程中访问到的对象才会加锁。 </li><li><font color='green'><strong>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为记录锁。</strong></font> </li><li><font color='green'>**优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，nextkey lock 退化为间隙锁。 **</font></li><li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol></blockquote><blockquote><blockquote></blockquote></blockquote><blockquote><p><strong>两阶段锁协议</strong>：</p><blockquote><p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</strong></p></blockquote><blockquote><p><img src="/../images/mysql-Technology/image-20230805221422216.png" alt="image-20230805221422216"></p></blockquote><h2 id="2、一致性非锁定读（快照读）"><a href="#2、一致性非锁定读（快照读）" class="headerlink" title="2、一致性非锁定读（快照读）"></a>2、一致性非锁定读（快照读）</h2><p>一致性非锁定读是指InnoDb通过多版本控制（MVCC）的方式读一个我能看到的数据。</p><p><font color='green'><strong>所以我们要讲一下这个MVCC，他这个就依赖于undolog版本链和readView。</strong></font></p><p>首先，每一行数据其实都有两个隐藏列，一个是trxid一个是rollpointer，trxid 表示最新修改事务的id，rollpointer表示指向旧版本undo log</p><p>我们修改的数据的时候，我们把该行数据拷贝到 <code>undo log</code>作为旧版本。进行真正的修改操作，同时修改trxid 和roll_pointer，这样就形成了一个版本链条，那至于我们能看到哪个版本的就依赖于readview</p><p>ReadView，里面有四个比较关键的东西：</p><p>一个是m_ids，这个就是说事务开启那一刻有哪些事务在Mysql里面执行还没有提交的；</p><p>一个是min_trx_id，就是m_ids里最小的事务id的值；</p><p>一个是max_trx_id，就是此刻mysql下一个要生成的事务id，就是最大事务id；</p><p>一个是creator_trx_id，就是你这个事务的id。</p><p><font color='red'><u><em><strong>如果比mintexid小或者等于creatoridexid，我们可以看得见。</strong></em></u></font></p><p>比如一条记录旧版本里面有三条记录：10，20，30。然后我们的事务id是15，m_ids里面有20，30。这里的min_trx_id就是20，我们的15比她小，说明还没有提交。因为隔离性所以肯定是看不到的，然后再去找更前面版本，我们就找到了10，发现10可以，所以我们这次读到的数据就是事务id为10的那一个版本。</p><h2 id="3、一致性锁定读（当前读）"><a href="#3、一致性锁定读（当前读）" class="headerlink" title="3、一致性锁定读（当前读）"></a>3、一致性锁定读（当前读）</h2><p>有时候用户需要些显式的对读操作进行加锁保证一致性。 <font color='red'><u><em><strong>select for share mode， for update还有update也是当前读</strong></em></u></font></p></blockquote><blockquote><h2 id="5、锁问题（并发事务带来的问题）"><a href="#5、锁问题（并发事务带来的问题）" class="headerlink" title="5、锁问题（并发事务带来的问题）"></a>5、锁问题（并发事务带来的问题）</h2><p><img src="/../images/CS:mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115193544143.png" alt="image-20231115193544143"></p><h3 id="1、脏读-or-不可重复读-or-幻读"><a href="#1、脏读-or-不可重复读-or-幻读" class="headerlink" title="1、脏读 or 不可重复读 or 幻读"></a>1、脏读 or 不可重复读 or 幻读</h3><p>脏读：<font color='blue'><u><em><strong>读到了其他事务没有提交的数据</strong></em></u></font></p><p>不可重复读：<font color='blue'><u><em><strong>两次读，读的数据值不一样。readview是每一次读生成一次的。</strong></em></u></font></p><p>幻读：<font color='blue'><u><em><strong>一个事务在前后两次同样的查询，查到的数据数量不一样。</strong></em></u></font></p><h2 id="2、怎么解决"><a href="#2、怎么解决" class="headerlink" title="2、怎么解决"></a>2、怎么解决</h2><p>解决脏读：<font color='red'><u><em><strong>MVCC</strong></em></u></font></p><p>解决不可重复读：<font color='red'><u><em><strong>MVCC+只用一个readview</strong></em></u></font></p><p>解决幻读innoDB的解决方法：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决不可重复度和幻读</strong></li><li>针对<strong>当前读</strong>（select … for update 等语句），是<font color='red'><u><em><strong>通过 next-key lock（记录锁+间隙锁）（前开后闭区间）</strong></em></u></font><strong>方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li><li><font color='green'><strong>行锁是加在索引上的</strong></font></li></ul><p><font color='red'><u><em><strong>但是幻读没有完全避免：因为readview可以看到自己修改的undolog，A先读id为5，发现没有。B增加一条记录id &#x3D; 5。A修改ID为5，update是当前读所以能看到，修改完A再读一次就有了。</strong></em></u></font></p><h3 id="3、丢失更新"><a href="#3、丢失更新" class="headerlink" title="3、丢失更新"></a>3、丢失更新</h3><p>是指一个事务的操作被另一个事务的操作覆盖了，但是当前数据库的任何隔离级别都对行或者粗粒度的对象加锁，所以还是比较难发生。</p></blockquote><h2 id="6、死锁"><a href="#6、死锁" class="headerlink" title="6、死锁"></a>6、死锁</h2><p>死锁是指两个或以上的事务争夺资源造成的一种互相等待的现象</p><blockquote><p><font color='blue'><u><em><strong>互斥条件</strong></em></u></font></p><p><font color='blue'><u><em><strong>请求和保持条件</strong></em></u></font></p><p><font color='blue'><u><em><strong>不可剥夺条件</strong></em></u></font></p><p><font color='blue'><u><em><strong>循环等待条件</strong></em></u></font></p><p>解决方法：</p><p>死锁的检测：JSTACK。</p><p><font color='green'><strong>预防死锁：破坏这四个条件</strong></font></p><p><font color='green'><strong>解除死锁：资源剥夺、撤销进程、进程回退。</strong></font></p></blockquote><h2 id="7、锁升级"><a href="#7、锁升级" class="headerlink" title="7、锁升级"></a>7、锁升级</h2><p>会出现从行锁升级到表锁的情况吗？</p><p><font color='red'><u><em><strong>不会，innodb的目的是高并发盒高性能，如果用表锁，会导致出现更多的事务等待现象，这不是我们想看到的。</strong></em></u></font></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="1、认识事务"><a href="#1、认识事务" class="headerlink" title="1、认识事务"></a>1、认识事务</h2><p><font color='red'><u><em><strong>什么是事务：多条sql语句，要么成功，要么失败</strong></em></u></font></p><h3 id="1、四个特性：acid。"><a href="#1、四个特性：acid。" class="headerlink" title="1、四个特性：acid。"></a>1、四个特性：acid。</h3><p><font color='green'><strong>原子性：要么成功要么失败</strong></font></p><p><font color='green'><strong>一致性：讲数据库从一种状态转变为下一种一致的状态，完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</strong></font></p><p><font color='green'><strong>隔离性Isolation：一个事务提交之前对其他事务不可见</strong></font></p><p><font color='green'><strong>Durability：一旦提交，那么结果是永久性的</strong></font></p><p>可以举个例子：就是转账。</p><h2 id="2、事务的实现"><a href="#2、事务的实现" class="headerlink" title="2、事务的实现"></a>2、事务的实现</h2><p>事务的隔离性由锁机制来实现。</p><p>原子性、一致性、持久性通过redo log和undo log完成</p><p>redo log保证持久性</p><p>undo log保证事务的原子性，一致性</p><h3 id="1、redo-log"><a href="#1、redo-log" class="headerlink" title="1、redo log"></a>1、redo log</h3><p><font color='red'><u><em><strong>它为了防止断电导致数据丢失的问题</strong></em></u></font>，<font color='red'><u><em><strong>当有一条更新操作的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，InnoDB 引擎会在适当的时候，在 Buffer Pool 的脏页刷新到磁盘里</strong></em></u></font>。这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p><p><font color='red'><u><em><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。</strong></em></u></font></p><p>主要有下面几个时机：</p><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。</li></ul><p>由参数 <code>innodb_flush_log_at_trx_commit</code> 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：</p><ul><li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li><li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li><li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看<a href="https://xiaolincoding.com/os/6_file_system/pagecache.html">这篇 (opens new window)</a>），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li></ul><p>事务提交的时候必须把事务的所有日志写入重做日志文件进行持久化。这个的所有日志包括redo log 和undo log</p><p><img src="/../images/mysql-Technology/image-20231007131604938.png" alt="image-20231007131604938"></p><p><img src="/../images/mysql-Technology/image-20231007131752781.png" alt="image-20231007131752781"></p><p><img src="/../images/mysql-Technology/image-20231007131726290.png" alt="image-20231007131726290"></p><h3 id="2、undo-log"><a href="#2、undo-log" class="headerlink" title="2、undo log"></a>2、undo log</h3><blockquote><p>undo log最主要的作用有两点：<font color='red'><u><em><strong>一个是事务回滚，保证原子性；还有一个是支持mvcc</strong></em></u></font></p><p>那我们先讲第一个，就是事务提交之前，如果发生意外，这时候你用redolog是没有办法恢复的，所以我们可以使用undolog，因为undolog他记录的是修改前的记录。</p><p>另外一个大的作用是mvcc，mvcc他是基于undo log版本链和ReadView实现</p><p>首先，每一行数据其实都有两个隐藏列，一个是trxid一个是rollpointer，trxid 表示最新修改事务的id，rollpointer表示指向旧版本log</p><p>undolog版本链形成的原因是，我们修改的数据的时候，我们把该行数据拷贝到 <code>undo log</code>作为旧版本。进行真正的修改操作，同时修改trxid 和roll_pointer。</p><p>ReadView，里面有四个比较关键的东西：</p><p>一个是m_ids，这个就是说事务开启那一刻有哪些事务在Mysql里面执行还没有提交的；</p><p>一个是min_trx_id，就是m_ids里最小的事务id的值；</p><p>一个是max_trx_id，就是此刻mysql下一个要生成的事务id，就是最大事务id；</p><p>一个是creator_trx_id，就是你这个事务的id。</p><p><font color='red'><u><em><strong>如果比mintexid小或者等于creatoridexid，我们可以看得见。</strong></em></u></font></p><p>比如一条记录旧版本里面有三条记录：10，20，30。然后我们的事务id是15，m_ids里面有20，30。这里的min_trx_id就是20，我们的15比她小，说明还没有提交。因为隔离性所以肯定是看不到的，然后再去找更前面版本，我们就找到了10，发现10可以，所以我们这次读到的数据就是事务id为10的那一个版本。</p></blockquote><p>rr：事务第一次读的时候创建readview</p><p>rc：每次查询都会创建一个readview</p><p>mvcc是快照读，update是当前读，但是要注意两阶段锁协议</p><h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><p><img src="/../images/mysql-Technology/image-20231115220333308.png" alt="image-20231115220333308"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-JVM</title>
      <link href="/2023/11/04/%E5%85%AB%E8%82%A1-JVM/"/>
      <url>/2023/11/04/%E5%85%AB%E8%82%A1-JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="1、JVM内存结构"><a href="#1、JVM内存结构" class="headerlink" title="1、JVM内存结构"></a>1、JVM内存结构</h1><p>主要有五大部分：程序计数器（私有）、虚拟机栈（私有）、本地方法栈（私有）、堆（公有）、方法区（公有），不过在8之后，永久代就已经被元空间代替了，而元空间在本地内存。</p><p><img src="/../images/JVM/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）"></p><p>1、程序计数器</p><blockquote><p><font color='red'><u><em><strong>存储当前指令执行的地址</strong></em></u></font>，线程恢复都靠这个。</p></blockquote><p>2、虚拟机栈</p><blockquote><p>每个方法调用的时候都会生成一个栈帧，栈帧里面存储了<font color='red'><u><em><strong>局部变量表，操作数栈、动态连接、方法出口</strong></em></u></font>等。</p><p>局部变量表里面放了<font color='red'><u><em><strong>方法参数、方法内部定义的局部变量</strong></em></u></font>。包括各类基本数据类型、对象引用(reference) ，以及returnAddress类型。</p><p>对象引用要完成两件事情：找到在JVM堆里面的对象，还有一个是找到元空间存储的类型信息。</p><p><font color='red'><u><strong>操作数栈：同时作为计算过程中变量临时的存储空间</strong></u></font></p><p><font color='red'><u><strong>动态连接：指向运行时常量池中该栈帧所属方法的引用，为了支持方法调用过程中的动态链接（Dynamic Linking）</strong></u></font></p><p>方法出口：<font color='green'><u><em><strong>方法执行完去哪里</strong></em></u></font></p></blockquote><p>3、本地方法栈</p><blockquote><p>和虚拟机栈很像，区别是为了虚拟机使用本地native方法服务的。</p></blockquote><p>4、堆</p><blockquote><p>线程共享的，存放对象实例都在这里。这里有一块是字符串常量池，存的是String实例的引用。</p><p>虽然在g1 zgc垃圾回收器有了被分成了region，但是依旧保留着年轻代和老年代的思想。</p><p>他被分成年轻代和老年代，年轻代有分成伊甸区和幸存者区。垃圾回收的时候先扫伊甸区和一个幸存者区，存活的对象放到另一个幸存者区。</p><p>然后还有一点需要提的是：1.7中的堆有方法区，或者说永久代。但是到了1.8，方法区转移到了直接内存里面变成了元空间。</p></blockquote><p>5、方法区</p><blockquote><p>存储被虚拟机加载的类信息。</p><p><font color='red'><u><em><strong>运行时常量池：</strong></em></u></font></p><p>Class文件除了类的版本字段方法接口描述外，还有一个常量池，用于存放编译期间生成的字面量和符号引用，而当类加载到内存中后，jvm把符号引用换成直接引用，将class常量池中的内容存放到运行时常量池中。</p><p><font color='red'><u><em><strong>符号引用就是：接口、类、字段、方法简单名称和描述符【解析那里】</strong></em></u></font></p><p><font color='red'><u><em><strong>直接引用：直接指向目标的指针、偏移量、句柄</strong></em></u></font></p><p>例如，<code>test()</code>这个符号引用在运行时就会被转变为<code>test()</code>方法具体代码在内存中的地址，主要通过对象头里的类型指针去转换直接引用。Person preson &#x3D; new Person（）。类型指针就是从person找到Person.class</p></blockquote><p><img src="/../images/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0MDA1,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><strong>对象的创建</strong></p><blockquote><p><font color='green'><strong>1、当遇到new，先去检查在常量池找到类的符号引用，检查是不是已经类加载、解析、初始化。</strong></font></p><p><font color='green'><strong>2、如果没有，就先执行类加载。</strong></font></p><p>3、然后分配内存，内存的大小在类加载的时候就确认了。具体分配用“指针碰撞”还是“空闲列表”就看用那种垃圾收集器。为了保证不出现并发问题：有两种方案。<font color='red'><u><em><strong>1）CAS+失败重试。2）给线程自己预先分配本地线程分配缓冲。（TLAB）</strong></em></u></font></p></blockquote><p><strong>对象的内存布局</strong></p><blockquote><p>每一个对象在堆里面分为三块：<font color='red'><u><em><strong>对象头、实例数据、对其填充。</strong></em></u></font></p><p>对象头是<font color='red'><u><em><strong>markword+类型指针+数组长度（如果是数组的话），</strong></em></u></font></p><ul><li>markword就是记录哈希码、gc分代（<font color='red'><u><em><strong>4位，所以年龄设置为15</strong></em></u></font>）、锁标志、锁id，偏向锁。</li><li>类型指针就是指向类型元数据的指针</li></ul><p>实例数据：</p><p>对象真正存储的有效信息。无论是父类继承的还是子类</p><p>对其填充：</p><p>HotSpot要求对象的起始地址是8字节的整数倍。</p></blockquote><p><strong>对象的访问定位</strong></p><p>1、句柄方法。reference放的是存储的是句柄地址，句柄包含对象实例数据和类型数据，各自的具体位置。句柄最大的优势就是即使在垃圾收集的时候对象被移动了，只用修改句柄中的指针就好，不用修改reference。</p><p>2、直接指针。存储的就是对象地址。他的优势是少一次间接访问的消耗。</p><h1 id="2、内存溢出异常"><a href="#2、内存溢出异常" class="headerlink" title="2、内存溢出异常"></a>2、内存溢出异常</h1><blockquote><p><font color='red'><u><em><strong>除了程序计数器，其他区域都有OOM的可能。</strong></em></u></font></p><p><font color='green'><u><em><strong>堆是最常见的</strong></em></u></font></p><p><font color='green'><u><em><strong>虚拟机栈和本地方法栈（-Xss），在HotSpot虚拟机里面，无论你是栈太深还是说栈容量太小了，都会报stackoverflow错误</strong></em></u></font></p><p><font color='green'><u><em><strong>方法区，运行时常量池溢出</strong></em></u></font></p></blockquote><h1 id="3、字节码文件"><a href="#3、字节码文件" class="headerlink" title="3、字节码文件"></a>3、字节码文件</h1><ul><li><p>魔数：唯一的作用就是确定这个文件是否为一个虚拟机可以接受的Class文件</p></li><li><p>次版本号</p></li><li><p>主版本号</p></li><li><p>常量池：第一个表类型的数据</p><ul><li>主要存放两大类常量：字面量和符号引用。比如包名、类名、接口名、方法名、变量名等等，但是Class常量池中他就是一个符号，需要在类加载的时候翻译成具体的内存地址。</li></ul></li><li><p>访问标志：有16个标志位，是类还是接口、是否public 是否abstract 是否final</p></li><li><p>类索引、父类索引、接口索引：用着三项去确认继承关系</p></li><li><p>字段表集合：描述类中声明的变量。最主要有三个部分：access_flag，是否public、是否provate、是否static。name_index：常量池的第几个，比如0005，代表常量池的第五个值（m）是discriptor_index 是int类型（0006：第六个值I，代表是int类型）</p></li><li><p>方法表：方法表的结构和字段表基本一样，不过是针对方法的</p></li><li><p>属性表：太复杂了</p></li></ul><h1 id="4、类加载机制"><a href="#4、类加载机制" class="headerlink" title="4、类加载机制"></a>4、类加载机制</h1><p><font color='red'><u><em><strong>类加载什么时候加载类</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>类加载其实是有点延迟加载的，除了一些基础的类以外，其他的类都是用到的时候才加载，比如你要创建类实例，或者使用静态方法的时候就会加载</strong></em></u></font></p></blockquote><p>类加载分成三个阶段，<font color='blue'><u><em><strong>加载、连接、初始化</strong></em></u></font>。连接可以分成，验证、准备、解析</p><h2 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h2><p>加载是类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构（JDK 1.8之前：永久代；JDK 1.8之后：元空间）</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区各种数据的访问入口（堆）</li></ol><p><img src="/../images/JVM/image-20231016140218073.png" alt="image-20231016140218073"></p><h2 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a>2、验证</h2><p>确保Class文件的信息复合虚拟机的约束</p><p>1、文件格式验证。就是去检查类文件格式是否规范。什么魔数主次版本常量池字段池方法池</p><p>2、元数据验证。对描述信息进行语义分析，有没有父类，有没有继承不能继承的父类。</p><p>3、字节码校验。最复杂的阶段。通过数据流分析和控制流分析程序语义是否合法，主要就是检查方法体的</p><p>4、符号引用验证。<font color='red'><u><em><strong>符号引用验证发生在解析阶段，就是把符号引用转化为直接引用的时候去验证的。</strong></em></u></font></p><h2 id="3、准备阶段"><a href="#3、准备阶段" class="headerlink" title="3、准备阶段"></a>3、准备阶段</h2><p>为静态变量分配内存，并设置初始值的阶段。如果没有final修饰，那就是默认值，比如0这类，真正赋你定义的值那就在初始化阶段。如果用final修饰了，那就是你自己定义的了。</p><h2 id="4、解析"><a href="#4、解析" class="headerlink" title="4、解析"></a>4、解析</h2><p>把常量池中的符号引用转化为直接引用的阶段。有类和接口解析，字段解析，方法解析等。实际上就是先把类加载到方法区里面，然后返回相应直接引用。</p><p>我们拿字段解析举个例子，先解析这个字段表所在的类或接口，假设成功解析为C。我们就在C的字段表里面找有没有匹配的简单名称和字段描述符，如果有就直接返回。没有就找C的接口和父接口，看看有没有匹配的简单名称和字段描述符。如果又返回，没有就按继承关系找父类有没有匹配的，否则就失败。</p><p>但是方法解析有一点不一样，他有一部分在类加载的时候是不能解析的，如果 Human h &#x3D; new Man。这种可能方法调用不能确定，这里就解析不了。能解析的叫非虚方法，不能解析的叫虚方法。虚方法需要使用另外一种调用形式就是分派，分派分为静态多动态和动态单分派，静态分派【两个宗量1、方法参数。2、方法调用者】实现重载（先确定静态类型human，然后确定哪一个方法），动态分派【1个宗亮】实现重写（invokevirtual，先找到这个动态类型，如果有这个方法那就直接用，如果没有，我们再去找他的父类）。</p><h2 id="5、初始化"><a href="#5、初始化" class="headerlink" title="5、初始化"></a>5、初始化</h2><p>初始化就是执行类构造器的过程，而这个类构造器做的事情就是对类中所有静态变量的赋值操作和所有<font color='green'><u><em><strong>静态</strong></em></u></font>语句块的操作。</p><p>顺序就是语句在源文件的顺序</p><h1 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h1><p><font color='red'><u><em><strong>类加载器的作用就是实现类加载过程中的加载这一步，通过双亲委派机制去维护一个三层的组织架构。</strong></em></u></font></p><p>三层：</p><p>启动类加载器：负责加载JAVA_HOME&#x2F;LIB目录的或者被-xbootclasspath指定。</p><p>扩展类加载器：负责加载JAVA_HOME&#x2F;LIB&#x2F;EXT的类或者被JAVA.EXT.DIRS系统变量制定的所有的类库。由于是由Java代码实现，所以开发者可以在程序中直接使用这个加载器去加载Class文件</p><p>应用程序类加载器：负责加载用户类路径CLasspath上所有的类库。开发者也可以直接使用这个</p><h2 id="双亲委派："><a href="#双亲委派：" class="headerlink" title="双亲委派："></a>双亲委派：</h2><p>双亲委派是类加载器的组织模型。</p><p>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载</p><p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</p><p>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</p><p>如果子类加载器也无法加载这个类，那么它会抛出一个 <code>ClassNotFoundException</code> 异常。</p><p><strong>好处</strong></p><p><font color='blue'><u><em><strong>可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</strong></em></u></font></p><h2 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h2><p>1、自定义类加载器，重写 <code>loadClass()</code>方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。</p><blockquote><p>解决方案：新添加一个findClass</p></blockquote><p>2、高层的类加载器（<code>SharedClassLoader</code>）借助子类加载器（ <code>WebAppClassLoader</code>）来加载业务类</p><blockquote><p>解决方案：线程上下文类加载器。线程上下文类加载器的原理是将一个类加载器保存在线程私有数据里，跟线程绑定，然后在需要的时候取出来使用。这个类加载器通常是由应用程序或者容器（如 Tomcat）设置的。类加载冲突问题</p></blockquote><p>3、OSGI实现模块化热部署，把类加载从双亲委派变成更加复杂的网状结构。</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p><strong>什么是JDK9模块化系统</strong></p><ul><li>是一种新的组织方式，将Java SE分成多个模块，每个模块都有自己的API和实现</li><li>每个模块都有一个唯一的标识符和版本号，可以独立地进行开发</li></ul><p>为了模块化系统的顺利实施。</p><p>扩展类加载器被平台类加载器取代。<strong>加载器用于加载 JDK 中的模块</strong></p><p>双亲委派机制也发生了变动。</p><p>平台或应用程序类加载器收到类加载请求后，在委派给父加载器前，先判断该类是否能够归属到某一个模块中，如果可以，就先找到负责这个模块的加载器进行加载。每个模块都有一个类加载器</p><h1 id="6、线程安全"><a href="#6、线程安全" class="headerlink" title="6、线程安全"></a>6、线程安全</h1><p>线程安全：不可变，绝对安全、相对安全、线程兼容、线程对立。</p><p>线程安全的实现方式：</p><p>1、互斥同步</p><p>synchronized，重入锁都是</p><p>2、非阻塞同步</p><p>CAS</p><h1 id="7、垃圾回收"><a href="#7、垃圾回收" class="headerlink" title="7、垃圾回收"></a>7、垃圾回收</h1><h2 id="1、如何判断对象死亡？"><a href="#1、如何判断对象死亡？" class="headerlink" title="1、如何判断对象死亡？"></a><strong>1、如何判断对象死亡？</strong></h2><p>1、<font color='red'><u><em><strong>传统有个引用计数法，在对象里面加一个引用计数器</strong></em></u></font>，有一个地方引用他就加1，但是小问题很多，比如很难解决互相引用的问题，所以主流的虚拟机都不用这个。</p><p>2、可达性分析法。基本思路就是从GC Roots这个根对象作为初始节点集，然后根据引用关系向下搜索，走过的路叫引用链。没有引用链可以尝试回收。但是具体要不要回收还是要经历两次标记过程。第一次发现没有引用链就会被第一次标记，然后进行一次筛选，看看有没有必要执行finalize方法，如果没有覆盖finalize或者执行过了，那就直接记为死亡。如果执行finalize的过程中建立了与引用链上的任何一个对象建立了联系，那么在第二次标记时，会被移出“即将回收”集合</p><blockquote><p>在 堆内存 中 , 存在一个 根对象 GC Root , GC Root 对象一般是如下几种情况 :</p><p><font color='blue'><u><em><strong>线程栈 中的 栈帧 中的 局部变量表 中的 引用对象 ;</strong></em></u></font><br><font color='blue'><u><em><strong>方法区 中的 静态变量引用对象 ;</strong></em></u></font><br><font color='blue'><u><em><strong>方法区 中的 常量引用对象 ;</strong></em></u></font><br><font color='blue'><u><em><strong>本地方法栈 中的 JNI 中的 引用的对象 ;</strong></em></u></font></p></blockquote><p>当然除了堆区，方法区也会回收。</p><p><strong>方法区回收</strong></p><blockquote><p>主要收集两个部分，废弃的常量和不再使用的类型。</p><p>废弃的意思：该类的所有实例被回收，类加载器被回收，Class对象没有在任何地方被引用。</p></blockquote><h2 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h2><p>首先垃圾收集算法基本遵循分代收集。分代收集建立于两个假说：1）弱分代假说：大多数对象都是朝生夕灭的。2）强分代假说：熬过越多次垃圾收集的对象越难消亡。3）跨代引用相对于同代引用占比极少。</p><p>先理清一些小概念：</p><ul><li><p>部分收集：</p><ul><li><p>新生代收集：Minor GC&#x2F;Young GC : 只收集新生代</p></li><li><p>老生代收集：Major GC&#x2F;Old GC : 只收集老生代：目前只有CMS收集器会有。</p></li><li><p>混合收集：Mixed GC：整个新生代和部分老生代，目前只有G1有</p></li></ul></li><li><p>整堆收集：</p><ul><li>Full GC</li></ul></li></ul><h3 id="1、标记-清除-CMS"><a href="#1、标记-清除-CMS" class="headerlink" title="1、标记-清除 CMS"></a>1、标记-清除 CMS</h3><p>很简单，就是标记可回收或者不可回收，然后清除。</p><p>有两个缺陷：执行效率不稳定和会有很多内存碎片（导致分配较大的对象困难）</p><h3 id="2、标记-复制-youngGC"><a href="#2、标记-复制-youngGC" class="headerlink" title="2、标记-复制 youngGC"></a>2、标记-复制 youngGC</h3><p>先把内存分成两半，然后每次使用其中一块，当一块用完了，就把这块内存中存活的复制到另外一块，清楚原来那一块。现在很多Java虚拟机都采用这种方法去回收新生代。</p><p>把新生代分为一块较大的eden区和两个较小的survivor区，每次分配只用eden和survivor的一块。发生垃圾回收，将eden和Survivor仍然存活的复制到Survivor，然后清除eden和那一块Survivor。</p><p>缺点就是如果对象存活率比较高那就不适合。</p><h3 id="3、标记-整理-G1"><a href="#3、标记-整理-G1" class="headerlink" title="3、标记-整理 G1"></a>3、标记-整理 G1</h3><p>标记后，让存活的对象都往内存空间的一端移动。</p><p>缺点：对于老年代这种存活率很高的也不适合。必须暂停用户应用程序</p><h3 id="4、细节"><a href="#4、细节" class="headerlink" title="4、细节"></a>4、细节</h3><p><strong>枚举根节点</strong></p><p>后台有个GC守护线程，当需要GC的时候，GC线程需要在标记阶段枚举根节点，这是需要stop the world。就是为了防止工作中的线程修改了引用关系，导致结果准确性不能保证。为了加快检索，hotspot用了一种oopMap的数据类型。</p><p>从GC<strong>往下遍历对象图</strong></p><p>这个是和堆的大小成正比的，怎么去减少暂停时间呢？<strong>三色标记法</strong></p><p>白色：对象没有被垃圾收集器访问过</p><p>黑色：已经被访问过了，且这个对象的所有引用都已经扫描过。</p><p>灰色：已经被访问过了，但是至少有一个引用没有被扫描。</p><h4 id="说一下JVM的分代回收"><a href="#说一下JVM的分代回收" class="headerlink" title="说一下JVM的分代回收"></a>说一下JVM的分代回收</h4><p><img src="/../images/JVM/image-20231117194042634.png" alt="image-20231117194042634"></p><h2 id="3、垃圾回收器"><a href="#3、垃圾回收器" class="headerlink" title="3、垃圾回收器"></a>3、垃圾回收器</h2><p><font color='red'><u><em><strong>四种引用</strong></em></u></font></p><blockquote><p>强引用：只有GCroot都不通过强引用引用该对象，才可以回收</p><p>软引用：内存不足的时候回收</p><p>弱引用：无论内存够不够，都会回收</p><p>虚引用：它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p></blockquote><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a><strong>新生代</strong></h3><blockquote><h4 id="1、Serial收集器"><a href="#1、Serial收集器" class="headerlink" title="1、Serial收集器"></a>1、Serial收集器</h4><blockquote><p>串行，单线程，暂停其他线程。现在用的人比较少，但是优点是简单高效，对内存消耗最少。（整体STW）</p></blockquote><blockquote><p>策略：标记-复制</p></blockquote><h4 id="2、Parrallel-New收集器"><a href="#2、Parrallel-New收集器" class="headerlink" title="2、Parrallel New收集器"></a>2、Parrallel New收集器</h4><blockquote><p>本质是Serial的多线程并行版本。（整体STW）</p></blockquote><blockquote><p>策略：标记-复制</p></blockquote><h4 id="3、Parrallel-Scanvenge"><a href="#3、Parrallel-Scanvenge" class="headerlink" title="3、Parrallel Scanvenge"></a>3、Parrallel Scanvenge</h4><blockquote><p>吞吐量优先收集器</p></blockquote><blockquote><p>Parrallel很多特性和ParNew一样，但是Parallel Scanvenge 的关键点在于它关注的是吞吐量，吞吐量 &#x3D; 代码运行时间 &#x2F; （代码运行时间 + 垃圾收集时间）</p></blockquote><blockquote><blockquote><p>策略：标记-复制</p></blockquote></blockquote><blockquote><blockquote><p>-XX:MaxGcPauserMillis：最大停顿时间</p><p>-XX:GCTimeRatio：吞吐量的倒数，比如 如果是 19 那么允许的最大GC时间比例为 1&#x2F;（1 + 19） &#x3D;5 %</p></blockquote></blockquote><blockquote><p>-XX:+UseAdaptiveSizePolicy：不需要手动指定新生代大小，虚拟机会自动调整参数（GC自适应）</p></blockquote></blockquote><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><blockquote><h4 id="1、Serial-Old"><a href="#1、Serial-Old" class="headerlink" title="1、Serial Old"></a>1、Serial Old</h4><p>Serial的老年代版本，</p><p>收集策略：标记-整理</p><h4 id="2、Parallel-Old-收集器"><a href="#2、Parallel-Old-收集器" class="headerlink" title="2、Parallel Old 收集器"></a>2、Parallel Old 收集器</h4><p>策略：标记-整理</p></blockquote><h4 id="3、CMS收集器"><a href="#3、CMS收集器" class="headerlink" title="3、CMS收集器"></a>3、CMS收集器</h4><p>它是一种获取最短回收停顿时间的收集器，就是希望stw的时间越短越好。</p><p>策略：标记-清除</p><p>因为回收过程和用户线程一起进行，所以有四个步骤。</p><p>1）初始标记，只是标记一下GC Roots和能直达的对象，（<font color='red'><u><em><strong>是广义上的gcroots，包含了年轻代所有对象。所以初始标记除了和狭义直接关联，还有年轻代到老年代的引用）</strong></em></u></font>（STW）</p><p>2）并发标记，从GC Roots遍历对象的过程，这个是和用户线程一起进行的。（这里会出现很多引用的变化，比如年轻代到老年代，直接在老年代分配、漏标）</p><p>3）重新标记，因为和用户线程一起进行，对于漏标问题的解决方案是（写后屏障+增量更新（<font color='green'><u><em><strong>就是把新增加的引用进行记录</strong></em></u></font>））。（STW）</p><p>4）并发清除，清除对象，因为策略是标记-清除，不需要移动所以同样选择了并发的方式。</p><p>缺点：</p><p>1）<font color='blue'><u><em><strong>对处理资源敏感</strong></em></u></font>，而且大于1&#x2F;4。CMS的默认收集线程数量是（处理器数量+3）&#x2F;4。</p><p>2）<font color='blue'><u><em><strong>无法处理浮动垃圾【多标】</strong></em></u></font>（<font color='red'><u><em><strong>在并发标记与并发清理阶段，有些对象从可达到不可达，但是没扫出来），有可能触发full gc</strong></em></u></font></p><p>3）<font color='blue'><u><em><strong>用的是标记清除，会有内存碎片</strong></em></u></font></p><p>​</p><p>CMSFullGCsBeforeCompaction：进行过几次不整理的full gc之后进行碎片整理的full gc</p><p>CMSInitialtingOccupancyfraction 什么时候触发cms 默认92</p><p>浮动垃圾如下：<code>D &gt; E</code> 的引用断开</p><p>此刻之后，对象<code>E/F/G</code>是“应该”被回收的。然而因为<strong>E已经变为灰色</strong>了，其仍会被<strong>当作存活对象</strong>继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即<strong>本轮GC不会回收这部分内存</strong>。</p><h3 id="全部"><a href="#全部" class="headerlink" title="全部"></a>全部</h3><h4 id="1、G1"><a href="#1、G1" class="headerlink" title="1、G1"></a>1、G1</h4><blockquote><p><font color='blue'><u><em><strong>用空间换时间的垃圾回收器，这个收集器是基于Region的内存布局的，他把Java堆划分为多个大小相等的region（2048），每一个region都可以是eden，suvivor，老年代。每一个region大小最小1m，最大32m，中间是2，4，8，16 接近哪个就用哪个作为大小。</strong></em></u></font></p><p><font color='red'><u><em><strong>为了加快搜索，G1是使用card table和RSet。</strong></em></u></font></p><p><font color='blue'><u><em><strong>card table是CMS的解决方案，他可以避免对老年代进行整个扫描。他的做法是把region分成一个个512字节的card，然后用一个位0或者1去标记他的状态，如果有指向年轻代的对象，就置为1，否则0。所以你扫描的时候直接找card状态是1的区域就可以找到gcroot，不用对老年代扫描。</strong></em></u></font></p><p><font color='blue'><u><em><strong>Rset是G1提出来的，每个region都有rset，它记录了哪些region引用了当前的region。他是一个键值对的形式，键就是其他region的起始地址，值就是card的索引号的集合，这样就把card table和rset配合起来了。</strong></em></u></font></p><p><font color='red'><u><em><strong>维护这两个是依赖写屏障</strong></em></u></font></p></blockquote><p>下面我们讲讲G1的垃圾收集过程，分为四个步骤</p><p>然后他把region作为单次回收的最小单元，那每次回收都是region的整数倍。</p><blockquote><p>1、初始标记，只是标记一下gcroot和能直达的对象，这个和young gc密切相关，这个之前讲过（STW）</p><p>2、并发标记，扫描对象图</p><p>3、最终标记，处理并发标记中变化的哪些引用，这里对于漏标情况G1用的SATB（原始快照）（STW）</p><p>4、筛选回收，后台维护一个优先级列表，跟踪每一个region的回收价值（空间大小和回收所需时间），在指定的停顿时间内回收回收价值最大的region。（STW）</p></blockquote><p>优点：</p><blockquote><p><font color='blue'><u><em><strong>可以指定最大停顿时间，</strong></em></u></font></p><p><font color='blue'><u><em><strong>不会产生内存碎片，</strong></em></u></font></p><p><font color='blue'><u><em><strong>按收益回收</strong></em></u></font></p></blockquote><p>缺点：</p><blockquote><p><font color='blue'><u><em><strong>内存占用负载都比较高。</strong></em></u></font></p><p><font color='blue'><u><em><strong>浮动垃圾也很严重。</strong></em></u></font></p></blockquote><p><font color='green'><u><em><strong>算法：整体标记整理，局部标记复制。</strong></em></u></font></p><p>为什么年轻代比以前的快？</p><p>他是筛选回收，是通过region个数进行minor gc 不用对整个eden区minorgc ，而且有个容忍时间。</p><p>G1的SATB算法为什么比CMS的增量标记算法快（原因之一）：</p><p>① CMS的重新标记需要重新扫描所有gc root，包括年轻代</p><p>② G1：在开始标记的时候生成一个快照图，标记存活对象。所有被改变引用关系的对象都标记，至于它是不是真的存活。留给下一次gc扫描</p><h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p><img src="/../images/CS:JVM/image-20240706205403817.png" alt="image-20240706205403817"></p><p><font color='red'><u><em><strong>浮动垃圾(多标)：将原本应该被清除的对象，误标记为存活对象。后果是垃圾回收不彻底，不过影响不大，可以在下个周期被回收；</strong></em></u></font></p><p><font color='red'><u><em><strong>对象消失(漏标)：将原本应该存活的对象，误标记为需要清理的对象。后果很严重，影响程序运行，是不可容忍的。</strong></em></u></font></p><p>漏标必须要同时满足以下两个条件：</p><ol><li>赋值器插入了一条或者多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ol><p>CMS解决对象消失问题，用的是写屏障+增量更新（黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了，后续对这个对象再进行扫描）</p><p>G1用的是，写屏障+STAB。（灰色对象要删除指向白色对象的引用关系的时候，就把这个删除的引用记录下来，涂成灰色，等并发扫描结束，再重新扫一次）</p><p>ZGC用的是，读屏障+STAB</p><p><font color='red'><u><em><strong>写屏障：</strong></em></u></font><code>HotSpot</code> 虚拟机中，不管是新增还是删除，这种记录的操作都是通过写屏障实现的。就是在写操作的前后做一些事情，类似AOP原理。</p><h4 id="2、ZGC"><a href="#2、ZGC" class="headerlink" title="2、ZGC"></a>2、ZGC</h4><p>也是使用分区的内存分布，但是它有三种不同的区。小型、中型、大型。</p><p>然后传统垃圾回收器是在markwork里面有个字段去标记的，但是ZGC标记是使用一种叫着色指针的机制。现在的计算机大多数64位，但是64肯定用不满，所以就把高位那一块拿出3位来实现着色机制的标记。</p><p><img src="/../images/JVM/image-20231018155448410.png" alt="image-20231018155448410"></p><p><strong>标记过程</strong></p><ul><li><p><strong>初始标记（STW，时间很短，小于1mm）</strong></p><ul><li>初始标记就是去扫GC Roots直接关联的对象，标记就是把蓝色变成绿色（44位置0,42位置1）</li></ul></li><li><p><strong>并发标记（并发）</strong></p><ul><li>继续遍历对象图，把蓝色变成绿色（44位置0,42位置1）</li><li>这里要用到<strong>三色标记</strong></li></ul></li><li><p><strong>再标记</strong>（<strong>STW，时间很短，小于1mm，小于初始标记</strong>）</p><ul><li>三色标记会存在漏标的问题，重新标记<strong>并发标记阶段</strong>发生变化的对象，使用读屏障+SATB算法解决</li></ul></li></ul><p><strong>转移过程</strong></p><ul><li><strong>并发转移准备（并发）</strong><ul><li>统计处本次收集过程要清理哪些region</li></ul></li><li><strong>初始转移（STW，和初始标记差不多）</strong><ul><li>把GC Roots直接关联的进行转移，颜色从绿色回到蓝色，（44位置为1,42位置为0）</li></ul></li><li><strong>并发转移</strong><ul><li>这里要维护转发表，记录老对象和新对象的转向关系。</li><li>如果在这个阶段访问，那就依赖读屏障，去完成新老指针的修正。</li><li><strong>其他指针的修正就依赖于并发标记这个阶段</strong></li></ul></li></ul><h2 id="JVM调优参数"><a href="#JVM调优参数" class="headerlink" title="JVM调优参数"></a>JVM调优参数</h2><p><font color='red'><u><em><strong>堆内存默认设置为操作系统的一半，初识堆大小和最大堆大小建议一样</strong></em></u></font></p><p>jar包启动的时候java和 -jar直接可以去配置jvm的参数</p><h2 id="JVM调优的参数有哪些？"><a href="#JVM调优的参数有哪些？" class="headerlink" title="JVM调优的参数有哪些？"></a>JVM调优的参数有哪些？</h2><blockquote><p><font color='green'><u><em><strong>内存管理：JVM-Xms，-Xmx，新生代晋级老年代的阈值（MaxTenuringThreshold，默认15），新生代大小（Xmn），永久代大小（PermSize），线程栈大小（Xss），垃圾回收器（UseParallelGC，UseConcMarkSweepGC），内存OOM导出快照（HeapDumpOnOutOfMemoryError），新生代和老年代的比例（newRadio），eden区和幸存者区的大小比例（SurvivorRatio），（）</strong></em></u></font></p><p>CMSFullGCsBeforeCompaction：进行过几<strong>次Full GC（标记清除）之后进行一次标记整理算法</strong></p><p>CMSInitialtingOccupancyfraction 什么时候触发cms 默认92 or 68</p><p>CMSScavengeBeforeRemark：默认不开启 ,开启之后是每次CMS之前都要有一次young gc</p><p>InitiatingHeapOccupancyPercent：老年代占用空间超过整堆比，45%</p><p><font color='blue'><u><em><strong>MaxGCPauseMillis：G1指定时间</strong></em></u></font></p></blockquote><h2 id="FullGC怎么排查"><a href="#FullGC怎么排查" class="headerlink" title="FullGC怎么排查"></a>FullGC怎么排查</h2><blockquote><p><font color='red'><u><em><strong>如果出现FullGC，请求和响应会变得特别慢，系统也变得很卡。</strong></em></u></font></p><p><font color='red'><u><em><strong>先用top找到java进程pid，然后用jstat（jstat -gcutil  pid）去看看是否发生了GC，尤其看，【老年代】OC，OU和，FGC确实一直在慢慢变多，那就说明FULLGC了，那我们就去解决</strong></em></u></font></p><p>内存：</p><blockquote><p> <font color='green'><strong>1、可以获得内存的快照dump（jmap -dump或者启动的时候就加上参数-XX：heapdumpOnOutOfMemeryERROR）</strong></font></p><p><font color='green'><strong>2、visualVM去加载， memory analyzer</strong></font></p></blockquote><p>Cpu：</p><blockquote><p><font color='green'><strong>然后就排查CPU消耗，用top找到进程pid，用top -H和jps找到线程id，找到占比高的用jstack看看堆栈情况</strong></font></p></blockquote></blockquote><h2 id="FULL-GC的原因"><a href="#FULL-GC的原因" class="headerlink" title="FULL GC的原因"></a>FULL GC的原因</h2><blockquote><p><font color='green'><u><em><strong>1、System.gc方法调用</strong></em></u></font></p><p><font color='green'><u><em><strong>2、老年代不够用（年龄晋升、大对象）</strong></em></u></font></p><p><img src="/../images/%E5%85%AB%E8%82%A1-JVM/image-20240714171145825.png" alt="image-20240714171145825"></p><blockquote><p><font color='green'><u><em><strong>CMS GC的过程中同时业务线程将对象放入老年代，而此时老年代空间不足。调大老年代newradio</strong></em></u></font></p></blockquote><p><font color='green'><u><em><strong>3、元空间不够用</strong></em></u></font></p><p><font color='green'><strong>4、空间分配担保失败</strong></font></p><blockquote><p><font color='green'><strong>当准备出发young gc时，进行空间分配担保，老年代最大连续空间小于年轻代所有对象总空间。如果handlepromotionfailure是false直接full gc，如果是true，那继续判断老年代最大连续空间小于历代晋升的平均。</strong></font></p></blockquote></blockquote><h2 id="Java内存泄漏排查"><a href="#Java内存泄漏排查" class="headerlink" title="Java内存泄漏排查"></a>Java内存泄漏排查</h2><blockquote><p>内存泄漏会逐渐累加导致内存溢出，内存溢出会发生在：虚拟机栈（stackoverflow）、方法区（OOM：metaspace）、堆空间（OOM：heap space）</p><p>1、可以获得内存的快照dump（jmap -dump或者启动的时候就加上参数-XX：heapdumpOnOutOfMemery）</p><p>2、visualVM去加载，analyzer memory analyzer</p></blockquote><p><font color='red'><u><em><strong>内存泄漏时分配的内存没有正常回收【没有关闭的数据库连接】，内存溢出时内存不够用了</strong></em></u></font></p><h2 id="CPU标高的排查"><a href="#CPU标高的排查" class="headerlink" title="CPU标高的排查"></a>CPU标高的排查</h2><p><font color='blue'><u><em><strong>top或者pidstat命令找到cpu明显过高的进程id，然后用进程id去找到线程id（ps H -eo pid,tid,%cpu | grep进程id），最后jstack 一下定位到该线程就可以</strong></em></u></font></p><p>标高的原因：死锁？死循环？频繁fullgc？一些复杂计算</p><h2 id="JVM调优工具"><a href="#JVM调优工具" class="headerlink" title="JVM调优工具"></a>JVM调优工具</h2><blockquote><p><font color='red'><u><em><strong>命令：</strong></em></u></font></p><p>jps + jstack 查看进程内线程的堆栈信息</p><p>jmap -dump 生成一个内存快照的信息</p><p>jstat ：JVM性能监测工具。 显示伊甸区 幸存者区、老年区的比例，还有gc压力</p><p><font color='red'><u><em><strong>可视化工具：</strong></em></u></font></p><p>jconsole</p><p>visualVM，eclipse memory analyzer</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-设计模式</title>
      <link href="/2023/10/10/%E5%85%AB%E8%82%A1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/10/%E5%85%AB%E8%82%A1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><font color='red'><u><em><strong>问到设计模式就说：策略、代理、单例、工厂、组合、模版。</strong></em></u></font></p><ul><li><strong>设计模式原则</strong></li></ul><blockquote><p><font color='green'><strong>①单⼀职责原则：它规定⼀个类只有⼀个职责。</strong></font></p><p><font color='green'><strong>②开闭原则： 核心是：对扩展开放，对修改封闭。我们应该将那些可能发生变化的部分抽象出来，构建一个抽象框架，然后针对这些抽象接口进行编程。当需求发生变化时，我们只需要扩展新的实现类</strong></font></p><p><font color='green'><strong>③⾥⽒替换原则：里氏替换原则是对开闭原则的重要补充。【父类的地方都可以用子类代替】核心是：子类可以扩展父类的功能，但不应该改变父类原有的功能。父类一个hello方法，你子类就不要重写，就重新写个新方法就好</strong></font></p><p><font color='green'><strong>⑥依赖倒置原则：核心是：【是程序要依赖于抽象接口，不要依赖于具体实现】，变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间就存在一个缓冲层，变量就可以映射不同的实现类，有利于程序扩展和优化。</strong></font></p><p><font color='green'><strong>⑤接⼝隔离原则：不同的功能定义在一个冗杂的接⼝，这是不好的，一个类如果只用到一个功能，但是他需要实现所有的方法。所以应该把接口拆分多个独立的接口，让对应的类实现对应的接口</strong></font></p></blockquote><ul><li><strong>策略模式</strong></li></ul><p><font color='green'><strong>是一种 if else 的优化方法。我们一般都是搭配map来做的，不同的实现策略都传到这个map里面，map是有key value，然后通过这个参数，去map里面找就可以了。否则你可能还要很多个if判断，就像我实习的代码里面，有一个批量导入的功能，这个批量导入是走mq的，但是有很多个模块都有批量导入功能，用的都是这个topic，那消费者拿到的时候就要去判断是哪一个service调用，这里之前就是ifif，后来leader就让我用策略模式改了一下。不过当时还有点小问题，就是每一个导入导出的方法名其实是不一样的，所以如果我要把这些service全部再包装一层，就多了50个策略类，这样也不太好，速度快了，但是文件太多了，后来查资料发现Java8有个Consumer接口，可以直接把方法装进去，这样就解决了上述的所有问题，很方便。</strong></font></p><ul><li><strong>模版模式</strong></li></ul><blockquote><p><font color='green'><strong>模版模式的主要思路就是把自己要实现的功能抽象成一组步骤，或者说定义算法的骨架，具体实现留给子类。但是这里有一点非常重要，就是模版类的流程是定义好的，或者说定死了，子类就是在每一个步骤中实现自己的个性化。我觉得它比较适合那些定死的公式化的功能吧，后面优化或者重构代码的时候用</strong></font></p></blockquote><ul><li><strong>工厂模式</strong></li></ul><blockquote><p>工厂模式有三种，简单工厂、工厂模式、抽象工厂模式。</p><p><font color='red'><u>**简单工厂（工厂不是抽象的）只适合单一产品的生产，他的思路很简单，就是根据不同信息new出来不同的对象。比如海尔冰箱和格力冰箱 **</u></font>（冰箱工厂+ 收到冰箱品牌名，生成不同冰箱）</p><p><font color='red'><u><em><strong>工厂模式是把在简单工厂的基础上抽象了一层，。比如海尔工厂，格力工厂</strong></em></u></font></p><p><font color='red'><u><em><strong>抽象工厂模式就考虑了产品族的问题，一个工厂可以生产多等级的产品，说得简单点就是在抽象工厂里面增加生产其他产品的接口，子类去实现它。</strong></em></u></font></p></blockquote><ul><li><strong>单例模式</strong></li></ul><blockquote><p>该类负责创建自己的对象，保证只有单个对象被创建。</p><p>单例模式分两类，<font color='blue'><u><em><strong>饿汉式和懒汉式。饿汉式就是类加载的时候就会创建，其实类加载有个准备和初始化过程，静态变量和静态代码块，里就可以创建，懒汉式是用到了才创建。Bean默认是饿汉式，然后可以设置成懒汉式。</strong></em></u></font></p><p><strong>volatile懒汉式单例使用的场景？线程安全的单例场景，<font color='blue'><u><em><strong>数据库连接池</strong></em></u></font></strong></p><p><font color='red'><u><em><strong>为什么要用双重检查锁？</strong></em></u></font></p><p><font color='green'><strong>懒汉式里面的双重检查锁JVM在实例化对象的时候会进行优化和指令重排序操作。指令重排序导致空指针问题</strong></font></p></blockquote><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote><p><font color='red'><u><em><strong>组合模式用树形结构描述整体与部分的关系中 。最顶层的节点称为根节点 ，根节点下面可以包含树枝节点和叶子节点 ，树枝节点下面又可以包含树枝节点和叶子节点。</strong></em></u></font></p><p>这里我们是用组合模式搭建规则引擎树，规则树有两种对象。一种是树节点，一种是树枝，树节点包括连接的树枝集合，树枝里面包含了连接的前后两个树节点和判断依据，这样子就能构建出一个有判断规则的规则树了。具体的流程就是假设我们现在在根节点，然后看了下根节点的规则是性别，那我就拿到年龄规则过滤器，遍历根节点的树枝集合，假如这里有两个树枝，一个树枝的规则是&#x3D;男，就走这个树枝；另一个树枝的规则是&#x3D;女，就走这个树枝。这时候我们拿出用户的信息一对比，发现应该走男生那个树枝。这样就进入下一个节点，然后这个节点的判断规则是年龄，可能大于某个枝走某个树枝，小于就走另外的树枝。直到我们找到叶子结点就结束。</p></blockquote><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>代理分成<font color='blue'><u><em><strong>静态代理和动态代理</strong></em></u></font>，静态代理需要自己实现对每一个方法对代理，非常繁琐。动态代理更加灵活，不需要你一个一个的对方法进行代理。</p><p><strong>动态代理</strong>是代理类在程序运行时创建的代理方式被成为动态代理。</p><p>动态代理有两种方式一种是jdk方法，一种是cglib方法</p><p>jdk代理依赖于一个Proxy类和一个InvocationHandler接口<strong>，</strong>通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><p><font color='red'><u><em><strong>InvocationHandler接口，他只有一个invoke方法，三个参数是代理类，被代理方法，方法参数组.被代理方法和参数组是可以变化的，所以在这里我们说实现了动态的意义。</strong></em></u></font> 代理方法和参数组其实我们可以依赖于最基础反射得到</p><p><font color='red'><u><em><strong>那我们怎么去调用这个方法呢？先要靠Proxy类和他的方法newproxyInstance，getProxyClass0(loader, intfs)这个类的产生就是整个动态代理的关键，产生的类反编译之后知道，调用被代理对象的方法其实会直接调用我们InvocationHandler接口的invoke方法，在invoke方法中调用了被代理对象的相应方法。</strong></em></u></font></p><p><strong>下面来讲CGLIB代理</strong></p><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。你可以通过 <code>Enhancer</code>类来动态获取被代理类，</strong></p><p>  <font color='blue'><u><em><strong>CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，每次调用代理类的方法都会被方法<a href="https://so.csdn.net/so/search?q=%E6%8B%A6%E6%88%AA%E5%99%A8&spm=1001.2101.3001.7020">拦截器</a>拦截，在拦截器中才是调用目标类的该方法的逻辑。所以我们说，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</strong></em></u></font></p><p>为什么JDK动态代理只能代理接口实现类，原因是JDK动态代理是基于接口实现的。</p><p>有两个原因，一个是继承Proxy。第二个是当你使用Proxy类创建代理对象时，你需要指定一个接口列表来表示理对象的类型。代理对象的类型是由接口列表决定的，因此只有实现了接口的类才能被代理。如果你想代理一个类而不是一个接口，你需要使用其他的代理技术，比如CGLIB。</p><p><strong>二者区别</strong><br>总结一下两者的区别吧：</p><p>JDK 动态代理基于接口，CGLIB 动态代理基于类。因为 JDK 动态代理生成的代理类需要继承 java.lang.reflect.Proxy，所以，只能基于接口；CGLIB 动态代理是根据类创建此类的子类，所以，此类不能被 final 修饰<br>JDK 和 CGLIB 动态代理都是在运行期生成字节码。而 JDK 是直接写 Class 字节码；而 CGLIB 使用 ASM 框架写 Class 字节码（不鼓励直接使用ASM，因为它要求你必须对 JVM 内部结构包括 class 文件的格式和指令集都很熟悉）<br>JDK 通过反射调用方法，CGLIB 通过 FastClass 机制直接调用方法。所以，CGLIB 执行的效率较高<br>JDK 核心是实现 InvocationHandler接口，使用 invoke()方法进行面向切面的处理，调用相应的通知；CGLIB 动态代理是利用 asm 开源包，对代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。核心是实现 MethodInterceptor 接口，使用 intercept() 方法进行面向切面的处理，调用相应的通知。</p></blockquote><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><blockquote><p><font color='red'><u><em><strong>装饰器模式其实就是在原本类的基础上包装一个装饰器类，这个类在执行源类的行为的前后再加入一些新的逻辑。</strong></em></u></font></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">抽象组件</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">具体组件（需要被装饰的组件）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体组件处理业务逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">抽象装饰器（继承、实现抽象组件，并持有抽象组件）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">     * 抽象组件</span><br><span class="line">    <span class="keyword">public</span> Component component;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        component.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">具体装饰器A继承抽象装饰器</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteDecorator前置操作....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteDecorator后置操作....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">组件本身执行的动作</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        component.execute();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decorator 通用写法测试</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建需要被装饰的组件</span></span><br><span class="line">        <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">        <span class="comment">//给对象透明的增加功能并调用</span></span><br><span class="line">        <span class="type">Decorator</span> <span class="variable">decorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecorator</span>(component);</span><br><span class="line">        decorator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul><li>目标角色（Target）：该角色定义把其他类转换为何种接口。</li><li>源角色（Adaptee）：被适配的对象</li><li>适配器角色（Adapter）：该对象将源对象转换成目标接口</li></ul><p>总结一下就是：<font color='green'><u><em><strong>我们在适配器里面实现目标角色的接口，然后在这个接口里面去调用源角色的方法</strong></em></u></font>。</p><p>如果这个源角色类需继承，那我们就叫类适配器。如果直接作为适配器的一个变量，那么就叫做对象适配器。</p><p>分为两类：类适配器和 对象适配器</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p><strong>桥接模式通过将继承改为组合的方式来解决这个问题</strong>。具体来说，就是抽取其中一个维度并使之成为独立的类层次，这样就可以在初始类中引用这个新层次的对象，从而使得一个类不必拥有所有的状态和行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BridgeD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">yellow</span>();</span><br><span class="line">        <span class="type">bag1</span> <span class="variable">bag1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">bag1</span>(color);</span><br><span class="line">        bag1.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yellow</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">bag</span> &#123;</span><br><span class="line">    Color color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">bag</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        color.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bag1</span> <span class="keyword">extends</span> <span class="title class_">bag</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">bag1</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bag1&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式可以理解为转换一群接口，客户只要调用这一个接口而不用调用多个接口才能达到目的，也不需关心这个子系统的内部细节。就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p><strong>其本质就是缓存共享对象，降低内存消耗</strong>。</p></blockquote><p>**享元模式其实就是工厂模式的一个改进机制，享元模式同样要求创建一个或一组对象，并且就是通过**工厂方法**生成对象的，不同的地方在于享元模式增加了*<em>缓存*<em>的功能</em></em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by njy on 2023/6/21</span></span><br><span class="line"><span class="comment"> * 1.抽象享元类（FlyWeight）：单车</span></span><br><span class="line"><span class="comment"> * 单车有很多共同的信息比如：价格、颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Bike</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> String color;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> price;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bike</span><span class="params">(String color,<span class="type">int</span> price)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.color=color;</span><br><span class="line">        <span class="built_in">this</span>.price=price;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//展示单车信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by njy on 2023/6/21</span></span><br><span class="line"><span class="comment"> * 2.具体享元类（ConcreteFlyWeight）：摩拜单车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mobike</span> <span class="keyword">extends</span> <span class="title class_">Bike</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mobike</span><span class="params">(String color,<span class="type">int</span> price)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(color,price);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产成功：摩拜单车——&quot;</span>+color+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;起步价&quot;</span>+price+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by njy on 2023/6/21</span></span><br><span class="line"><span class="comment"> * 2.具体享元类（ConcreteFlyWeight）：美团单车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MTBike</span> <span class="keyword">extends</span> <span class="title class_">Bike</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MTBike</span><span class="params">(String color,<span class="type">int</span> price)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(color,price);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产成功：小黄车——&quot;</span>+color+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;起步价&quot;</span>+price+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by njy on 2023/6/21</span></span><br><span class="line"><span class="comment"> * 3.享元工厂类（FlyWeightFactory）：单车工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BikeFactory</span> &#123;</span><br><span class="line">    <span class="comment">//map缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Bike&gt; bikeMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bike <span class="title function_">getBike</span><span class="params">(String color,String type)</span>&#123;</span><br><span class="line">        String key=color+<span class="string">&quot;_&quot;</span>+type;</span><br><span class="line">        <span class="keyword">if</span>(bikeMap.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//如果已经有该颜色和类型的单车，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> bikeMap.get(key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Bike bike=<span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//没有，创建并放入缓存</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;mobike&quot;</span>.equals(type))&#123;</span><br><span class="line">                bike=<span class="keyword">new</span> <span class="title class_">Mobike</span>(color,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;MT&quot;</span>.equals(type))&#123;</span><br><span class="line">                bike=<span class="keyword">new</span> <span class="title class_">MTBike</span>(color,<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;抛异常！没有该类型的单车&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//放入缓存</span></span><br><span class="line">            bikeMap.put(key,bike);</span><br><span class="line">            <span class="keyword">return</span> bike;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-Redis</title>
      <link href="/2023/10/09/%E5%85%AB%E8%82%A1-Redis/"/>
      <url>/2023/10/09/%E5%85%AB%E8%82%A1-Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Redis数据结构"><a href="#1、Redis数据结构" class="headerlink" title="1、Redis数据结构"></a>1、Redis数据结构</h1><p>我在项目中用到的数据结构有String、Hash。</p><p>String我主要用于三类。 1）库存和订单数量，2）还有一些策略对象、活动对象，这种读多写少，没有频繁变化的对象。3）分布式锁。</p><p>Hashmap 我主要用于活动剩余的奖品数量和还有用户剩余次数。本身奖品是一个对象，可以用String+JSON的格式，但是奖品数量这个属性频繁变化，我就把他抽出来放到HashMap里面了。</p><blockquote><p>Redis的对象都是RedisObject，RedisObject里面有<font color='blue'><u><em><strong>type encoding ptr</strong></em></u></font>。</p><p>简单动态字符串</p><p><font color='green'><strong>如果是String类型，且这个字符串保存的是整数型，那就会把encoding设置成int，然后ptr用来存储整数。如果是一个字符串且小于32字节，就是embstr的SDS，如果是大于32字节就是RAW格式的SDS，embstr分配一次<font color='red'><u><em><strong>连续</strong></em></u></font>的内存空间，RAW格式要分配两次分别保存RedisObeject和SDS。(SDS包括字符串长度、分配的空间、sds类型、字节数组。)</strong></font>。</p><p>SDS 由长度（<code>len</code>）、内存空间大小（<code>alloc</code>）、字符串类型（<code>flags</code>）和存储的字节数组（<code>buf</code>），四个部分组成</p></blockquote><blockquote><p>List是<strong>quicklist</strong><font color='red'><u><em><strong>（其实就是双向链表 + 压缩列表）</strong></em></u></font>，<font color='red'><u><em><strong>链表的每个节点就是一个压缩列表，压缩列表是一个连续的内存块组成的顺序性数据结。链表的形式减少用于解决连锁更新的问题。</strong></em></u></font></p></blockquote><blockquote><p><font color='green'><strong>HashMap是压缩列表和哈希表。哈希冲突用链式哈希解决。</strong></font></p></blockquote><blockquote><p><font color='green'><strong>SET 是整数集合（元素个数少于512）、哈希表。整数集合就是一块连续的数组</strong></font></p></blockquote><blockquote><p><font color='red'><u><em><strong>ZSET是压缩列表或跳表。</strong></em></u></font></p><p><font color='green'><strong>跳表是在链表基础，对节点分层，每一个节点里面保存了 score 和 member，所有的节点都按照 score 排序，而当 score 相同时，会再按照 member 的字典顺序进行排序。跳表的相邻两层的节点数量最理想的比例是 2:1。实际上在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong></font></p><p><font color='red'><u><em><strong>查找从顶层链表的头部元素开始，然后遍历该链表，如果next的值大于我们要找的就从下一层找结果</strong></em></u></font></p><p><font color='red'><strong>为什么用跳表不用平衡树？</strong></font></p><p>这个问题，Redis的作者回答过，主要是三点：</p><blockquote><p><font color='green'><strong>内存小，平衡树非叶子节点要放两个指针，跳表1.33个</strong></font></p></blockquote><blockquote><p><font color='green'><strong>对范围查找友好，平衡树红黑树，这些你要按照中序遍历的方式找，但是跳表，你找到一个较小的值之后，直接在最底层往右遍历就好了</strong></font></p></blockquote><blockquote><p><font color='green'><strong>实现简单，平衡树的插入删除可能发生子树的调整，跳表的插入删除只需要修改相邻节点的指针</strong></font></p></blockquote><p><font color='blue'><u><em><strong>跳表的空间复杂度是 O(n)，时间logn</strong></em></u></font></p></blockquote><p>​</p><h1 id="2、Redis线程模型"><a href="#2、Redis线程模型" class="headerlink" title="2、Redis线程模型"></a>2、Redis线程模型</h1><h2 id="2、线程模型是怎么样的？是不是单线程"><a href="#2、线程模型是怎么样的？是不是单线程" class="headerlink" title="2、线程模型是怎么样的？是不是单线程"></a>2、线程模型是怎么样的？是不是单线程</h2><p><font color='red'><u><em><strong>1）以前严格意义上来说也不是单线程，还有后台线程，比如aof刷盘</strong></em></u></font><br><font color='red'><u><em><strong>2）6.0.x后，由于网络的瓶颈出现，Redis采用了多线程来解决这个问题，具体的步骤是</strong></em></u></font></p><p>流程简述如下：</p><ul><li>主线程获取 socket 放入等待列表</li><li>将 socket 分配给各个 IO 线程（并不会等列表满）</li><li>主线程<code>阻塞等待 IO 线程(多线程)</code>读取 socket 完毕</li><li>主线程执行命令 - <code>单线程</code>（如果命令没有接收完毕，会等 IO 下次继续）</li><li>主线程<code>阻塞等待 IO 线程(多线程)</code>将数据回写 socket 完毕（一次没写完，会等下次再写）</li></ul><p>所以多线程就是把最耗时的socket读、请求解析、socket写，这个外包给io线程组，实现socet读写并行化，主线程只去执行命令。所以redis为什么快，一个多线程、多路复用、内存、执行命令的单线程</p><p><img src="/../images/Redis/image-20231031151613941.png" alt="image-20231031151613941"></p><p>其实redis的单线程是先初始化后一直走一个循环处理。初始化的时候就做了三件事情：</p><p><img src="/../images/Redis/image-20231023173508951.png" alt="image-20231023173508951"></p><ul><li>创建一个 epoll 对象，就是我们的io多路复用的实现</li><li>对配置的监听端口进行 listen</li><li>把 listen socket 让 epoll 给管理起来，注册accept处理函数。</li></ul><p>做完这些之前之后就要真正处理用户请求，他会调用 epoll_wait 函数等待事件的到来，交给事件分发器。</p><ul><li>若发现 listen socket 上有新连接到达，就调用我们刚刚注册的那个accept函数，并追加这个client socket到epoll中进行管理</li><li>若发现其它 socket 上的读写请求，那就调用相应的读事件处理，和写事件处理。</li></ul><p>当然这里6.0以后引入了多线程，那接收数据、解析数据、写回数据都交给了io线程组，和主线程无关了。</p><h2 id="3、为什么这么快？高性能"><a href="#3、为什么这么快？高性能" class="headerlink" title="3、为什么这么快？高性能"></a>3、为什么这么快？高性能</h2><p><font color='blue'><u><em><strong>基于内存</strong></em></u></font></p><p><font color='blue'><u><em><strong>单线程执行命令</strong></em></u></font></p><p><font color='blue'><u><em><strong>io多路复用</strong></em></u></font></p><p><font color='blue'><u><em><strong>多线程读写socket</strong></em></u></font></p><h2 id="6、讲一下io多路复用"><a href="#6、讲一下io多路复用" class="headerlink" title="6、讲一下io多路复用"></a>6、讲一下io多路复用</h2><p>io多路复用是基于NIO的，他的思路就是一个线程去监听多个线程，那个socket准备好了，我就去读哪一个，bio是同步阻塞，一个线程处理一个请求。</p><p><font color='red'><u><em><strong>io多路复用有多种实现，select、poll、epoll。我们Redis他在初始化的过程中回去注册一个epoll对象，这个就是id多路复用的实现</strong></em></u></font></p><p><font color='blue'><u><em><strong>select和poll要扫描所有的socket，包括就绪和没有就绪。而且select的文件描述符默认最大是1024，而poll对她进行了升级，引入了链表，所以监听的socket可以是无限的，需要自己去遍历，是哪个发了可读通知。epoll是（ epoll_wait()）直接告诉你是哪个socket就绪。</strong></em></u></font></p><h2 id="4、采用单线程原因"><a href="#4、采用单线程原因" class="headerlink" title="4、采用单线程原因"></a>4、采用单线程原因</h2><ul><li>使用单线程模型是 Redis 的开发和维护更简单</li><li>即使使用单线程模型也并发的处理多客户端的请求，主要使用的是多路复用IO</li><li>对于 Redis 系统来说， 主要的<code>性能瓶颈是内存或者网络带宽而并非 CPU</code>。</li></ul><h2 id="5、引入多线程原因"><a href="#5、引入多线程原因" class="headerlink" title="5、引入多线程原因"></a>5、引入多线程原因</h2><p>内存问题比较好解决，因此Redis的瓶颈原因为网络IO</p><h1 id="3、Redis持久化"><a href="#3、Redis持久化" class="headerlink" title="3、Redis持久化"></a>3、Redis持久化</h1><p><font color='red'><u><em><strong>Redis宕机数据会丢失么？</strong></em></u></font></p><blockquote><p><font color='green'><strong>如果没开启持久化机制，那么会丢失全部数据.</strong></font></p><p><font color='green'><strong>如果是 RDB 快照，假如我们在 RDB 快照生成后宕机，那么会丢失快照生成期间全部增量数据。如果在连快照都没成功生成，那么就会丢掉全部数据。</strong></font></p><p><font color='green'><strong>而当我们仅开启了 AOF 时，丢失数据的多少取决于我们设置的刷盘策略：当设置为每条指令执行后都刷盘 <code>Always</code>，我们最多丢失一条指令；当设置为每秒刷一次盘的 <code>Eversec</code> 时，最多丢失一秒内的数据；当设置为非主动刷盘的 <code>No</code> 时，则可能丢失上次刷盘后到现在的全部数据。</strong></font></p></blockquote><h2 id="1、AOF"><a href="#1、AOF" class="headerlink" title="1、AOF"></a>1、AOF</h2><blockquote><p><font color='green'><strong>每执行一条写操作命令，就以命令的形式追加的方式写入到一个文件里，不过是先写到aof缓冲里面，然后在写回aof文件</strong></font></p><p><font color='red'><u><em><strong>AOF写回策略几种？</strong></em></u></font></p><blockquote><p>三种：Always everySec no</p><p>第一种就是<font color='blue'><u><em><strong>每次都同步</strong></em></u></font></p><p>第二种就是<font color='blue'><u><em><strong>每一秒都讲缓冲区里面的写会磁盘</strong></em></u></font></p><p>第三种就是<font color='blue'><u><em><strong>写到缓冲区里面，但是什么时候写到磁盘依赖于操作系统</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>AOF 日志过大，会触发什么机制？</strong></em></u></font></p><blockquote><p><font color='blue'><u><em><strong>aof重写机制(后台子进程)：读取当前数据库中的所有键值对，对每一键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</strong></em></u></font></p><p><font color='blue'><u><em><strong>如果aof重写过程中，主进程对内存进行了修改，怎么办？会触发写时复制。假设A，我们复制一个A’出来，然后修改操作就在A’上面做，把原本的A留给AOF重写，并且要把写命令加入aof缓冲区和aof重写缓冲区，重写完成后，把重写缓冲区里面的内容追加到新的aof文件里面</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>为什么先执行命令，再把数据写入日志呢？</strong></em></u></font></p><blockquote><p><font color='green'><strong>1、避免额外的开销</strong></font></p><p><font color='green'><strong>2、不会阻塞当前的写命令</strong></font></p><p>缺点：</p><p>1、<font color='green'><strong>可能数据丢失</strong></font>，因为如果在执行完还没写入aof文件之间宕机，那就丢失</p><p>2、<font color='green'><strong>可能阻塞下一个命令</strong></font></p></blockquote></blockquote><h2 id="2、RDB快照"><a href="#2、RDB快照" class="headerlink" title="2、RDB快照"></a>2、RDB快照</h2><blockquote><p><font color='blue'><u><em><strong>RDB是以二进制的形式在持久化启动的那一瞬间的数据。所以rdb快照不会想aof那样开辟一个缓冲区用于记录新操作。这里rdb用的是全量快照数据。如果在rdb快照的时候，主线程修改了内容，那么这时候会出发写保护中断，写时复制，原本的物理内存A，复制一份A‘，然后主线程修改A’就好了</strong></em></u></font></p><p>有两种启动的方式，一个save阻塞住线程，一种bgsave，后台线程，fork一个子进程，也复制了页表。他的做法是</p></blockquote><h2 id="3、混合持久化"><a href="#3、混合持久化" class="headerlink" title="3、混合持久化"></a>3、混合持久化</h2><blockquote><p>混合持久化就是合并了aof和rdb的两个优点，rdb恢复数据块，aof丢失数据少</p><p>混合持久化，fork出来的子进程先去把共享内存以rdb的格式写入到aof文件里面，然后写入过程中主进程执行的命令会被记录到重写缓冲区里面，然后这些增量命令最后会以aof的格式增加到aof文件里面，所以aof文件里面前一部分时rdb，后一部分是aof。</p></blockquote><h1 id="4、Redis主从同步-主从切换"><a href="#4、Redis主从同步-主从切换" class="headerlink" title="4、Redis主从同步+主从切换"></a>4、Redis主从同步+主从切换</h1><p>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。</p><blockquote><p><font color='red'><u><em><strong>全量同步</strong></em></u></font></p><ul><li><font color='red'><u><em><strong>第一阶段是建立链接、协商同步；</strong></em></u></font></li></ul><p>建立链接的时候会给主服务器发送psync，然后带上主服务器的runID（其实第一次不知道）和复制进度</p><p>主服务器收到后会返回一个FULLRESYNC响应，主服务器的runID和目前的复制进度</p><ul><li><font color='red'><u><em><strong>第二阶段是主服务器同步数据给从服务器；</strong></em></u></font></li></ul><p>接着主服务器就执行bgsave生产rdb文件，发给从服务器，从服务器收到rdb文件，会清空当前自己的数据，然后载入rdb文件。并且把新增的写操作写入到replication buffer缓冲区</p><ul><li><font color='red'><u><em><strong>第三阶段是主服务器发送新写操作命令给从服务器</strong></em></u></font></li></ul><p>把repliacation buffer缓冲区里面的写操作发给从服务器</p></blockquote><p>第一次同步完成后，双方会维护一个TCP链接。</p><blockquote><p><font color='red'><u><strong>增量复制</strong></u></font></p><p>网络断开又恢复后，从主从服务器会采用<strong>增量复制</strong>的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。</p><p>主要有三个步骤：</p><ul><li>从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1（slave_repl_offset）</li><li>主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据；</li><li>主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li></ul><p><strong>主服务器怎么知道要将哪些增量数据发送给从服务器呢？</strong></p><ul><li><strong>repl_backlog_buffer</strong>，是一个「<strong>环形</strong>」缓冲区，用于主从服务器断连后，从中找到差异的数据。（主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到 repl_backlog_buffer 缓冲区里。）</li><li><strong>replication offset</strong>，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 来记录自己「<em>写</em>」到的位置，从服务器使用 slave_repl_offset 来记录自己「<em>读</em>」到的位置。</li></ul><p>如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>增量同步</strong>的方式；</p><p>相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>全量同步</strong>的方式。</p></blockquote><h2 id="哨兵模式（怎么保证redis的高可用？）"><a href="#哨兵模式（怎么保证redis的高可用？）" class="headerlink" title="哨兵模式（怎么保证redis的高可用？）"></a>哨兵模式（怎么保证redis的高可用？）</h2><p>他有三大作用：监控、恢复、通知。</p><p><strong>怎么监控？怎么主从切换</strong></p><blockquote><p><font color='red'><u><em><strong>哨兵是基于心跳机制去监控节点。每隔1s会向实例发送ping命令，然后实例响应pong，假如规定时间内，没回复，那就认为主观下线。如果主节点超过一半的哨兵都认为下线了，那就是客观下线，这个时候就要选取新的master。判断主节点客观下线的那个哨兵成为候选者，候选节点向其他哨兵发送成为leader的请求，如果成功就负责进行主从切换。</strong></em></u></font></p><p>1、选出主节点、先看优先值，再看offset，再看id</p><p>2、将从节点指向新主节点</p><p>3、通知客户的主节点已更换</p><p>4、如果旧的主节点重新上线，将旧主节点变为从节点</p></blockquote><p><strong>主从切换如何减少数据丢失</strong>？</p><blockquote><p>主从切换有两种情况会数据丢失</p><ul><li><font color='red'><u><em><strong>异步复制同步丢失。master来不及同步给从节点就挂了</strong></em></u></font></li><li><font color='red'><u><em><strong>集群产生脑裂数据丢失。</strong></em></u></font>就是因为网络问题，哨兵监听不到主节点，那么哨兵就去从节点里面选了一个主节点，这个时候就有多个主节点，那原先的主节点就会被迫降为从节点，然后去新的主节点同步数据，他一同步，那么原先的数据就丢了。所以他的解决方案就是，必须有从节点和设置主从同步之间的延迟时间，如果从节点不够或者网络延迟太大，那我就禁止写操作</li></ul></blockquote><p><strong>如何应对主从数据不一致？</strong></p><blockquote><p>第一种方法，尽量<font color='red'><u><em><strong>保证主从节点间的网络连接状况良好</strong></em></u></font>，避免主从节点在不同的机房。</p><p>第二种方法，可以开发一个外部程序来<font color='red'><u><em><strong>监控主从节点间的复制进度</strong></em></u></font>。具体做法：得到主从的复制差距，如果过大，就不再和这个从节点进行数据同步</p></blockquote><p><strong>怎么判断 Redis 某个节点是否正常工作？</strong></p><blockquote><p>基本都是通过互相的 ping-pong 心态检测机制,</p><p>哨兵每隔1s会向主节点和从节点发送ping，</p><p>每隔10s会向主节点发送info命令获取从节点的信息。</p></blockquote><h1 id="5、Redis-过期删除与内存淘汰"><a href="#5、Redis-过期删除与内存淘汰" class="headerlink" title="5、Redis 过期删除与内存淘汰"></a>5、Redis 过期删除与内存淘汰</h1><h2 id="1、Redis过期策略"><a href="#1、Redis过期策略" class="headerlink" title="1、Redis过期策略"></a>1、Redis过期策略</h2><p>Redis 使用的过期删除策略是「<strong>惰性删除+定期删除</strong>」这两种策略配和使用。</p><blockquote><p>什么是惰性删除？</p><p>我不主动的删除，每当访问key的时候，我去判断一下是否过期，如果过期那么就删除该key</p><p>优点：占用比较少的资源，对cpu时间最友好</p><p>缺点：会导致缓存污染，浪费内存空间，对内存不友好</p></blockquote><blockquote><p>什么是定期删除策略？</p><p>就是定期的数据库里面随机抽取一定数量的key，并删除其中的过期的key</p><p>抽取策略？</p><p>1、从过期字典里面随机找20个</p><p>2、然后判断是否过期，并删除已经过期的key</p><p>3、如果过期的key超过了25%，那么就重复这个过程，如果没有，那就等待下一轮的抽查</p><p>优点：通过调整删除操作的时长的频率可以减少一些无用的占用</p><p>缺点：很难确定删除的时长和频率，太频繁对cpu不好，太少又和惰性删除一样。</p></blockquote><h3 id="1、Redis-持久化时，对过期键会如何处理的？"><a href="#1、Redis-持久化时，对过期键会如何处理的？" class="headerlink" title="1、Redis 持久化时，对过期键会如何处理的？"></a>1、Redis 持久化时，对过期键会如何处理的？</h3><p>:red_circle: 持久化有两种 aof和rdb</p><p>aof：考虑aof写入阶段和重写阶段</p><blockquote><p><font color='green'><strong>写入阶段：如果这个key过期了，但是没有被删除，那么aof文件就会保留这个key，如果这个key被过期策略删除了，那么就会往aof文件里面追加一条del语句</strong></font></p><p>重写阶段：重写阶段如果过期了，那么就直接删除，不会保留在新的aof文件里面</p></blockquote><p>对于rdb，考虑生成和加载阶段</p><blockquote><p><font color='green'><strong>生成阶段：对于过期的key不写入rdb文件里面</strong></font></p><p>加载阶段：这里分两种情况，一种是主服务器，另一种是从服务器。</p><p>​主服务器：加载阶段回去判断key是不是过期了，如果过期了那我就不加载这个</p><p>​从服务器：不管key是不是过期，全部加载。</p></blockquote><h3 id="2、Redis-主从模式中，对过期键会如何处理？"><a href="#2、Redis-主从模式中，对过期键会如何处理？" class="headerlink" title="2、Redis 主从模式中，对过期键会如何处理？"></a>2、Redis 主从模式中，对过期键会如何处理？</h3><blockquote><p>主从模式中，从数据库完全依赖于主数据库，所以即使从库的key过期了，但是你查询，依旧能查到。只有主数据库在key到期的时候往aof文件里面增加del语句，同步到所有的从库，从库才会删除这个key。</p></blockquote><h2 id="2、Redis-内存淘汰"><a href="#2、Redis-内存淘汰" class="headerlink" title="2、Redis 内存淘汰"></a>2、Redis 内存淘汰</h2><p><font color='red'><u><em><strong>在 Redis 的运行内存达到了某个阀值，就会触发内存淘汰机制</strong></em></u></font></p><blockquote><p>这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p><p><font color='green'><strong>默认是不淘汰</strong></font>，内存满了我拒绝添加。</p><p>如果要淘汰，内存淘汰机制分为两类：一类是对有过期时间的内存淘汰机制；一类是对所有数据的淘汰机制。</p><p><font color='green'><strong>对过期时间的内存淘汰机制可以分成四种：</strong></font></p><p>1、volatile random</p><p>2、volatile lru 最近最少使用</p><p>3、volatile lfu <strong>最近最不常用的</strong></p><p>4、volatile ttl  最早时间</p><p>对所有数据的淘汰机制：</p><p>1、volatile random</p><p>2、volatile lru 最近最少使用</p><p>3、volatile lfu <strong>最近最不常用的</strong></p></blockquote><h3 id="LRU-算法和-LFU-算法有什么区别？"><a href="#LRU-算法和-LFU-算法有什么区别？" class="headerlink" title="LRU 算法和 LFU 算法有什么区别？"></a>LRU 算法和 LFU 算法有什么区别？</h3><p>LRU</p><blockquote><p><font color='green'><strong>Redis实现lru是在RedisObject里面新增一lru个字段，记录最后一次访问时间</strong></font></p><p><font color='green'><strong>进行淘汰的时候，随机选取五个，然后淘汰访问时间最早的</strong></font></p><p><font color='green'><strong>优点：节省空间，提高性能</strong></font></p><p><font color='green'><strong>缺点：无法解决缓存污染</strong></font></p></blockquote><p>LFU</p><blockquote><p>lfu在RedisObject的基础上新增了一个字段，<font color='red'><u><em><strong>用于记录数据的访问频次</strong></em></u></font>。每次淘汰频次最低</p><p>24位 高16位记录时间戳，后8位记录访问频次，默认5，会随着时间衰减</p><p>数据每次被访问的时候：</p><p><font color='green'><strong>先对访问频次做一个时间衰减操作，根据时间和上一次访问时间的差</strong></font></p><p><font color='green'><strong>然后做一次增加的操作，这个是基于一定的概率</strong></font></p></blockquote><p><img src="/../images/Redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5.jpg" alt="img"></p><p><img src="/../images/Redis/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.jpg" alt="img"></p><h1 id="6、Redis缓存设计"><a href="#6、Redis缓存设计" class="headerlink" title="6、Redis缓存设计"></a>6、Redis缓存设计</h1><h2 id="如何解决大Key问题？"><a href="#如何解决大Key问题？" class="headerlink" title="如何解决大Key问题？"></a><strong>如何解决大Key问题？</strong></h2><p><font color='red'><u><em><strong>1、缩小key</strong></em></u></font></p><p><font color='green'><strong>就是把Key缩小，1、用gzip这种进行压缩。2、数据拆分。3、换数据、4、定期清理</strong></font></p><p><font color='red'><u><em><strong>2、增加配置</strong></em></u></font></p><p><font color='green'><strong>1、加节点。2、或者改配置，分配更大的内存空间。</strong></font></p><h2 id="热Key"><a href="#热Key" class="headerlink" title="热Key"></a>热Key</h2><p><font color='red'><u><em><strong>怎么发现热key？</strong></em></u></font></p><blockquote><p><font color='green'><strong>1、经验。2、hotkey命令，monitor命令。3、客户端服务端进行监控。</strong></font></p></blockquote><p><font color='red'><u><em><strong>怎么解决热Key？</strong></em></u></font></p><ol><li><font color='green'><strong>读写分离</strong></font></li><li><font color='green'><strong>备份：</strong></font><font color='green'><strong>把热 Key 复制到多个 Redis 实例，并在请求时随机选择一个备份实例来分散请求压力。</strong></font></li><li><font color='green'><strong>二级缓存</strong></font></li></ol><h2 id="1、如何避免缓存雪崩？"><a href="#1、如何避免缓存雪崩？" class="headerlink" title="1、如何避免缓存雪崩？"></a>1、如何避免缓存雪崩？</h2><blockquote><p><font color='green'><strong>缓存雪崩是指在同一时间大量的key同时过期了</strong></font></p><p>解决方法：</p><p><font color='green'><strong>1、打乱过期的时间</strong></font></p><p><font color='green'><strong>2、设置缓存不过期</strong></font></p></blockquote><h2 id="2、缓存击穿"><a href="#2、缓存击穿" class="headerlink" title="2、缓存击穿"></a>2、缓存击穿</h2><blockquote><p><font color='green'><strong>对于一个热点数据过期了，导致请求全部打到数据库</strong></font></p><p><font color='green'><strong>1、设置缓存不过期，后台异步的去更新</strong></font></p><p><font color='green'><strong>2、互斥锁，分布式锁的方法。让同一时间只有一个线程去访问</strong></font></p></blockquote><h2 id="3、缓存穿透"><a href="#3、缓存穿透" class="headerlink" title="3、缓存穿透"></a>3、缓存穿透</h2><blockquote><p><font color='green'><strong>访问的值既不在redis 也不在mysql，所以很可能是那种黑客攻击之类的，解决方法的话</strong></font></p><p><font color='green'><strong>1、非法请求的限制</strong></font></p><p><font color='green'><strong>2、空值或者默认值</strong></font></p><p>3、<font color='green'><u><em><strong>布隆过滤器</strong></em></u></font></p><p>布隆过滤器的主要原理是使用一组哈希函数，将元素映射成一位数组里。当要检查一个元素是否在集合中时，将该元素进行哈希处理，然后查看哈希值对应的位数组的值是否为1。如果哈希值对应的位数组的值都为1，那么这个元素可能在集合中，否则这个元素肯定不在集合中。</p><p><font color='red'><u><em><strong>3.2、怎么实现布隆过滤器</strong></em></u></font></p><p><font color='green'><strong>guava和redisson，一个是本地缓存一个是分布式缓存，一般来说我们都认为本地缓存比较珍贵，所以可以用分布式缓存</strong></font></p><p>4、<font color='green'><u><em><strong>布谷鸟过滤器</strong></em></u></font></p><p>它是一种鸠占鹊巢的过滤器，默认的布谷鸟过滤器用两个hash函数得到两个下标，如果都为空，插入一个，如果有一个空，那就插入空的位置，如果都不为空，那就随机踢出一个元素，再为这个元素重新hash做插入。</p><p><font color='red'><u><em><strong>循环挤兑</strong></em></u></font>怎么办？</p><p>1、对桶进行扩容</p><p>2、增加hash函数</p><p>区别：布谷鸟可以删除元素，查询效率更高，空间利用率更高</p></blockquote><h2 id="4、说说常见的缓存更新策略？-x2F-怎么保证数据一致性"><a href="#4、说说常见的缓存更新策略？-x2F-怎么保证数据一致性" class="headerlink" title="4、说说常见的缓存更新策略？&#x2F;怎么保证数据一致性"></a>4、说说常见的缓存更新策略？&#x2F;怎么保证数据一致性</h2><blockquote><p>redis和mysql的数据一致性其实有两类方式：<font color='red'><u><em><strong>一种是更新数据库+更新缓存，一种是更新数据库+删除缓存。</strong></em></u></font></p><p>我们一般来说是<font color='red'><u><em><strong>先更新数据库，再去删除或更新缓存</strong></em></u></font>。<font color='red'><u><em><strong>虽然在理论上存在着 一个读请求读到旧值然后准备更新到redis里面的时候，有一个写请求更新数据库并且删除了缓存，这时候读请求才把旧值缓存到redis里面，这样出现redis和mysql的不一致。但是其实由于我们的缓存写入是远远快于数据库的写入，所以很难出现我一个请求更新完数据库删除完缓存了这时候，原先的读请求才写入缓存。但是究竟是更新数据库然后更新缓存还是更新再删除，其实我觉得得看这个数据是不是热数据，如果很冷，你修改10000次，只读了一次，那命中率很低，代价很大。如果很热，那就可以双更新</strong></em></u></font></p><p>为了保证第二个操作能成功，可以订阅binlog或者消息队列做删除。</p><p>如果对一致性要求高，就需要加<font color='red'><u><em><strong>分布式锁</strong></em></u></font>和<font color='red'><u><em><strong>延迟双删</strong></em></u></font>。</p><p>但是我们业务对同步的实时性要求没那么高，我借用的是那种读穿写穿的，应用的更新操作只和缓存打交道，所以我们用的是异步消息+canal监听。redis的更新会依赖于定时任务发送异步消息同步给mysql，mysql如果有一些热点数据的修改，就监听这些数据去更新redis。</p><blockquote><p>常见的缓存更新策略共有3种：</p></blockquote><ul><li><p>Cache Aside（旁路缓存）策略；</p></li><li><p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略；</p></li><li><p>Write Back（写回）策略</p></li></ul><blockquote><p>旁路缓存策略</p><p><strong>写策略的步骤：</strong></p><ul><li>先更新数据库中的数据，再删除缓存中的数据。</li></ul><p><strong>读策略的步骤：</strong></p><ul><li>如果读取的数据命中了缓存，则直接返回数据；</li><li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户</li></ul></blockquote><blockquote><p>读穿 &#x2F; 写穿</p><p>策略原则是应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</p><p><strong>1、Read Through 策略</strong></p><ul><li>先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。</li></ul><p><strong>2、Write Through 策略</strong></p><ul><li><p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p><ul><li>如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</li><li>如果缓存中数据不存在，直接更新数据库，然后返回；</li></ul></li></ul></blockquote><blockquote><p>Write Back（写回）策略</p><p>写回在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。</p><p>实际上，Write Back（写回）策略也不能应用到我们常用的数据库和缓存的场景中，因为 Redis 并没有异步更新数据库的功能。</p><p>Write Back 是计算机体系结构中的设计，比如 CPU 的缓存、操作系统中文件系统的缓存都采用了 Write Back（写回）策略。</p></blockquote></blockquote><h1 id="7、分布式锁怎么实现"><a href="#7、分布式锁怎么实现" class="headerlink" title="7、分布式锁怎么实现"></a>7、分布式锁怎么实现</h1><p><img src="/../images/Redis/image-20231115124152900.png" alt="image-20231115124152900"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hot100</title>
      <link href="/2023/08/19/%E5%88%B7%E9%A2%98-JZ20240206/"/>
      <url>/2023/08/19/%E5%88%B7%E9%A2%98-JZ20240206/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th><strong>JZ6</strong> <strong>从尾到头打印链表</strong></th><th>0</th><th></th><th></th></tr></thead><tbody><tr><td><strong>JZ24</strong> <strong>反转链表</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ25</strong> <strong>合并两个排序的链表</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ52</strong> <strong>两个链表的第一个公共结点</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ23</strong> <strong>链表中环的入口结点</strong></td><td>0</td><td>快慢指针</td><td></td></tr><tr><td><strong>JZ22</strong> <strong>链表中倒数最后k个结点</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ35</strong> <strong>复杂链表的复制</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ76</strong> <strong>删除链表中重复的结点</strong></td><td><font color='green'><strong>1,0</strong></font></td><td>把重复的第一个记作tmp，然后略过所有和tmp相等的</td><td></td></tr><tr><td><strong>JZ55</strong> <strong>二叉树的深度</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ77</strong> <strong>按之字形顺序打印二叉树</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ54</strong> <strong>二叉搜索树的第k个节点</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ27</strong> <strong>二叉树的镜像</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ18</strong> <strong>删除链表的节点</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ7</strong> <strong>重建二叉树</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ26</strong> <strong>树的子结构</strong></td><td><font color='green'><strong>1,0</strong></font></td><td></td><td></td></tr><tr><td><strong>JZ32</strong> <strong>从上往下打印二叉树</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ33</strong> <strong>二叉搜索树的后序遍历序列</strong></td><td><font color='red'><u><em><strong>1,1</strong></em></u></font></td><td>这个需要关注一下谢谢</td><td></td></tr><tr><td><strong>JZ8</strong> <strong>二叉树的下一个结点</strong></td><td>0</td><td>Pre，可以逆中序遍历或者中序遍历记录</td><td></td></tr><tr><td><strong>JZ82</strong> <strong>二叉树中和为某一值的路径(一)</strong></td><td>0</td><td>简单的dfs</td><td></td></tr><tr><td><strong>JZ34</strong> <strong>二叉树中和为某一值的路径(二)</strong></td><td>0</td><td>不难，dfs函数里面多一个linkedlist的参数</td><td></td></tr><tr><td><strong>JZ36</strong> <strong>二叉搜索树与双向链表</strong></td><td>0</td><td>Pre,逆中序遍历或者中序遍历</td><td></td></tr><tr><td><strong>JZ79</strong> <strong>判断是不是平衡二叉树</strong></td><td>0</td><td>在深度的基础上加一个if，不难</td><td></td></tr><tr><td><strong>JZ28</strong> <strong>对称的二叉树</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ78</strong> <strong>把二叉树打印成多行</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ68</strong> <strong>二叉搜索树的最近公共祖先</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ86</strong> <strong>在二叉树中找到两个节点的最近公共祖先</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ37</strong> <strong>序列化二叉树</strong></td><td><font color='red'><u><em><strong>1,1</strong></em></u></font></td><td><font color='red'><u><em><strong>这个很重要，因为和构造二叉树有关</strong></em></u></font></td><td></td></tr><tr><td><strong>JZ84</strong> <strong>二叉树中和为某一值的路径(三)</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ30</strong> <strong>包含min函数的栈</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ9</strong> <strong>用两个栈实现队列</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ31</strong> <strong>栈的压入、弹出序列</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ73</strong> <strong>翻转单词序列</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ59</strong> <strong>滑动窗口的最大值</strong></td><td><font color='red'><u><em><strong>1,1</strong></em></u></font></td><td>两次几乎一样的循环，第二次循环多一次宽度的判断，每一次判断里面需要非空</td><td></td></tr><tr><td><strong>JZ53</strong> <strong>数字在升序数组中出现的次数</strong></td><td><font color='red'><u><em><strong>1,1</strong></em></u></font></td><td>二分，但是需要事先判断数组的范围，因为是非降序的数组</td><td></td></tr><tr><td><strong>JZ4</strong> <strong>二维数组中的查找</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ11</strong> <strong>旋转数组的最小数字</strong></td><td><font color='red'><u><em><strong>1,1</strong></em></u></font></td><td>这个二分竟然很重要</td><td></td></tr><tr><td><strong>JZ38</strong> <strong>字符串的排列</strong></td><td></td><td></td><td></td></tr><tr><td>JZ65 不用加减乘除做加法</td><td><font color='red'><u><em><strong>1,1</strong></em></u></font></td><td><font color='green'>**进位是&amp;再&lt;&lt;1，不进位的和是^。int sum &#x3D; num1, add &#x3D; num2;**</font></td><td></td></tr><tr><td><strong>JZ15</strong> <strong>二进制中1的个数</strong></td><td><font color='green'><strong>1,0</strong></font></td><td>》》》</td><td></td></tr><tr><td><strong>JZ16</strong> <strong>数值的整数次方</strong></td><td><font color='red'><u><em><strong>1,1</strong></em></u></font></td><td>1，正常。2，快速幂</td><td></td></tr><tr><td><strong>JZ56</strong> <strong>数组中只出现一次的两个数字</strong></td><td><font color='red'><u><em><strong>1,1</strong></em></u></font></td><td>先全部异或，然后找到结果第一个二进制为1，最后</td><td></td></tr><tr><td><strong>JZ64</strong> <strong>求1+2+3+…+n</strong></td><td><font color='red'><u><em><strong>1,1</strong></em></u></font></td><td>boolean flag &#x3D; (n &gt; 1) &amp;&amp; (n +&#x3D; Sum_Solution(n - 1)) &gt; 0;</td><td></td></tr><tr><td><strong>JZ42</strong> <strong>连续子数组的最大和</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ85</strong> <strong>连续子数组的最大和(二)</strong></td><td><font color='red'><u><em><strong>0.5,0.5</strong></em></u></font></td><td>可以动态规划，也可以双指针，几乎一模一样。就是双指针需要额外一个指针，更新left指针，需要一个cur储存临时的当前的值</td><td></td></tr><tr><td><strong>JZ69</strong> <strong>跳台阶</strong></td><td>0</td><td>n + 1</td><td></td></tr><tr><td><strong>JZ10</strong> <strong>斐波那契数列</strong></td><td></td><td></td><td></td></tr><tr><td><strong>JZ19</strong> <strong>正则表达式匹配</strong></td><td><font color='red'><u><em><strong>1,1</strong></em></u></font></td><td>很重要，如果为‘*’，两次if【i，j-2】，第一次0次，第二次1次或者多次，可以用aaa和 . ※进行实验。 【i, j - 1】【i-1, j】</td><td></td></tr><tr><td><strong>JZ71</strong> <strong>跳台阶扩展问题</strong></td><td><font color='red'><u><em><strong>1,0.5</strong></em></u></font></td><td>dp[i] &#x3D; dp[i - 1] * 2;</td><td></td></tr><tr><td><strong>JZ63</strong> <strong>买卖股票的最好时机(一)</strong></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>JZ47</strong> <strong>礼物的最大价值</strong></td><td>0</td><td>简单dp</td><td></td></tr><tr><td><strong>JZ48</strong> <strong>最长不含重复字符的子字符串</strong></td><td><font color='red'><u><em><strong>0.5,0.5</strong></em></u></font></td><td>两种方法，dp简单，双指针，需要更新left，更新的时候要和left自己比</td><td></td></tr><tr><td><strong>JZ46</strong> <strong>把数字翻译成字符串</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ13</strong> <strong>机器人的运动范围</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ12</strong> <strong>矩阵中的路径</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ3</strong> <strong>数组中重复的数字</strong></td><td><font color='green'><strong>1,0</strong></font></td><td>和找第一个正数一样，先把小于等于0 的置为MAXVALUE；用zero记录0的个数，如果zero大于1，返回0。剩下的就用负号进行操作。</td><td></td></tr><tr><td><strong>JZ51</strong> <strong>数组中的逆序对</strong></td><td><font color='green'><strong>1,0</strong></font></td><td>count &#x3D; (count + mid - i + 1) % 1000000007;</td><td></td></tr><tr><td><strong>JZ40</strong> <strong>最小的K个数</strong></td><td>0</td><td>快排思想</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></td><td>1</td><td>private int getKthElement(int[] nums1, int start1, int end1,  int[] nums2, int start2, int end2, int k)</td><td></td></tr><tr><td><strong>JZ41</strong> <strong>数据流中的中位数</strong></td><td><font color='green'><strong>1,0,5</strong></font></td><td>两个堆</td><td></td></tr><tr><td><strong>JZ61</strong> <strong>扑克牌顺子</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ67</strong> <strong>把字符串转换成整数(atoi)</strong></td><td><font color='green'><strong>1,0.5</strong></font></td><td>if (res &gt; Integer.MAX_VALUE &#x2F; 10 ||(res &#x3D;&#x3D; Integer.MAX_VALUE &#x2F; 10 &amp;&amp; cur &gt; Integer.MAX_VALUE % 10)) {</td><td></td></tr><tr><td><strong>JZ20</strong> <strong>表示数值的字符串</strong></td><td>0</td><td>四个is</td><td></td></tr><tr><td><strong>JZ66</strong> <strong>构建乘积数组</strong></td><td><font color='green'><strong>1,0.5</strong></font></td><td>左右两个数组</td><td></td></tr><tr><td><strong>JZ50</strong> <strong>第一个只出现一次的字符</strong></td><td>0</td><td></td><td></td></tr><tr><td><strong>JZ5</strong> <strong>替换空格</strong></td><td><font color='green'><strong>0.5,0</strong></font></td><td></td><td></td></tr><tr><td><strong>JZ21</strong> <strong>调整数组顺序使奇数位于偶数前面(一)</strong></td><td><font color='green'><strong>1,0.5</strong></font></td><td>两种方法，1：两次遍历第一次记录奇数，第二次记录偶数。2：插入排序</td><td></td></tr><tr><td><strong>JZ39</strong> <strong>数组中出现次数超过一半的数字</strong></td><td>0.5</td><td>简单用哈希，进阶用众数思想，遇到众数+1，反之减1</td><td></td></tr><tr><td><strong>JZ43</strong> <strong>整数中1出现的次数（从1到n整数中1出现的次数）</strong></td><td>1</td><td></td><td></td></tr><tr><td>JZ45 把数组排成最小的数</td><td><font color='green'><strong>0.5,0</strong></font></td><td></td><td></td></tr><tr><td><strong>JZ49</strong> <strong>丑数</strong></td><td><font color='green'><strong>1,0</strong></font></td><td><font color='red'><u><em><strong>关键在于3个if 不是一个if+elseif</strong></em></u></font></td><td></td></tr><tr><td><strong>JZ81</strong> <strong>调整数组顺序使奇数位于偶数前面(二)</strong></td><td></td><td>对相对位置不做要求，那就直接前后双指针</td><td></td></tr><tr><td><strong>JZ74</strong> <strong>和为S的连续正数序列</strong></td><td><font color='green'><strong>0.5,0.5</strong></font></td><td>两个前指针，1,2</td><td></td></tr><tr><td><strong>JZ57</strong> <strong>和为S的两个数字</strong></td><td><font color='green'><strong>0.5,0</strong></font></td><td>前后指针，0， n-1</td><td></td></tr><tr><td><strong>JZ58</strong> <strong>左旋转字符串</strong></td><td></td><td>两次substring就好，别想太难</td><td></td></tr><tr><td><strong>JZ75</strong> <strong>字符流中第一个不重复的字符</strong></td><td></td><td></td><td></td></tr><tr><td><strong>JZ17</strong> <strong>打印从1到最大的n位数</strong></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hot100</title>
      <link href="/2023/08/19/%E5%88%B7%E9%A2%98-hot/"/>
      <url>/2023/08/19/%E5%88%B7%E9%A2%98-hot/</url>
      
        <content type="html"><![CDATA[<p><font color='red'><u><em><strong>正则表达式很重要：</strong></em></u></font></p><details>  public class Solution {    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *     * @param str string字符串     * @param pattern string字符串     * @return bool布尔型     */    public boolean match (String str, String pattern) {        // write code here        int n  = str.length();        int m = pattern.length();        boolean [][] dp = new boolean[n + 1][m + 1];        dp[0][0] = true;        for (int i = 1; i <= m; i++) {            if (pattern.charAt(i - 1) == '*') {                dp[0][i] = dp[0][i - 2];            }        }        for (int i = 1; i <= n; i++) {            for (int j = 1; j <= m; j++) {                if (str.charAt(i - 1) == pattern.charAt(j - 1)) {                    dp[i][j] = dp[i - 1][j - 1];                } else if (pattern.charAt(j - 1) == '.') {                    dp[i][j] = dp[i - 1][j - 1];                } else {                                // 0 次 dp[i][j - 1]                    if (j >= 2) {                        dp[i][j] |= dp[i][j - 2];                    }                                         if (j >= 2 &&  i >= 1 && (pattern.charAt(j - 2) == '.' || str.charAt(i - 1) == pattern.charAt(j - 2))) {                        // 1 次 dp[i][j - 2]                        dp[i][j] |= dp[i][j - 1];                        // >1 次 dp[]                        dp[i][j] |= dp[i - 1][j];                     }                }            }        }        return dp[n][m];  }  }</details>  <p><strong>旋转数组的最小数字</strong> </p><p><strong>JZ48</strong> <strong>最长不含重复字符的子字符串</strong> 动态规划+hashmap或者滑动窗口+hashmap，<font color='green'><u><em><strong>这题总是忘记</strong></em></u></font></p><p><strong>数组中重复的数字</strong> 交换 </p><p><strong>数组中的逆序对</strong> 归并排序</p><p><strong>最小的K个数</strong></p><p>:red_circle:<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a> ：非常重要，因为有个极端情况，最好快速排序前先来一次随机位，和0位交换。</p><p>划分字母区间：贪心</p><p>:red_circle: 缺失的第一个正数 : 巧妙地思想，需要先负的变成n + 1， 然后把存在的那个下标对应的置为负数，最后遍历，如果有负数就直接返回i + 1；</p><details>  int k;    ArrayList<Integer> list = new ArrayList<Integer>();    public ArrayList<Integer> GetLeastNumbers_Solution (int[] input, int k) {        // write code here        this.k = k;        quickSort(input, 0 , input.length - 1);        return list;    }    public void quickSort(int[] input, int left, int right) {        if (left > right) {            return;        }        int i = left;        int j = right;        int t = input[left];        while (i < j) {            while (i < j && input[j] >= t) {                j--;            }            while (i < j && input[i] <= t) {                i++;            }             swap(input, i ,j);        }        swap(input, left, i);        if (i == k - 1) {            for (int z = 0; z < k; z ++) {                list.add(input[z]);            }            return;        } else {            if (k > i) {                quickSort(input, i + 1, right);            } else {                quickSort(input, left, i - 1);            }        }    }</details><p>:red_circle: <strong>数据流中的中位数</strong> 两个堆，一个最大堆，一个最小堆</p><p>:cactus:最长回文串：动态规划，boolean</p><p>:cactus:没有重复字符的最长子串：借助map的滑动窗口</p><p>:cactus:寻找两个正序数组的中位数：</p><p>:cactus:<a href="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a> : 双指针</p><p>:cactus:Lru : 多练，<font color='green'><u><em><strong>两个指针+Map使用伪头部和伪尾部节点(多写三个函数，删除最后的，增加最前的，删除中间的)</strong></em></u></font> ()</p><p><a href="https://leetcode.cn/problems/regular-expression-matching/">:cactus:正则表达式匹配</a>: 动态规划，条件较复杂</p><p>:cactus:三数之和：两个循环，第二个循环用前后双指针。两个循环里面都要做去重，都是和前一个对比if (second &gt; first + 1 &amp;&amp; nums[second] &#x3D;&#x3D; nums[second - 1]) {continus;</p><p>:cactus:括号生产：较简单的dfs:cactus:</p><p><a href="https://leetcode.cn/problems/group-anagrams/">:cactus:字母异位词分组</a> : 简单的</p><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">:cactus:滑动窗口最大值</a> :  单调队列，用linkedlist</p><p>:cactus:<a href="https://leetcode.cn/problems/next-permutation?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">下一个排列</a> : 要推导一下，<font color='green'><u>***先一个循环从右往左找到第一个a[i] &lt;a[i + 1]，然后再用一个和上面那个同等级的循环去从右往左找到第:cactus:一个小于a[i]的交换，然后Arrays.sort(nums, left + 1, n);***</u></font></p><p><a href="https://leetcode.cn/problems/longest-valid-parentheses/">:cactus:最长有效括号</a> : <font color='blue'><u><em><strong>动态规划</strong></em></u></font> 很有趣</p><p>:cactus:不同路径 ： 动态规划</p><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">:cactus: 和为 K 的子数组</a> ： <font color='blue'><u><em><strong>是前缀和 + map</strong></em></u></font>, 很有趣。1 2 3 4 5 6, 每次判断前j个减去前i个是不是等于k，用map优化</p><p>:cactus:<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a> :  <font color='red'><u><em><strong>动态规划</strong></em></u></font> 这个非常重要, 背包问题，<font color='red'><u><em><strong>int[n] [target]</strong></em></u></font>  </p><p>:cactus:<font color='red'><u><em><strong><a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a>：不是动态规划，从小遍历到n，然后每次遍历判断</strong></em></u></font></p><details>    for (int i = 0; i < nums.length; i++) {            if (k < i) {                return false;            }            k = Math.max(k, i + nums[i]);        }</details>:red_circle: 还有个跳跃游戏2：可以动态规划，但是时间复杂度高，所以可以用贪心，但是要注意一点for循环的条件是 i < n - 1<hr><p>:cactus:电话号码的字母组合 : 回溯</p><p><font color='red'><u><em><strong><a href="https://leetcode.cn/problems/daily-temperatures/">:cactus:每日温度</a> 如果能想到用单调栈 就会比较简单。遍历的每次都先从栈里面弹出比自己小的。</strong></em></u></font></p><details>  de.offerLast(0);        for (int i = 1; i < n; i++) {            while (!de.isEmpty() && temperatures[de.peekLast()] < temperatures[i]) {                int t = de.pollLast();                res[t] = i - t;            }            de.offerLast(i);        }</details>---<p>:cactus:<font color='red'><u><em><strong>搜索旋转排序数组 : 二分法，</strong></em></u></font> <font color='green'><u><em><strong>经常没写出来</strong></em></u></font> </p><details>  if (nums[0] <= nums[mid]) {            if ( target <= nums[mid] && target >= nums[left] ) {                return find(nums, target, left, mid - 1);            } else {                return find(nums, target, mid + 1, right);            }        } else {            if ( target >= nums[mid] && target <= nums[right]) {                return find(nums, target, mid + 1, right);            } else {                return find(nums, target, left, mid - 1);            }        }</details>---<p>:cactus:<a href="https://leetcode.cn/problems/course-schedule/">课程表</a> : DFS 分三个状态，分别是未搜索0，搜索中1， 结束2. <font color='red'><u><em><strong>多做————–</strong></em></u></font></p><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">:cactus:二叉树中的最大路径和</a> : 回溯，挺有意思的</p><details>  int Lson = Math.max(recurtion(root.left), 0);        int Rson = Math.max(recurtion(root.right), 0);        maxV = Math.max(maxV, root.val + Lson + Rson);        return root.val + Math.max(Lson, Rson);</details>---<p>:cactus:链表排序：<font color='red'><u><em><strong>需要很熟练</strong></em></u></font></p><details>    public ListNode sort(ListNode head) {        // find mid point        if (head == null) {            return null;        } else if (head.next == null) {            return head;        }        ListNode pre = head;        ListNode left = head;        ListNode right = head.next;        while (right != null && right.next != null) {            pre = left;            left = left.next;            right = right.next.next;  else {                tmp.next = tmpRight;                tmpRight = tmpRight.next;                tmp = tmp.next;            }</details><hr><p>:cactus:<a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并 K 个升序链表</a> 用最小堆 </p><p>:cactus:全排列：dfs 加一个辅助的set</p><p>:cactus:<a href="https://leetcode.cn/problems/subsets/">子集</a> :DFS 然后用到当前的位置</p><details>  public void dfs(int[] nums, int nowIndex, Deque<Integer> ll) {        if (nowIndex == nums.length) {            list.add(new ArrayList<>(ll));            return;        }        ll.offerLast(nums[nowIndex]);        dfs(nums, nowIndex + 1, ll);        ll.removeLast();        dfs(nums, nowIndex + 1, ll);    }</details><hr><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">:cactus:实现 Trie (前缀树)</a> ：用字典，很重要，因为第二次没想起来</p><details>  private Trie[] childen;    private boolean isEnd;    public Trie() {        childen = new Trie[26];        isEnd = false;    }  public void insert(String word) {        Trie node = this;        for (int i = 0; i < word.length(); i++) {            char ch = word.charAt(i);            int index = ch - 'a';            if (node.childen[index] == null) {                node.childen[index] = new Trie();               }            node = node.childen[index];        }        node.isEnd = true;    }</details><hr><p>:cactus:<a href="https://leetcode.cn/problems/word-break/">单词拆分</a> ：简单的dp</p><details>  for (int i = 1; i <= n; i++) {            for (int j = 0; j < i; j++) {                String tmp = s.substring(j, i);                if (dp[j] == true && set.contains(tmp)) {                    dp[i] = true;                }            }        }</details><hr><p>:cactus: <a href="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a> : 需要两个dp数组，一个最小，一个最大,对比的时候要用两个Math.max Math.min哈哈</p><p>:question::question::question::question::question: <a href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a> 没写出来</p><details>  public int numTrees(int n) {        int dp[] = new int[n + 1];        dp[0] = 1;        dp[1] = 1;        for (int i = 2; i <= n; i++) {            for (int j = 1; j <= i; j ++) {                dp[i] += dp[j - 1] * dp[i - j];            }        }        return dp[n];    }</details><hr><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">:question::question::question::question::question:柱状图中最大的矩形 </a> 一开始没写出来 <font color='red'><u><em><strong>单调栈</strong></em></u></font></p><details>  for (int i = 0; i < heights.length; i++) {            while (!de.isEmpty() && heights[de.peekLast()] >= heights[i]) {                de.pollLast();            }            left[i] = (de.isEmpty() ? -1 : de.peekLast());            de.offerLast(i);        }        de.clear();        for (int i = n - 1; i >= 0; i --) {            while (!de.isEmpty() && heights[de.peekLast()] >= heights[i]) {                de.pollLast();      }        right[i] = (de.isEmpty() ? n : de.peekLast());        de.offerLast(i);    }  </details><p>:question::question::question::question::question:<a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a> ：滑动窗口+两个map对比，两个map对比的关键在于if (windows.getOrDefault(entries.getKey(), 0) &lt; entries.getValue()) </p><p>:question::question::question::question::question:<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"> 从前序与中序遍历序列构造二叉树</a> <font color='red'><u><em><strong>很重要， 四个未知参数</strong></em></u></font></p><p><a href="https://leetcode.cn/problems/sort-colors/">:question::question::question::question::question:颜色分类</a> ，<font color='red'><u><em><strong>好几次没写出来</strong></em></u></font> 双指针，一个指代0，一个指代1，遇到1交换p1++，遇到0，交换，然后如果p0&lt;p1也要交换。p1++ p0++</p><p>:question::question::question::question::question:<a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a> <font color='red'><u><em><strong>没做出来2次</strong></em></u></font> </p><p>:question::question::question::question::question: <a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/"> 最短无序连续子数组</a> <font color='red'><u><em><strong>没做出来</strong></em></u></font>  双指针，一次遍历，更新max 和 min</p><details>        int max = Integer.MIN_VALUE, right = -1;        int min = Integer.MAX_VALUE, left = -1;        int n = nums.length;        for (int i = 0; i < nums.length; i ++) {            if (nums[i] < max) {                right = i; // num【i】比前面的最大值小 有问题，把i记录下来，            } else {                max = nums[i]; // max > 前面所有的， 没问题 更新最大值            }            if (min < nums[n - 1 - i]) {                left = n - 1 - i;            } else {                min = nums[n - 1 - i];            }        }        return right == -1 ? 0 : right - left + 1;</details><p>:question::question::question::question::question:<a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a>  <font color='red'><u><em><strong>没写出来 先序遍历的逆序遍历</strong></em></u></font></p><p>:question::question::question::question::question: <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a>  <font color='red'><u><em><strong>没写出来 中序遍历的逆序遍历</strong></em></u></font></p><p>:question::question::question::question::question:<a href="https://leetcode.cn/problems/evaluate-division/">除法求值</a> 先构造图，然后dfs</p><p>:question::question::question::question::question:<a href="https://leetcode.cn/problems/meeting-rooms-ii/">会议室 II</a> 用优先级队列</p><details>  class Solution {    public int minMeetingRooms(int[][] intervals) {        PriorityQueue<int[]> qp = new PriorityQueue<>(new Comparator<int[]>() {            public int compare(int[] a, int[] b){                if (a[0] == b[0]) {                    return a[1] - b[1];                } else {                    return a[0] - b[0];                }            }        });        for (int[] inin : intervals) {            qp.add(new int[]{inin[0], 1});            qp.add(new int[]{inin[1], -1});        }        int count = 0;        int maxv = 0;        while (!qp.isEmpty()) {            count += qp.remove()[1];            maxv = Math.max(maxv, count);        }        return maxv;    }}</details><p>:question::question::question::question::question: <a href="https://leetcode.cn/problems/path-sum-iii/">路径总和 III</a> <font color='red'><u><em><strong>前缀和，没做出来</strong></em></u></font> </p><details>   public void dfs(TreeNode root, Map<Long, Integer> prefix, long curr, int targetSum) {        if (root == null) {            return;        }        curr += root.val;        count += prefix.getOrDefault(curr - targetSum, 0);        prefix.put(curr, prefix.getOrDefault(curr, 0) + 1);        dfs(root.left, prefix, curr, targetSum);        dfs(root.right, prefix, curr, targetSum);        prefix.put(curr, prefix.getOrDefault(curr, 0) - 1);    }</details><p><a href="https://leetcode.cn/problems/find-the-duplicate-number/">寻找重复数</a> <font color='red'><u><em><strong>没写出来</strong></em></u></font> 二分查找，每次二分都遍历，看看mid对应的《&#x3D;mid 的个数，如果大于mid，说明重复的在left，mid；反之mid+1， left</p><details>  int left = 0, right = n - 1;        while (left < right) {            int mid = (left + right) / 2;            int curCount = 0;            for (int i = 0; i < n; i++) {                if (nums[i] <= mid) {                    curCount++;                }            }            if (curCount > mid) {                right = mid;            } else {                left = mid + 1;            }        }        return left;</details><p>:cactus:<a href="https://leetcode.cn/problems/task-scheduler/">任务调度器</a> 自己写出来了，不过用的是模拟的方法，其实还有另外的规律的方法:</p><details>  HashMap<Character, Integer> map = new HashMap<>();        for (int i = 0; i < tasks.length; i ++) {            map.put(tasks[i], map.getOrDefault(tasks[i], 0) + 1);        }        int bufa = 0;        while (!map.isEmpty()) {            int count = 0;            List<Character> tmp =  new ArrayList<>(map.keySet());            Collections.sort(tmp, new Comparator<Character>() {                public int compare(Character a, Character b) {                return map.get(b) - map.get(a);                }            });            for (Character ch : tmp) {                if (map.get(ch) == 1) {                     map.remove(ch);                 }  else {                    map.put(ch, map.get(ch) - 1);                 }                 count++;                 bufa++;                 if (count > n) {                     break;                 }            }            if (map.isEmpty()) {                break;            }            while (count <= n) {                count++;                bufa++;            }                   }        return bufa;</details><p>:cactus:<a href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍 III</a> 回溯，<font color='red'><u><em><strong>很重要得会</strong></em></u></font></p><p>:cactus:最长递增子序列: 很简单的dp，但是一开始没想到</p><p>:cactus:<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词 </a> 用两个map 指定大小的滑动窗口慢慢划过去就好，不难，注意.equal</p><details>  int n = nums.length;        int dp[] = new int[n];        dp[0] = 1;        int max = 1;        for (int i = 1; i < n; i ++) {            dp[i] = 1;            for (int j = 0; j < i; j++) {                if (nums[i] > nums[j]) {                    dp[i] = Math.max(dp[i], dp[j] + 1);                }             }            max = Math.max(max, dp[i]);        }        return max;</details><hr><p>:cactus:<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/"> 二叉树的最近公共祖先</a> : dfs </p><p>:cactus:<a href="https://leetcode.cn/problems/top-k-frequent-elements/">前 K 个高频元素</a> ：第二遍自己写出来了，就是map统计个数，然后把频率变成key，放到另外一个HashMap&lt;Integer, ArrayList<Integer>&gt; map22 &#x3D; new HashMap&lt;&gt;();里面</p><p>:red_circle:<a href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树的直径 </a> 第二次没想起来，其实就是求节点数量，不难</p><p>:cactus: <a href="https://leetcode.cn/problems/word-search/">单词搜索</a> 挺有意思的，不难</p><p><a href="https://leetcode.cn/problems/product-of-array-except-self/">:cactus:除自身以外数组的乘积</a> ：弄个left数组和right数组</p><p>:cactus: <a href="https://leetcode.cn/problems/palindromic-substrings/">回文子串</a> : 动态规划  不难 二维动态数组</p><p>:cactus:<a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a> 动态规划 不难</p><p>:evergreen_tree:<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">买卖股票的最佳时机含冷冻期</a>：dp【n】【2】 两个状态 <font color='red'><u><em><strong>第二次没写出来</strong></em></u></font></p><p>:evergreen_tree:<a href="https://leetcode.cn/problems/combination-sum/">组合总和</a> dfs</p><p>:evergreen_tree:<a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">根据身高重建队列</a> : 排序：先通过元素1降序，然后元素2升序。<font color='red'><u><em><strong>然后利用list的按位插入</strong></em></u></font>：核心思想：高的先排好，矮的插入</p><p>:evergreen_tree:<a href="https://leetcode.cn/problems/decode-string/">字符串解码</a> 很有意思，<font color='red'><u><em><strong>两个栈</strong></em></u></font></p><p>:thumbsup: <a href="https://leetcode.cn/problems/maximal-rectangle/">最大矩形</a> 困难题， 单调栈，很有趣，值得学习</p><p>:tangerine:<a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">找到所有数组中消失的数字</a> 没写出来</p><p><a href="https://leetcode.cn/problems/string-to-integer-atoi/">字符串转换整数 (atoi)</a> <font color='red'><u><em><strong>没写出来</strong></em></u></font></p><details>  if (res > Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 && cur > Integer.MAX_VALUE % 10)) {                return Integer.MAX_VALUE;            }            if (res < Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE / 10 && cur < (Integer.MIN_VALUE % 10))) {                return Integer.MIN_VALUE;            }</details><hr><p>简单的一些：</p><p><a href="https://leetcode.cn/problems/add-strings/">字符串相加</a> ：后往前一个一个加，最后逆序</p><p><a href="https://leetcode.cn/problems/min-stack/">最小栈</a> : 用两个栈</p><p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">搜索二维矩阵 II</a> 从右上角开始遍历</p><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">合并二叉树</a> <font color='red'><u><em><strong>递归</strong></em></u></font></p><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a> </p><p><a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a> : 很简单的回溯，不能不会</p><p>只出现一次的数字 : <font color='red'><u><em><strong>异或</strong></em></u></font></p><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a> : 反转链表，对比，反正的时候需要用新的node</p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a> : 双指针，关键在构造一个首节点</p><p>最大正方形：简单的dp</p><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a>  两次logn <font color='green'><u>***中间对比的时候要加等于号，while (left &lt;&#x3D; right)***</u></font></p><p><a href="https://leetcode.cn/problems/move-zeroes/">移动零</a> :最好还是回忆一下</p><p>旋转矩阵</p><p><a href="https://leetcode.cn/problems/counting-bits/">比特位计数</a></p><p><a href="https://leetcode.cn/problems/hamming-distance/">汉明距离</a> <font color='red'><u><em><strong>异或 位运算符</strong></em></u></font></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hot100</title>
      <link href="/2023/08/19/%E5%88%B7%E9%A2%98-hot1000124/"/>
      <url>/2023/08/19/%E5%88%B7%E9%A2%98-hot1000124/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></th><th>0</th><th></th><th></th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></td><td><font color='green'><strong>1-0-0.5</strong></font></td><td>String字符串排序方法：先<font color='red'><u>***toCharArray()+Arrays.sort()   ***</u></font>                                                                    map转成Arraylist：<font color='red'><u><em><strong>ArrayList&lt;&gt;(map.values())</strong></em></u></font></td><td>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]                                                                    输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</td></tr><tr><td><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></td><td>0;0</td><td>Set.contains | hashmap.containsKey</td><td>输入：nums &#x3D; [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</td></tr><tr><td><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></td><td>1;0;0</td><td>两个指针，一个zero一个left，都是从左到右</td><td>输入: nums &#x3D; [0,1,0,3,12] 输出: [1,3,12,0,0]</td></tr><tr><td><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></td><td>0;0</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></td><td><font color='red'><u><em><strong>0;1</strong></em></u></font></td><td><font color='red'><u><em><strong>两重循环</strong></em></u></font>，关键在于，每一次循环紧跟着一个continue的判断</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></td><td><font color='red'><u><em><strong>0.5;0.5</strong></em></u></font></td><td>有数组，也可以去数组,建议用没有数组的，左边最大值，右边最大值</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></td><td>动态规划0 滑动窗口1;0</td><td>滑动窗口的关键：if (map.containsKey(s.charAt(i))) {                left &#x3D; Math.max(map.get(s.charAt(i)) + 1, left);            }</td><td>输入: s &#x3D; “abcabcbb” 输出: 3  解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</td></tr><tr><td><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></td><td><font color='red'><u><em><strong>1,0.5</strong></em></u></font></td><td><font color='red'><u><em><strong>用数组最简单。</strong></em></u></font>用两个map<font color='red'><u>*** 指定大小***</u></font>的滑动窗口慢慢划过去就好，不难，<font color='red'><u><em><strong>注意.equal</strong></em></u></font>;<font color='red'><u><em><strong>getOrDefault</strong></em></u></font></td><td>输入: s &#x3D; “cbaebabacd”, p &#x3D; “abc” 输出: [0,6] 解释: 起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。 起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</td></tr><tr><td><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></td><td><font color='red'><u><em><strong>1-1-1</strong></em></u></font></td><td><font color='red'><u><em><strong>前缀和+Hashmap，一个循环就够了，不要用dfs</strong></em></u></font></td><td>输入：nums &#x3D; [1,1,1], k &#x3D; 2 输出：2</td></tr><tr><td><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></td><td>0 困难</td><td>两次几乎一样循环，第二次循环多考虑了宽度的问题,也需要非空，虽然是困难，但是不难</td><td>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3 输出：[3,3,5,5,6,7]</td></tr><tr><td><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></td><td>0 困难</td><td>虽然是困难，但是和前一题目基本一样</td><td>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC” 输出：”BANC” 解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、’B’ 和 ‘C’。</td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></td><td>0</td><td><font color='red'><u><em><strong>de.toArray(new int[de.size()][]);</strong></em></u></font></td><td>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]                                                                                输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</td></tr><tr><td><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></td><td>0</td><td>return a - b是升序，return b - a 降序。思考的时候假定一个1,2，然后2-1大于0，需要改变位置，所以b - a是降序</td><td>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</td></tr><tr><td><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></td><td>0</td><td>自己定义一个reverse函数，调用三次。int index &#x3D; (k) % n; re(nums, 0, n - 1);  re(nums, 0, index - 1);    re(nums, index, n - 1);</td><td>输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3 输出: [5,6,7,1,2,3,4]</td></tr><tr><td><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></td><td>0</td><td>可以用两个数组分别存左边的乘积和右边的乘积，<font color='blue'><u><em><strong>也可以不需要两个数组</strong></em></u></font></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></td><td>0</td><td>三次循环，第一次处理负数，第二次操作下标，第三次出结果</td><td>输入：nums &#x3D; [1,2,0] 输出：3</td></tr><tr><td><a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></td><td><font color='red'><u><em><strong>1,1</strong></em></u></font></td><td>我用了六次循环，思想：1-n如果有0，就让下标为0的置为0，用另外两个变量存储0行0列的是否为0的情况</td><td>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法<strong>。</strong></td></tr><tr><td><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></td><td><font color='red'><u><em><strong>0;0.5</strong></em></u></font></td><td><font color='red'><u><em><strong>一个while里面四个for循环</strong></em></u></font></td><td>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</td></tr><tr><td><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></td><td>0,0</td><td>两次旋转，一次对称一次对折。就是旋转的范围需要整理一下</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></td><td>0,0</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></td><td>0,0</td><td>走一遍自己的，再走一遍别人的 h1 &#x3D; h1 &#x3D;&#x3D; null ? headB : h1.next;</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></td><td>0,0</td><td>1、dummyHead 2、头插  3 关键在于：slow &#x3D; head，fast &#x3D; head.next</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></td><td>0,0</td><td><font color='blue'><u><em><strong>关键在于：slow &#x3D; head，fast &#x3D; head.next</strong></em></u></font>。为什么一定相遇：因为进入环后，快指针是一个点一个点靠近慢指针</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></td><td>0,0</td><td><font color='blue'><u><em><strong>关键在于：slow &#x3D; head，fast &#x3D; head</strong></em></u></font>。这里slow和fast是同一个起点</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></td><td>0,0</td><td>while两个非空，拼接非空的</td><td>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4] 输出：[1,1,2,3,4,4]</td></tr><tr><td><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a> <font color='red'><u><em><strong>困难</strong></em></u></font></td><td>0,0</td><td></td><td>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3 输出：[3,2,1,4,5]</td></tr><tr><td>[19. 删除链表的倒数第 N 个结点<font color='blue'><u><em><strong>中等</strong></em></u></font></td><td>0,0</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a>中等</td><td>0</td><td>注意有一个进位就好</td><td>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4] 输出：[7,0,8] 解释：342 + 465 &#x3D; 807.</td></tr><tr><td><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a>中等</td><td>0</td><td>不过和上面那个k个反转不一样，直接进行变化就可以while (cur.next !&#x3D; null &amp;&amp; cur.next.next !&#x3D; null) {</td><td>输入：head &#x3D; [1,2,3,4] 输出：[2,1,4,3]</td></tr><tr><td>随机复制</td><td>0</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>简单</td><td><font color='red'><u><em><strong>0,1</strong></em></u></font></td><td><font color='red'><u><em><strong>学会如何用不递归的</strong></em></u></font>，递归,</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></td><td>0;0</td><td>递归return Math.max(left, right) + 1;</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></td><td>0;0</td><td>不难别想多，递归函数就一个cur参数</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></td><td>0;0</td><td>递归函数两个参数（left，right），第一次是（root，root）hh</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></td><td>0,0</td><td>在最大深度的基础上加一个全局变量就好</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></td><td>0</td><td>bfs</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></td><td><font color='red'><u><em><strong>0,1</strong></em></u></font></td><td>直接就是中序遍历的逆操作</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></td><td>0</td><td>可以中序递归，也可以中序逆递归。关键在于有一个pre变量记录前一个值，哈哈</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></td><td>0</td><td>先序遍历的逆遍历</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></td><td>0</td><td>中序遍历</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></td><td>0</td><td>层序遍历</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></td><td>0</td><td>构造二叉树</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></td><td>0</td><td><font color='red'><u><em><strong>1、map.put(0L, 1); 2、先+，然后put</strong></em></u></font></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></td><td>0</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></td><td>0</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></td><td>0</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></td><td><font color='red'><u><em><strong>0;1</strong></em></u></font></td><td>BFS，挺有趣</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></td><td><font color='green'><strong>1;0;0</strong></font></td><td>DFS找有没有环.需要一个visit数组0,1,2</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></td><td><font color='green'><strong>0.5;0.2</strong></font></td><td><font color='red'><u><em><strong>Trie[] trie;    boolean end &#x3D; false;if (node.trie[index] &#x3D;&#x3D; null) {                node.trie[index] &#x3D; new Trie();  }</strong></em></u></font></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></td><td><font color='red'><u><em><strong>0.2;0.2</strong></em></u></font></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></td><td><font color='red'><u><em><strong>0;0.5</strong></em></u></font></td><td><font color='red'><u><em><strong>注意要在left &#x3D;&#x3D; n的时候再addlist</strong></em></u></font></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></td><td><font color='green'><strong>0;0</strong></font></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></td><td><font color='green'><strong>0;0</strong></font></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></td><td><font color='green'><strong>0;0</strong></font></td><td>这些回溯都要有一个参数是begin</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></td><td><font color='green'><strong>0;0</strong></font></td><td></td><td></td></tr><tr><td><font color='red'><u><em><strong>重要</strong></em></u></font><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></td><td><font color='green'><strong>0.5;0</strong></font></td><td><font color='red'><u><em><strong>先动态规划，然后dfs</strong></em></u></font></td><td></td></tr><tr><td><font color='red'><u><em><strong>重要</strong></em></u></font><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></td><td><font color='red'><u><em><strong>0;0.5</strong></em></u></font></td><td><font color='red'><u><em><strong>dfs判断的时候，斜率判断不要用触发，要用两条边长度是否相等，不难。StringBuffer也有深拷贝和浅拷贝，所以不能直接赋值</strong></em></u></font></td><td></td></tr><tr><td><font color='red'><u><em><strong>(非常重要)</strong></em></u></font><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></td><td>1,0</td><td>if (text1.charAt(i) &#x3D;&#x3D; text2.charAt(j)) {                dpi,j &#x3D; dp[i - 1]j - 1] + 1;  } else {  dp[i]j] &#x3D; Math.max(dp[i[j - 1], dp[i - 1][j);  }</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></td><td>00</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></td><td><font color='red'><u><em><strong>0;0.5</strong></em></u></font></td><td>类似70</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></td><td>0;0</td><td>类似70</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></td><td><font color='red'><u><em><strong>1;0.5</strong></em></u></font></td><td><font color='red'><u><em><strong>双重遍历，第二重遍历有两类，可以从0到i，也可以对list遍历</strong></em></u></font></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></td><td><font color='red'><u><em><strong>0;1</strong></em></u></font></td><td>有一种ologn的方法，贪心+二分。另一种On2类似70</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a></td><td>0</td><td>维护两个数组，一个最大一个最小，0索引都是num（0）</td><td></td></tr><tr><td>(<font color='red'><u><em><strong>重要</strong></em></u></font>)<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></td><td><font color='red'><u><em><strong>1,0.5</strong></em></u></font></td><td>这个正常情况下是二维dp，dp【n】【sum &#x2F; 2】，但是可以优化成1维的。</td><td>输入：nums &#x3D; [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。</td></tr><tr><td><font color='red'><u><em><strong>(困难)</strong></em></u></font><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></td><td><font color='red'><u><em><strong>0;1</strong></em></u></font></td><td><font color='red'><u><em><strong>还是需要联系，其实并不难</strong></em></u></font></td><td>输入：s &#x3D; “(()” 输出：2 解释：最长有效括号子串是 “()”</td></tr><tr><td><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></td><td>00</td><td>最简单的dp</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></td><td>00</td><td>最简单的dp</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></td><td>00</td><td><font color='red'><u><strong><em>回文的套路就是，new一个n</em>n大小的dp数组，第一重循环就后往前，第二重从i到后</strong>*</u></font></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></td><td>00</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></td><td>0</td><td>三个指针，一个right，一个zero，一个first</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></td><td><font color='red'><u><em><strong>1;1</strong></em></u></font></td><td><font color='red'><u><em><strong>第一种方法：快慢指针，第一次循环两步走，第二次循环一步走。第二种方法：二分查找</strong></em></u></font></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></td><td>0.5</td><td><font color='red'><u><em><strong>先判断有没有，再判断容量。算上putget，一共4个函数，新的两个一个delete一个tohead。delete里面先判断容量，在判断contains，四种情况</strong></em></u></font></td><td></td></tr><tr><td>排序链表</td><td>0</td><td></td><td></td></tr><tr><td>合并k个链表</td><td>0</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></td><td><font color='red'><u><em><strong>1</strong></em></u></font></td><td><font color='red'><u><em><strong>只需要一个dp数据，两个也能做，一个够用</strong></em></u></font></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></td><td><font color='red'><u><em><strong>1</strong></em></u></font></td><td>和下面一个很像，但是有不一样的地方</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></td><td><font color='red'><u><em><strong>0.5</strong></em></u></font></td><td><font color='red'><u>***最后一个不需要范围i &lt; n - 1;***</u></font></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></td><td><font color='red'><u><em><strong>0.2</strong></em></u></font></td><td>单调栈，求两个 数组，一个left，一个right，有两种poll的方式。</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></td><td>0</td><td>用上栈就很简单</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></td><td><font color='green'><strong>0;0</strong></font></td><td><font color='red'><u><em><strong>应该熟悉，用的快速排序</strong></em></u></font></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></td><td>0</td><td>两个map搞定，这个应该很熟练才对</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></td><td>0</td><td>两个栈就可以解决</td><td></td></tr><tr><td>字符串解码</td><td><font color='red'><u><em><strong>0.2</strong></em></u></font></td><td>两个栈，一个数字栈，一个string栈</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></td><td><font color='red'><u><em><strong>1;1</strong></em></u></font></td><td>和下面一题很像</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></td><td><font color='red'><u><em><strong>1;0.5</strong></em></u></font></td><td><font color='red'><u><em><strong>需要多练习。先判断哪里有序，然后判断</strong></em></u></font></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></td><td>1</td><td>做二分要【l，mid，r】，看看是找最后一个大于小于，还是第一个大于小于。</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></td><td>0</td><td>&#x2F;&#x2F;找到第一个大于等于:if (nums[mid] &gt;&#x3D; target) {right &#x3D; mid}else l &#x3D; mid + 1;</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></td><td>1</td><td>return mid;摩尔投票</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></td><td>0</td><td>0和所有异或</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java刷题</title>
      <link href="/2023/08/19/%E5%88%B7%E9%A2%98-shua/"/>
      <url>/2023/08/19/%E5%88%B7%E9%A2%98-shua/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int left = 0;</span><br><span class="line">        int right = data.length - 1;</span><br><span class="line">        //二分左右界</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if(data[mid] &lt; k)</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            else if(data[mid] &gt; k)</span><br><span class="line">                right = mid - 1;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><font color='green'><strong>数组中第k大的元素</strong></font>：要想排一个递增的，先从右开始遍历</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><blockquote><p>难：<font color='red'><u><em><strong>序列化二叉树</strong></em></u></font>  层序遍历或者先序遍历</p><p><font color='blue'><u><em><strong>递归</strong></em></u></font></p><p><font color='red'><u><em><strong>前序遍历、中序遍历、后序遍历、最大深度（等于左右子树最大的+1）。</strong></em></u></font>全部都是递归解决，无非就是赋值和两个递归顺序换一下</p><p><font color='red'><u><em><strong>重建二叉树</strong></em></u></font></p><p><img src="/../images/shua/image-20231107163434834.png" alt="image-20231107163434834"></p><p><font color='red'><u><em><strong>对称二叉树：</strong></em></u></font></p><p><font color='red'><u><em><strong>合并二叉树</strong></em></u></font></p><p><font color='red'><u><em><strong>二叉树镜像</strong></em></u></font>，</p><p><font color='red'><u><em><strong>判断是不是平衡树</strong></em></u></font> 、靠深度</p><p><font color='red'><u>***二叉搜索树的最近公共祖先(按照值搜索，所以四种分类，左左，右右，中，相等) ***</u></font>  </p><p><font color='red'><u><em><strong>在二叉树中找到两个节点的最近公共祖先（按照节点搜索值对比，分3类，左右子树都有，左找到右没找到，右找到左没找到，出现相等说明找到了，就返回节点）</strong></em></u></font> :这些递归稍显复杂</p><p>还有很多是依赖于前序遍历解决的：<font color='red'><u><em><strong>二叉搜索树与双向链表</strong></em></u></font>，<font color='red'><u><em><strong>判断是不是二叉搜索树</strong></em></u></font></p></blockquote><blockquote><p><font color='blue'><u><em><strong>BFS广度搜索</strong></em></u></font></p><p><font color='red'><u><em><strong>求二叉树的层序遍历、按之字形顺序打印二叉树</strong></em></u></font>。都是<font color='green'><u><em><strong>BFS广度搜索</strong></em></u></font>，不过代码值得一看</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Queue&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">list.add(root);</span><br><span class="line"><span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> list.poll();</span><br><span class="line">        temp.add(t.val);</span><br><span class="line">        <span class="keyword">if</span> (t.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(t.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array.add(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><font color='red'><u><em><strong>二叉树中和为某一值的路径(一)</strong></em></u></font>，深度搜索，比较简单。</p></blockquote><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><p>注意Integer和Int，基础和引用的&#x3D;&#x3D;是不一样的，在此基础上形成的stack vector，List也是这样</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h1><p>如果能做一次这种就好了</p><p>递归函数体一般分三部分</p><p>1、结束</p><p>2、主要函数操作，比如visit【】&#x3D;true</p><p>3、列举 dfs</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><font color='blue'><u><em><strong>状态定义</strong></em></u></font>：<font color='red'><u><em><strong>要么是以i结尾、要么是前i个、要么是从i到j</strong></em></u></font></p><p><font color='blue'><u><em><strong>状态转移函数：</strong></em></u></font><font color='red'><u><em><strong>这个就是各种各样了</strong></em></u></font></p><p><font color='blue'><u><em><strong>状态初始化</strong></em></u></font> ：<font color='red'><u>***如果是一维数组，可能初始前1个，也可能初始化前两个。如果是两个数组，可能初始化第一行第一列。那辅助表就是二维数组，最好比原来的宽长都多1位 ***</u></font></p><p>爬楼梯 + 杨辉三角 +</p><p>例题:</p><blockquote><p><font color='green'><u><em><strong>最长回文子串</strong></em></u></font>：用两维度的数组，表示从j到i。最后返回最长的</p><p><font color='green'><u><em><strong>最长不含重复字符的子字符串</strong></em></u></font>: 需要借助一个map存key和index，这里用到了Math.min</p><p><font color='green'><u><em><strong>最长公共子序列(二</strong></em></u></font>)：数组的意义：<font color='red'><u><em><strong>s1的前i个字符串和s2的前j个字符串的最长公共子序列</strong></em></u></font>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">             array[i][j] = array[i - <span class="number">1</span>][j - <span class="number">1</span>] + String.valueOf(s2.charAt(j));                  </span><br><span class="line">              <span class="comment">// = min([i-1,j],[i-1][j-1]+1)</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> array[i][j - <span class="number">1</span>];</span><br><span class="line">              <span class="keyword">if</span> (array[i][j-<span class="number">1</span>].length() &gt; array[i-<span class="number">1</span>][j].length()) &#123;</span><br><span class="line">                  array[i][j] = array[i][j-<span class="number">1</span>];</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  array[i][j] = array[i-<span class="number">1</span>][j];</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p><font color='green'><u><em><strong>最长公共子串</strong></em></u></font>：与上面的差别在于子串是连续的。<font color='red'><u><em><strong>这里就是以s1中以第i个字符结尾和s2中以第j个字符结尾的最长公共子串</strong></em></u></font>。判断更简单</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;                   </span><br><span class="line">            array[i][j] = array[i - <span class="number">1</span>][j - <span class="number">1</span>] + String.valueOf(str1.charAt(i));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            array[i][j] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><font color='green'><u><em><strong>最长上升子序列</strong></em></u></font>：<font color='red'><u><em><strong>以第i个字符结尾的最长子序列</strong></em></u></font></p></blockquote><p><font color='green'><u><em><strong>不同路径的数目(一)</strong></em></u></font> <font color='green'><u><em><strong>矩阵的最小路径和</strong></em></u></font> 这两个比较简单，就是得<font color='red'><u><em><strong>初始化第一列和第一行</strong></em></u></font></p><p><font color='green'><u><em><strong>兑换零钱(一)</strong></em></u></font>：这个就是两个循环，第二个循环遍历纸币集合。</p><blockquote><p><font color='green'><u><em><strong>连续子数组的最大和</strong></em></u></font>：前i个</p><p><font color='green'><u><em><strong>连续子数组的最大和(二)</strong></em></u></font> ：以i结尾，不过判断需要些思考</p></blockquote><blockquote><p><font color='green'><u><strong>跳台阶：</strong></u></font>数组的意义是第i个</p><p><font color='green'><u><em><strong>跳台阶扩展问题</strong></em></u></font> ：比较简单，双重循环。</p><p><font color='green'><u><em><strong>最小花费爬楼梯</strong></em></u></font>：跳到第i个台阶最少花费跳几次。关键在于<font color='red'><u><em><strong>初始化两个0.</strong></em></u></font></p></blockquote><blockquote><p><font color='green'><u><em><strong>买卖股票的最好时机(一)</strong></em></u></font>：初始化一个二维的【i】【2】大小。只能买一次，所以和当前的比</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">           a[i][<span class="number">0</span>] = Math.max(a[i - <span class="number">1</span>][<span class="number">0</span>], a[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">           a[i][<span class="number">1</span>] = Math.max(a[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><font color='green'><u><em><strong>买卖股票的最好时机(二)</strong></em></u></font>，初始化一样，但是可以买卖多次，不过必须先买后卖。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">           dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">           dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><font color='green'><u><em><strong>买卖股票的最好时机(三)</strong></em></u></font>：这个初始化就不一样了，【i】【4】。<font color='red'><u><em><strong>可以考虑维度的问题</strong></em></u></font></p></blockquote><blockquote><p><font color='green'><u><em><strong>打家劫舍(一)</strong></em></u></font>：这个比较正常。数组的意思是前i个</p><p><font color='green'><u>*** 打家劫舍(二)***</u></font>：多了一个环形的条件，其实就是分两种情形，第一类要第一个不要最后一个；第二不要第一个（dp[0] &#x3D; 0）要最后一个。数组的意义也是前i个。</p><p><font color='green'><u><em><strong>打家劫舍三</strong></em></u></font> ：分两种状态，直接dfs返回的时候，用new int[2]返回两种状态下的不同最大值。一种状态是选中，一种是不选中</p></blockquote><blockquote><p><font color='green'><u><em><strong>矩形覆盖</strong></em></u></font> 简单 dp[i] &#x3D; dp[i - 1] + dp[i - 2] ;</p><p><font color='green'><u>*** 把数字翻译成字符串***</u></font>:也不是很难</p></blockquote><blockquote><p><font color='green'><u><em><strong>最长有效括号</strong></em></u></font></p></blockquote><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><font color='red'><u><em><strong>判断有没有环形 ：</strong></em></u></font> 一个走两步一个走一步，重要的是while里面是&amp;&amp;，如果碰到了就代表有环</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nextt</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">while</span> (nextt != <span class="literal">null</span> &amp;&amp; pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            <span class="keyword">if</span> (nextt.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                nextt = nextt.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;      </span><br><span class="line">            <span class="keyword">if</span> (pre == nextt) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;            </span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;  </span><br></pre></td></tr></table></figure><p><font color='red'><u><em><strong>链表相加(二)</strong></em></u></font><code>就是反转在做操作，其他的就是一些小细节没什么大不了的</code></p><p><font color='red'><u><em><strong>反转链表</strong></em></u></font> <code> 就是new一个新的链表头，或者栈</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head.next;</span><br><span class="line">           head.next = newHead;</span><br><span class="line">           newHead = head;</span><br><span class="line">           head = tmp;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><font color='red'><u><em><strong>链表内指定区间反转</strong></em></u></font><code>这个和上面那个一样，但是更加复杂</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; n - m; i++) &#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = tmp.next;</span><br><span class="line">            tmp.next = pre.next;</span><br><span class="line">            pre.next = tmp;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面这两个题目其实关键在反转，其实就是三步：1）记录当前的下个节点tmp；2）当前的节点的下一个是下一个的下一个（tmp的下一个）；3）tmp的下一个是反转开始前节点的下一个pre或者head；4）pre。next &#x3D; tmp</p><p>上面两个不同的点在于，<font color='red'><u><em><strong>第一个和后面的节点不是连在一起的，第二个是连在一起的</strong></em></u></font></p><p><font color='red'><u><em><strong>链表中的节点每k个一组翻转</strong></em></u></font>    <code>递归反转</code></p><p><font color='red'><u><em><strong>单链表的排序</strong></em></u></font><code>一种是直接用arraylist存每个节点的值，自己排完，再构造链表，另一种方法就是直接归并排序</code></p><h1 id="堆-x2F-栈-x2F-队列-x2F-hashmap"><a href="#堆-x2F-栈-x2F-队列-x2F-hashmap" class="headerlink" title="堆&#x2F;栈&#x2F;队列&#x2F;hashmap"></a>堆&#x2F;栈&#x2F;队列&#x2F;hashmap</h1><blockquote><p><font color='red'><u><em><strong>栈</strong></em></u></font></p><p><strong>用两个栈实现队列</strong>: <code>难度不大</code></p><p><strong>包含min函数的栈</strong>：<code>双栈法，就是定义一个辅助栈作为存min的栈</code></p><p><strong>有效括号序列</strong>：<code>借助一个栈就可以</code></p><p><strong>最小栈</strong>：两个栈，一个普通栈，一个最小栈。最小栈只有在空、元素&lt;&#x3D;栈顶，才会入栈；等于栈顶才会出栈</p><p>字符串解码：两个栈，一个数字栈，一个String栈，很有意思</p><p>每日温度：单调栈，找右边第一个大，维护递减栈</p><p>柱状图中最大矩阵：单调栈，找左右第一个小，维护递增栈</p></blockquote><blockquote><p> <font color='red'><u><em><strong>堆</strong></em></u></font></p><p> <font color='red'><u><em><strong>最小的K个数</strong></em></u></font>: <code>用一个大顶堆可以</code> 关键是这里priorityqueue需要你给comparator</p><p> <font color='green'><strong>前k个高频元素：map存次数，+小顶堆</strong></font></p><p> <font color='red'><u><em><strong>寻找第k大的数</strong></em></u></font>： <code>和上面的一样用堆结构，不过不同之处在于用的是</code><font color='red'><u><em><strong>小顶堆</strong></em></u></font> ，<code>并且comparator返回得到不一样</code></p><p> <font color='red'><u><em><strong>数据流中的中位数</strong></em></u></font>：<code>这个有些难度，用的是</code> 双堆法。一个大顶堆放小的一般，一个小顶堆放大的一半。奇数的时候放入大顶堆，偶数放入小顶堆。放入过程判断大小，做调解。</p></blockquote><blockquote><p><font color='red'><u><em><strong>栈</strong></em></u></font></p><p><font color='red'><u><em><strong>表达式求值</strong></em></u></font> 这个是这里面最难得一个，用一个栈做，思想就是，减法就是加负号，所以对加减直接保留在栈里面，认为都是加法，最后遍历栈加起来就可以。如果遇到乘除，就得做运算，polllast出末尾然后做乘除然后add，每次做完运算num都为0。做运算的时候是要和上一个符号判断的，建议看代码</p></blockquote><blockquote><p><font color='red'><u>**Hashmap **</u></font></p><p><font color='red'><u><em><strong>两数之和</strong></em></u></font> : 很简单，用hashmap更简单</p><p><font color='red'><u><em><strong>数组中出现次数超过一半的数字</strong></em></u></font> ： 很简单</p><p><font color='red'><u><em><strong>缺失的第一个正整数</strong></em></u></font> ; 很简单</p><p><font color='red'><u><em><strong>三数之和</strong></em></u></font>：这个是这一块最难的一题目。用哈希可以得到答案，但是不能通过，有顺序的原因。具体做法是：先sort，然后外面一个循环作为第一个值，循环里面一个left &#x3D; i + 1，一个right &#x3D; length - 1.这样三个值，然后left 和 right向中间靠拢。</p></blockquote><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><blockquote><p><font color='red'><u><em><strong>旋转数组</strong></em></u></font>：关键在于三次反转</p><p><font color='red'><u><em><strong>螺旋矩阵</strong></em></u></font>：按着圈走就行了，比较简单</p><p><font color='red'><u><em><strong>顺时针旋转矩阵</strong></em></u></font>：这个有两种方法，一种new一个数组；然后双重循环<code>array[i][j] = mat[n -1 - j][i];</code></p><p>还有一种方法就是，先沿着左对角线翻转，然后每一行翻转。</p><p><font color='red'><u><em><strong>设计LRU缓存结构</strong></em></u></font>：用双向链表（自己构造node）和一个hashmap来实现，比较麻烦。</p><p><font color='red'><u><em><strong>扑克牌顺子</strong></em></u></font> ：这个就是先排序，找最大最小，最大最小之间的差小于5</p><p><font color='red'><u><em><strong>把字符串转换成整数(atoi)</strong></em></u></font> 这个就是按照他的步骤走，不难，就是需要调整两下</p><p><font color='red'><u><em><strong>构建乘积数组</strong></em></u></font> 右上三角形为一个数组，左下三角形为一个数组。两个数组乘起来。</p><p><font color='red'><u><em><strong>整数中1出现的次数（从1到n整数中1出现的次数）</strong></em></u></font>：遍历每个位置等于1的数量，都加起来。</p><p><font color='red'><u><em><strong>把数组排成最小的数</strong></em></u></font> 加一个比较器就可以</p><p><font color='red'><u><em><strong>和为S的连续正数序列</strong></em></u></font> : 双指针 滑动窗口</p><p><font color='red'><u><em><strong>左旋转字符串</strong></em></u></font>: 多次旋转</p></blockquote><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><blockquote><p>基本就是：翻转 切割 遍历</p><p><font color='red'><u><em><strong>字符串变形</strong></em></u></font> ：这个就是变成sb后 翻转 ，然后对非空的再反转</p><p><font color='red'><u><em><strong>最长公共前缀</strong></em></u></font> ：这个也挺烦的，就是直接遍历第一个，双重循环。</p><p><font color='red'><u><em><strong>IP地址验证</strong></em></u></font>：主要是split（ ，-1）；分完之后，循环遍历切好的集合，看看有没有什么不符合的条件。</p><p><font color='red'><u><em><strong>大数加法</strong></em></u></font>： 用栈，循环从后往前遍历两个字符串。</p></blockquote><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><blockquote><p><font color='red'><u><em><strong>双指针指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针（特殊情况甚至可以多个），两个指针或是同方向访问两个链表、或是同方向访问一个链表（快慢指针）、或是相反方向扫描（对撞指针），从而达到我们需要的目的。</strong></em></u></font></p><p><font color='red'><u><em><strong>合并两个有序的队列</strong></em></u></font>：可以用归并排序，这个排序需要重点记住</p><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">guibing</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> temp[], <span class="type">int</span>  left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//hebing</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        guibing(a,temp,left, mid);</span><br><span class="line">        guibing(a,temp, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right )&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">                temp[k++] = a[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid )&#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right )&#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t&lt; right - left + <span class="number">1</span>; t++) &#123;</span><br><span class="line">            a[left + t] = temp[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote><p><font color='red'><u><em><strong>合并区间</strong></em></u></font>：关键在于先排序，然后每次都和队列尾 部的比较就可以。</p><p><font color='red'><u><em><strong>最长无重复子数组</strong></em></u></font>：这个双重循环+Set集合</p><p><font color='red'><u><em><strong>盛水最多的容器</strong></em></u></font> 前指针 + 后指针 向中间靠拢</p><p><font color='red'><u><em><strong>接雨水问题</strong></em></u></font>： 前指针 + 后指针 向中间靠拢</p></blockquote><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>跳跃游戏</p><p>跳跃游戏2，这两个关注一下</p><p>划分字母空间：</p><p>这几个都可以用下面的模版</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            right = Math.max(right, array[s.charAt(i) - &#x27;a&#x27;]);</span><br><span class="line">            if (i == right) &#123;</span><br><span class="line">                list.add(right - left + 1);</span><br><span class="line">                left = right + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><blockquote><p>只出现一次的数字：直接异或操作</p><p>多数元素：摩尔投票</p><p>颜色分类：两个指针，从左往右。遇到1正常交换 one++；遇到0先交换一次，如果把1交换到后面再交换一次，然后zero++ one++；。</p><p>下一个排列：先找第一个i &lt; i + 1;然后找第一个j使得i &lt; j。交换i和 j，（i + 1， n）排序。</p><p>寻找重复的数字：抽屉理论，两重循环+二分思想</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-Java基础知识</title>
      <link href="/2023/08/07/%E5%85%AB%E8%82%A1-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/08/07/%E5%85%AB%E8%82%A1-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><strong>jre和jdk</strong></p><blockquote><p>jre是java运行时环境，jdk是java development kit</p></blockquote><p><strong>本地缓存和分布式缓存</strong></p><blockquote><p><font color='green'><strong>本地缓存就是存储在单个应用程序的内存里面，Map和ConcurrentHashMap这些都是缓存，或者caffeine框架。优点就是速度快容易管理。缺点就是数据不能共享同步，不好持久化</strong></font></p><p><font color='green'><strong>分布式缓存就是支持多个应用程序共享数据，比如redis。优点就是可扩展性强，加机器，高可用，可持久化。缺点就是需要额外资源，还需要考虑数据一致性</strong></font></p></blockquote><p><strong>多级缓存</strong></p><blockquote><p><font color='green'><strong>在做多级缓存的方案中，会先查询本地缓存，如果本地缓存查不到，再查询分布式缓存。并旦在分<br>布式缓存中查询到之后保存到本地缓存中一份。</strong></font></p><p><font color='red'><u><em><strong>多级缓存数据一致性？版本号机制</strong></em></u></font></p></blockquote><p>FIFO LRU LFU</p><blockquote><p><font color='green'><strong>FIFO：先进先出</strong></font></p><p><font color='green'><strong>LRU：最近最少使用。一个链表，新访问的放到头节点，淘汰尾节点</strong></font></p><p><font color='green'><strong>LFU：最近最不常使用。每个节点有一个访问次数，按照访问次数排序，相同次数按时间排，淘汰尾节点</strong></font></p></blockquote><p><strong>类和类之间的关系？</strong></p><blockquote><p>组合【生命周期一体】、聚合【生命周期不一体】、泛化、实现</p></blockquote><p><strong>反射</strong></p><blockquote><p><font color='red'><u>*** Java的反射机制是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法。***</u></font></p><p> 获得Class对象的三种方式：</p><p><font color='green'><strong>(1)使用Class.forName方法(“类的全路径名”)；</strong></font></p><p><font color='green'><strong>(2)使用需要反射的类名调用class方法；</strong></font></p><p><font color='green'><strong>(3)使用需要反射的类的对象调用getClass方法</strong></font></p><p>缺点：</p><p><font color='green'><strong>耗时</strong></font></p></blockquote><p><font color='red'><u><em><strong>Error和Exception</strong></em></u></font></p><blockquote><p><font color='green'>*<strong>Throwable为基类，Error和Exception继承Throwable。Error是程序员解决不了比如OOM，SOF。Exception分为未检查异常和检查异常。检查异常：编译的时候就出问题。非检查：运行的时候出问题。—-非检查异常像是空指针，类型转换都是。检查异常比如文件没找到异常，SqlException</strong></font></p></blockquote><blockquote><p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240214002243390.png" alt="image-20240214002243390"></p></blockquote><p><strong>BIO NIO AIO</strong></p><blockquote><p>首先我们知道用户缓冲区去内核缓冲区读数据的时候，有两个耗时的过程，一个是等待从网卡来的数据，一个是内核拷贝到用户缓冲区。阻塞io两个都要等、非阻塞需要等待拷贝这个过程。但是io多路复用，先监听一个socket集合，这时候才调用revfrom去读。</p><p><font color='green'><strong>BIO :同步并阻塞,一个线程处理一个请求，一个请求过来我就为他创建一个线程。</strong></font></p><p><font color='green'><strong>NIO :同步非阻塞,一个线程处理多个请求。Channel(通道，构件连接) ，Buffer( 缓冲区，存取数据), Selector( 选择器，用来监听多个channel的，select，poll链表，epoll红黑树)，然后某个socket数据就绪了，发了个可读的通知。他的非阻塞是指数据从网卡通过DMA到内核缓冲区这一块他是不阻塞的，但是如果你到了内核缓冲区了，那其实从内核缓冲区到用户缓冲区还是有阻塞的</strong></font></p><p><font color='green'><strong>AIO(NIO.2) :异步非阻塞，服务器实现模式为一 个有效请求一个线程，关键就是异步，不回去等待，你空闲的时候做自己的事情就好，等socket就绪了，你再来读就可以。</strong></font></p></blockquote><p><strong>String StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？</strong></p><blockquote><p><font color='green'><strong>String是字符串常量，因为定义的char数组是final的。而StringBuffer和StringBuilder是字符串变量。由String创建的字符内容是不可改变的，而由StringBuffer和StringBuidler创建的字符内容是可以改变的。</strong></font></p><p><font color='green'><strong>StringBuffer是线程安全的【所有方法都是synchronized】，而StringBuilder是非线程安全的</strong></font></p><p>append方法。append会先去判断一下现在的容量够不够用，不够就扩容，够用就插入</p></blockquote><p><strong>equals与&#x3D;&#x3D;的区别</strong></p><blockquote><p>&#x3D;&#x3D; 基本类型比较值，引用类型比地址。</p><p>equals是object的方法，在object类里面其实用的还是&#x3D;&#x3D;，如果对象类重写了equals，那就走重写的规则。</p></blockquote><p><strong>深拷贝和浅拷贝</strong></p><blockquote><p><font color='green'><strong>浅拷贝：基本类型的成员变量拷贝值，引用类型成员变量拷贝引用地址</strong></font></p><p><font color='green'><strong>深拷贝：基本类型的成员变量拷贝值，引用类型是创建新的对象保存成员变量</strong></font></p><p><font color='red'><u><em><strong>通过实现clone方法实现浅拷贝和深拷贝</strong></em></u></font></p></blockquote><p><strong>字符型常量和字符串常量的区别</strong></p><blockquote><p>1.形式上: <font color='green'><strong>单引号，双引号</strong></font><br>2.含义上:<font color='green'><strong>字符常量相当于一个整形值( ASCII 值)</strong></font>,可以参加表达式运算；<font color='green'><strong>字符串常量代表一个地址值</strong></font>(该字符串在内存中存放位置，相当于对象)</p><p>3.占内存大小：<font color='green'><strong>字符常量只占2个字节；字符串常量占若干个字节2N</strong></font></p></blockquote><p><strong>自动装箱和自动拆箱</strong></p><blockquote><p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p></blockquote><p><strong>请说出作用域public，private，protected，以及不写时的区别。</strong></p><blockquote><p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240213231737281.png" alt="image-20240213231737281"></p></blockquote><p><font color='red'><u><em><strong>创建几个对象？</strong></em></u></font></p><blockquote><p>1、String a&#x3D;”123”;</p><p><em>创建了1个对象</em></p><p>jvm在编译阶段会判断常量池中是否有 “123” 这个常量对象如果有，a直接指向这个常量的引用，如果没有会在常量池里创建这个常量对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、<span class="title class_">String</span> a=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p><em>创建了2个对象</em></p><p>同情况1，jvm编译阶段判断常量池中 “123”存在与否，进而来判断是否创建常量对象，然后运行阶段通过new关键字在java heap创建String对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>、<span class="title class_">String</span> a=<span class="string">&quot;123&quot;</span>+<span class="string">&quot;456&quot;</span>;</span><br></pre></td></tr></table></figure><p><font color='green'><em><strong>创建了1个对象</strong></em></font></p><p>jvm编译阶段过编译器优化后会把字符串常量直接合并成”123456”，所有创建对象时最多会在常量池中创建1个对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">4</span>、<span class="title class_">String</span> a=<span class="string">&quot;123&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;456&quot;</span>);</span><br></pre></td></tr></table></figure><p><em>创建了4个对象</em></p></blockquote><h2 id="讲讲Java的代理"><a href="#讲讲Java的代理" class="headerlink" title="讲讲Java的代理"></a>讲讲Java的代理</h2><blockquote><p>代理分成静态代理和动态代理，静态代理需要自己实现对每一个方法对代理，那么如果新增一个方法，那就要手动修改目标对象代理对象的代码，非常繁琐。动态代理更加灵活，不需要你一个一个的对方法进行代理。</p><p>动态代理就是运行的时候生成class。这个DynamicProxy其实就是一个Proxy，</p><p>动态代理有两种方式一种是jdk方法，一种是cglib方法</p><p><strong>我们先来讲jdk代理：</strong></p><blockquote><p><font color='blue'><u><em><strong>JDK代理依赖于Proxy类和InvocationHandler接口，InvocationHandler接口他只有一个invoke方法，三个参数是代理类，被代理方法，方法参数组。代理方法和参数组其实我们可以利用反射得到，所以参数其实是可以变化的，那这样就成功的实现了动态的代理。</strong></em></u></font></p><p><font color='blue'><u><em><strong>那我们怎么去调用这个方法呢？依赖于Proxy类和他的方法newproxyInstance，得到的代理类，调用方法其实会直接调用我们实现InvocationHandler接口的invoke方法</strong></em></u></font></p></blockquote><p><strong>下面来讲CGLIB代理</strong></p><blockquote><blockquote><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。你可以通过 <code>Enhancer</code>类来动态获取被代理类，</strong></p><p>  CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，每次调用代理类的方法都会被方法<a href="https://so.csdn.net/so/search?q=%E6%8B%A6%E6%88%AA%E5%99%A8&spm=1001.2101.3001.7020">拦截器</a>拦截，在拦截器中才是调用目标类的该方法的逻辑。所以我们说，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p></blockquote><p><strong>二者区别</strong><br>总结一下两者的区别吧：</p><p><font color='blue'><u><em><strong>JDK 动态代理基于接口，CGLIB 动态代理基于类。</strong></em></u></font><font color='green'><strong>因为 JDK 动态代理生成的代理类需要继承Proxy，所以，只能基于接口；CGLIB 动态代理是根据类创建此类的子类，所以，此类不能被 final 修饰</strong></font><br><font color='blue'><u><em><strong>JDK 是自带的、CGLIB需要加载包</strong></em></u></font></p><p><font color='blue'><u><em><strong>JDK是反射机制，CGLIB是使用ASM框架。</strong></em></u></font></p></blockquote></blockquote><p><strong>为什么Java不能多继承？</strong></p><blockquote><p>会出现方法冲突和变量冲突</p></blockquote><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231116121230926.png" alt="image-20231116121230926"></p><h2 id="Arraylist底层原理"><a href="#Arraylist底层原理" class="headerlink" title="Arraylist底层原理"></a>Arraylist底层原理</h2><p>可以从底层数据结构，构造函数和关键方法理解。</p><blockquote><p><font color='red'><u><em><strong>Arraylist的底层数据结构是object[]数组，构造函数分有参无参，如果是无参就是空数组，如果是有参，就用你定义的那个初始大小。如果参数是容器，那就是把容器转成数组copy给object。关键方法就是add方法，需要保证容量够用才能添加元素，所以会在添加之前进行一个ensurecapacity的过程。他会先计算mincapacity的值，他会拿mincapacity去和现在的数组长度比较，如果大了说明要扩容，扩容的过程是先×1.5看看够不够，够的话就1.5，不够就用新的这个mincapacity。</strong></em></u></font>如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code></p><blockquote><p><font color='blue'><u><em><strong>对于插入</strong></em></u></font>：如果不需要扩容，<font color='green'><strong>头插和指定位置插入都是O(n)，尾插是O(1)</strong></font>。如果需要扩容，就得再做一次扩容，O(n)，然后在插入，就是刚才讲的时间复杂度。</p><p><font color='blue'><u><em><strong>对于删除</strong></em></u></font>：头删和指定位置删除是O(n)，尾部删除是O(1)</p></blockquote></blockquote><h2 id="Linkedlist"><a href="#Linkedlist" class="headerlink" title="Linkedlist"></a>Linkedlist</h2><blockquote><p><font color='red'><u><em><strong>Linkedlist 是双向链表，因为是链表，所以没什么扩容的问题，基本的方法都是围绕前节点、后节点、节点值展开的。</strong></em></u></font></p><ul><li>头部插入&#x2F;删除： O(1)。</li><li>尾部插入&#x2F;删除： O(1)。</li><li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul></blockquote><h2 id="ArrayList-与-LinkedList区别"><a href="#ArrayList-与-LinkedList区别" class="headerlink" title="ArrayList 与 LinkedList区别?"></a>ArrayList 与 LinkedList区别?</h2><blockquote><p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构，内存一个是连续一个不是连续</p><p><strong>插入和删除的时间复杂度</strong>：arraylist，头插、指定插、头删、指定删除都是On，尾插和尾删除是O1。linkedlist 头插和尾插、头删除、尾删除都是O1，指定位置是On</p><p><strong>内存空间占用</strong>：<font color='blue'><u><em><strong>linkedlist每个节点要存前后指针，所以内存占用大。</strong></em></u></font></p><p><font color='red'><u><em><strong>使用场景：</strong></em></u></font></p><p><font color='blue'><u><em><strong>如果需要频繁进行随机访问和查询操作的场景，例如按索引读取数据或搜索特定元素，应该选择ArrayList。</strong></em></u></font></p><p><font color='blue'><u><em><strong>如果需要频繁进行插入、删除或位置变动较多的场景，特别是在链表的首尾位置进行操作，那么LinkedList是更合适的选择。</strong></em></u></font></p><h2 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h2><blockquote><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能</p><p><code>ArrayDeque</code> 是<font color='green'><strong>基于可变长的数组和双指针来实现</strong></font>，而 <code>LinkedList</code> 则通过链表来实现。</p><p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p></blockquote><p><font color='red'><u><em><strong>LinkedList和ArrayList存储了一定数据，循环查询了上亿次</strong></em></u></font></p><blockquote><p><font color='green'><strong>array底层是数组，读取的时候会将相邻的数据读进来，而linked是分散，要找到才读，而且array是随机读，link是遍历到该位置，所以array快。</strong></font></p></blockquote></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><p><font color='blue'><u><em><strong>如何实现数组和arraylist之间的转换</strong></em></u></font></p><p>List.toarray  (修改原先list，array不受影响)</p><p>Arrays.aslist （受影响）</p><h2 id="hashmap和hashset"><a href="#hashmap和hashset" class="headerlink" title="hashmap和hashset"></a><font color='red'><u><em><strong>hashmap和hashset</strong></em></u></font></h2><blockquote><p>hashset还是比较适合去重和集合运算</p><p>hashmap比较适合键值对这类数据</p></blockquote><h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li><font color='red'><u><em><strong><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</strong></em></u></font></li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><blockquote><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p></blockquote></blockquote><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>hashmap最关键的是他的<font color='blue'><u><em><strong>底层数据结构、put 扩容 和 线程安全方面的知识。</strong></em></u></font></p><p><font color='red'><u><em><strong>HASHMAP为什么用红黑树</strong></em></u></font></p><blockquote><p><font color='green'><strong>普通二叉树会形成链表；</strong></font></p><p><font color='green'><strong>平衡二叉树插入的时候会左旋右旋保持绝对平衡</strong></font></p><p><font color='green'><strong>红黑树，插入最多两次旋转，删除最多三次</strong></font></p></blockquote><blockquote><h2 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h2><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong>。1.8之后是数组+链表+红黑树</p><p>构造函数是懒加载，没有初始化数据，就是把负载因子赋为0.75。</p><p><font color='green'><strong>put的时候，先判断数组是否为空，如果为空，就初始化为16大小。通过 key 的 <code>hashcode</code> 经过扰动函数（右移16位再异或），然后通过 <code>  hash &amp; (n - 1)</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果定位到的数组位置没有元素 就直接插入。如果有数据，就判断key是不是相同，相同就覆盖，不相同就判断是不是红黑树，如果是就调用putTree，如果是链表就遍历链表，看看key有没有，有就覆盖，没有就在尾部插入新的节点，然后判断长度是否大于8，大于8就去尝试转红黑树，插入结束后，最后要判断一下是否需要扩容。</strong></font></p><p>为什么阈值时8</p><p>哈希碰撞的时候8次的时候几乎已经是非常低的概率了，那时候就转红黑树</p><p>一开始不转？内存问题吧</p></blockquote><blockquote><h2 id="hashmap扩容过程"><a href="#hashmap扩容过程" class="headerlink" title="hashmap扩容过程"></a>hashmap扩容过程</h2><p>扩容简单来说就是做了两件事。1：创建一个新数组，原来的两倍大。2：遍历旧数组每个槽<br>如果槽位中是一个普通节点，则将节点放在新数组中，所在新数组中的下标计算方式为：e.hash &amp; (newCap - 1);<br>如果槽位中是一个树节点，则进行红黑树的迁移操作，新数组中下标计算方式同普通节点；<br>如果槽位中是一个链表节点，则将链表拆为高位链表和低位链表，就是拿hash值和旧容量做与操作，等于0就放入放入新数组的旧数组的下标位置和，不等于0会放到（旧数组下标 + 旧数组容量）下标位置；<br>最后返回新数组。</p><h2 id="HashMap-多线程操作导致死循环问题（1-7会，1-8是在树操作）"><a href="#HashMap-多线程操作导致死循环问题（1-7会，1-8是在树操作）" class="headerlink" title="HashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）"></a>HashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）</h2><p><font color='red'><u><em><strong>扩容问题和头插法问题</strong></em></u></font></p><p>假设两个线程同时对hashmap进行扩容，这时候两个都指向首节点A，后面的节点分别是bcd。</p><p>那么这时候线程1正常执行，线程2卡住了。但是A执行完后因为是头插法所以abc变成了cba。线程2唤醒启动，线程2第一个e还是指向a，a的next指向b，这样子就出现了问题，但是还没出现环状。那我们继续执行。把e也就是a赋放到新链表，a &#x3D;</p><p>a的next其实就是b，b拿过来，然后b&#x3D;b的next，b的next是谁呢，就是a，然后a指向链表头，这个头节点就是b呀！这里就出问题了。</p><p>解决的方法：concurrenthashmap，推荐；hashtable安全，不建议；或者直接加锁，也不建议。或者头插法改成尾插法。</p><h2 id="HashMap-为什么线程不安全？"><a href="#HashMap-为什么线程不安全？" class="headerlink" title="HashMap 为什么线程不安全？"></a>HashMap 为什么线程不安全？</h2><p><font color='red'><u><em><strong>一方面就是多线程操作导致的死循环问题。</strong></em></u></font></p><p><font color='red'><u><em><strong>另一方面就是两个线程 1,2 进行 put 操作，线程1 执行的时候通过判断发现没有出发hash碰撞，但是时间片用完了挂起，这时候线程2也判断有没有hash碰撞发现没有，因为线程1还没来得及插入。这时候线程2插入一个b值结束了，线程1重新获得时间片，因为之前已经成功判断过了，所以直接插入一个a值，那么这样b值就被a值覆盖了。</strong></em></u></font></p><h2 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h2><p>散列采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 **采用二进制位操作 &amp;，相对于%能够提高运算效率）</p><p><strong>loadFactor 负载因子</strong></p><p>loadFactor 负载因子是控制数组存放数据多少的参数和扩容的界限。默认0.75</p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><ul><li><p><strong>线程是否安全：</strong><code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）</p></li><li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> <font color='blue'><u><em><strong>默认的初始化大小为 16</strong></em></u></font>。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p></li><li><p><strong>底层数据结构：</strong> <strong>hashmap 数组+链表+红黑树，hashtable 数组+链表</strong></p></li></ul><h2 id="hashmap的key规范"><a href="#hashmap的key规范" class="headerlink" title="hashmap的key规范"></a>hashmap的key规范</h2><p>用自定义类作为key，必须<font color='red'><u><em><strong>重写equals()和hashCode()方法。</strong></em></u></font></p><p><font color='red'><u><em><strong>Hashcode和equals</strong></em></u></font></p><blockquote><p><font color='green'><strong>两个对象相同的话，他们的HashCode一定相等；</strong></font></p><p><font color='green'><strong>两个对象HashCode相等，equals不一定是同一个对象；</strong></font></p><p>hashcode和equals?<br>HashCode()是Obiects的方法，返回的是散列码，默认放的是内存地址,int值<br>equals比较的是两个内存地址是否相同，当然可以重写<br>如果equals要重写，那hashcode也要重写?<br>为什么还需要重写 hashCode方法呢?这是因为在使用散列数据结构时，比如哈希表，我们希望相等的对象具有相等的哈希码。如果两个相等的对象具有不同的哈希码，那么它们将被存储在哈希表的不同位置，导致无法正确查找这些对象。</p></blockquote></blockquote><h1 id="线程安全容器"><a href="#线程安全容器" class="headerlink" title="线程安全容器"></a><font color='red'><u><em><strong>线程安全容器</strong></em></u></font></h1><blockquote><h2 id="1、ConcurrentHashMap"><a href="#1、ConcurrentHashMap" class="headerlink" title="1、ConcurrentHashMap"></a>1、<strong>ConcurrentHashMap</strong></h2><p><font color='red'><u><em><strong><code>ConcurrentHashMap</code>1.8的底层数据结构采用数组+链表+红黑树的形式。是线程安全的，而是通过CAS+Synchronized的方法保证了多线程的线程安全。1.8以前是用16个<code>Segment</code> 分段锁加hashentry数组+Reentranlock。1.8添加元素的时候，1，先判断key和value是不是空，如果空就抛异常。2，然后hashcode扰动函数模运算得到下标索引。3、先判断是不是初始化。4、节点为空就cas添加。5、如果正在扩容，就帮助扩容；6、如果冲突就加synchronized后再插入。7、看看能不能转成红黑树</strong></em></u></font></p><p>Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p><p><font color='green'><strong>1.7 size（）返回各个segment的size和，如果写入频繁，就加锁，全局锁</strong></font></p><p>1.8</p><h2 id="2、CopyOnWriteArrayList（读多写少）"><a href="#2、CopyOnWriteArrayList（读多写少）" class="headerlink" title="2、CopyOnWriteArrayList（读多写少）"></a>2、CopyOnWriteArrayList（读多写少）</h2><p><font color='red'><u><em><strong>原理：读的时候不加锁，对数组进行改变的时候，通过锁 + 数组拷贝 + volatile 关键字保证了线程安全；</strong></em></u></font></p><ul><li><font color='red'><u><em><strong>加锁</strong></em></u></font>；<font color='blue'><u><em><strong>ReentrantLock</strong></em></u></font></li><li><font color='red'><u><em><strong>从原数组中拷贝出新数组</strong></em></u></font>；</li><li><font color='red'><u><em><strong>在新数组上进行操作，并把新数组赋值回去</strong></em></u></font>；</li><li><font color='red'><u><em><strong>解锁</strong></em></u></font></li></ul><h2 id="3、BlockingQueue"><a href="#3、BlockingQueue" class="headerlink" title="3、BlockingQueue"></a>3、BlockingQueue</h2><p><code>BlockingQueue</code> （阻塞队列）是一个接口，<font color='red'><u><em><strong>没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。&#96;</strong></em></u></font></p><p><font color='red'><u><em><strong>阻塞队列有哪些</strong></em></u></font></p><blockquote><p>ArrayBlockingqueue：底层是数组、有界队列。一把锁，锁是不分离的</p><p>LinkBlockingQueue：底层是链表、默认无界但是支持有界。头尾两把锁</p><p>PriorityBlockingQueue 由优先级堆支持的无界优先级队列</p><p>DelayedWorkQueue：<font color='blue'><u><em><strong>DelayedWorkQueue是基于堆的数据结构，按照时间顺序将每个任务进行排序，将待执行时间越近的任务放在在队列的队头位置，以便于最先进行执行</strong></em></u></font></p><p>SynchronousQueue</p></blockquote></blockquote><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><font color='red'><u><em><strong>线程池</strong></em></u></font></h1><blockquote><p><font color='red'><u><em><strong>创建线程池的方式</strong></em></u></font></p><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造方法来创建（推荐）。</strong></p><p><strong>方式二： <code>Executors的工厂方法：比如Executors.newCachedThreadPool()</code>（不推荐）。</strong></p><p>两种方法都在concurrent包下面。</p><blockquote><p>为什么不推荐？我觉得就是Executors提供的创建的几个线程池都有点局限性，都有不足的地方。</p><p>然后像Fixed和Single用的<font color='red'><u><em><strong>工作队列是无界队列</strong></em></u></font>，可能会堆积大量的请求,导致OOM</p><p>还有<font color='red'><u><em><strong>cached和Schedule最大的线程数量是Integer.MAX_VALUE</strong></em></u></font>，可能堆积大量的线程，导致OOM</p></blockquote><ul><li>1、ThreadPoolExecutor</li></ul><blockquote><p> <font color='red'><u><em><strong>线程池的类型</strong></em></u></font></p><blockquote><p>FixedThreadPool，没有救济的线程，只有核心线程。阻塞队列是LinkedBlockingQueue，默认大小是Integer的MaxValue</p><p>SingleThreadPool，核心线程和最大线程就1个。阻塞队列是LinkedBlockingQueue，默认大小是Integer的MaxValue</p><p>CachedThreadPool：这个是没有核心线程数，全都是救济线程。阻塞队列是SynchronousQueue</p></blockquote></blockquote><ul><li>2、ScheduledThreadPoolExecutor</li></ul><blockquote><p><font color='blue'><u><em><strong>ScheduledThreadPool：这个是定时执行任务，阻塞队列是DelayedWorkQueue（基于小根堆实现的延时优先级）</strong></em></u></font></p></blockquote><blockquote><p>ScheduledThreadPoolExecutor继承了<code>ThreadPoolExecutor</code>，也实现了一个ScheduledExecutorService接口，所以有一些特有的方法：比如schedule</p><p>他有个类DelayedWorkQueue，见上面。还有一个**<code>ScheduledFutureTask</code>**</p><p><font color='red'><u><em><strong>ScheduledThreadPoolExecutor相比Threadpoolexcutor，具备延时执行任务和可周期性执行任务的特性</strong></em></u></font></p></blockquote><h2 id="3、CompletableFuture"><a href="#3、CompletableFuture" class="headerlink" title="3、CompletableFuture"></a>3、CompletableFuture</h2><p><code>CompletableFuture</code>是对<code>Future</code>的扩展和增强。<code>CompletableFuture</code>实现了<code>Future</code>接口，并在此基础上进行了丰富的扩展，完美弥补了<code>Future</code>的局限性，<strong>同时<code>CompletableFuture</code>实现了对任务编排的能力</strong></p></blockquote><h2 id="元素排序-Comparable-和-Comparator-有什么区别？"><a href="#元素排序-Comparable-和-Comparator-有什么区别？" class="headerlink" title="元素排序 Comparable 和 Comparator 有什么区别？"></a>元素排序 Comparable 和 Comparator 有什么区别？</h2><blockquote><p>Comparable：实现 Comparable 接口并重写 compareTo 方法就可以实现某个类的排序了，它支持 Collections.sort 和 Arrays.sort 的排序。compareTo 方法接收的参数 p 是要对比的对象，排序规则是用当前对象和要对比的对象进行比较，然后返回一个 int 类型的值。正序从小到大的排序规则是：使用当前的对象值减去要对比对象的值；而倒序从大到小的排序规则刚好相反：是用对比对象的值减去当前对象的值。</p><p>Comparator 除了可以通过创建自定义比较器外，还可以通过<a href="https://so.csdn.net/so/search?q=%E5%8C%BF%E5%90%8D%E7%B1%BB&spm=1001.2101.3001.7020">匿名类</a>的方式，更快速、便捷的完成自定义比较器的功能，具体的代码实现如下：</p><p><font color='red'><u><em><strong>Comparable 必须由自定义类内部实现排序方法，而 Comparator 是外部定义并实现排序的</strong></em></u></font></p></blockquote><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><font color='red'><u><em><strong>Linux常用命令</strong></em></u></font>：<font color='blue'><u><em><strong>cat, pwd, ls、TOP，mpstat，chattr -i +i不可修改删除，lsattr,chmod 777 (读写执行)</strong></em></u></font></p><blockquote><p><strong>lsof -i:9080</strong>可以查看9080端口正在运行的程序 </p><p>kill -9 PID 是操作系统从内核级别强制杀死一个进程.</p><p>kill -15 PID 可以理解为操作系统发送一个通知告诉应用主动关闭.如果在准备过程中遇到阻塞，那么这个kill-15可能被忽略，所以就失效了</p></blockquote><p><font color='red'><u><em><strong>查日志的命令</strong></em></u></font>：cat tail head</p><p><font color='red'><u><em><strong>怎么排查项目故障</strong></em></u></font>：</p><blockquote><p><font color='green'><strong>可以用top先看看是cpu还是内存的问题，cpu的话，可以拿到pid，然后ps -eo pid,%cpu | grep进程id 或者top -H -p pid，查看线程情况，拿到线程id，最后jstack查看堆栈信息。内存泄漏的话就jmap -dump一个内存快照，然后加载到visualVMEclipse Memory Analyzer里面。或者jstat -gcutil pid看看各个分区的情况和gc的压力。还有那个HeapDumpOnMemoryError这个JVM的配置</strong></font></p></blockquote><p>标高的原因：</p><blockquote><p>死锁？死循环？频繁fullgc？一些复杂计算</p></blockquote><p><strong>查看机器的负载情况linux</strong></p><blockquote><p>Top htop mpstat vmstat</p></blockquote><h1 id="Spirng"><a href="#Spirng" class="headerlink" title="Spirng"></a>Spirng</h1><p><font color='red'><u><em><strong>springboot和spring</strong></em></u></font></p><blockquote><p><font color='green'><strong>SpringBoot 是一个在spring基础上，简化了 配置和开发流程的web整合的轻量级框架</strong></font></p><p>@SpringBootApplication</p><p>@EnableAutoConfiguration</p><p>@ComponentScan</p></blockquote><p><font color='red'><u><em><strong>怎么加一个starter</strong></em></u></font></p><blockquote><p><font color='green'><strong>1、springboot依赖。2、contiguration 3、spring.factories</strong></font></p></blockquote><p><font color='red'><u><em><strong>@Transactional（Spring默认JDK，Springboot默认cglib【性能好、不用依赖接口对代码侵入性弱】）</strong></em></u></font></p><blockquote><p><font color='green'><strong>是一个事务注解，底层是AOP，Spring AOP底层用的动态代理，所以Spring 会创建一个代理对象来包装该方法，并在方法执行前和后添加代码，以启动和提交、回滚事务。在写代码的时候一般单表查询我们不需要加，如果是多个写操作，那就得用上这个，也得防止失效</strong></font></p><p><font color='green'><strong>他可以用于<code>接口</code>、<code>类</code>、<code>方法</code>。把注解放到类上，那所有的public方法都配置了相同的事务配置信息，作用于方法，那方法的事务会覆盖类的事务配置信息</strong></font>。</p><p><font color='red'><u><em><strong>使用Transcantional需要注意的点</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>1、@Transactional 只能应用到 public 方法才有效</strong></em></u></font></p><blockquote><p><font color='green'><strong>Spring 会调用一个叫做 computeTransactionAttribute 方法去获取 @Transactional 注解的事务配置信息，这个方法里面会判断你是不是为public，如果是才能往下走，</strong></font></p><p><font color='green'><strong>还有一个层面，aop底层是两种代理方式吗，如果是基于接口，那你就得是public，因为接口的性质。如果你是基于类的，那我们cglib的原理是重写父类的方法，你如果是private，那都对子类不可见，那更不要说其他的了</strong></font></p></blockquote><p><font color='red'><u><em><strong>5、final、static（不可重写）</strong></em></u></font></p><p><font color='red'><u><em><strong>2、异常类型不匹配：或者异常被吃掉了</strong></em></u></font></p><p><font color='green'><strong><code>@Transactional</code> 默认只在运行时异常（RuntimeException）发生时才回滚，对检查异常（Checked Exception）不回滚。</strong></font></p><p><font color='red'><u><em><strong>3、自调用失效this：</strong></em></u></font></p><p><font color='green'><strong>当一个标记为 <code>@Transactional</code> 的方法内部调用另一个 <code>@Transactional</code> 方法时，内部方法的事务设置可能不会生效。</strong></font></p><p><font color='red'><u><em><strong>4、多线程，</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>@transactional在多线程情况下是无法生效的，因为transactional的事务管理器是基于threadlocal‘，threadlocal是本来就是用来解决多线程线程安全的，她是线程隔离的。</strong></em></u></font></p></blockquote></blockquote><p><font color='green'>**我们说同一个事务，是指同一个数据库连接。继承AbstractRoutingDataSource，重写determineTargetDataSource。这个方法是核心，你会调用determineCurrentLookupKey，他就用来决定切换到哪一个数据源**</font></p><p><font color='red'><u><em><strong>Spring事务基于Spring AOP，Spring AOP底层用的动态代理，动态代理有两种方式：</strong></em></u></font></p><blockquote><p>基于接口代理(JDK代理)</p><ul><li>基于接口代理，凡是类的方法<strong>非public</strong>修饰，或者用了<strong>static、finanl</strong>关键字修饰（不能重写），</li></ul><p>基于CGLib代理(子类代理)</p><ul><li>基于子类代理，凡是类的方法使用了private、static、final修饰，那这些方法都不能被Spring AOP增强 由于是继承关系，无法代理final的类和方法(无法继承)，或是private的方法(对子类不可见)。</li></ul></blockquote><p>————————————————</p><p>这个注解有几个核心的字段，</p><p><font color='green'><strong>事务的隔离级别</strong></font></p><p><code>isolation</code> ：事务的隔离级别，默认值为 <code>Isolation.DEFAULT</code>。</p><table><thead><tr><th>Isolation.DEFAULT：使用底层数据库默认的隔离级别。</th></tr></thead><tbody><tr><td>Isolation.READ_UNCOMMITTED</td></tr><tr><td>Isolation.READ_COMMITTED</td></tr><tr><td>Isolation.REPEATABLE_READ</td></tr><tr><td>Isolation.SERIALIZABLE</td></tr></tbody></table><p><font color='green'><strong>传播机制</strong></font></p><blockquote><table><thead><tr><th><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。**(** 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 <strong>）</strong></th></tr></thead><tbody><tr><td><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行</td></tr><tr><td><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</td></tr><tr><td><code>Propagation.REQUIRES_NEW</code>：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。**(** 当类A中的 a 方法用默认<code>Propagation.REQUIRED</code>模式，类B中的 b方法加上采用 <code>Propagation.REQUIRES_NEW</code>模式，然后在 a 方法中调用 b方法操作数据库，然而 a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停 a方法的事务 <strong>)</strong></td></tr><tr><td><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</td></tr><tr><td><code>Propagation.NEVER</code>：以非事务的方式运行，如果当前存在事务，则抛出异常。</td></tr></tbody></table></blockquote><p><font color='green'><strong>是否为只读</strong></font></p><blockquote><p>默认情况下是false，如果你的事务确实只有查询的需求，那就可以这里设置为true；</p></blockquote></blockquote><blockquote><p><font color='red'><u><em><strong>常用的注解？</strong></em></u></font></p><p><a href="https://nageoffer.com/pages/7563ce/#%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3">https://nageoffer.com/pages/7563ce/#%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3</a></p><p><font color='red'><u><em><strong>注解是什么作用?</strong></em></u></font><br>注解其实就是一些标记，有了标记之后，我们就可以在解析的时候得到这个标记，然后做一些特别的处理，这就是注解的作用，注解就是标记，可以给编译器用，也可以写入class，可以通过反射得到。</p><blockquote><p><font color='red'><u><em><strong>spring常用的注解</strong></em></u></font></p></blockquote><blockquote><p>@Component(“foo”) &#x2F;&#x2F; 声明一个 Foo 类型的 Bean，其 beanName 为 “foo”<br>@Named(“a”) &#x2F;&#x2F; &#x3D;&#x3D; @Component(“a”)<br>@ManagedBean &#x2F;&#x2F; &#x3D;&#x3D; @Component<br>@Configuration &#x2F;&#x2F; 声明一个配置类，其本身也视为一个 Bean<br>@Bean &#x2F;&#x2F;注解用于注解在工厂方法上，标明该方法返回的对象需要作为一个 Bean 交由 Spring 管理。<br>@Lazy 懒加载：延迟单例 Bean 的加载时机，在不被其他非懒加载 Bean 依赖的情况下，不在 AbstractApplicationContext.refresh 执行过程中随其他单例 Bean 提前实例化，而是等到被从 Spring 容器获取时再初始化</p></blockquote><blockquote><p>@PostConstruct &#x2F;&#x2F;被 @PostConstruct 注解的方法会在 Bean 初始化后调用</p></blockquote><blockquote><hr></blockquote><blockquote><p><font color='red'><u><em><strong>Spring Web常用的注解</strong></em></u></font></p></blockquote><blockquote><p>1、@Controller &amp; @Service &amp; @Repository<br>2、@RequestMapping：<br>@Controller<br>@RequestMapping(“&#x2F;example”) &#x2F;&#x2F; 当放在类上时，等同于定义公共路径前缀<br> @RequestMapping(<br>        path &#x3D; {“&#x2F;method1”, “&#x2F;method”}, &#x2F;&#x2F; 支持同时映射多个路径<br>        method &#x3D; RequestMethod.GET<br>    )<br> public String method1() {<br>     &#x2F;&#x2F; 处理 &#x2F;example&#x2F;method1 或 &#x2F;example&#x2F;method 的 get 请求<br>     return “view1”;<br> }<br>@RequestParam、@PathVariable、@RequestBody不同<br><a href="http://localhost:8080/find/1/china/2?id=100&amp;name=zhangSan%E3%80%82%E5%88%99">http://localhost:8080/find/1/china/2?id=100&amp;name=zhangSan。则</a> @RequestParam 可以用来获取 “?” 后面的 id、name 参数，而 @PathVariable 则是获取 url 中的参数，如里面的 “1”、”china”、”2”</p></blockquote><blockquote><ol start="3"><li>@ResponseBody<br> 直接放回JSON数据，不需要渲染<br> 7.@ControllerAdvice官方提供的仅针对控制器的切面注解<br> 依赖注入的注解<br> 1、@Autowired @Qualifier 等同与@Inject @Named<br> 2、@Resource<br> 3、@Value 注解可以使用 ${} 语法注入配置文件的某些配置，也可以使用 #{} 语法注入 Spring 容器中的 Bean</li></ol></blockquote><blockquote><hr><p><font color='red'><u><em><strong>Spring上下文注解</strong></em></u></font></p></blockquote><blockquote><ol><li>@ComponentScan</li></ol></blockquote><p><font color='red'><u><em><strong>AOP是什么？</strong></em></u></font></p><p><font color='green'><u><em><strong>aop是面向切面编程， 把一些和业务无关的公共的代码抽出来自己弄成一个模块。然后在不改变原有的逻辑情况下动态的切入到类的指定方法、指定位置上，这个就是aop 底层是动态代理JDK和CGLIB</strong></em></u></font></p><p>bean实例化之后的第二个后置处理器那里创建代理对象</p><p><font color='red'><u><em><strong>有没有用过AOP</strong></em></u></font></p><p><font color='green'><u><em><strong>有的，我之前在一个分库分表的组件项目里面用到过，就是分库分表要切换数据源，我就是用aop切面去计算出落到哪个库哪个表里面，切入点是一个注解。Transactional这个注解其实也是aop，还有一些监控到注解什么的</strong></em></u></font></p><p><font color='red'><u><em><strong>aop的实现方式</strong></em></u></font></p><blockquote><p><font color='green'><strong>0、最常见，通过注解实现AOP，Aspect</strong></font></p></blockquote><blockquote><p><font color='green'><strong>1、Spring API实现AOP，</strong></font></p></blockquote><blockquote><p><font color='green'><strong>2、自定义切面类，用xml配置</strong></font></p></blockquote><p><font color='red'><u><em><strong>aop失效的原因和解决方法</strong></em></u></font></p><blockquote><p>失效原因联系动态代理失效的原因</p></blockquote><blockquote><p><font color='red'><u><em><strong>失效原因：1、自调用。2、final。3、static</strong></em></u></font></p></blockquote><blockquote><p><font color='blue'><u><em><strong>解决方法：在方法a中获取当前代理对象p, 执行p.a()可使得事务生效</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>aop用那种动态代理</strong></em></u></font></p><blockquote><p>如果被代理对象实现了接口，那么SpringAOP会优先使用<em>JDK动态代理</em>；否则，它会使用<em>CGLIB代理</em></p></blockquote><p><font color='red'><u><em><strong>IOC</strong></em></u></font></p><blockquote><p><font color='green'><u><em><strong>控制反转的意思，以前我们创建的时候new，但是这种方法很麻烦，且很难处理对象直接的依赖关系。他是把对象创建和对象之间的调用过程，交给spring进行管理。</strong></em></u></font></p></blockquote><blockquote><p><font color='green'><u><em><strong>Spring有几种容器</strong></em></u></font></p></blockquote><blockquote><ol><li><strong>BeanFactory</strong>: BeanFactory是Spring框架最基本的IOC容器。</li><li><strong>ApplicationContext</strong>: ApplicationContext是BeanFactory的子接口，提供了更多的企业级功能，如国际化处理、事件传播、应用层面的异常处理等。它对BeanFactory进行了扩展，是Spring中最常用的IOC容器。</li><li><strong>ClassPathXmlApplicationContext</strong>: ClassPathXmlApplicationContext是从类路径下加载配置文件的容器，通过XML文件配置来管理Bean。</li><li><strong>FileSystemXmlApplicationContext</strong>: FileSystemXmlApplicationContext从文件系统中加载配置文件的容器，同样也是通过XML文件配置来管理Bean。</li><li><strong>AnnotationConfigApplicationContext</strong>: AnnotationConfigApplicationContext是通过Java类配置来管理Bean的容器，不需要XML配置文件，而是通过注解来完成Bean的定义和依赖注入。</li></ol></blockquote><p><font color='red'><u>**BeanFactory和FactoryBean，ApplicationContext的区别？ **</u></font></p><blockquote><p><font color='green'><strong>答：①BeanFactory是⼀个Factory接⼝，是⽤来管理bean的IOC容器或对象⼯⼚。 ②FactoryBean是⼀个Bean接⼝，是⼀个可以⽣产或者装饰对象的⼯⼚Bean，可以通过 实现该接⼝⾃定义的实例化Bean的逻辑。③ApplicationConext是BeanFactory的⼦接 ⼝，扩展了其功能，ApplicationContext是⽴即加载</strong></font></p></blockquote><p><font color='red'><u><em><strong>Bean的生命周期？</strong></em></u></font></p><blockquote><p>—实例化</p></blockquote><blockquote><p>1 、扫描各种注解 @Compoent、@Service、@Configuration加载<strong>Bean信息</strong></p></blockquote><blockquote><p>2、用<strong>BeanDefinitionReader</strong>把Bean解析成BeanDefinition（类名、方法名、等等）结构，放到beanDefinitionMap，扫描这个</p></blockquote><blockquote><p>3、从BeanDefinition里面拿Bean.Class的构造函数，通过反射创建Bean，这里构造函数的选用，一般先选有autowire修饰和无参构造函数。</p></blockquote><blockquote><p>初始化—–</p></blockquote><blockquote><p>4、populate方法，先设置一些必要的属性（公有，私有，注入方式），依赖注入</p></blockquote><blockquote><p>5、检查有没有实现aware结尾接口，有的话会调一个方法做处理，比如setclassname</p></blockquote><blockquote><p>7、<em><strong>BeanPostProcessor：前置处理器，你可以自定义</strong></em></p></blockquote><blockquote><p>8、 初始化操作，（先是@PostConstruct，afterpropertiesSet（InitializingBean接口的作用），init-method（自己指定的方法，spring是xml配置，boot可以注解））</p></blockquote><blockquote><p>9、<em><strong>BeanPostProcessor：自定义的逻辑后置处理</strong></em> aop核心底层动态代理</p></blockquote><p><font color='red'><u><em><strong>创建Bean的方式</strong></em></u></font></p><blockquote><ul><li><a href="https://blog.csdn.net/qq_42764468/article/details/103286994#1bean_8">1.使用默认的构造函数创建bean对象</a></li><li><a href="https://blog.csdn.net/qq_42764468/article/details/103286994#2bean_25">2.通过静态工厂方法创建bean</a></li><li><a href="https://blog.csdn.net/qq_42764468/article/details/103286994#3bean_90">3.通过实例工厂方法创建bean</a></li><li><a href="https://blog.csdn.net/qq_42764468/article/details/103286994#4FactoryBean_141">4.实现FactoryBean接口</a></li></ul></blockquote><p><font color='red'><u><em><strong>依赖注入Bean的方式</strong></em></u></font></p><blockquote><p><a href="https://blog.csdn.net/supercrazy008/article/details/132125887">https://blog.csdn.net/supercrazy008/article/details/132125887</a></p></blockquote><blockquote><p><font color='green'><strong>1、构造器，在对象实例化最开始将依赖对象注入到依赖项中</strong></font></p></blockquote><blockquote><p><font color='green'><strong>2、setter，基于 Setter 的 依赖注入是通过容器在调用无参构造函数或无参静态工厂方法来实例化您的 bean 后调用您的 bean 上的 setter 方法来完成的。</strong></font></p></blockquote><blockquote><p><font color='green'><strong>3、字段注入，bean变量上的注解进行依赖注入，本质上是通过反射直接注入到字段中</strong></font></p></blockquote><p><font color='red'><u><em><strong>为什么依赖注入不适合用字段注入？</strong></em></u></font></p><blockquote><p><font color='green'><strong>1、会导致循环依赖</strong></font></p></blockquote><blockquote><p><font color='green'><strong>2、无法为静态变量和final修饰的进行注入，原因是final变量必须在类实例化进行初始化</strong></font></p></blockquote><p><font color='red'><u><em><strong>Bean的循环依赖？</strong></em></u></font></p><blockquote><p><font color='green'><strong>循环依赖问题在Spring中主要有三种情况：</strong></font></p></blockquote><blockquote><ul><li><font color='green'><strong>第一种：通过构造方法进行依赖注入时产生的循环依赖问题。</strong></font><font color='red'><u><em><strong>Lazy懒加载</strong></em></u></font></li><li><font color='green'><strong>第二种：通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</strong></font></li><li><font color='green'><strong>第三种：通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</strong></font> <font color='red'><u><em><strong>三级缓存</strong></em></u></font></li></ul></blockquote><p>三次缓存中：<font color='green'><u><em><strong>一级缓存存放完整的bean，二级缓存存放半成品Bean、三级缓存放单例bean的创建工程ObjectFactory。</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>为什么三层？</strong></em></u></font></p></blockquote><blockquote><p><strong>所以如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题，如果加上AOP，两级缓存是无法解决的。如果对象被AOP代理了，我每次从三级缓存中拿到singleFactory对象，执行getObject()方法会产生新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象</strong></p></blockquote><p>![<img src="/../images/%E5%85%AB%E8%82%A1-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/b892927da91c1058a04184035a05e02a.png" alt="在这里插入图片"></p><p><font color='red'><u><em><strong>可以直接调用bean.init的进行初始化吗？</strong></em></u></font></p><blockquote><p><font color='green'><strong>最好不要，如果你在new之后直接调用init方法，那会出现一种情况，假设这个bean里面有个Car类，然后我做初始化setName结果人家刚刚实例化，就会报空指针异常。</strong></font></p></blockquote><blockquote><ul><li><font color='green'><strong><code>private Car car;</code> 这行代码在栈内存中为 <code>car</code> 引用变量分配空间。这个空间只是用来存储引用的</strong></font></li><li><font color='green'><strong><code>car = new Car();</code> 这行代码在堆内存中为 <code>Car</code> 对象分配空间，并将堆内存中的对象地址赋值给 <code>car</code> 引用变量。</strong></font></li></ul></blockquote><p><font color='red'><u><em><strong>Autowire和Resourse</strong></em></u></font></p><p>Autowire默认按类型，如果想要实现按名字注入，主要配置@Primary 或者@Qualifier</p><p>Resource默认按名字然后类型。<font color='blue'><u><em><strong>spring推荐setter和构造器，但是我们用字段注入比较简单，idea明确不推荐Autowire，我觉得原因是和框架的强耦合。</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>Springboot启动流程</strong></em></u></font></p></blockquote><blockquote><p><font color='red'><u><em><strong>主要分为4步：服务构建、环境准备、容器创建、填充容器。</strong></em></u></font></p></blockquote><blockquote><p><font color='green'><strong>1、服务构建就是构造springapplication，包括确认web服务器、加载spring.factories下的所有初始化类监听器，找到主导方法。</strong></font></p></blockquote><blockquote><p><font color='green'><strong>2、然后调用run方法进入环境准备，通过配置类、和配置文件构造出一个environment，用于后面的容器创建。</strong></font></p></blockquote><blockquote><p><font color='green'><strong>3、容器创建的话，其实就是创建一个BeanFactory，然后加载bean信息，通过beanDefinitionReader把bean信息读成BeanDefinition并且把他放到beanDefinitionMap里面</strong></font></p></blockquote><blockquote><p><font color='green'><strong>4、填充容器。就是我们的refresh（）方法，一个12步，但是可以分成四块，预处理，后置处理器，国际化分派器，实例化剩下的所有bean。</strong></font></p></blockquote><p><font color='red'><u><em><strong>容器初始化流程</strong></em></u></font></p><blockquote><p>1、prepareRefresh()刷新前的预处理：<br>2、obtainFreshBeanFactory()：创建容器对象，实际就是获取一个DefaultListenableBeanFactory：<br>3、prepareBeanFactory(beanFactory)：BeanFactory的预处理工作，向容器中添加一些组件：<br>4、postProcessBeanFactory(beanFactory)：</p></blockquote><blockquote><p>5、invokeBeanFactoryPostProcessors(beanFactory)：即BeanFactory的后置处理器：<br>6、registerBeanPostProcessors(beanFactory)：向容器中注册Bean的后置处理器BeanPostProcessor，它的主要作用是干预Spring初始化bean的流程，从而完成代理、自动注入、循环依赖等功能</p></blockquote><blockquote><p>7、initMessageSource()：初始化MessageSource组件，主要用于做国际化功能，消息绑定与消息解析：<br>8、initApplicationEventMulticaster()：初始化事件派发器，在注册监听器时会用到：</p></blockquote><blockquote><p>9、onRefresh()：留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑</p></blockquote><blockquote><p>10、registerListeners()：注册监听器：将容器中所有的ApplicationListener注册到事件派发器中，并派发之前步骤产生的事件：<br>11、finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；<br>12、finishRefresh()：发布BeanFactory容器刷新完成事件：</p></blockquote><blockquote><p>可以分成四块</p></blockquote><blockquote><p><font color='green'><strong>第一步：预处理，包括刷新的预处理，然后获取我们刚刚创建的BeanFactory再做预处理。</strong></font></p></blockquote><blockquote><p><font color='green'><strong>第二步：后置处理器，执行BeanFactory的后置处理器，然后在容器里面注册一个Bean的后置处理器。</strong></font></p></blockquote><blockquote><p><font color='green'><strong>第三步：就是一些国际化，事件分派器的东西。</strong></font></p></blockquote><blockquote><p><font color='green'><strong>第四步：非常重要了，finishBeanFactoryInitailization，初始化所有剩下的单实例bean，bean的生命周期也从这里开始。</strong></font></p></blockquote><p><font color='red'><u><em><strong>Spring用到的设计模式</strong></em></u></font></p><blockquote><p>单例模式：这个在创建Bean的时候用到，创建单例Bean的时候会先去缓存里面找，如果找不到，在触发createBean方法。</p><p>工厂模式：spring的ioc容器就是哥工厂</p><p>代理模式：就是aop。jdk和cglib</p><p>模版模式：jdbcTemplate，还有编程式事务</p></blockquote><p><font color='red'><u><em><strong>Springboot自动装配？</strong></em></u></font></p><blockquote><p>springboot的自动配置是指根据类路径下的jar包、类，为jar包里面的类进行自动配置，简单的说就是会根据classpath下的类，自动的给你生成bean，加载到ioc容器中</p><p><font color='blue'><u><em><strong>springboot的自动装配是依赖于springbootapplication这个注解，这个注解是一个复合注解，真正实现自动装配的是一个enableautoConfiguration这个注解，这个注解里面import了一个selector。 我们引入的starter里面会有@Configuration配置类，然后这个配置类的路径放在spirng.factories下，selector用springfactoryloader找到配置类，最后我们spring会通过ImportSelector接口去实现动态的加载bean，加载过程中会依赖于一些注解，@ConditionalOnBean和@ConditionalOnMissingBean 定义的条件进行选择加载。</strong></em></u></font></p></blockquote><p><font color='red'><u><em><strong>Bean是线程安全的吗？</strong></em></u></font></p><blockquote><p>默认单例，但是不是线程安全。因为Bean内部的成员变量是共享可修改的，所以不是线程安全的。多例是线程安全的</p></blockquote><p><font color='red'><u><em><strong>Spring MVC的工作流程如下：</strong></em></u></font></p><p><img src="/../images/%E5%85%AB%E8%82%A1-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9e7bc8a9246e6e95c4468a138f5a5403.jpg" alt="在这里插入图片描述"></p><blockquote><ol><li><font color='green'><strong>用户发送请求至前端控制器DispatcherServlet</strong></font></li><li><font color='green'><strong>前端控制器收到请求调用处理器映射器，处理器映射器根据请求url找到具体的处理器，然后吧处理器和处理器拦截器封装成执行链返回给DispatcherServlet</strong></font></li><li><font color='green'><strong>DispatcherServlet根据处理器Handler，找到对应的处理器适配器HandlerAdapter执行handle方法，就调用对应的controller</strong></font></li><li><font color='green'><strong>方法如果添加了ResponseBody就转为json直接返回了，都则可能还要视图解析，渲染一下。</strong></font></li></ol></blockquote></blockquote><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><blockquote><p><font color='blue'><u><em><strong>Mybatis怎么传多个参数：</strong></em></u></font></p><blockquote><p><font color='green'><strong>1、顺序传参</strong></font></p><blockquote></blockquote><p><font color='green'><strong>2、map传参</strong></font></p><blockquote></blockquote><p><font color='green'><strong>3、用mybatis的注解，Param</strong></font></p></blockquote><p><font color='blue'><u><em><strong>MyBatis中${} 和 #{} 有什么区别</strong></em></u></font></p><blockquote><p><font color='green'><strong>1、功能不同： #{} 是占位符，${} 是直接替换，；2、使用场景不同：普通参数使用 #{}，如果传递的是 SQL 命令或 SQL 关键字，需要使用 ${}，但在使用前一定要做好安全验证；3、安全性不同：使用 ${} 存在安全问题，而 #{} 则不存在安全问题。</strong></font></p></blockquote></blockquote><h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><p><font color='red'><u><em><strong>git rebase 和 git merge</strong></em></u></font></p><blockquote><p>git merge ，会保留历史的提交，然后new一个新的提交记录</p><p>rebase是一般在非公共分支上rebase，然后合并到main分支，原来的那个分支会被清除。</p></blockquote><p><strong>setNX有什么缺陷？</strong>redison锁过期的问题</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><strong>1、进程和线程的区别</strong></p><blockquote><p><font color='green'><strong>1、进程是操作系统资源分配的基本单位，把磁盘的代码加载到内存，分配数据空间。</strong></font></p><p><font color='green'><strong>2、线程是任务调度的基本单位，进程的一个实体，cpu运行和独立调度的基本单位，cpu上面真正运行的其实是线程</strong></font></p><p><font color='green'><strong>3、一个进程可以拥有多个线程。</strong></font></p><p><font color='green'><strong>4、线程的切换消耗要比进程小。共享代码区、数据区，堆区</strong></font></p></blockquote><p><strong>2、死锁</strong></p><blockquote><p>多个进程，互相请求对方已经持有的资源。</p><p><font color='green'><strong>互斥条件</strong></font></p><p><font color='green'><strong>请求和保持</strong></font></p><p><font color='green'><strong>不可被剥夺</strong></font></p><p><font color='green'><strong>循环等待</strong></font></p><p>死锁的检测：</p><ul><li>可以依赖JPS和JSTACK。用jps拿到java进程的id，然后jstack分析堆栈信息。</li><li>也可以用可视化工具virtualVM</li></ul><p>预防死锁：破坏这四个条件</p><p>解除死锁：资源剥夺、撤销进程、进程回退。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-Kafka</title>
      <link href="/2023/07/08/%E5%85%AB%E8%82%A1-Kafka/"/>
      <url>/2023/07/08/%E5%85%AB%E8%82%A1-Kafka/</url>
      
        <content type="html"><![CDATA[<p>常见面试问题：</p><p><font color='red'><u><em><strong>怎么配置</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>比如你的秒杀商品有1000件，处理一次购买请求的时间是500ms，那么总共就需要500s的时间。这时，你部署10个队列处理程序，那么秒杀请求的处理时间就是50s，也就是说用户需要等待50s才可以看到秒杀的结果，这是可以接受的。这时会并发10个请求到达数据库，并不会对数据库造成很大的压力。</strong></em></u></font></p></blockquote><h2 id="使用场景和作用"><a href="#使用场景和作用" class="headerlink" title="使用场景和作用"></a>使用场景和作用</h2><blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><font color='green'><strong>1、日志收集</strong></font></p><p><font color='green'><strong>2、消息队列</strong></font></p><p><font color='green'><strong>3、用户活动和运营指标追踪</strong></font></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><font color='green'><strong>1、削峰解耦，假设A系统每秒就处理1000个请求，那A去Kafka里面慢慢自己拉取就可以了，不会一股脑全部打到A系统上</strong></font></p><p><font color='green'><strong>2、高性能，有4点</strong></font></p><p><font color='green'><strong>3、高可用，持久化，两点，一个broker一个副本机制</strong></font></p><p><font color='green'><strong>4、可扩展，加机器</strong></font></p></blockquote><h2 id="Kafka高性能的设计"><a href="#Kafka高性能的设计" class="headerlink" title="Kafka高性能的设计"></a><strong>Kafka高性能的设计</strong></h2><p><font color='red'><u><em><strong>1）批量发送，并行发送。批量消费，并行消费。</strong></em></u></font></p><p><font color='red'><u><em><strong>2）磁盘顺序写（减少磁盘寻址时间）</strong></em></u></font></p><p><font color='red'><u><em><strong>3）MMF+页缓存</strong></em></u></font> 即使kafka是顺序写，这个本身比较快，速度也追不上内存。所以Kafka不是实时写入磁盘，而是先把数据写到页缓存里面，满足一定条件在刷回磁盘。它的工作原理是MMF，直接利用操作系统的页缓存来实现磁盘文件到物理内存的直接映射，完成映射之后你对物理内存的操作会被同步到硬盘上（操作系统在适当的时候）。</p><p><font color='red'><u><em><strong>4）零拷贝</strong></em></u></font></p><p><font color='red'><u><em><strong>传统的io，四次拷贝，其中两次是 DMA（直接内存访问） 的拷贝，另外两次则是通过 CPU 拷贝的。</strong></em></u></font></p><p>分别是：</p><ol><li>第一次：将磁盘文件，读到内核缓冲区；</li><li>第二次：将内核缓冲区的数据，copy 到 application 应用程序的 buffer；</li><li>第三步：将 application 应用程序 buffer 中的数据，copy 到 socket 网络发送缓冲区(属于操作系统内核的缓冲区)；</li><li>第四次：将 socket buffer 的数据，copy 到网卡，由网卡进行网络传输。</li></ol><p>零拷贝是只拷贝两次，</p><ul><li><font color='blue'><u><em><strong>Sendfile 可以直接将read buufer里面的文件内容拷贝到socket buffer，也是cpu介入，优化成了3次，后来在linux2.4里面直接可以用文件描述可以代替数据拷贝，Read Buffer 的内存地址、偏移量记录到相应的 Socket Buffer 中，这样就只剩下两次DMA的copy了</strong></em></u></font></li></ul><p><strong>DMA（直接存储器访问）用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输，他本质是一个硬件技术，就是比如你要把外设A的数据传到内存B，你直接给A和B之间加一条数据通路，然后给几个配件就可以实现，传输操作交给DMAC控制器（类似CPU）</strong></p><p><font color='red'><u><em><strong>用户态和内核态的内存拷贝开销有什么区别</strong></em></u></font></p><blockquote><p><font color='green'><strong>在用户态是个初级管理员，权限不高，只能通过系统调用进行内存拷贝，那就涉及到用户态和内核态的切换。</strong></font></p><p><font color='green'><strong>在内核态下高级管理员，进程具有直接访问物理内存的权限，可以直接进行内存拷贝操作，无需通过系统调用。这</strong></font></p></blockquote><h2 id="Kafka的高可用了解过吗"><a href="#Kafka的高可用了解过吗" class="headerlink" title="Kafka的高可用了解过吗"></a>Kafka的高可用了解过吗</h2><ul><li><p>集群：首先kafka集群由多个broker组成，一个broker宕机，其余的broker依旧提供服务。</p></li><li><p>副本机制：一个topic有多个分区，每个分区有多个副本 、存在不同的broker里面。然后如果leader故障了，会从ISR中选举新的leader（ISR中存活，并且排在AR列表前面的优先），通过高水位线保持同步。如果Follower挂了，先踢出ISR，如果恢复那就等日志末端位移追上leader的HW。</p><blockquote><table><thead><tr><th><strong>1.follower故障流程</strong></th><th></th><th></th></tr></thead><tbody><tr><td><img src="/../images/Kafka/b01dad78f006b40d82e719fe71caeb78.png" alt="image-20220902210759125"></td><td></td><td></td></tr><tr><td>2.leader故障流程</td><td></td><td></td></tr><tr><td><img src="/../images/Kafka/1f96e55810be5ff8cbf64c04b5d37315.png" alt="image-20220902210830344"></td><td></td><td></td></tr></tbody></table></blockquote></li></ul><h2 id="消息保证消息不丢失？可靠性"><a href="#消息保证消息不丢失？可靠性" class="headerlink" title="消息保证消息不丢失？可靠性"></a>消息保证消息不丢失？可靠性</h2><blockquote><p>分成三个方面分析：</p><p><font color='red'><u><em><strong>生产者发送丢失：</strong></em></u></font>【不能保证不丢失，重试失败】</p><blockquote><p><font color='red'><u><em><strong>他是有一个main线程会把消息发到消息累加器里面，然后sender线程把消息从消息累加器发送到broker。</strong></em></u></font></p><p><font color='green'><strong>1、重试机制</strong></font></p><p><font color='green'>**2、注册回调函数处理异步发送结果，如果发送失败进行记录或者重发 **</font></p><p><font color='green'><strong>3、ACK确认机制</strong></font></p><p>0：发了就不管了，<font color='green'><u><em><strong>这意味着消息可能会在发送之后丢失，而生产者将无法知道它是否成功到达服务器</strong></em></u></font></p><p>1：需要leader成功接收，<font color='green'><u><em><strong>leader同步Follower之前宕机，那消息可能就丢失</strong></em></u></font></p><p>-1：所有ISR的follower都成功接收才可以</p></blockquote><p><font color='red'><u><em><strong>broker存储丢失：</strong></em></u></font>【不能保证，borker持久化写到cache，万一机器宕机了】</p><blockquote><p><font color='green'><strong>replication.factor &gt;&#x3D; 3</strong></font></p><p><font color='green'><strong>min.insync.replicas：Kafka <a href="https://so.csdn.net/so/search?q=ISR&spm=1001.2101.3001.7020">ISR</a> 列表中最小同步副本数&gt;&#x3D;2</strong></font></p><p><font color='green'><strong>unclean.leader.election.enable&#x3D;false：非ISR的不能精选leader</strong></font></p></blockquote><p><font color='red'><u><em><strong>消费者消费丢失：</strong></em></u></font></p><blockquote><p><font color='green'><strong>设置自动提交enable.auto.commit 为 false</strong></font></p></blockquote></blockquote><h2 id="重复消费问题怎么解决？"><a href="#重复消费问题怎么解决？" class="headerlink" title="重复消费问题怎么解决？"></a>重复消费问题怎么解决？</h2><blockquote><p><font color='green'><strong>重复消费的话也分生产者和消费者。</strong></font></p><p><font color='green'><strong>生产者：两种重试机制</strong></font>，单分区内是可以用<font color='green'><u><em><strong>幂等性</strong></em></u></font>解决的。<font color='red'><u><em><strong>（enable.idempotence&#x3D;true）</strong></em></u></font></p><p><font color='green'><strong>消费者：消费者重复消费是因为自动提交，</strong></font>首先最好关闭自动提交，然后开启<font color='green'><u><em><strong>手动提交</strong></em></u></font>。用同步+异步的组合方式。</p></blockquote><p><font color='green'><u><em><strong>Kafka并发数和消费者的实例数有关，和批的大小无关</strong></em></u></font></p><h2 id="怎么保证顺序性-？"><a href="#怎么保证顺序性-？" class="headerlink" title="怎么保证顺序性 ？"></a>怎么保证顺序性 ？</h2><p>一个topic的数据会通过那个分区分配器分发到某个分区，如果会发到多个分区，我们是不能保证顺序性的，但是我们可以用幂等性保证在一个分区内是顺序的。因为生产者发送消息给broker的时候会携带PID和sequence number，一个是生产者的id，一个是消息的序列号。我们靠这个可以保证顺序性。所以我们尽可能的要把消息发到一个分区里面。那这个就要配合分区器来使用，如果你指定了分区号或者指定key，那就代表指定了某个分区，这样就能实现顺序性。如果你用没有指定，他就会用随机粘性分区策略，那就不能保证顺序性。</p><blockquote><p>生产者发送消息给broker的时候会携带PID和sequence number，一个是生产者的id，一个是消息的序列号。</p><p>broker中会在内存维护一个pid+分区对应的序列号。如果收到的序列号正好比内存序列号大一，才存储消息，如果小于内存序列号，意味着消息重复，那么会丢弃消息，并应答。如果远大于内存序列号，意味着消息丢失，会抛出异常。</p><p>了解：</p><p>至少一次（At Least Once）： ACK级别设置为-1 + 分区副本大于等于2 + ISR里应答的最小副本数量&gt;&#x3D;2。可以保证数据不丢失，但是不能保证数据不重复。<br>最多一次（At Most Once）：ACK级别设置为0 。可以保证数据不重复，但是不能保证数据不丢失。<br>精确一次（Exactly Once）：至少一次 + 幂等性 。 Kafka 0.11版本引入一项重大特性：幂等性和事务。</p></blockquote><blockquote><p>AR &#x3D; ISR + ORS</p><p>ISR 表示在保持一定程度同步的 follower 副本；</p><p>OSR 表示不能保持一定程度同步的follower副本</p></blockquote><p><strong>数据完全可靠条件 &#x3D; ACK级别设置为-1 + 分区副本大于等于2 + ISR里应答的最小副本数量大于等于2</strong></p><blockquote><p>幂等性只能保证的是在单分区单会话内不重复。如果设计到跨区，为了保证同时发的多条消息，要么全成功，要么全失败。kafka引入了事务</p><p>开启事务需要producer设置transactional.id的值并同时开启幂等性。</p><h2 id="定位事务协调器"><a href="#定位事务协调器" class="headerlink" title="定位事务协调器"></a>定位事务协调器</h2><p>其本质也是一个后端的broker，只是这个broker起到了针对当前事务的协调作用，它是在transaction_state特殊主题里面根据transcationid%50在一个特殊主题里面选出对应节点。</p><p>事务初始化</p><p>事务启动，消息发送</p><p>事务提交</p></blockquote><h2 id="Kafka文件存储机制"><a href="#Kafka文件存储机制" class="headerlink" title="Kafka文件存储机制"></a>Kafka文件存储机制</h2><blockquote><p><font color='blue'><u><em><strong>文件存储实际是按分区存的，一个分区对应多个segment（删除和查找方便），每一个segment里面都有三个文件，分别是log日志文件，index索引文件，timeindex时间戳索引文件，producer的数据会追加到log里面，每次往log里面写4k数据，就会到index文件写一条索引。</strong></em></u></font></p></blockquote><h2 id="Kafka数据清理机制"><a href="#Kafka数据清理机制" class="headerlink" title="Kafka数据清理机制"></a>Kafka数据清理机制</h2><p>Kafka提供了两种日志清理策略。</p><p><font color='blue'><u>**日志删除(delete) **</u></font>: 日志删除也分两种</p><p>​按照时间，当消息保存的时间超过指定的时间（默认七天），就会触发清理</p><p>​按照文件大小：当topic所有 分区的数据总和达到了默认的阈值（1G），就开始删除最久的消息</p><p><font color='blue'><u>**日志压缩(compact) **</u></font>:针对每个消息的key进行整合，对于有相同key的不同value值，只保留最后一个版本。</p><h2 id="消息堆积-（-消费者如何提高吞吐量）"><a href="#消息堆积-（-消费者如何提高吞吐量）" class="headerlink" title="消息堆积 （ 消费者如何提高吞吐量）"></a>消息堆积 （ 消费者如何提高吞吐量）</h2><blockquote><p><font color='green'><strong>上游可以增加分区数量和调整batchsize和lingerms</strong></font></p><p><font color='green'><strong>下游可以增加消费者数量和调大消费者每次拉取的消息大小</strong></font></p><p><font color='green'><strong>数据倾斜问题，那就调整一下消息分区的策略，使其平均的散发每一个分区</strong></font></p></blockquote><h2 id="Kafka选举机制："><a href="#Kafka选举机制：" class="headerlink" title="Kafka选举机制："></a>Kafka选举机制：</h2><p><font color='blue'><u><em><strong>broker（控制器）选leader</strong></em></u></font></p><blockquote><p>集群中由很多的broker选出一个leader，其他事follower。负责主题创建删除，管理broker，分区重分配，分区leader选举等等</p><p>方法简单粗暴：</p><p>每个broker都有唯一的brokerId，启动后会去竞争注册zookeeper上的Controller结点，谁先抢到，谁就是broker leader。一般第一个broker都是controller。而其他broker会监听该结点事件，以便后续leader下线后触发重新选举。</p><p><img src="/../images/Kafka/12b4f076e8f82c66b00ec8782433649f.png" alt="image-20220902200901222"></p></blockquote><p>分区多副本选leader</p><ul><li><font color='blue'><u><em><strong>由controller节点控制，决策是：ISR中存活，并且排在AR列表前面的优先，同时必须在isr里面。</strong></em></u></font></li></ul><blockquote><p><img src="/../images/Kafka/e5c14b9c17123faf3eefa58a22ab0668-20230928225949575.png" alt="image-20220902201352868"></p></blockquote><p><font color='blue'><u><em><strong>消费者选Leader</strong></em></u></font></p><blockquote><p><font color='green'><strong>先用groupid%50 得到一个主题分区（consumer_offset），这个分区所属的节点的消费者协调器就作为这个消费者组的老大，每个消费者向这个协调器发送joinGroup请求，具体的选举方法是，取出HashMap里面的第一个，就是消费者组的信息是放在一个hashmap里面的，我么选的时候是直接拿出第一个就好。所以比较偏随机。</strong></font></p></blockquote><h2 id="Kafka分区机制"><a href="#Kafka分区机制" class="headerlink" title="Kafka分区机制"></a><font color='red'><u><em><strong>Kafka分区机制</strong></em></u></font></h2><blockquote><p>分为<font color='green'><strong>生产者分区和消费者分区</strong></font>。还有一种副本分区机制，那个先不说。</p><p>1、生产者分区就是依赖于main线程里面的消息分区器，他有一个默认的分区器DefaultPartitioner，支持4种分区策略 1) 指定分区； 2）指定key，计算hash得分区； 3）指定随机粘性分区以前是轮训；（4）还可以自定义分区器（见代码）（下图））</p><p>2、消费者分区就是谁去消费谁的问题，支持三种策略：RoundRobin[轮训，036，14，25]、Range【123，45，67】、sticky粘性分区</p></blockquote><h1 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h1><p>分布式的基于发布订阅模式的消息队列</p><p>主要应用场景包括：<strong>缓存消峰</strong>、<strong>解耦</strong>和<strong>异步通信。</strong></p><p>消息队列有两种模式：</p><ul><li>点对点模式：一个消费者消费一个主题，数据被消费后会删除</li><li>发布订阅模式：多个消费者消费多个主题，数据被消费不会删除</li></ul><p><strong>基础架构</strong>：</p><p><img src="/../images/Kafka/708e86e70504f41234b05cb3cc30dea7.png" alt="image-20220902125656203"></p><p>（1）Producer：消息生产者，就是向 Kafka broker 发消息的客户端。</p><p>（2）Consumer：消息消费者，向 Kafka broker 取消息的客户端。</p><p>（3）Consumer Group（CG）：消费者组，由多个 consumer 组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</p><p>（4）Broker：一台 Kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个broker 可以容纳多个 topic。</p><p>（5）Topic：可以理解为一个队列，生产者和消费者面向的都是一个 topic。</p><p>（6）Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。</p><p>（7）Replica：副本。一个 topic 的每个分区都有若干个副本，一个 Leader 和若干个Follower。</p><p>（8）Leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 Leader。</p><p>（9）Follower：每个分区多个副本中的“从”，实时从 Leader 中同步数据，保持和Leader 数据的同步。Leader 发生故障时，某个 Follower 会成为新的 Leader。</p><p>其实总的流程就是生产者发送数据到kafka，然后消费者从kafka拉取数据。所以架构中最主要的就是生产者、kafka集群和消费者这三个，其他的很多知识都是为了这三个服务的。</p><h1 id="2、生产者"><a href="#2、生产者" class="headerlink" title="2、生产者"></a>2、生产者</h1><p> 在消息发送的过程中，涉及到两个线程，<font color='red'><u><em><strong>main线程和sender线程。</strong></em></u></font></p><p>main线程的流程就是<strong>producer</strong>（就是生产者）、然后拦截器（相当于留了一个供我们修改的接口）、<strong>序列化器</strong>（消息发送总要有一种形式，什么json啊）、分区器（我们事先其实是分好了区，但是发送消息的时候发送到那一个区？<strong>分区器</strong>，他有一个默认的分区器DefaultPartitioner，支持三种分区策略 1) 指定分区； 2）指定key，计算hash得分区； 3）指定随机粘性分区；（4）还可以自定义分区器（见代码）（下图））<img src="/../images/Kafka/18a0b6ba56db8e5b16b3d6fac9ba7fb7.png" alt="image-20220902163808502"></p><p>但是，并不是来一条消息就发一次，他是把消息加入到一个叫消息累加器里面，然后进行批量发送，一次是16k，32M大小的内存。 我看了下代码，就是 累加器的存储形式为ConcurrentMap&lt;TopicPartition, Deque<ProducerBatch>&gt;，一个分区对应一个双端队列</p><p>真正的发送要靠sender线程。发送的时机是：当双端队列中的DQueue满足 batch.size 或者 linger.ms 条件时触发sender线程。 同时Sender线程默认每个分区容纳5个未确认的消息，消息发送失败后会进行重试。</p><p><img src="/../images/Kafka/cd41370a872e70b75435f35692925370.png" alt="image-20220902155220662"></p><h1 id="3、Broker"><a href="#3、Broker" class="headerlink" title="3、Broker"></a>3、Broker</h1><h2 id="Broker架构"><a href="#Broker架构" class="headerlink" title="Broker架构"></a>Broker架构</h2><p>一台机器一个broker</p><p><img src="/../images/Kafka/image-20231024150746020.png" alt="image-20231024150746020"></p><p><strong>Zookeeper</strong>的作用</p><blockquote><p>Zookeeper在Kafka中扮演了重要的角色，kafka使用zookeeper进行<font color='red'><u><em><strong>元数据管理，保存broker注册信息，包括主题（Topic）、分区（Partition）信息等，选择分区leader。</strong></em></u></font></p><p><img src="/../images/Kafka/b1f0ebc535b00384be6bf81540c5f416.png" alt="image-20220902200249692"></p></blockquote><h2 id="kafka分区策略"><a href="#kafka分区策略" class="headerlink" title="kafka分区策略"></a>kafka分区策略</h2><p>如果 kafka 服务器只有 4 个节点，那么设置 kafka 的分区数大于服务器台数，在 kafka底层如何分配存储副本呢？</p><ul><li>这里如果用默认的就是如下</li></ul><p><img src="/../images/Kafka/15514da0f22aca9e3017fa2305733ba4.png" alt="image-20220902211334365"></p><ul><li>也可以手动指定</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim increase-replication-factor.json</span><br><span class="line">输入如下内容：</span><br><span class="line">&#123;</span><br><span class="line">&quot;version&quot;:1,</span><br><span class="line">&quot;partitions&quot;:[</span><br><span class="line">&#123;&quot;topic&quot;:&quot;three&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[0,1]&#125;,</span><br><span class="line">&#123;&quot;topic&quot;:&quot;three&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[0,1]&#125;,</span><br><span class="line">&#123;&quot;topic&quot;:&quot;three&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,0]&#125;,</span><br><span class="line">&#123;&quot;topic&quot;:&quot;three&quot;,&quot;partition&quot;:3,&quot;replicas&quot;:[1,0]&#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1、分区自动调整"><a href="#1、分区自动调整" class="headerlink" title="1、分区自动调整"></a><strong>1、分区自动调整</strong></h3><p>这个是指broker故障，<font color='blue'><u><em><strong>leader集中在某台broker上的情况</strong></em></u></font>，造成集群负载不均衡，这时候就需要分区平衡。那他一般有个比例，就是不平衡比例超过10%，就需要再平衡。</p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h1 id="4、kafka消费者"><a href="#4、kafka消费者" class="headerlink" title="4、kafka消费者"></a>4、kafka消费者</h1><h2 id="0、重平衡"><a href="#0、重平衡" class="headerlink" title="0、重平衡"></a>0、重平衡</h2><p><font color='red'><u><em><strong>当消费者的数量或者订阅主题的数量发生变化的时候会发生重平衡。</strong></em></u></font></p><p><font color='red'><u><em><strong>首先1、暂停所有消费者消费，2、重新计算分区分配方案，3、通知消费者、4、重新分配分区、5、重新启动消费。</strong></em></u></font></p><p><font color='blue'><u><em><strong>分区方案还是那三个【Range、RoundRobin、Sticky】</strong></em></u></font></p><h2 id="1、Kafka-消费方式（pull拉）"><a href="#1、Kafka-消费方式（pull拉）" class="headerlink" title="1、Kafka 消费方式（pull拉）"></a>1、Kafka 消费方式（pull拉）</h2><p><font color='blue'><u><em><strong>为什么</strong></em></u></font></p><blockquote><p><font color='red'><u><em><strong>能够匹配broker的发送速率和consumer的消费速率吧</strong></em></u></font></p></blockquote><h2 id="2、消费者工作流程"><a href="#2、消费者工作流程" class="headerlink" title="2、消费者工作流程"></a>2、消费者工作流程</h2><p><strong>消费者组初始化流程</strong></p><p><a href="https://baijiahao.baidu.com/s?id=1767477534734641183&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1767477534734641183&amp;wfr=spider&amp;for=pc</a></p><p>多个消费者协调器发送JoinGroup请求，协调器选一个消费者leader，消费者leader指定消费方案，并发送给协调器，协调器把这个方案通知到每一个消费者。</p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235058845.png" alt="在这里插入图片描述"></p><p><strong>消费者组详细消费流程</strong></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235306060.png" alt="在这里插入图片描述"></p><h2 id="4、消费者分区的分配"><a href="#4、消费者分区的分配" class="headerlink" title="4、消费者分区的分配"></a>4、消费者分区的分配</h2><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235523539.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235554746.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000334551.png" alt="在这里插入图片描述"></p><h5 id="Sticky-以及再平衡"><a href="#Sticky-以及再平衡" class="headerlink" title="Sticky 以及再平衡"></a>Sticky 以及再平衡</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000640458.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000728390.png" alt="在这里插入图片描述"></p><h2 id="5、offset-位移"><a href="#5、offset-位移" class="headerlink" title="5、offset 位移"></a>5、offset 位移</h2><h5 id="1、offset-的默认维护"><a href="#1、offset-的默认维护" class="headerlink" title="1、offset 的默认维护"></a>1、offset 的默认维护</h5><blockquote><p><font color='blue'><u><em><strong>__consumer_offsets 主题里面采用 key 和 value 的方式存储数据。</strong></em></u></font></p><p><font color='blue'><u><em><strong>key 是group.id+topic+分区号，value 就是当前 offset 的值。</strong></em></u></font></p></blockquote><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000851750.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929001509066.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-计算机网络1</title>
      <link href="/2023/07/08/%E5%85%AB%E8%82%A1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"/>
      <url>/2023/07/08/%E5%85%AB%E8%82%A1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/</url>
      
        <content type="html"><![CDATA[<p>计算机网络整体的学习可以按照tcpip网络模型进行学习。我们的总结也是这样的</p><p>Tcp&#x2F;ip网络模型分别是应用层、传输层、网络层、数据链路层</p><p>这里面前三层比较重要，数据链路层复杂的方面涉及实际的物理知识所以我们只对逻辑思想上做一个学习，</p><p>那每一层分别学的是什么呢？</p><p>应用层：HTTP  HTTPS TLS</p><p>传输层：tcp udp </p><p>网络层：ipv4 v6</p><p>基本上就是这样子</p><p>TCP 连接传输协议，这是传输层的，很多应用层的协议在传输层都是使用这个的，比如HTTP</p><p><font color='red'><u><em><strong>Dns基于什么协议实现？udp 还是 tcp？</strong></em></u></font></p><blockquote><p><font color='green'><strong>DNS域名解析服务，需要快速响应，而udp这种不需要建立连接的，简单快速的，轻量级的是比较适合的</strong></font></p></blockquote><p>TCP</p><h1 id="TCP和UDP的不同"><a href="#TCP和UDP的不同" class="headerlink" title="TCP和UDP的不同"></a>TCP和UDP的不同</h1><blockquote><p>那tcp和udp的差距是，tcp相比udp多了很多为了可靠连接所增加的特性，比如三次握手、四次挥手、拥塞控制，超时重传，就是为了数据能可靠的传到对方。udp他不用建立连接，不保证可靠交付，所以效率高。</p><p>除此之外，还有一个很大的不同就是tcp是会分片的，但是udp是不会分片。在这里我们还要知道的一点是在网络层，也就是ip协议中还是会分片的，大小是MTU。但是对于tcp来说因为你要是在ip层才分片，我为了保证可靠，我假设12345 丢了一个2，那我就要12345全部重新发，这样不好，所以我们就在tcp层也分片，大小是MSS。而udp不用可靠，所以他不用分片。</p></blockquote><p>报文头也不一样：udp是源端口目的端口，长度校验和。tcp多了很多东西，源端口目的端口，序列号确认号，状态位，首部长度，校验和等等。</p><p>但是过程中究竟是请求-应答模式还是什么模式，那就是后面的不同版本做出的更新。</p><p>但是他并不是不能做到可靠传输，因为udp只是传输层，我们还可以在应用层做出一定的限制来保证传输是可靠的，比如quic协议，当然这是困难的。</p><h1 id="那我们这里用输入网址到显示，来串联一下整体的流程："><a href="#那我们这里用输入网址到显示，来串联一下整体的流程：" class="headerlink" title="那我们这里用输入网址到显示，来串联一下整体的流程："></a>那我们这里用输入网址到显示，来串联一下整体的流程：</h1><p>首先是解析URL，得到三个信息，一个协议、一个域名、一个路径。</p><p>（浏览器缓存 -&gt; 操作系统缓存-&gt;本地DNS服务器-&gt;根域名服务器-&gt;顶级域名服务器-&gt;权威域名服务器）</p><p>根据域名，我们可以先去浏览器缓存里面找有没有，如果有，就直接返回，如果没有那就问操作系统的缓存再去看hosts文件，如果都没有，那就看走下面</p><p>客户端首先会发出一个 DNS 请求，问 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 是啥，发给本地 DNS 服务器。</p><p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.xx.com,则它直接返回/">www.xx.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器，根 DNS 收到来自本地 DNS 的请求后，返回一个.com的顶级域名服务器地址。</p><p>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？”</p><p>顶级域名服务器说：“我给你负责 <a href="http://www.xx.com/">www.xx.com</a> 区域的权威域名服务器的地址，你去问它应该能问到”。</p><p>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.xx.com对应的IP是啥呀？”">www.xx.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</p><p>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS，本地域名服务器返回给我们。这时候我们要先建立连接，进行三次握手，然后数据传输。通过调用 Socket 库，来委托协议栈工作。首当其冲肯定是TCP，其实就是加一个tcp报文头部（源端口、目的端口之的），然后由IP模块把数据封装成网络包，就是加一个IP头（源IP、目的IP）这时候你就知道了起点和终点。但是还不知道路径怎么规划，这个就需要ARP协议。具体就是先查ARP缓存，没有的话发一个ARP广播。网卡会把数字信号转为电信号，通过网线发送出去。中间会通过交换机（）、路由器，总之就是做FCS校验后，查询<strong>路由表</strong>找到转发的目标，然后重新加一个mac头（同样是ARP），发出去</p><h4 id="1、解析url"><a href="#1、解析url" class="headerlink" title="1、解析url"></a>1、解析url</h4><p><font color='red'><u><em><strong>解析之后得到三个信息，一个协议，一个是web服务器域名，一个是请求文件的路径（可选）。这时候客户端生产自己的HTTP请求报文</strong></em></u></font></p><p>格式如下，方法get，url没有默认index什么的，版本HTTP1.1，字段名就很多，然后是数据，这个数据也是后面一直包装的根数据。</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728193306158.png" alt="image-20230728193306158"></p><h2 id="地址查询-——-DNS"><a href="#地址查询-——-DNS" class="headerlink" title="地址查询 —— DNS"></a>地址查询 —— DNS</h2><p>（浏览器缓存 -&gt; 操作系统缓存-&gt;本地DNS服务器-&gt;根域名服务器-&gt;顶级域名服务器-&gt;权威域名服务器）</p><p>基于我们已经拿到的web服务器域名，我们可以先去浏览器缓存里面找有没有，如果有，就直接返回，如果没有那就问操作系统的缓存再去看hosts文件，如果都没有，那就看走下面</p><p>客户端首先会发出一个 DNS 请求，问 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 是啥，发给本地 DNS 服务器。</p><p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.xx.com,则它直接返回/">www.xx.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器，根 DNS 收到来自本地 DNS 的请求后，返回一个.com的顶级域名服务器地址。</p><p>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？”</p><p>顶级域名服务器说：“我给你负责 <a href="http://www.xx.com/">www.xx.com</a> 区域的权威域名服务器的地址，你去问它应该能问到”。</p><p>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.xx.com对应的IP是啥呀？”">www.xx.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</p><p>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</p><p>本地 DNS 再将 IP 地址返回客户端，我们要先建立连接，进行三次握手，然后数据传输。</p><p>消息传输的过程是我们拿到IP之后，通过调用 Socket 库，来委托协议栈工作。首当其冲肯定是TCP，其实就是加一个tcp报文头部（源端口、目的端口之后的），然后由IP模块把数据封装成网络包，就是加一个IP头（源IP、目的IP）这时候你就知道了起点和终点。但是还不知道路径怎么规划，这个就需要ARP协议。具体就是先查ARP缓存，没有的话发一个ARP广播。网卡会把数字信号转为电信号，通过网线发送出去。中间会通过交换机（）、路由器，总之就是做FCS校验后，查询<strong>路由表</strong>找到转发的目标，然后重新加一个mac头（同样是ARP），发出去</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728193808617.png" alt="image-20230728193808617"></p><p>通过dns或者缓存获取到ip地址之后，我们就要为发送做一些准备，首先浏览器通过调用 Socket 库，来委托协议栈工作。</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728193955912.png" alt="image-20230728193955912"></p><p>说是协议栈，其实就是中间tcp udp ip这些协议。那下面我们就来仔细的看看</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>tcp段的头如下所示：</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728194108402.png" alt="image-20230728194108402"></p><p>TCP 传输数据之前，要先三次握手建立连接</p><p>前提：客户端 为closed状态，服务端变成listen状态</p><p>连接：</p><p>1、客户端向服务端发送连接syn，之后客户端处于syn-sent状态；</p><p>2、服务端接收到这个消息之后，会返回一个syn+ack，之后服务端处于syn-rcvd状态</p><p>3、客户端收到这个之后，再给服务端发送一个对syn的ack，之后客户端处于establish状态</p><p>服务端收到ack也变成了establish状态</p><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><p>假设我们已经建立了连接，我们要发送消息，但是消息要遵循tcp协议，他的消息大小是有限制的，不是每一次都可以发送全部消息。具体要求如下：</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728195857751.png" alt="image-20230728195857751"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li></ul><p>所以如果HTTP请求消息超过mss，那么就要分段发送。</p><p>到这里我们得到了一个tcp的报文段或者说包，下面我们就要把这个包发送给网络层，因为在传输层我们就是服务应用层，然后对好端口，确定好协议，之后的事情就不归传输层管控了。</p><p>到这里，我们的数据包的格式如下所示：</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728200405680.png" alt="image-20230728200405680"></p><h2 id="定位IP"><a href="#定位IP" class="headerlink" title="定位IP"></a>定位IP</h2><p>ip协议的最重要的功能就是寻址和路由，他要做到这两点就需要你遵循ip协议，那么遵循的要求就是你加一个ip头<img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728200452235.png" alt="image-20230728200452235"></p><p>加上ip头之后我们就知道了我们的源ip和目的ip地址，那么起点站和终点站就已经知道了</p><p>可以现在又有一个小问题，那就是路径怎么规划呢？这时候就需要用到Mac地址</p><h2 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h2><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728202408619.png" alt="image-20230728202408619"></p><ul><li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li><li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询</li></ul><p>也就是说到了网络接口层，要发了，结果不知道往哪里发，这时候就按照上面两步得到mac地址</p><p>因为上面已经得到了ip地址，所以直接喊话：这个 IP 地址是谁的？请把你的 MAC 地址告诉我，就得到mac地址了。</p><p>到这里数据包还差最后一层包装</p><h2 id="出口–网卡"><a href="#出口–网卡" class="headerlink" title="出口–网卡"></a>出口–网卡</h2><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728204942674.png" alt="image-20230728204942674"></p><p>最后一层包装就是上面图片提到的报头和起始帧分界符和fcs帧校验序列</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p>到这里数据包就真正的包装结束了，最后网卡会将包转为电信号，通过网线发送出去。！！</p><h2 id="送别者—交换机"><a href="#送别者—交换机" class="headerlink" title="送别者—交换机"></a>送别者—交换机</h2><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><p>一般在网线接口啊这些地方，其实路由器也可以作为交换机。</p><h3 id="交换机的包接收操作"><a href="#交换机的包接收操作" class="headerlink" title="交换机的包接收操作"></a>交换机的包接收操作</h3><p>交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的fcs校验错误，没问题就放到缓存区，这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><h3 id="交换机查找自己的MAC-地址表"><a href="#交换机查找自己的MAC-地址表" class="headerlink" title="交换机查找自己的MAC 地址表"></a>交换机查找自己的MAC 地址表</h3><p>如果找到，就发送到相应的端口，如果找不到，那说明该mac地址的设备还没有向我们交换机发送过包，那这时候我们主动的向除了源端口的所有端口都发送一遍，因为后面的设备他自己都有检测功能，所以不需要担心</p><p>这时候要么就发送到位，要么就可能离开子网了，离开子网需要用到路由器</p><h2 id="出境大门–路由器"><a href="#出境大门–路由器" class="headerlink" title="出境大门–路由器"></a>出境大门–路由器</h2><h3 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h3><blockquote><p>1、首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>2、检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>3、路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p></blockquote><h3 id="路由器的发送操作"><a href="#路由器的发送操作" class="headerlink" title="路由器的发送操作"></a>路由器的发送操作</h3><p><font color='red'><u><em>*<em><strong>匹配路由表确定输出端口并判断转发目标</strong>。</em>*而路由器则会忽略主机号部分，只匹配网络号部分 这里用的是最长匹配，</em><em>如果匹配上了，我们就看下他的网关列，如果网关是一个 IP 地址，那就是我们的转发目标，如果为空，那就是终点了。下面通过通过 ARP协议根据 IP 地址查询 MAC 地址，路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</em>**</u></font></p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20231025123050860.png" alt="image-20231025123050860"></p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这边举个例子<img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230729000740012.png" alt="image-20230729000740012"></p><p>子网1某个设备想要发送数据给子网2的某个设备</p><p>首先源ip和目的ip是知道的，如果只是简单的arp群发这个ip问是谁的ip地址，其实是找不到的，所以判断是否为同一子网，如果不是，就把目的mac改成网关的mac，然后数据发送到网关，这时候官网一查mac地址，发现属于子网2的设备，这时候修改源mac为自己的mac，修改目的mac为设备的地址，从子网2的网卡发出。</p><p>大多数情况下一个子网的默认网关就是一个，就基本代表着出口。复杂情况就需要某种选择算法了</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>超文本传输协议，就是两点之间超越普通文本范畴的文本（包括文本视频图片等等）的一种协议</p><h4 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h4><blockquote><table><thead><tr><th>1XX 代表提示信息</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>2XX 这个就是成功的状态吗</td><td>200 普通的正常的成功</td><td></td><td></td><td></td></tr><tr><td>3XX 代表重定向</td><td>301 永久重定向</td><td>302 临时重定向</td><td>304 缓存重定向</td><td></td></tr><tr><td>4XX 代表客户端的报文错误</td><td>400 比较笼统的</td><td>404 没找到</td><td></td><td></td></tr><tr><td>5XX 代表服务器端端报文错误</td><td>500 同样比较笼统</td><td>503 请稍后再访问</td><td></td><td></td></tr></tbody></table></blockquote><h4 id="常见的字段"><a href="#常见的字段" class="headerlink" title="常见的字段"></a>常见的字段</h4><blockquote><p>host</p><p>content-length</p><p>content-type</p><p>connection </p><p>content-encodeing</p></blockquote><h4 id="HTTP-Get和Post区别"><a href="#HTTP-Get和Post区别" class="headerlink" title="HTTP://Get和Post区别"></a><a href="http://get和post区别/">HTTP://Get和Post区别</a></h4><blockquote><p>额，get和post在请求行会有method的区别，实际中，其实get也可以带数据，post也可以不带数据。所以我觉得最大的区别还是在于语义的，get是读取的语义，post是有一种处理操作的语义。最后get是安全幂等，post不安全也不幂等。</p></blockquote><h4 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h4><blockquote><p>包括强制缓存和协商缓存</p><p>强制缓存就是浏览器缓存没有过期，那我就直接使用浏览器的缓存，一般用Cache-Control，相对时间。</p><p>协商缓存是有两种，一种时间，一种依赖唯一标识</p><p>1、请求头部里面的if modified since 和响应头部last- modified</p><p>响应信息的头部会有last modified，然后我们会带这个ifmodifiedsince：时间，去访问服务器，服务器看到之后，就拿自己的Last modified去对比 如果没改，返回304，如果改了，返回200</p><p>2、Etag 唯一标识</p><p>流程一样，但是etag优先级更高，因为 if modified since还是基于时间，而时间本身可能有一些限制。</p><p>1、有可能没有修改文件，但是文件的最后修改时间会变化</p><p>2、秒级以内的操作也许不能充分做出响应</p></blockquote><h4 id="HTTP优缺点"><a href="#HTTP优缺点" class="headerlink" title="HTTP优缺点"></a>HTTP优缺点</h4><p><strong>优点：</strong></p><blockquote><p>简单，灵活易扩充，应用广泛跨平台</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1、HTTP无状态的。</p><p>在此基础上出现了cookie技术，他就是通过在请求和响应报文里面增加cookie信息，来控制客户端的状态</p><p>2、明文传输。</p><p>3、不安全 也是最重要的原因</p><blockquote><p>账号信息不安全</p><p>不验证对方的身份</p><p>无法证明报文的完整性</p></blockquote></blockquote><p><strong>HTTP1.1改进</strong></p><blockquote><p>1、HTTP1.1在HTTP1.0的基础上提出了长连接，之前是《请求-应答》模式就是你发完应答完，关闭连接，想要进行下一次通信，那就得重新建立连接，现在可以建立一次连接之后，就可以 发收发收发收 只要一方没有明确提出断开连接，那么就一直连着</p><p>2、管道通信，HTTP1.1支持管道，就是所有请求都处于管道内部，我们可以发发发，而不需要等他先回复再发第二个，你可以发发发，减少了时间</p><p>但是这里有一个问题，HTTP是基于tcp的所以服务端会按照顺序接收请求。</p><p>所以说，HTTP1.1可以解决发送端的对头阻塞，但是无法解决接受端的对头阻塞</p><p>然而！然而！HTTP1.1默认不开启管道，</p></blockquote><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="HTTPS和HTTP的区别？"><a href="#HTTPS和HTTP的区别？" class="headerlink" title="HTTPS和HTTP的区别？"></a>HTTPS和HTTP的区别？</h3><p><font color='red'><u><em><strong>Https在Http的基础上加入了TLS协议，在三次握手之后还要进行TLS握手，有RSA、ECDHE。这个TLS握手的过程中就用到了信息加密、数字签名、身份证书。</strong></em></u></font></p><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p><strong>1、信息加密</strong></p><p>使用的是混合加密，<font color='red'><u><em><strong>非对称加密是在TLS握手的时候，对称加密是在传输数据的时候。</strong></em></u></font></p><p>非对成加密安全，非对称加密速度更快。</p><p><strong>2、数字签名（一个哈希值），身份证书（经过CA私钥加密的服务器公钥+内容+数字签名），这两个可以一起讲</strong></p><p>整体流程：服务器发送公钥和数字签名发到CA里面，CA用自己的私钥加密服务器的公钥和数字签名，这个就是证书！然后客户端发来请求的时候，服务器就把自己的证书发过去，客户端收到证书，用CA的公钥解密，得到了服务器的公钥和服务器的数字签名，这个签名我们上面讲了一个是原始内容一个是私钥对于哈希值的加密，那我们怎么验证呢？就是用公钥去解密加密项得到一个哈希值，再对原始内容做同样的哈希操作，判断两个哈希值到底一不一样，一样代表认证成功，否则，认证失败。</p><h4 id="3、TLS的秘钥交换算法"><a href="#3、TLS的秘钥交换算法" class="headerlink" title="3、TLS的秘钥交换算法"></a>3、TLS的秘钥交换算法</h4><p>TLS的密钥交换算法不同，那么连接步骤也不同，我们会介绍两种</p><h5 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h5><p><strong>1、客户端 &gt; 服务端。</strong></p><blockquote><p>Client Hello：client 随机数 + TLS版本号+密码套件，密码套件可以说是一组配置的整合信息罢了</p></blockquote><p><strong>2、客户端 &lt; 服务端。</strong></p><blockquote><p>Server Hello:server随机数+确认版本号+确认密码套件</p><p>Certificate: 证书</p><p>Server Hello Done：</p></blockquote><p>当然这里收到之后，先校验，校验流程如下：</p><p>首先我们知道了数字签名有原始内容和对于哈希值加密的数字签名，我们对原始内容加密（签名算法），对数字签名解密（CA公钥）</p><p>当然，其中有一个问题就是证书的信任问题？为什么？</p><p>因为我们得到的证书不一定是CA签发的，假如是中间机构签发的百度证书，那么我们就不能用内置的本地CA证书中的公钥去认证，所以我们先找签发机构，发现是一个中间机构，我们向中间机构请求证书，收到证书后发现这个机构的签发者是CA，那么我们可以用CA去认证中间的这个证书，这个证书被认证了 ，那么百度的也就认证了。</p><p><strong>3、客户端 &gt; 服务端 使用服务器的公钥加密pre-master随机数发给服务端</strong></p><blockquote><p>Client Key Exchange: 用第二步解密得到的公钥加密pre-master</p><p>Change Cipher spec：改用会话秘钥加密通信，</p><p>Finished：所有握手数据的摘要，再用会话密钥（master secret）加密一下，让服务端做个验证</p></blockquote><p><strong>4、客户端 &lt; 服务端 服务端发送 加密算法改变通知，和握手结束通知</strong></p><blockquote><p>Change Cipher spec：改用会话秘钥加密通信</p><p>Finished: 所有握手数据的摘要，再用会话密钥（master secret）加密一下，让客户端做个验证</p></blockquote><p>上面这个就是RSA的基本流程，但是基于RSA的HTTPS依旧存在《前向安全》的问题，客户端发送给服务端的随机数要用服务端的公钥加密，如果服务端私钥泄密，那么所有的TLS通讯就将被破解</p><h5 id="ECDHE"><a href="#ECDHE" class="headerlink" title="ECDHE"></a>ECDHE</h5><p>讲过程之前，可以先说一下这个算法。先讲一下前身DH算法。这个算法依赖的就是对数运算的基础上加了「模运算」。我们对数算法知道对数得到真数很简单，但是从真数得到对数是很难的。</p><p><strong>1、客户端 &gt; 服务端。</strong></p><blockquote><p>Client Hello：client 随机数 + TLS版本号+密码套件，密码套件可以说是一组配置的整合信息罢了</p></blockquote><p><strong>2、客户端 &lt; 服务端。</strong></p><blockquote><p>Server Hello:server随机数+确认版本号+确认密码套件</p><p>Certificate: 证书</p><p><strong>Server Key Exchange</strong>：选择椭圆曲线，和根据椭圆曲线的基点公钥，发给客户端</p><p>Server Hello Done：</p></blockquote><p><strong>3、客户端 &gt; 服务端 使用服务器的公钥加密pre-master随机数发给服务端</strong></p><blockquote><p>Client Key Exchange: 生成一个随机数作为客户端的私钥，根据前面信息生成<strong>客户端的公钥</strong>，发给服务端。<font color='red'><u><em><strong>至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。所以能算出x，两个随机数+x就是最后的秘钥</strong></em></u></font></p><p>Change Cipher spec：改用会话秘钥加密通信，</p><p><strong>Encrypted Handshake Message</strong>：所有握手数据的摘要，再用会话密钥加密一下，让服务器做个验证</p></blockquote><p><strong>4、客户端 &lt; 服务端 服务端发送 加密算法改变通知，和握手结束通知</strong></p><blockquote><p>Change Cipher spec：改用会话秘钥加密通信</p><p>Encrypted Handshake Message: 所有握手数据的摘要，再用会话密钥（master secret）加密一下，让服务器做个验证</p></blockquote><p>RSA和ECDHE的区别</p><ul><li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；</li><li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间（这个是 RFC 文档规定的，具体原因文档没有说明，所以这点我也不太明白）；</li><li>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息</li></ul><h4 id="HTTPS怎么实现数据的完整性？"><a href="#HTTPS怎么实现数据的完整性？" class="headerlink" title="HTTPS怎么实现数据的完整性？"></a>HTTPS怎么实现数据的完整性？</h4><p>刚才我们提到了TLS可以解决三个问题，包括完整性，</p><p>其实TLS在实现上包括了握手协议和记录协议</p><p>​握手协议就是四次握手+后续加密来保护应用程序</p><p>​记录协议负责保护数据的完整性和来源</p><p>所以我们来看记录协议：，他的实现就是负责对消息（HTTP数据）的压缩，加密和数据认证<img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230802185945107.png" alt=""></p><p>这里还是应用层，消息被分割后进行压缩，加上消息验证码，加密，加密后加上一个报头，后面就是交给tcp层，传输层</p><h4 id="HTTPS一定安全吗"><a href="#HTTPS一定安全吗" class="headerlink" title="HTTPS一定安全吗"></a>HTTPS一定安全吗</h4><p>理论上这个协议是安全的，HTTPS其实就是加了个TLS协议，那就是问这个TLS是不是安全的</p><p>而TLS就是按四次握手</p><p>1、第一种方法：返回的证书，他大概率是伪造的，但是我们如果接受了，那就不一样了，你接受了服务器的证书，相当于信任了，那后面的通信就会被监听</p><p>2、直接植入根证书也会导致这种情况</p><p>所以关键就是对于证书的认证</p><h3 id="HTTP1-1-gt-HTTP-2-gt-HTTP3"><a href="#HTTP1-1-gt-HTTP-2-gt-HTTP3" class="headerlink" title="HTTP1.1  -&gt; HTTP 2 -&gt; HTTP3"></a>HTTP1.1  -&gt; HTTP 2 -&gt; HTTP3</h3><p><font color='red'><u><em><strong>HTTP1.1在HTTP1.0的基础上增了长连接和管道，解决了发送方的对头阻塞</strong></em></u></font></p><p>缺点：header是没有压缩的，只压缩了body部分，接收方会有对头阻塞，服务端智能被动响应</p><p><font color='red'><u><em><strong>HTTP2在是基于HTTPS的，所以安全性肯定有保障</strong></em></u></font></p><p><strong>1、头部压缩</strong></p><p>HTTP2会压缩头部，会帮你压缩消除重复的部分，用的是HPACK算法</p><p><font color='red'><u><em><strong>这就是HPACK算法，HPACK包括三个部分（静态字典、动态字典、huffman编码），字段名会被静态表或者动态表的index代替，huffman编码则是去压缩Value的值。</strong></em></u></font></p><blockquote><p><strong>静态表</strong></p><p>表中的参数都是提前定义好的，只有固定的 61个值。如果头部字段在静态表里面，第一个字节是01+静态表的Index，第二个字节代表是否使用Huffman编码+长度。后面就是内容。</p><p><strong>动态表</strong></p><p>重复的字段会被放到动态表里面，编码什么的和静态表一样</p></blockquote><p><strong>2、二进制格式</strong></p><p>HTTP2不像是HTTP1是纯文本的报文，而是全部改成了二进制，头部和数据题都是二进制，统称帧</p><p><strong>3、并发传输，引入了流的机制</strong></p><p>一条tcp连接有多个流，每个流可以包含一个或者多个message，这个message就是请求或者响应，message里面有一个或者多个frame帧，不同的HTTP请求有独一无二的帧，所以可以乱序发送，后面会按照streamid组装，<strong>同一 Stream 内部的帧必须是严格有序的</strong></p><p><font color='red'><u><em><strong>HTTP3，把tcp换成了udp，但是为了可靠，推出了QUIC</strong></em></u></font></p><blockquote><p>1、接住了流、没有对头阻塞</p><blockquote><p>但是各个流之间是相互独立的，一个流阻塞了，另外的流不会阻塞，这样就保证了没有对头阻塞</p></blockquote><p>2、QUIC包括了TLS，所以连接更快</p><blockquote><p>因为HTTP2里面tcp和TLS是分层的先三次握手然后四次握手，这样需要3个rtt。然而quic内部携带了TLS，而且TLS1.3只需要一个rtt就可以完成密钥的协商。就是说，第一次发送的时候就已经把签名算法、随机数都发给服务端了，甚至在第二次可以达到0rtt</p></blockquote><p>3、连接迁移和连接建立都更快了</p><blockquote><p>tcp是四元组，而quic是基于udp的，他是靠<font color='red'><u><em><strong>连接id</strong></em></u></font>来标记通信，所以ip换了也没事</p></blockquote><p>4、头部压缩变成了QPACK</p><blockquote><p>静态表变成91项，动态编码方式换了</p></blockquote></blockquote><h4 id="HTTP1-1请求怎么优化"><a href="#HTTP1-1请求怎么优化" class="headerlink" title="HTTP1.1请求怎么优化"></a>HTTP1.1请求怎么优化</h4><p>一方面是HTTP发送的问题，一方面是他本身数据的问题</p><p>1、首先肯定是避免HTTP请求：缓存技术</p><p>2、减少重定向，这个就是把重定向请求交给代理服务器</p><p>3、合并请求，就是把多个访问小文件的请求合并成一个大的</p><p>4、延迟发送，只访问看得到的资源</p><p>5、无损压缩，accept- encoding：gzip br </p><p>6、有损压缩，webP png</p><h4 id="HTTPS怎么优化"><a href="#HTTPS怎么优化" class="headerlink" title="HTTPS怎么优化"></a>HTTPS怎么优化</h4><p>HTTPs对于HTTP多了一个TLS，关键就是通过非对成加密握手得到对成加密的会话密钥</p><ul><li>提高cpu</li><li>升级linux </li><li>对密钥交换过程进行优化</li><li>RSA要四次握手，慢，安全性不高，我们可以缓存eche密钥交换算法，曲线选择x25519，对成加密算法，也可以换aes128</li><li>TLS升级1.3，升级的地方在于hello和公钥交换两个消息合并成一个消息</li><li>证书优化，分为传输优化和验证优化。</li></ul><p>传输：服务器证书选择椭圆曲线</p><p>验证：验证的过程中不仅需要ca还需要是否被ca吊销；crl是吊销列表，ca定期更新，但是实时性不好，ocsp，向ca fan song请求，返回状态，这个增加了请求开销，万一网络不好或者ca繁忙就会出现延迟；oscp stapling，服务器向ca定期查证书状态，然后在握手阶段就直接发给客户端，这样客户端就不用再去请求了。</p><ul><li>会话复用：session id 和session ticket</li></ul><p>session id：首次连接后，在内存缓存会话密钥，用session id标识，再次连接的时候，会在hello消息中带上这个，服务器收到这个就从缓存里面找，直接回复会话状态，跳过中间流程</p><p>缺点是，内存压力大</p><p>session ticket：类似于cookie，把缓存的工作交给客户端，首次连接，会加密这个发给客户端缓存起来，第二次连接，客户端会发送ticket，服务器解密后验证日期是否有效，没问题就恢复会话。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-计算机网络3</title>
      <link href="/2023/07/08/%E5%85%AB%E8%82%A1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/"/>
      <url>/2023/07/08/%E5%85%AB%E8%82%A1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/</url>
      
        <content type="html"><![CDATA[<h3 id="这一章节就来学习IP协议"><a href="#这一章节就来学习IP协议" class="headerlink" title="这一章节就来学习IP协议"></a>这一章节就来学习IP协议</h3><p>我们知道两个不相连的网络之间的传输其实靠的是ip地址，两个直连的设备之间的用的协议MAC头，</p><p>ipv4是32位</p><p>我们把这些分成了5类，包括a类，b类，c类，d类，e类</p><p>a类是0开头，b类是10开头，c类是11开头，d类是1110开头，然后e类是1111开头</p><p>d类用于多播，多播是可以穿透网段的，e类用于留存</p><p>然后每个网络号对应的主机号的数量其实是2的主机号次幂-2，因为，主机号全为0指定某个网络，主机号全为1指代某个网络下的所有主机，用于广播</p><p>广播是用于对链路中相互连接的主机发送消息</p><p>在本网络中的广播叫做本地广播，不同网络之间的叫直接广播、</p><p>这种分类方式的好处就是简单，清晰</p><p>但是有缺点：</p><p>首先同一层次下，没有分类</p><p>第二，不能和现实网络很好的适配</p><p>所以提出了无分类地址cidr</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A03/image-20230804145043580.png" alt="image-20230804145043580"></p><p>我们知道可以通过子网掩码划分出网络号和主机号，那实际上子网掩码还有一个作用，那就是<strong>划分子网</strong>。</p><p><strong>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址</strong></p><p>其实就是在a类b类上再分而已</p><p>dhcp</p><p>先说明一点，DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号。</p><p>这 4 个步骤：</p><ul><li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP <strong>广播</strong>通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li><li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCP OFFER）</strong> 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 <strong>IP 地址租用期</strong>。</li><li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数。</li><li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数。</li></ul><p>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-计算机网络2</title>
      <link href="/2023/07/08/%E5%85%AB%E8%82%A1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/"/>
      <url>/2023/07/08/%E5%85%AB%E8%82%A1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="1、TCP和UDP"><a href="#1、TCP和UDP" class="headerlink" title="1、TCP和UDP"></a>1、<strong>TCP和UDP</strong></h3><p><strong>UDP和TCP可以共用一个端口，因为是完全独立的两个软件模块</strong></p><h3 id="2、为什么不能两次握手或者四次握手？"><a href="#2、为什么不能两次握手或者四次握手？" class="headerlink" title="2、为什么不能两次握手或者四次握手？"></a>2、为什么不能两次握手或者四次握手？</h3><blockquote><p>两次握手：在两次握手的时候，服务端没有中间状态给客户端来阻止历史连接，也就是服务端会多建立一个历史连接浪费资源，因为收到syn就变成established。这里靠序列号同步就知道了</p><p>四次握手：四次握手无非就是，你给我发我返回同意，我给你发你返回同意，但是第二和第三部完全可以合并，所以三次就ok了。</p></blockquote><h3 id="3、为什么，每次建立连接序列号都要求不一样？"><a href="#3、为什么，每次建立连接序列号都要求不一样？" class="headerlink" title="3、为什么，每次建立连接序列号都要求不一样？"></a>3、为什么，每次建立连接序列号都要求不一样？</h3><p>1、防止历史报文被下一个连接接受，如果每次都从特定的值开始，那历史报文就可能被下一个连接接受。</p><p>2、防止黑客伪造的相同序列号被接受</p><h3 id="4、那这个序列号是怎么随机产生的？"><a href="#4、那这个序列号是怎么随机产生的？" class="headerlink" title="4、那这个序列号是怎么随机产生的？"></a>4、那这个序列号是怎么随机产生的？</h3><p>rfc提高了序列号ISN随机生成算法：ISN &#x3D; M + F</p><p>m是计时器，四微秒+1</p><p>F是哈希算法根据四元组推出来的</p><h3 id="5、为什么ip层会分片，TCP还分片，"><a href="#5、为什么ip层会分片，TCP还分片，" class="headerlink" title="5、为什么ip层会分片，TCP还分片，"></a>5、为什么ip层会分片，TCP还分片，</h3><p>因为ip不能超时重传，所以只能靠tcp，而万一ip层丢了一部分，那么ip层就不能组装成一个完整的tcp报文，也就不可能发给接收方tcp层，所以发送方的tcp层就会重发整个tcp报文，所以我们最好就是自己分片，然后缺什么发什么，直接以MSS为单位就可以了</p><h3 id="6、TCP三次握手过程丢失问题"><a href="#6、TCP三次握手过程丢失问题" class="headerlink" title="6、TCP三次握手过程丢失问题"></a>6、TCP三次握手过程丢失问题</h3><blockquote><p>第一次握手丢失，会发生什么？</p><p>触发超时重传，每次重传次数是上一次两倍，报文最大重传次数由 <code>tcp_syn_retries</code></p><p>第二次握手丢失，会发生什么？</p><p>客户端和服务端都会重传，重传次数分别有tcp_syn_retries和tcp_synack_retries决定</p><p>第三次握手丢失了，会发生什么？</p><p>这里有一点很关键，就是ack报文是不会重传的，所以服务端会认为自己的syn+ack没发到，触发重传机制，服务端重传，次数由tcp_synack_retries决定</p></blockquote><h3 id="7、半连接状态和全连接状态"><a href="#7、半连接状态和全连接状态" class="headerlink" title="7、半连接状态和全连接状态"></a>7、半连接状态和全连接状态</h3><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p>正常流程：</p><ul><li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li><li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li></ul><p>所以这样子就出会先一些问题</p><p>受到SYN攻击怎么办？就是说半连接状态很多怎么办？</p><ul><li>调大 netdev_max_backlog；缓冲队列</li><li>增大 TCP 半连接队列；</li><li>开启 tcp_syncookies；不用建立半连接</li><li>减少 SYN+ACK 重传次数</li></ul><h3 id="8、TCP四次挥手"><a href="#8、TCP四次挥手" class="headerlink" title="8、TCP四次挥手"></a>8、TCP四次挥手</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803130523828.png" alt="image-20230803130523828"></p><blockquote><p>msl是报文最大生存时间，ip头有一个ttl字段，这个字段代表可以经历的最大路由数</p><p>msl大于等于ttl消耗为0的时间，默认60</p></blockquote><blockquote><p><strong>为什么需要这个timewait状态</strong></p><p>1<font color='red'><u><em><strong>、也是为了防止接收历史连接中的第三次挥手</strong></em></u></font>。这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失。</strong></p><p>2、也就是说，TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p></blockquote><blockquote><p><font color='red'><u><em><strong>为什么4次？</strong></em></u></font></p><p>服务端可能还有数据要发给客户端，所以需要先处理自己的最后流程，然后给客户端发送一个fin报文，也就是说，第二次握手和第三次握手大概率是不同步的。</p><p><font color='red'><u><em><strong>特定情况下，可以变成三次，刚刚好没有数据。</strong></em></u></font></p><p><font color='red'><u><em><strong>第一次挥手丢失，会发生什么？</strong></em></u></font></p><p>客户端收不到来自服务端的ack报文，那么就会触发超时重传，这个次数是由tcp_orphan_retries决定的</p><p><font color='red'><u><em><strong>第二次挥手丢失，会发生什么？</strong></em></u></font></p><p>ACK 报文是不会重传的,所以首先客户端还是会触发超时重传，这个次数是由tcp_orphan_retries决定的</p><p><font color='red'><u><em><strong>第三次丢失，会发生什么？</strong></em></u></font></p><p>相当于服务端一直收不到来自客户端的ack，那么服务端会触发超时重传,次数达到后还没收到，断开连接。</p><p>而客户端已经进入了fin_wait2状态，一直等，如果超过设定的时间tcp_fin_timeout ，断开连接。</p><p><font color='red'><u><em><strong>第四次丢失，会发生什么？</strong></em></u></font></p><p>服务端一直收不到，那么触发超时重传，这时候因为客户端已经是timewait状态，所以每一次重传都会重置2msl定时器，超过时间就close，而服务端同样的重传几次之后close</p></blockquote><blockquote><p><strong>如果建立了连接，结果客户端故障了，不发送消息，但是服务端一直establish</strong></p><p>tcp搞了个保活机制，隔一段时间发送探测报文，没有得到相应则认为tcp死亡，</p><p>但是，这个保活机制时间太长了，我们自己在应用层实现一个心跳机制，一般web服务软件都会提供keepalive-timeout状态</p><p><strong>如果服务器的进程崩溃了，那发生什么</strong></p><p>其实连接信息是由内核维护的，所以服务端的内核还是会发送fin报文进行四次挥手</p></blockquote><h3 id="9、可靠性保证方法"><a href="#9、可靠性保证方法" class="headerlink" title="9、可靠性保证方法"></a>9、可靠性保证方法</h3><blockquote><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p><font color='red'><u><em><strong>重传分为超时重传和快速重传两种。</strong></em></u></font></p><p><font color='red'><u><em><strong>超时重传：超过时间进行重传，时间RTO</strong></em></u></font></p><p><font color='red'><u><em><strong>快速重传：收到三个相同的 ACK 报文时，重传丢失的报文段。这里的问题在于传一个还是传所有，这里引入了SACK和DSACK机制</strong></em></u></font></p><p>SACK：服务端把已经收到的数据信息驾到tcp头部的选项里面，告诉发送发我收到了哪些</p><p>后面又出现了D-SACK：这是用来告诉发送方哪些被重复接受了了</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>操作系统开辟的一个缓存空间，发送方在收到ACK应答之前，在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除</p><p>TCP头部里面既有一个字段叫窗口大小，就是用来告诉发送端自己还有多少缓冲区可以使用，所以窗口大小一般由接收方决定</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>网络发生拥塞，那么tcp就会降低自己的发送量，防止网络负担加重</p><p>慢启动 一开始是1，就是可以传1个mss，然后收到应答变成2，4，8，16…..</p><p>拥塞避免 触碰到<font color='green'><u><em><strong>慢启动门限</strong></em></u></font>就是用拥塞避免，变成线性的，收到一个ack cwnd增加1&#x2F;cwnd（拥塞窗口）</p><p>如果网络发生了拥塞，也就是重传。重传分两种，如果是超时重传，就慢启动门限变成cwnd&#x2F;2，cwnd&#x3D;1重新开始慢启动</p><p>如果是快速重传，拥塞窗口和慢启动门限都设置为拥塞窗口的一半，然后拥塞窗口+3，继续发送重复的，如果收到新数据的ACK，快速恢复结束，进入拥塞避免。</p><p>握手优化就是调整重传次数、半连接队列，全连接队列</p><p>挥手就是调整：重传次数、FINwait2状态时间、</p><p>传输速度的话就是调整：接收方缓冲区大小、发送方缓冲区大小、窗口大小，打开缓冲区动态调节。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>避免发送方的数据填满接收方</p></blockquote><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803161404210.png" alt="image-20230803161404210"></p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803163142196.png" alt="image-20230803163142196"></p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803163236556.png" alt="image-20230803163236556"></p><blockquote><h4 id="如何理解字节流"><a href="#如何理解字节流" class="headerlink" title="如何理解字节流"></a>如何理解字节流</h4><p>udp操作系统不会对齐拆分，所以每一个udp就是一个消息的边界.然而tcp是会分片的，这时候，接收方如果不知道消息的长度或者边界，是无法读取消息的，<strong>不能认为一个用户消息对应一个TCP报文，正因为这样，TCP是面向字节流的协议。</strong></p><p><strong>没有accept，能建立tcp连接吗</strong></p><p>可以</p><p><strong>已经建立的tcp，收到syn会发生什么</strong></p><p>新的syn首先看看端口是不是一样，如果不一样的话，就建立新的连接，老的那个如果一直不发消息就会触发tcp保活机制</p><p>如果相同（可能就是宕机重传），其实会返回一个challenge ack，携带正确的序列号的确认号的ack报文，这时候客户端确认号收到这个，发现不是自己期望收到的，就会返回rst，这样，服务器就释放了连接</p><h4 id="如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗"><a href="#如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗" class="headerlink" title="如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗"></a>如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗</h4><p>先到的fin包其实是乱序的，所以会进入乱序队列，等数据真正的到了，才会回头检查这个fin，然后给服务端发这个。</p><h4 id="如果timewait状态收到syn？会怎么样？"><a href="#如果timewait状态收到syn？会怎么样？" class="headerlink" title="如果timewait状态收到syn？会怎么样？"></a>如果timewait状态收到syn？会怎么样？</h4><p>还是先看序列号时间戳吧，如果确实合法，那应该会重新进入三次握手阶段，</p><p>如果不合法，就会返回一个和第四次挥手一样的ack，这时候服务端收到发现不是自己的，就回复一个rst报文</p><h4 id="服务端没有-listen，客户端发起连接建立，会发生什么？"><a href="#服务端没有-listen，客户端发起连接建立，会发生什么？" class="headerlink" title="服务端没有 listen，客户端发起连接建立，会发生什么？"></a>服务端没有 listen，客户端发起连接建立，会发生什么？</h4><p><strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文</strong></p><h4 id="Tcp连接，断电和进程崩溃有什么区别？没有保活机制"><a href="#Tcp连接，断电和进程崩溃有什么区别？没有保活机制" class="headerlink" title="Tcp连接，断电和进程崩溃有什么区别？没有保活机制"></a>Tcp连接，断电和进程崩溃有什么区别？没有保活机制</h4><p>客户端主机崩溃，没有保活机制，那就无法感知到，一直处于establish</p><p>进程崩溃，内核还是会发送fin完成4次挥手</p><h4 id="客户端主机宕机，又迅速重启"><a href="#客户端主机宕机，又迅速重启" class="headerlink" title="客户端主机宕机，又迅速重启"></a>客户端主机宕机，又迅速重启</h4><p><strong>只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</strong></p><h4 id="拔掉网线tcp连接还在吗"><a href="#拔掉网线tcp连接还在吗" class="headerlink" title="拔掉网线tcp连接还在吗"></a>拔掉网线tcp连接还在吗</h4><p>在的，tcp连接信息是存储于内核的一个结构体，网线断了，但是结构体不会改变</p><ul><li>拔掉网线后，有数据传输；</li><li>如果在重传前网线插回去了，那我觉得应该什么事情都没发生</li><li>如果没插回去，那么就超时重传几次之后，认为此连接死亡，就断开连接，即使后面插回来了，客户端向服务端发送请求，也不是连接的状态，那么服务端就会返回rst</li><li>拔掉网线后，没有数据传输</li><li>如果开启了保活机制，那就探测几次，如果有工作就重制保活时间，如果客户端没有正常工作，就断开连接</li><li>如果没有开启保活机制，就一直连着</li></ul></blockquote><h4 id="HTTPS-中-TLS-和-TCP-能同时握手吗？"><a href="#HTTPS-中-TLS-和-TCP-能同时握手吗？" class="headerlink" title="HTTPS 中 TLS 和 TCP 能同时握手吗？"></a>HTTPS 中 TLS 和 TCP 能同时握手吗？</h4><p>可能，但是有条件</p><ul><li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li><li><strong>客户端和服务端已经完成过一次通信。</strong></li></ul><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803205908513.png" alt="image-20230803205908513"></p><p>TCP Fast Open定义<br>TCP Fast Open（TFO）是用来加速连续TCP连接的数据交互的TCP协议扩展，原理如下：在TCP三次握手的过程中，当用户首次访问Server时，发送SYN包，Server根据用户IP生成Cookie（已加密），并与SYN-ACK一同发回Client；当Client随后重连时，在SYN包携带TCP Cookie；如果Server校验合法，则在用户回复ACK前就可以直接发送数据；否则按照正常三次握手进行<br><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803210533146.png" alt="image-20230803210533146"></p><p>所以就是在第二次以后的通信过程中，tcp open fast在ack发回来之前直接进行tls1.3</p><h4 id="quic怎么实现可靠传输"><a href="#quic怎么实现可靠传输" class="headerlink" title="quic怎么实现可靠传输"></a>quic怎么实现可靠传输</h4><p>总的来说，<strong>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</strong>，</p><p>Packet Number 是严格递增，即使重传报文的 Packet Number 也是递增的，既然重传数据包的 Packet N+M 与丢失数据包的 Packet N 编号并不一致，我们怎么确定这两个数据包的内容一样呢？</p><p>所以引入 Frame Header 这一层，<strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong>，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803212833705.png"></p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803213009597.png" alt="image-20230803213009597"></p><h3 id="QUIC怎么解决对头阻塞"><a href="#QUIC怎么解决对头阻塞" class="headerlink" title="QUIC怎么解决对头阻塞"></a>QUIC怎么解决对头阻塞</h3><p><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，都是相互独立的，各自控制的滑动窗口</strong>。</p><h3 id="QUIC-是如何做流量控制的？"><a href="#QUIC-是如何做流量控制的？" class="headerlink" title="QUIC 是如何做流量控制的？"></a>QUIC 是如何做流量控制的？</h3><p>QUIC 实现流量控制的方式：</p><ul><li>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。 如果消耗数据的长度大于了最大接收窗口的一半发送</li><li>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-输入网络，期间发生了什么？</title>
      <link href="/2023/07/08/%E5%85%AB%E8%82%A1-%E8%BE%93%E5%85%A5%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2023/07/08/%E5%85%AB%E8%82%A1-%E8%BE%93%E5%85%A5%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？"><a href="#输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？" class="headerlink" title="输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？"></a>输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？</h1><h2 id="1、解析url"><a href="#1、解析url" class="headerlink" title="1、解析url"></a>1、解析url</h2><p>首先，就是对我们输入的url进行解析，一般可以得到三个信息：协议，web服务器，文件的路径</p><p>拿到这三个信息之后我们就可以包装成一个http请求信息</p><p>![image-20230728193306158](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728193306158.png)</p><p>如图所示，一个是请求一个是响应报文</p><p>那我们生产出一个消息之后就要开始发送？那应该怎么发？往哪里发？</p><p>这就需要下面的知识。</p><h2 id="地址查询-——-DNS"><a href="#地址查询-——-DNS" class="headerlink" title="地址查询 —— DNS"></a>地址查询 —— DNS</h2><p>基于我们已经拿到的web服务器域名，我们可以先去浏览器缓存里面找有没有，如果有，就直接返回，如果没有那就问操作系统的缓存再去看hosts文件，如果都没有，那就看走下面</p><p>客户端首先会发出一个 DNS 请求，问 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</p><p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.xx.com,则它直接返回/">www.xx.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</p><p>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.xx.com/">www.xx.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</p><p>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？”</p><p>顶级域名服务器说：“我给你负责 <a href="http://www.xx.com/">www.xx.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</p><p>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.xx.com对应的IP是啥呀？”">www.xx.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</p><p>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</p><p>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接</p><p>![image-20230728193808617](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728193808617.png)</p><p>通过dns或者缓存获取到ip地址之后，我们就要为发送做一些准备，首先浏览器通过调用 Socket 库，来委托协议栈工作。</p><p>![image-20230728193955912](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728193955912.png)</p><p>说是协议栈，其实就是中间tcp udp ip这些协议。那下面我们就来仔细的看看</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>tcp段的头如下所示：</p><p>![image-20230728194108402](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728194108402.png)</p><p>TCP 传输数据之前，要先三次握手建立连接</p><p>前提：客户端 为closed状态，服务端变成listen状态</p><p>连接：</p><p>1、客户端向服务端发送连接syn，之后客户端处于syn-sent状态；</p><p>2、服务端接收到这个消息之后，会返回一个syn+ack，之后服务端处于syn-rcvd状态</p><p>3、客户端收到这个之后，再给服务端发送一个对syn的ack，之后客户端处于establish状态</p><p>服务端收到ack也变成了establish状态</p><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><p>假设我们已经建立了连接，我们要发送消息，但是消息要遵循tcp协议，他的消息大小是有限制的，不是每一次都可以发送全部消息。具体要求如下：</p><p>![image-20230728195857751](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728195857751.png)</p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li></ul><p>所以如果http请求消息超过mss，那么就要分段发送。</p><p>到这里我们得到了一个tcp的报文段或者说包，下面我们就要把这个包发送给网络层，因为在传输层我们就是服务应用层，然后对好端口，确定好协议，之后的事情就不归传输层管控了。</p><p>到这里，我们的数据包的格式如下所示：</p><p>![image-20230728200405680](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728200405680.png)</p><h2 id="定位IP"><a href="#定位IP" class="headerlink" title="定位IP"></a>定位IP</h2><p>ip协议的最重要的功能就是寻址和路由，他要做到这两点就需要你遵循ip协议，那么遵循的要求就是你加一个ip头![image-20230728200452235](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728200452235.png)</p><p>加上ip头之后我们就知道了我们的源ip和目的ip地址，那么起点站和终点站就已经知道了</p><p>可以现在又有一个小问题，那就是路径怎么规划呢？这时候就需要用到Mac地址</p><h2 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h2><p><img src="/../images/typora-user-images/image-20230728202408619.png" alt="image-20230728202408619"></p><ul><li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li><li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询</li></ul><p>也就是说到了网络接口层，要发了，结果不知道往哪里发，这时候就按照上面两步得到mac地址</p><p>因为上面已经得到了ip地址，所以直接喊话：这个 IP 地址是谁的？请把你的 MAC 地址告诉我，就得到mac地址了。</p><p>到这里数据包还差最后一层包装</p><h2 id="出口–网卡"><a href="#出口–网卡" class="headerlink" title="出口–网卡"></a>出口–网卡</h2><p>![image-20230728204942674](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728204942674.png)</p><p>最后一层包装就是上面图片提到的报头和起始帧分界符和fcs帧校验序列</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p>到这里数据包就真正的包装结束了，最后网卡会将包转为电信号，通过网线发送出去。！！</p><h2 id="送别者—交换机"><a href="#送别者—交换机" class="headerlink" title="送别者—交换机"></a>送别者—交换机</h2><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><p>一般在网线接口啊这些地方，其实路由器也可以作为交换机。</p><h3 id="交换机的包接收操作"><a href="#交换机的包接收操作" class="headerlink" title="交换机的包接收操作"></a>交换机的包接收操作</h3><p>交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的fcs校验错误，没问题就放到缓存区，这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><h3 id="查询MAC-地址表"><a href="#查询MAC-地址表" class="headerlink" title="查询MAC 地址表"></a>查询<strong>MAC 地址表</strong></h3><p>如果找到，就发送到相应的端口，如果找不到，那说明该mac地址的设备还没有向我们交换机发送过包，那这时候我们主动的向除了源端口的所有端口都发送一遍，因为后面的设备他自己都有检测功能，所以不需要担心</p><p>这时候要么就发送到位，要么就可能离开子网了，离开子网需要用到路由器</p><h2 id="出境大门–路由器"><a href="#出境大门–路由器" class="headerlink" title="出境大门–路由器"></a>出境大门–路由器</h2><h3 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h3><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p><p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p><p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p><h3 id="路由器的发送操作"><a href="#路由器的发送操作" class="headerlink" title="路由器的发送操作"></a>路由器的发送操作</h3><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>反正我们从路由表知道了ip地址，那么我们同样用这个地址去查mac地址</p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这边举个例子![image-20230729000740012](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230729000740012.png)</p><p>子网1某个设备想要发送数据给子网2的某个设备</p><p>首先源ip和目的ip是知道的，如果只是简单的arp群发这个ip问是谁的ip地址，其实是找不到的，所以判断是否为同一子网，如果不是，就把目的mac改成网关的mac，然后数据发送到网关，这时候官网一查mac地址，发现属于子网2的设备，这时候修改源mac为自己的mac，修改目的mac为设备的地址，从子网2的网卡发出。</p><p>大多数情况下一个子网的默认网关就是一个，就基本代表着出口。复杂情况就需要某种选择算法了</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目-mybatis组件</title>
      <link href="/2023/04/26/%E9%A1%B9%E7%9B%AE-mybatis%E7%BB%84%E4%BB%B6/"/>
      <url>/2023/04/26/%E9%A1%B9%E7%9B%AE-mybatis%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="Spring整合Mybatis要解决的问题"><a href="#Spring整合Mybatis要解决的问题" class="headerlink" title="Spring整合Mybatis要解决的问题"></a>Spring整合Mybatis要解决的问题</h4><p>重点关注下的Mapper动态代理对象，因为Spring整合Mybatis的核心目标是：把某个Mapper的代理对象作为一个bean放入Spring容器中，使得能够像使用一个普通bean一样去使用这个代理对象，比如能被@Autowire自动注入。常用如下通过Ioc容器把UserMapper注入了UserService</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;    </span><br><span class="line">    @Autowired    </span><br><span class="line">    private UserMapper userMapper;    </span><br><span class="line">    </span><br><span class="line">    public UserEntity queryUser(int id)&#123;        </span><br><span class="line">        UserEntity userEntity = userMapper.getById(id);        </span><br><span class="line">        return userEntity;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    public void printServiceName()&#123;        </span><br><span class="line">        System.out.println(&quot;I&#x27;m UserService&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Spring启动过程中，bean的生命周期如下</p><ul><li>扫描指定的包路径下的class文件或解析xml文件</li><li>生成对应的BeanDefinition</li><li>BeanFactoryPostProcessor注册或修改BeanDefinition定义</li><li>根据BeanDefinition反射实例化Bean</li><li>BeanPostProcessor修改Bean定义</li><li>Bean的业务调用</li><li>Bean的销毁</li></ul><p>对于两个Service：UserService&#x2F;OrderInfoService定义如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"> </span><br><span class="line">    public void printServiceName()&#123;</span><br><span class="line">        System.out.println(&quot;I&#x27;m UserService&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">执行如下命令：</span><br><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">System.out.println(ctx.getBean(&quot;userService&quot;));</span><br><span class="line">结果如下：</span><br><span class="line">com.hobbit.service.UserService@4167d97b</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增加一个FactoryBean后置处理器，修改userService的BeanDefinition定义</span><br><span class="line">@Component</span><br><span class="line">public class RenameBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(&quot;userService&quot;);</span><br><span class="line">        beanDefinition.setBeanClassName(OrderInfoService.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">重新运行结果如下，生成了OrderInfoService对象。</span><br><span class="line">com.hobbit.service.OrderInfoService@57ad2aa7</span><br></pre></td></tr></table></figure><p><em><strong>所以在Spring中bean对象跟class或xml定义的bean无直接关系，跟最终的BeanDefinition有直接关系。</strong></em></p><p><em><strong>要想生成一个bean，首先要有一个BeanDefinition。那Mapper对应的BeanDefinition是？</strong></em></p><p>这就引出了下一个类</p><h4 id="MapperFactoryBean"><a href="#MapperFactoryBean" class="headerlink" title="MapperFactoryBean"></a>MapperFactoryBean</h4><p>Spring通过BeanDefinition的beanClassName生成对应的bean，那mapper的对应的beanClassName是什么？本可以有两个答案：</p><ul><li>代理对象对应的代理类</li><li>代理对象对应的接口</li></ul><p>因为代理类是动态生成的，spring启动时无法得知，无法使用。那么代理对象对应的接口？思路如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanDefinition bd = new BeanDefinitoin();</span><br><span class="line">// 注意这里，设置的是UserMapper</span><br><span class="line">bd.setBeanClassName(UserMapper.class.getName());</span><br><span class="line">SpringContainer.addBd(bd);</span><br></pre></td></tr></table></figure><p>实际上给BeanDefinition对应的类型设置为一个接口是行不通的，因为Spring没有办法根据这个BeanDefinition去new出对应类型的实例，接口是没法直接new出实例的。</p><p>所以想通过设置BeanDefinition的class类型，然后由Spring自动地帮助我们去生成对应的bean，但是这条路是行不通的。可以通过其它方<strong>MapperFactoryBean</strong>来实现。</p><p>MapperFactoryBean继承关系</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/b00b1795cde71cbf838c42c2d7bd8d42.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  ...</span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public T getObject() throws Exception &#123;</span><br><span class="line">    return getSqlSession().getMapper(this.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public Class&lt;T&gt; getObjectType() &#123;</span><br><span class="line">    return this.mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getObjectType返回的是Mapper接口，通过 AbstractBeanDefinition.AUTOWIRE_BY_TYPE时，可自动注入使用。</p><p>getObject返回了动态代理对象，跟之前的使用一致。至此完成了Mapper对应BeanDefinition定义的问题，那这些BeanDefinition是如何注册到Ioc容器呢？</p><h4 id="Mapper-BeanDefinition加载"><a href="#Mapper-BeanDefinition加载" class="headerlink" title="Mapper BeanDefinition加载"></a>Mapper BeanDefinition加载</h4><p>Spring可通过多种方式加载BeanDefinition，从XmlBeanDefinitionReader到ClassPathBeanDefinitionScanner在到ConfigurationClassBeanDefinitionReader分别对应xml、@component、@configuration类定义的加载。Mapper BeanDefinition可通过2种形式加载MapperScannerConfigurer和@MapperScan注解，内部都是通过ClassPathMapperScanner实现。ClassPathMapperScanner继承了ClassPathBeanDefinitionScanner，类图如下</p><p>两种方式如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定要扫描的包，在此包下自动搜索映射器(接口) --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;basePackage&quot; value=&quot;com.hobbit.mapper&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用@MapperScan加载</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用MapperScannerConfigurer加载在配置MapperScannerConfigurer中主要是加载dao包中的所有dao接口，通过sqlsessionFactory获取sqlsession，然后创建所有dao接口对象，存储在spring容器</strong></p><p><strong>会在spring容器刷新refresh过程中被调用</strong></p><p>到此为止，Spring整合Mybatis的核心原理就结束了，再次总结一下：</p><p>定义MapperFactoryBean，用来封装Mapper对应的BeanDefinition<br>通过ClassPathMapperScanner重新定义BeanClass及AutowireMode，实现BeanDefinition加载及MapperInterface与MapperFactory整合<br>通过MapperScannerConfigurer或@MapperScan，分别扩展BeanDefinitionRegistryPostProcessor及ImportBeanDefinitionRegistrar 用来在启动Spring时执行调用ClassPathMapperScanner完成Mapper BeanDefinition的注册</p><h2 id="Spring的启动流程："><a href="#Spring的启动流程：" class="headerlink" title="Spring的启动流程："></a>Spring的启动流程：</h2><p><a href="https://blog.csdn.net/weixin_39559282/article/details/118255793">https://blog.csdn.net/weixin_39559282/article/details/118255793</a></p><h2 id="MyBatis与Spring的集成原理"><a href="#MyBatis与Spring的集成原理" class="headerlink" title="MyBatis与Spring的集成原理"></a>MyBatis与Spring的集成原理</h2><p><a href="https://blog.csdn.net/m0_73311735/article/details/129226313">https://blog.csdn.net/m0_73311735/article/details/129226313</a></p><p>其实这里最核心的还是做一个ORM对象关系映射，用于不同类型系统的数据之间的转换，也让我们更方便的使用数据库。</p><p>主要做法其实就是通过：参数映射、SQL解析和执行以及结果封装的整体方式对数据库进行操作。这也是ORM框架的核心内容。</p><p>这里我们注意三类 类，没错就是三个类的类</p><p>分别是，sqlsession、sqlsessionfactory、sqlsessionfactorybuilder</p><p>sqlseesion：定义了对数据库的操作，什么查询啊之类的。然后接口必须有一个实现类，这里我们用的是defaultsqlsession，实现了接口的方法，也包装了jdbc，这样就把数据库的jdbc包装起来了，我们敲代码也会方便。</p><p>sqlsessionfactory：你每次有数据库操作都需要开启一个sqlsession那么从谁那里获取呢，就是factory。他也有一个实现类defaultsqlsession factory，他的唯一方法就是返回上面我们的defaultsqlsession，通过传进去的参数返回sqlsession，不过这个类的构造函数传递了configuration配置，包括connection connection，Map dataSource， Map mapperElement。</p><p>sqlsessionfactorybuilder：这个类主要包括：build构建实例化元素，parseConfiguration解析构造，datasource获取数据库配置，connnection链接数据库，mapperElement解析sql语句。</p><p>build，创建解析xml文件的类，然后初始化Defaultsqlsessionfactory工厂类，但是这个工厂类需要configuration，那这个configuration则需要parseconfiguration，所以往下看</p><p>parseConfigtation：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        configuration.setDataSource(dataSource(root.selectNodes(<span class="string">&quot;//dataSource&quot;</span>)));</span><br><span class="line">        configuration.setConnection(connection(configuration.dataSource));</span><br><span class="line">        configuration.setMapperElement(mapperElement(root.selectNodes(<span class="string">&quot;mappers&quot;</span>)));</span><br></pre></td></tr></table></figure><p>首先，我们在build以及把xml文件扫描进来了，然后我们用扫描后的参数去设置数据库、链接、节点这三个关键。</p><p>datasource函数打断点看看：就是进去了这四个数据库的参数</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/E7B0BF9D-E780-405F-9FE7-85CECE47328F-2492888.png" alt="E7B0BF9D-E780-405F-9FE7-85CECE47328F"></p><p>connectin函数里面用这几个参数得到一个链接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(dataSource.get(<span class="string">&quot;driver&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> DriverManager.getConnection(dataSource.get(<span class="string">&quot;url&quot;</span>), dataSource.get(<span class="string">&quot;username&quot;</span>), dataSource.get(<span class="string">&quot;password&quot;</span>));</span><br></pre></td></tr></table></figure><p>mapperElement函数<img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426154547513.png" alt="image-20230426154547513"></p><p>拿到build扫描的参数，做循环</p><p>每次循环，先拿到resource，举个例子：</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426154908196.png" alt="image-20230426154908196"></p><p>先拿到mapper&#x2F;usermapper.xml，然后去读这个文件，拿到namespace</p><p>也就是对应的dao类，这里就是iuserdao</p><p>然后去读doc文件里面的各个操作，我们这个读取了select等等操作，反正就是把xnode放到map里面</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426155555163.png" alt="image-20230426155555163"></p><p>这个map就是我们的mapperelement，里面是一个namespace对应一个xnode。</p><p>所以mapperelement函数就是去拿到</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426155850578.png" alt="image-20230426155850578">对应到我们的具体的mapper.xml文件，然后读取这个文件，去解析我们的sql语句，然后得到一个名称和sql的映射关系的map</p><p>orm我们已经知道具体的做法了，那怎么把这个和我们的spring结合在一起呢？</p><p>其实我们要做的就是让他参与到Spring的事务管理之中，然后创建映射器和sqlsession并注入到bean里面，再把异常转化成Spring到dataaccessexception。以上的种种就是要把我们自己的orm交给spring管理。<img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/image-20230427143800831.png" alt="image-20230427143800831"></p><p>orm结合spring的核心内容就是对需要注册对象的扫描，代理类的实现，bean的注册。</p><p>这里和orm框架一样，也有三个类非常重要：SqlSessionFactoryBean、MapperScannerConfigurer、MapperFactoryBean</p><p>先说SqlSessionFactoryBean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 在基本的 MyBatis 中，session 工厂可以使用 SqlSessionFactoryBuilder 来创建。而在 MyBatis-Spring 中,则使用 SqlSessionFactoryBean 来替代。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;SqlSessionFactory&gt;, InitializingBean &#123;</span><br><span class="line">    <span class="keyword">private</span> String resource;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> Resources.getResourceAsReader(resource)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlSessionFactory.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResource</span><span class="params">(String resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSessionFactoryBean实现InitializingBean主要适用于加载mybatis相关内容；解析xml、构造sqlsession、链接数据库等等，这三步就是我们orm框架中的核心部分，这也是为什么你只要引入一些数据库的依赖，你如果没有配置数据库，他在项目启动的时候就会报错，因为这个需要一开始就配置好。</p><p>MapperScannerConfigurer</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerConfigurer</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String basePackage;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + basePackage.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ResourcePatternResolver</span> <span class="variable">resourcePatternResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line"></span><br><span class="line">            Resource[] resources = resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMetadataReader</span>(resource, ClassUtils.getDefaultClassLoader());</span><br><span class="line"></span><br><span class="line">                <span class="type">ScannedGenericBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> Introspector.decapitalize(ClassUtils.getShortName(beanDefinition.getBeanClassName()));</span><br><span class="line"></span><br><span class="line">                beanDefinition.setResource(resource);</span><br><span class="line">                beanDefinition.setSource(resource);</span><br><span class="line">                beanDefinition.setScope(<span class="string">&quot;singleton&quot;</span>);</span><br><span class="line">                beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(beanDefinition.getBeanClassName());</span><br><span class="line">                beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(sqlSessionFactory);</span><br><span class="line">                beanDefinition.setBeanClass(MapperFactoryBean.class);</span><br><span class="line"></span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName);</span><br><span class="line">                registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBasePackage</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.basePackage = basePackage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个类要做的就是把Dao接口全部扫描出来（也就是所有的XXXdao），完成他们的代理，然后把他们注册到spring Bean容器</p><p>打个锻炼看看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postProcessBeanDefinitionRegistry</span><br></pre></td></tr></table></figure><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/image-20230427145417700.png" alt="image-20230427145417700"></p><p>看这个packagesearchpath就明白了</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/image-20230427145506491.png" alt="image-20230427145506491"></p><p>看resource，因为我们只有一个dao所以就扫描到了一个</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/image-20230427145729295.png" alt="image-20230427145729295"></p><p>这里把他注册到容器中</p><p>mapperfactory：</p><p>这个类其实就是你所有dao接口类的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日常调用的 dao 层接口就是 MapperFactoryBean 实例化的</span><br></pre></td></tr></table></figure><p>我们虽然配置的是<code>MapperFactoryBean</code>的实列，但是根据id拿到的是<code>getObject</code>方法里面返回的的对象。其实在容器中创建的对象仍然是<code>MapperFactoryBean</code>的实列，只是在获取的时候会判断这个结果对象是不是派生于<code>FactoryBean</code>，如果是的话则返回<code>getObject</code>方法创建的对象，并且这个对象并不是容器初始化时创建的，而是使用<code>context.getBean()</code>方法时才创建。当然了，如果你确实想要获取<code>FactoryBean</code>实例，你需要这样写: <em><code>MapperFactoryBean mapper = context.getBean(&quot;&amp;mapper&quot;, MapperFactoryBean.class);</code></em> 只需要在bean的名字ID前加上&amp;符号。</p><p>所以究竟getObject获取的是什么呢？那就看他return了什么，后面的详细知识和加载流程，就涉及spring源码，所以可以看我的Spring ioc加载流程，保真有所收获！</p><p>现在我们来把我们的成果整合到springboot中，但是我们又不想另起一个模块放我们的整合模块，那怎么做呢？诶，没错，就是依赖组件，我们开发自己的依赖组件，在项目中引入即可。</p><p>那么在springboot的starter的开发过程中，主要的核心在于自动加载autoconfiguration的使用，我们需要加载yml或者其他的配置文件，并结合配置信息注册相关的bean，因为spring和springboot的注册方式可以不同。</p><p>和myabtis组件的整合理解2中提到的mybatis-spring不同的在于，由于spring和springboot本身存在的区别所以加载配置和启动方式有所不同，所以这里我们需要修改的就是扫描方法，注册代码。</p><p>这个工程也主要分成三块：autoconfigure、mybatis、spring</p><p>●autoconfigure,读取自定义配置信息以及负责把相关mybatis、spring 中的Bean加载启动<br>●mybatis,这部分与我们之前实现的ORM框架源码几乎是一致的，只是对<br>SqlSessionFactoryBuilder做了符合yml配置方式的加载处理。<br>●spring,这一部分主要的变 动是MapperScannerConfigurer关于扫描定义Bean 信息时<br>addGenericArgumentValue入参信息的变更。</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis-starter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目-DBRouter组件</title>
      <link href="/2023/04/22/%E9%A1%B9%E7%9B%AE-DBRouter%E7%BB%84%E4%BB%B6/"/>
      <url>/2023/04/22/%E9%A1%B9%E7%9B%AE-DBRouter%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>这个项目我设计的初衷是考虑到业务体量的增加，为了避免原有的设计出现不能承载业务规模的情况发生，所以想设计分库分表， 因为想提高自己的理解，决定自己写一个小组件。</p><p><img src="/../images/DBRouter%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/image-20230428132828992.png" alt="image-20230428132828992"></p><p>主要考虑以下几个方面：</p><p>一是配置，分库分表需要配置连接池，这个依赖于配置文件，配置连接池之后要二是：考虑动态切换，所以需要去实现AbstractRoutingDataSource的deteemingCurrentlookKey方法。</p><p>三：数据库连接池和动态切换配置好了，就只剩下一个路由的计算模块了，从路由计算中获得分库分表的字段，通过哈希散列和扰动函数最终选择去哪个表，让数据均匀的散列到各个表。</p><p>首先讲一下：DataSourceAutoConfig，借助springboot自动配置机制，读取配置以及数据源的创建，包括yml自定义配置，JoinPoint、路由策略、路由配置、数据源、transactionTemplate.</p><p>举个例子：setEnvironment, 读取自定义配置，因为我们要设置的是一个在yml配置多组数据源，这个方法就是为了解析下面的配置信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router :</span><br><span class="line">jdbc:</span><br><span class="line">datasource :</span><br><span class="line">dbCount: 2</span><br><span class="line">tbCount: 4</span><br><span class="line">list: db01 , db02</span><br><span class="line">db01 :</span><br><span class="line">dr iver-class-name: com . mysql. jdbc .Driver</span><br><span class="line">url: jdbc :mysql://127.0.0.1:3306/bugstack_ 01?</span><br><span class="line">useUnicode-true</span><br><span class="line">username: root</span><br><span class="line">password: 123456</span><br><span class="line">db02 :</span><br><span class="line">dr iver-class-name: com. mysql. jdbc . Driver</span><br><span class="line">url: jdbc :mysql:/ /127.0.0.1:3306/bugstack_ 02?</span><br><span class="line">useUnicode-true</span><br><span class="line">username: root</span><br><span class="line">password: 123456</span><br></pre></td></tr></table></figure><p>动态数据源的切换如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;db&quot;</span> + DBContextHolder.getDBKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由计算：</p><p>路由结果会存储在DBConrtextHolder里面</p><p>路由计算首先需要一些前提</p><p>路由注解@DBRouter 路由的标识，目的是为了给切面提供切点，同时获取方法中入参属性点某个字段，这个字段会作为路由字段存在，比如某个dao接口的xxxdao方法上面就有这个</p><p>分表标记@DBRouterStrategy：目的是告诉路由组件要不要分表，默认false</p><p>最关键的，DBRouterJoinPoint切面类，进行路由选择</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DBRouter-starter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考资料</title>
      <link href="/2023/04/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"/>
      <url>/2023/04/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<hr><p>LS0tCnRpdGxlOiDlj4LogIPotYTmlpkKZGF0ZTogMjAyMy0wNC0xMQp0YWdzOiAKICAtIOeUn+eQhumcgOaxggpjYXRlZ29yaWVzOgogIC0g5a2m5Lmg6LWE5paZCgotLS0KIyMjIDIwMjMvMTAvMzHmm7TmlrAK5YaF5a655Li76KaB5p2l6Ieq5pCc5Lmm572R77yM5LiA5LiqSOWwj+ivtOe9keerme+8jOS9huaYr+acieW+iOWkmueRn+eRn+W5v+WRiuOAggpodHRwczovL3d3dy4xMDIwc3NsLjExMTFjaGVhcC5jb20vIOS4u+mhtQpodHRwczovL2YubXVzaWMuc2ZyZWUwODI1LnRvcDo5NDQzLyDmj5DkvpvnmoTlnKjnur&#x2F;op4bpopHnvZHnq5kKaHR0cHM6Ly93d3cuY2FyY2FyLmZsaWdodDJjaGVhcC5jb20vZm9ydW0ucGhwP21vZD1mb3J1bWRpc3BsYXkmZmlkPTIg5o+Q5L6b55qE5LiL6L296KeG6aKR6LWE5rqQCuWwj+ivtOWIhuWMuui&#x2F;mOacieiuuOWkmue9keermeWIhuaekO+8jOiHquihjOWvu+aJvgoKCgojIyMgMjAyMy8wNy8yOeabtOaWsAoK6Ym05LqO5pyA5Yid54mI5pys6YOo5YiG572R56uZ5bey5Lii5aSx77yM5Yaz5a6a5a+55omA5pyJ572R56uZ6L+b6KGM5YWo6Z2i5riF5rSX44CCCgojIyMjIOaXoOmcgOe&#x2F;u+Wime+8mgoKQVblpKnloILnvZHvvJpodHRwOi8vYmIuOTk5OXllcy5jb20vbmV3c2l0ZS5odG1sP2M9NDk5ODg4Mzg0MCAKCua8q+ibme+8iOmfqea8q++8ie+8mmh0dHBzOi8vbWFud2EubWUvCgrmgKflpYvoibLlkIPnk5znvZHvvJpodHRwOi8vd3d3Lnhmc2UxMS5jb20vCgo1R+W9semZou+8mmh0dHBzOi8vNXF3bWJhLnRvcC8KCuadj1RW77yaaHR0cHM6Ly8xOHhpbmd0di5jYy8KCueci+eJh+inhumike+8mmh0dHBzOi8vd3d3LmhrMTJxLnRvcC92b2RwbGF5aHRtbC8yMjQtMS0xLmh0bWwKCuS4u+aSreinhumike+8mmh0dHBzOi8vd3d3LnU3c2IuY29tL2VudGVyL2luZGV4Lmh0bWwKCnlvdXBvcm4gQVNJQSBDSEFOTkVM77yaaHR0cDovL3gzMzY5OS5jb20vCgp2OGs0bi5jb23vvJpodHRwczovL3d3dy52OGs0bi5jb20vaW5kZXgvaG9tZS5odG1sCgojIyMjIOe&#x2F;u+Wime+8mgoKeGhhbXN0ZXLvvJpodHRwczovL3poLnhoYW1zdGVyLmNvbS8KCueLvOWPi+mYge+8mmh0dHBzOi8vMDA1MWF2LmNvbS8KCum7keaWmeato+iDvemHj++8mmh0dHBzOi8vd3d3LmZ1bGkzNC5sdi8KClBvcm5odWLvvJpodHRwczovL2NuLnBvcm5odWIuY29tLwoKYuW9semZou+8mmh0dHBzOi8vYmJieXVuLnRvcC8KCiMjIyMg6L2v5Lu277yaCgrlhbblrp7orrjlpJrnvZHnq5nnmoTlj4vpk77kuK3pg73mnInova&#x2F;ku7bvvIzov5nph4zkuL7kuIDkvosKCum7keaWmeekvu+8mmh0dHBzOi8vdDYycm8uY29tLz9kYz1NSVlVMDQ&#x3D;</p><p><a href="https://www.iamwawa.cn/base64.html">https://www.iamwawa.cn/base64.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待定</title>
      <link href="/2023/04/04/New%20page/"/>
      <url>/2023/04/04/New%20page/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> new </category>
          
      </categories>
      
      
        <tags>
            
            <tag> new </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股-其余问题</title>
      <link href="/2023/04/04/%E5%85%AB%E8%82%A1-%E5%9C%BA%E6%99%AF%E9%A2%98/"/>
      <url>/2023/04/04/%E5%85%AB%E8%82%A1-%E5%9C%BA%E6%99%AF%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>分布式锁的实现方式</strong></p><p>1、数据库锁表</p><p>2、redis</p><p>3、zookeeper</p><h4 id="Roaring-BitMap"><a href="#Roaring-BitMap" class="headerlink" title="Roaring BitMap"></a>Roaring BitMap</h4><p><font color='red'><u><em><strong>为什么单表2000w</strong></em></u></font></p><p>一页16k，非叶子结点存主键和指针，16*1024字节&#x2F;（主键+指针）&#x3D;1000个</p><p>两层，1000*1000。&#x3D;100w</p><p>100w*每个叶子结点，16 * 100w &#x3D; 1.6kw</p><p><strong>订单超时自动取消功能如何设计？</strong></p><blockquote><p>首先，这个订单肯定已经是产生了的。</p><p><font color='red'><u><em><strong>一种方法就是：定时任务+轮训，但是如果订单很多的情况下，就不合适了。</strong></em></u></font></p><p><font color='red'><u><em><strong>时间轮算法：可能60个槽、可能365个槽。槽不够用要么加槽，要么分层（分+秒）</strong></em></u></font></p><p><font color='red'><u><em><strong>延迟消息mq，设置一个时间，等到这个时间到了我们去检查用户是否支付</strong></em></u></font></p><p>最好还是用消息队列mq</p></blockquote><p><strong>在 2G 大小的文件中，找出高频top100的单词</strong></p><blockquote><p>关于这个问题，我说一下我的回答思路 1. 把 2G 的文件进行分割成大小为 512KB 小文件，总共得到2048 个小文件，避免一次性读入整个文件造成内存不足。 2. 定义一个长度为 2048 的 hash 表数组，用来统计每个小文件中单词出现的频率。3. 使用多线程并行遍历 2048 个小文件，针对每个单词进行 hash 取模运算分别存储到长度为 2048 的 hash 表数组中 inthash&#x3D;Math.abs(word.hashCode() %hashTableSize); hashTables[hash].merge(word, 1, Integer::sum); 4. 接着再遍历这 2048 个 hash 表，把频率前 100 的单词存入小顶堆中5. 最后，小顶堆中最终得到的 100 个单词，就是 top 100 了。这种解决方案的核心思想是将大文件分割为多个小文件，然后采用分治和堆的算法，来解决这个问题。</p></blockquote><p><strong>设目前有一千万个字符串,请你统计最热门的10个查询</strong><br>要求使用的内存不能超过1G。</p><blockquote><p>1、可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数，用最小堆处理每个小文件的top10，最后扫描小文件的以得到最后的结。</p></blockquote><p><strong>40亿个非负整数中找到没出现的数</strong></p><blockquote><p>布隆过滤器</p></blockquote><p><strong>40亿个非负整数中找到出现两次的数</strong></p><blockquote><p>两个布隆过滤器，出现1次01，出现两次10，出现三次11，出现0次00.</p></blockquote><p><strong>求中位数</strong></p><blockquote><p><strong>桶排序</strong></p><p>1.假设整数为有符号的32位数据，其取值范围是[-2^31, 2^31-1]，将范围等份划分10000段，即thread_1[],thread_2[]…thread_10000[]。</p><p>　　2.将数据分为10组依次读入。首先装载第一个1G个数，遍历这些数，看它们落入thread_1[]至thread_10000[]的哪个区间，落入的对应区间统计计数增1；然后装载第二个1亿个数，重复比较与计数。</p><p>　　3.数据全部装载一次之后，从thread_1[]的计数开始累加，直至计数累加到全部数据的一半（假设为N&#x2F;2），那么第N&#x2F;2个元素所在的区间thread_i[]就包含了中位数。</p><p>　　4.假设中位数区间的范围是[a, b]，且前面所有区间的数据计数共有m个，再次按照每组1G个元素遍历全部数据，对于处在thread_i[]区间的每个元素都进行计数。</p><p>　　5.当thread_i[]区间每个元素的计数累加之和加上m第一次超过N&#x2F;2时，该计数处的元素就是中位数。</p><p>　　这种方法需要两次遍历全部数据，效率较高。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目-Lucky抽奖</title>
      <link href="/2023/04/03/%E9%A1%B9%E7%9B%AE-Lucky%E6%8A%BD%E5%A5%96/"/>
      <url>/2023/04/03/%E9%A1%B9%E7%9B%AE-Lucky%E6%8A%BD%E5%A5%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven的三种packaging方式-pom、jar、war"><a href="#Maven的三种packaging方式-pom、jar、war" class="headerlink" title="Maven的三种packaging方式(pom、jar、war)"></a>Maven的三种packaging方式(pom、jar、war)</h1><p>pom是maven依赖文件<br>jar是java普通项目打包<br>war是java web项目打包 </p><p>pom：打出来可以作为其他项目的maven依赖，在工程A中添加工程B的pom，A就可以使用B中的类。用在父级工程或聚合工程中。用来做jar包的版本控制。</p><p>jar包：通常是开发时要引用通用类，打成jar包便于存放管理。当你使用某些功能时就需要这些jar包的支持，需要导入jar包。</p><p>war包：是做好一个web网站后，打成war包部署到服务器。目的是节省资源，提供效率</p><h1 id="relativePath"><a href="#relativePath" class="headerlink" title="relativePath"></a>relativePath</h1><p>搭建<a href="https://so.csdn.net/so/search?q=maven&spm=1001.2101.3001.7020">maven</a>项目，子模块指定父模块试，经常会在parent下面出现relativePath类似下面：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;net.itxw&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;test&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>这个<parent>下面的<relativePath>属性是什么意思？</p><p>其实很明显，就是parent的路径，具体来说就是你引用这个parent项目，那parent项目的pom在哪里</p><h1 id="dependencyManagement"><a href="#dependencyManagement" class="headerlink" title="dependencyManagement"></a>dependencyManagement</h1><p>如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号。当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要逐个修改子项目；另外如果某个子项目需要另外的一个版本，只需要声明version即可。</p><p>dependencyManagement中定义的只是依赖的声明，并不实现引入，因此子项目需要显式的声明需要用的依赖。</p><p>在父项目的POM.xml中配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.2.3.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p>在子项目中配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="build"><a href="#build" class="headerlink" title="build"></a>build</h1><h3 id="1-约定的目录结构"><a href="#1-约定的目录结构" class="headerlink" title="1 约定的目录结构"></a>1 约定的目录结构</h3><p><code>build </code>标签的子标签大致包含三个主体部分：</p><p>2.2.1 约定的目录结构<br>参考附录中的如下部分：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;sourceDirectory&gt;D:\idea\maven-test\src\main\java&lt;/sourceDirectory&gt;</span><br><span class="line">&lt;scriptSourceDirectory&gt;D:\idea\maven-test\src\main\scripts&lt;/scriptSourceDirectory&gt;</span><br><span class="line">&lt;testSourceDirectory&gt;D:\idea\maven-test\src\test\java&lt;/testSourceDirectory&gt;</span><br><span class="line">&lt;outputDirectory&gt;D:\idea\maven-test\target\classes&lt;/outputDirectory&gt;</span><br><span class="line">&lt;testOutputDirectory&gt;D:\idea\maven-test\target\test-classes&lt;/testOutputDirectory&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;D:\idea\maven-test\src\main\resources&lt;/directory&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;testResources&gt;</span><br><span class="line">    &lt;testResource&gt;</span><br><span class="line">        &lt;directory&gt;D:\idea\maven-test\src\test\resources&lt;/directory&gt;</span><br><span class="line">    &lt;/testResource&gt;</span><br><span class="line">&lt;/testResources&gt;</span><br><span class="line">&lt;directory&gt;D:\idea\maven-test\target&lt;/directory&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>能看到各个目录的作用如下：</p><p>目录名作用<br>sourceDirectory主体源程序存放目录<br>scriptSourceDirectory脚本源程序存放目录<br>testSourceDirectory测试源程序存放目录<br>outputDirectory主体源程序编译结果输出目录<br>testOutputDirectory测试源程序编译结果输出目录<br>resources主体资源文件存放目录<br>testResources测试资源文件存放目录<br>directory构建结果输出目录</p><h3 id="2备用插件管理"><a href="#2备用插件管理" class="headerlink" title="2备用插件管理"></a>2备用插件管理</h3><p>pluginManagement 标签存放着几个极少用到的插件：</p><p>maven-antrun-plugin<br>maven-assembly-plugin<br>maven-dependency-plugin<br>maven-release-plugin<br>通过 pluginManagement 标签管理起来的插件就像 dependencyManagement 一样，子工程使用时可以省略版本号，起到在父工程中统一管理版本的效果，看下面例子：</p><p>被 spring-boot-dependencies 管理的插件信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;pluginManagement&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/pluginManagement&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line">子工程使用的插件信息：</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-生命周期插件"><a href="#3-生命周期插件" class="headerlink" title="3 生命周期插件"></a>3 生命周期插件</h3><h1 id="把cn-XXXX-改成自己的包名，发现也有蛮多地方需要修改，也能加深理解"><a href="#把cn-XXXX-改成自己的包名，发现也有蛮多地方需要修改，也能加深理解" class="headerlink" title="把cn.XXXX 改成自己的包名，发现也有蛮多地方需要修改，也能加深理解"></a>把cn.XXXX 改成自己的包名，发现也有蛮多地方需要修改，也能加深理解</h1><p> 比如application.xml，mybatis全局配置xml里的typeAliases，不过这个文件在第三章还没用到，configuration里面的注释里也能正常跑。</p><h1 id="第4节-策略"><a href="#第4节-策略" class="headerlink" title="第4节 策略"></a>第4节 策略</h1><p> 通常分库分表的几个常见方面；</p><ol><li>访问频率：对于高频访问的数据，可以将其存储在单独的数据库或表中，以提高读写性能。</li><li>数据大小：对于大量的数据，可以将其拆分到多个表中，以减少单表的数据量，降低存储开销。</li><li>数据类型：对于不同类型的数据，可以将其拆分到不同的数据库或表中，便于管理和查询。</li><li>数据范围：对于不同范围的数据，可以将其拆分到不同的数据库或表中，便于数据的管理和查询。</li></ol><p>分库分表的主要目的在于；数据分摊、提高QPS&#x2F;TPS、分摊压力、提高可扩展性。比如；比如数据库的读写性能下降，或者单表数据量过大，这时候您就需要考虑进行分库分表操作了。通过拆分数据库，可以将单个数据库的压力分摊到多个数据库上，从而避免单个数据库的性能瓶颈，提高系统的性能和可扩展性。此外，分库分表还可以解决数据库存储容量的限制，提高数据库的存储能力。</p><p>另外在分库分表之后，数据的一致性会受到影响，数据库的管理和维护成本也会增加。因此，在考虑分库分表时，需要仔细权衡利弊，确定是否真的需要进行分库分表操作。也就是你的开发成本问题。因为有分库分表就会相应的引入 canal binlog同步、es、mq、xxl-job等分布式技术栈。</p><h2 id="库表梳理"><a href="#库表梳理" class="headerlink" title="库表梳理"></a>库表梳理</h2><p>1、感觉从抽奖流程出发比较好理解，用户-&gt;抽奖-&gt;有无得奖-&gt;结果<br>抽奖单独提炼策略表，有无得奖提炼奖品表，策略表和奖品表可以联系成策略明细表（一个策略多个奖品1:n）。抽完后的结果肯定要弄出个结果表，包括奖品发放后续、抽奖明细，但是考虑到用户可以多抽几次，全放一张表肯定不行，那一个用户三个记录肯定不行，所以可以单独分出一个纯粹的参与活动记录表和用户活动抽奖次数表，至于发放奖品后续就可以一个用户一条记录，做成用户抽奖结果表，这样理解可以吗？<br>2、从什么角度出发对需求进行初步的库表梳理比较好的，就像傅哥说的怎么打好地基。</p><h1 id="第5节"><a href="#第5节" class="headerlink" title="第5节"></a>第5节</h1><p>原始mvc架构的一个服务可能对应多个实体类，多个服务可能对应一个实体类，那后面修改一个服务的时候可能造成牵一发而动全身的结果。<br>ddd架构中model（聚合对象）里的对象类只服务于这个领域的repository（数据仓储） service（领域服务），从包的结构区分问题。dao则是仓储的具体实现，repository是接口。</p><p>自增id</p><p>疑惑：不是说model放聚合对象吗，为什么award strategy这些在基础设施层呢，不是应该在strategy领域里面吗？<br>draw req res 这代表什么意思呢</p><p>思考：default抽奖算法，能不能直接在single每次抽奖完的基础上加一个判断，如果有一个奖品抽完了，那就重新更新rateTuple，这样是不是也可以呢，反正原本的default抽奖算法每次抽奖也是要循环奖品？</p><p>service层结构很清晰,DrawExecImpl为什么不自己申明一个变量作为抽奖类型，初始化的时候给他赋值。这样就不用每次抽奖都去数据库请求了。还是说为了防止抽奖方式的改变而这么做呢？</p><p>7-10，同时回顾一下4-6的内容</p><h1 id="第六节的重点是模版模式。"><a href="#第六节的重点是模版模式。" class="headerlink" title="第六节的重点是模版模式。"></a>第六节的重点是模版模式。</h1><p>模版模式是定义一个算法的骨架，并允许子类为一个或多个步骤提供实现。在第六节中这个算法骨架（抽象模版类）是AbstractDrawBase，这个类中有通用的比如对于抽奖结果的包装，也有抽象方法比如执行抽奖算法（这个在子类中实现）。小傅哥在这个基础上又把一些一些通用的数据服务抽象出新的一层DrawStrategySupport，这个算是一种优化，但是他本质也属于抽象模版类的一部分。</p><p>而我们抽奖则需要抽奖策略（怎么个抽法），这就是第五节的东西—策略模式：</p><p>对象的某个行为，在不同场景中有不同的实现方式，这样就可以将这些实现方式定义成一组策略，每个实现类对应一个策略，在不同的场景就使用不同的实现类，并且可以自由切换策略。</p><p>其实看完第六节会发现第五节和第六节很像，也是抽象出了一个接口和一个抽象模版类，其他的子类继承抽象模版类实现randomDraw（）方法，不同的实现对应不同的算法，具体算法我们自己可以修改逻辑、补充内容等操作。</p><p>在这时候我们发现策略模式和模版模式很像，但是是有一些区别的：</p><p>模板模式：问题处理的流程已经被定义好，父类实现通用的逻辑（当然你也可以再抽象出一层），子类实现个性化逻辑。</p><p>策略模式：父类定义一组抽象算法，子类自己实现自己的。每个策略完成的功能是重复的，同一时间，只能选择其中的一种，即互斥的</p><p>策略模式核心在使用者的策略，按照自己的策略去替换。模板方法模式核心在子类的怎么实现。</p><p>举个例子：</p><p>模版模式： 父类：早上6点吃饭，晚上6点吃面。子类1：早上6点吃稀饭，晚上6点吃泡面。子类2：早上6点吃干饭，晚上6点吃挂面。</p><p>策略模式：父类：早晚进食。子类1:早上5点吃面，晚上5点吃面。子类2:早上7点吃饭，晚上7点吃饭。子类3:早上不吃，晚上不吃…</p><h1 id="第八节：状态模式"><a href="#第八节：状态模式" class="headerlink" title="第八节：状态模式"></a>第八节：状态模式</h1><p>当一个对象的内在状态改变时，允许改变其行为，把不同状态当做一个类，解决对象在多种状态转换时，需要对外输出不同的行为的问题。</p><p>同样的有抽象模版类（AbstractState，当然你要自己提炼一个接口大概也没什么问题），多个具体实现的子类。要有一个Context类，这个类持有State，负责保持并切换当前的状态，当状态变化时，修改这个State。在项目中应该是活动创建的时候初始化状态，后续收到一些通知（比如：快递公司揽件，发送目的地，菜鸟驿站收到快递）修改活动中的状态变量就可以，非常方面。</p><p>第九节：ID生成策略</p><p>也是策略模型，因为目前就一个id生成的要求，也无需什么流程啊，也不涉及什么状态改变，不同情境下使用不同类型的id，所以策略模式最佳。</p><h1 id="第十节：分库分表"><a href="#第十节：分库分表" class="headerlink" title="第十节：分库分表"></a>第十节：分库分表</h1><p>内容多，也是这几天最花时间的，bug奇多，自己不小心把application.yml文件里面的配置写错了，然后报空指针，找不到bean，我还以为自己打包有问题呢；因为自己的版本和傅哥的不太一样，总报一些依赖错误，还有什么commons-lang、commons-beanutils依赖缺失。自己的的项目工程包名是自定义的，和傅哥的cn.itedus.lottery和那个cn.bugstack不一样，中途修改的时候感觉对理解还是有益处的。</p><p>之后再对第十节做一次总结，加深感悟。</p><h1 id="第十节我们可以从注解出发看项目。"><a href="#第十节我们可以从注解出发看项目。" class="headerlink" title="第十节我们可以从注解出发看项目。"></a>第十节我们可以从注解出发看项目。</h1><p>DBRouter注解写好后，肯定要配备切面类DBRouterJoinPoint（这里面包括了路由策略和路由配置几库几表），里面有一个@Around注解，表示包围一个函数，也就是可以在函数执行前做一些事情，也可以在函数执行后做一些事情。</p><p>项目中是先拿到Key字段（uId），判断是不是空，是的话Runtime异常，不是的话就去拿uId这个字段对应的值，按照例子就是Uhdgkw766120d。</p><p>拿到值之后，那么下面就是拿着这个值去做路由了（该怎么走），这部分内容被写在DBRouterStrategyHashCode的doRouter里面。其实就是hash的扰动函数，通过设定的算法得到去拿个库哪个表，把这两个信息交给DBContextHolder（一个标识类，用来存储当前数据源的key及状态判断），下面就要向数据集里面写东西了，jp.process(),接下去就是mybatis拦截器的任务了。</p><p>自定义拦截器需要实现org.apache.ibatis.plugin.Interceptor接口, 并在接口上添加@Intercepts注解。<br>@Intercepts注解是通过一个@Signature注解(拦截点),来指定拦截那个对象里面的某个方法。<br>@Signature注解需要定义三个东西：</p><p>定义拦截的类 Executor、ParameterHandler、StatementHandler、ResultSetHandler当中的一个<br>Class&lt;?&gt; type();</p><p>在定义拦截类的基础之上，在定义拦截的方法<br>String method();</p><p>在定义拦截方法的基础之上在定义拦截的方法对应的参数，<br>因方法里面可能重载，不指定参数列表，不能确定是对应拦截的方法<br>Class&lt;?&gt;[] args();</p><p>我们查看代码，发现拦截的类选择的是StatementHandler，目前不太了解mybatis的源码，但是查询资料之后发现毫无疑问是四大对象最重要的一个，它的任务就是和数据库对话。在它这里会使用parameterHandler和ResultSetHandler对象为我们绑定SQL参数和组装最后的结果返回。</p><p>拦截的方法是prepare，预编译阶段</p><p>参数是{Connection.class, Integer.class}</p><p>回到那个自定义拦截器类 继承了Interceptor。intercept里面就放着怎么把sql变成我们想要的那种动态分库分表的逻辑。<br>首先几行代码拿到dbRouterStrategy注解，看他是不是true<br>如果是，我们去拿sql语句，如下所示：</p><p>INSERT INTO user_strategy_export<br>        (u_id, activity_id, order_id, strategy_id, strategy_mode,<br>         grant_type, grant_date, grant_state, award_id, award_type,<br>         award_name, award_content, uuid, create_time, update_time)<br>        VALUES<br>        (?,?,?,?,?,<br>         ?,?,?,?,?,<br>         ?,?,?,now(),now())</p><p>他利用一个matcher找到 INTO user_strategy_export这段语句。为什么？因为INTO后面跟着的就是表，至于是哪个表，在上面已经提到了，就是DBContextHolder。这里就实现了分表。</p><p>至于分库，我们重写了determineCurrentLookupKey方法，这个方法被determineTargetDataSource调用，determineTargetDataSource被getConnection调用，getConection可以追溯到DataSource接口的getConnection抽象方法。但是我还不知道determineCurrentLookupKey什么时候被调用？？</p><p>所以就去查了查多数据源的处理机制的一些文章，发现和自己想的有区别，我一直以为调用DAO层的方法，应该先切面再切换数据源最后才是DAO的逻辑（毕竟我看不到什么时候切换数据源，但是DBRouter注解就是直勾勾的放在DAO方法上面的），结果文章中提到其实是先切换数据源，然后切面方法，最后DAO逻辑。文章给出的原因是事务中不支持数据源切换。<br>但是我打断点还是没找到调用determineCurrentLookupKey的那段代码，可惜。</p><p>最后就是把这些配置到DataSourceAutoConfig，打包给我们的项目。</p><h1 id="11"><a href="#11" class="headerlink" title="11"></a>11</h1><p>如果一个请求，需要对多个表进行修改，那么大概率需要事务，因为也许第一个对表的操作成功了，但是第二个对表的操作失败，那就出问题了。</p><p>Spring支持两种事务管理方式：编程式事务管理以及声明式事务管理。</p><p>编程式事务方式需要是开发者在代码中手动的管理事务的开启、提交、回滚等操作<br>声明式事务管理方法允许开发者配置的帮助下来管理事务，而不需要依赖底层API进行硬编码。声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚</p><p>声明式事务的优点：对代码没有侵入性，方法内只需要写业务逻辑就可以了。<br>声明式事务的缺点：<br>如果在一个事务下，连续操作不同的DAO操作，那么就会涉及到在 DAO 上使用注解 @DBRouter(key &#x3D; “uId”) 反复切换路由的操作。比如你第一个DAO对某个库表操作，第二个DAO对另一个库表操作，这就不行，原因是网上查的不知道对不对：<br>1、Spring@Transactional不支持跨数据源事物，Spring 事务控制是基于数据库链接进行的，当数据源切换后，数据库链接切换，事物回滚只能回退，当前持有的链接<br>2、Spring开启事物后，会将当前数据库及数据库链接资源进行线程绑定，导致数据源切换失效（数据源切换执行后，并未获取到新的数据库链接）</p><p>我们把领取活动提炼成一个模版，这个模版里的流程是有的操作需要同时处理多个数据源加上我们还是分库分表，所以不适用声明式，应该用编程式。<br>spring事务配置总是由DataSource、TransactionManager和代理机制这三部分，new一个TransactionManager然后放入我们自己的DataSource。然后在transactionTemplate里放入新的TransactionManager。到这里基本就配置好了，至于什么路由策略啊这些其实和第十章的没什么区别。</p><p>回顾一下第十章，我们是在DAO上加上注解，配合路由组件中的一系列（数据路由切面），拦截被切面的方法。<br>但是在第十一章中，通用模版类中第四步我们使用了编程式事务，他需要同时对多个表进行操作。但是第一步第二步这种查询工作、校验工作这种对数据库没有修改的操作，小傅哥要么DBRouter要么直接就没加（分库分表）。所以声明式和编程式配合使用也许会更好。</p><h1 id="12"><a href="#12" class="headerlink" title="12"></a>12</h1><p>这章有一个问题就是，傅哥给的sql语句是2021年的，然后你执行test方法会报错，因为里面有一个活动信息校验处理模块，他会去判断你当前的时间是不是在活动期限里面，要么你直接把时间写死在2021年，要么你对数据库里面的数据进行一定修改，要么直接就把校验模块注释。</p><h1 id="13"><a href="#13" class="headerlink" title="13"></a>13</h1><p>运用组合模式搭建规则引擎领域服务，包括：logic 逻辑过滤器、engine 引擎执行器。<br>其实我们现在脑海中想到一棵规则树，那么这个数有根节点，子节点，连线，我们把这三部分分别弄成三张表放到数据库中，也就是数据库中的三张表就代表着我们的规则树。<br>理论知识有了那么接下来就是实践了——引擎执行。<br>我们参考ruleTest测试方法，他是直接给出请求，这个请求包括了规则树id，但是之后项目复杂之后，关于这个规则数id的选取可能也要做些文章，现在我们假设就是这个规则树id。<br>从请求req到获取活动id，分成三步。<br>1、从id到数据库里取到规则树详细的信息<br>2、根据这颗规则树拿到果实节点<br>3、提炼果实节点的信息，包装成结果返回，这个结果里面就包括了活动id<br>第一步无需事务，直接查询，返回结果，这个看似没什么好讲的，其实非常重要，我们要查果实节点，那就需要完整的树，刚才我们提到了，树被分成了三个表，那这一步中就对这三张表分别进行了一次查询，将结果聚合成我们的聚合对象。第二步就是在第一步的基础上拿出东西做循环。第三步就是包装一下。因为第一步三个表也没做分库分表，所以也用不上DBRouter，也不是特别适合用编程式路由，就是对特定表的简单查询。但是问题在于是否要给这三个表的查询加上事务呢？<br>感觉加上是不是更好呢？</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lucky项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-去雾论文参考</title>
      <link href="/2022/10/23/%E7%AE%97%E6%B3%95-%E5%8E%BB%E9%9B%BE%E8%AE%BA%E6%96%87%E5%8F%82%E8%80%83/"/>
      <url>/2022/10/23/%E7%AE%97%E6%B3%95-%E5%8E%BB%E9%9B%BE%E8%AE%BA%E6%96%87%E5%8F%82%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p> 雾霾是户外常见的天气。雾天图像成像过程中，物体表面的反射光受到大气介质的吸收和散射作用能量衰减，环境光经过大气多次散射真实光照强度受损，所以拍摄的图片相较于真实场景存在能见度差、对比度低、区域模糊等问题。此类画质退化问题大大降低了计算机视觉系统在交通安全、遥感监控、目标监控与识别等领域的性能，为此去雾算法的研究生是必要的。</p><p>据统计，去雾研究可以分成三个大类：基于图像增强的去雾，基于大气散射模型的图像复原去雾以及结合深度学习的去雾。</p><p>图像增强方面： </p><p>Jobson提出多尺度Retinex，实现了同时的动态范围压缩和颜色一致性；Petro证实了多尺度Retinex用于图像颜色恢复和对比度增强的有效性。Ngo采取细节增强、伽马校正、单尺度图像融合和自适应色调重映射增强了融合欠曝光图像后得到的暗化结果。Ancuti通过应用白平衡和对比度增强保留了良好的可见性区域。</p><p>图像复原方面：</p><p>图像复原最流行的方法是Dark Channel Prior（DCP）。He首次提出DCP，使用最小滤波和大气散射模型进行去雾，并在后续提出引导滤波改进DCP算法。然而He对于大气散射模型中传输图和大气光值的估计不够准确，所以衍生出了大量的优秀算法。Li引入一种新的全局引导图像滤波去平滑传输图的估计。Zhu融合亮度信息去恢复天空区域的传输值信息。Cheng将DCP得到原始传输图与Gamma校正后的传输图进行适当融合，保留传输图中的细节信息。Zhao运用多尺度最优融合( Multi-scale Optimal Fusion，MOF )模型对像素级和块级传输图进行最优融合。Salazar-Colores利用形态学重构进行传输图的快速计算，还提出了一种基于DCP、局部香农熵和快速引导滤波的深度近似方法，以减少伪影和提高低计算时间的天空区域的图像恢复。Meng采用基于L1范数的正则化方法来细化传输图。Raikwar在正则化的基础上，定义一种先验来估计不混浊的图像的最小颜色通道。Liu改进得到一种全变分正则化的传输值估计方法。Gautam发现颜色恒常性先验能提高杂色的光照存在时大气光估计的鲁棒性。</p><p>除了以上的图像复原方法，还有一些不需要借助大气散射模型的算法被提出。Zhu等人通过观察有雾图像中亮度和饱和度的差值定义了Color Attenuation Prior（CAP），建立线性模型进行去雾。Galdran整合多个伽马校正图片中曝光良好的区域，使用多尺度拉普拉斯融合方案进行去雾。Hong对整幅图像进行单独恒透射，把中间潜影图像融合为单幅去雾图像。Ma优化彩色multi-exposure image fusion（MEF）结构相似性，提出一种多曝光的图像融合算法。</p><p>深度学习去雾方面：Cai提出一种可训练的端到端系统DehazeNet，能够直接输出传输图；Ren提出多尺度估计卷积神经网络MSCNN在质量和速度做出突破。Li提出轻量级一体化去雾网络AOD-Net直接生成干净的无雾图像。Chen提出端到端的门控上下文聚合网络GCANet着重解决了网格伪影。Engin提出的Cycle-Dehaze结合循环一致性和感知损失提高纹理信息恢复的质量。Liu提出GridDehazeNet基于注意力的多尺度估计有效减少最终输出中的伪影。Dong基于物理的特征提出PFDN，在网络设计中明确考虑了雾气的过程，并在深度特征空间中去除雾气。Chen本文提出了一种由细节增强卷积( DEConv )和内容引导注意力( CGA )组成的细节增强注意力块( DEAB )来增强特征学习，以提高去雾性能。Liu提出GMAN，基于编码器-解码器全卷积架构，学习捕获图像中的雾霾结构，克服一些最先进方法的常见缺陷，如颜色暗化和过度边缘锐化。Fang受知识蒸馏的启发，以端到端的方式为单幅图像去雾设计了指导性教学框架。深度学习方法虽然能在特定数据集上取得不错的效果，但是自然界中的雾霾分布和深度的规律难以捕捉，不同雾霾间的差距巨大，一旦使用与训练集差异较大的数据集测试结果较差，所以在真实场景下的去雾算法不尽人意。</p><p>[1]   D. J. Jobson, Z. Rahman, G. A. Woodell, A multiscale retinex for bridging the gap between color images and the human observation of scenes, IEEE Trans. Image Process. 6 (7) , 965–976 (1997).</p><p>[2]   A. B. Petro, C. Sbert, J.-M. Morel, Multiscale Retinex, Image Process. Line, 4, 71–88, 2014. </p><p>[3]   Ngo, D., Lee, S., Nguyen, Q.H., et al.: Single image haze removal from image enhancement perspective for real-time vision-based systems. Sensors 20(18), 5170–5191 (2020)</p><p>[4]   C.O. Ancuti, C. Ancuti, Single image dehazing by multi-scale fusion, IEEE Trans. Image Process. 22 (8) (2013) 3271–3282.</p><p>[5]   Kaiming, H., Jian, S., Xiaoou, T. Single image haze removal using dark channel prior. In: IEEE Conference on Computer Vision and Pattern Recognition, pp. 1956–1963 (2009)</p><p>[6]   He, K., Sun, J., Tang, X.. Guided image filtering. IEEE Trans. Pattern Anal. Mach. Intell. 35 (6), 1397–1409 (2013).</p><p>[7]   Z. Li, J. Zheng, Single image de-hazing using globally guided image filtering, IEEE Trans. Image Process. 27 (1) (2018) 442–450.</p><p>[8]   Zhu, Y., Tang, G., Zhang, X., et al.: Haze removal method for natural restoration of images with sky. Neurocomputing 275(31), 499–510 (2017)</p><p>[9]   Cheng, S., Yang, B. An efficient single image dehazing algorithm based on transmission map estimation with image fusion. Engineering Science and Technology, an International Journal <strong>35</strong>, 101190 (2022)</p><p>[10] Zhao, D., Xu, L., Yan, Y., et al.: Multi-scale optimal fusion model for single image dehazing. Signal Process. Image Commun. 74, 253–265 (2019)</p><p>[11] Salazar-Colores, S., Cabal-Yepez, E., Ramos-Arreguin, J.M., Botella, G., Ledesma-Carrillo, L.M., Ledesma, S.: A fast image dehazing algorithm using morphological reconstruction. IEEE Trans. Image Process. 28(5), 2357–2366 (2019)</p><p>[12] Salazar-Colores, S., Moya-Sánchez, E.U., Ramos-Arreguín, J.M., Cabal-Yépez, E., Flores, G., Cortés, U.: Fast single image defogging with robust sky detection. IEEE Access 8, 149176–149189 (2020)</p><p>[13] G. Meng, Y. Wang, J. Duan, S. Xiang, C. Pan, Efficient image dehazing with boundary constraint and contextual regularization, in: Proceedings of the IEEE International Conference on Computer Vision (ICCV), 2013, pp. 617–624.</p><p>[14] Raikwar, S.C., Tapaswi, S.: Tight lower bound on transmission for single image dehazing. Vis. Comput. 36, 191–209 (2020)</p><p>[15] Raikwar, S.C., Tapaswi, S.: Lower bound on transmission using non-linear bounding function in single image dehazing. IEEE Trans. Image Process. 29, 4832–4847 (2020)</p><p>[16] Y. Liu, J. Shang, L. Pan, A. Wang, M. Wang, A unified variational model for single image dehazing, IEEE Access 7 (2019) 15722–15736.</p><p>[17] S. Gautam, T. K. Gandhi和B. K. Panigrahi, An Improved Air-Light Estimation Scheme for Single Haze Images Using Color Constancy Prior, IEEE Signal Process. Lett., 27, 1695–1699, 2020.</p><p>[18] Zhu, Q., Mai, J., Shao, L. A fast single image haze removal algorithm using color attenuation prior. IEEE Trans. Image Process. 24 (11), 3522–3533 (2015).</p><p>[19] A. Galdran, Image dehazing by artificial multiple-exposure image fusion, Signal Process. 149 (2018) 135–147.</p><p>[20] S. Hong, M. Kim, M.G. Kang, Single image dehazing via atmospheric scattering model-based image fusion, Signal Process. 178 (2021) 107798.</p><p>[21] K. Ma, Z. Duanmu, H. Yeganeh, Z. Wang, Multi-exposure image fusion by optimizing a structural similarity index, IEEE Trans. Comput. Imaging 4 (1) (2018) 60–72.</p><p>[22] B. Cai, X. Xu, K. Jia, C. Qing, D. Tao, Dehazenet: an end-to-end system for single image haze removal, IEEE Trans. Image Process. 25 (11) (2016) 5187–5198.</p><p>[23] W. Ren, S. Liu, H. Zhang, J. Pan, X. Cao, and M.-H. Yang, Single image dehazing via multi-scale convolutional neural networks. in European conference on computer vision. Springer, 2016, pp. 154169.</p><p>[24] B. Li, X. Peng, Z. Wang, J. Xu, and D. Feng, “Aod-net: All-in-one dehazing network,” in Proceedings of the IEEE international conference on computer vision, 2017, pp. 4770–4778.</p><p>[25] D. Chen, M. He, Q. Fan, J. Liao, L. Zhang, D. Hou, L. Yuan, G. Hua, Gated Context Aggregation Network for Image Dehazing and Deraining, in: 2019 IEEE Winter Conf. Appl. Comput. Vis. WACV, IEEE, Waikoloa Village, HI, USA, 2019: pp. 1375–1383. <a href="https://doi.org/10.1109/WACV.2019.00151">https://doi.org/10.1109/WACV.2019.00151</a>.</p><p>[26] D. Engin, A. Genc, H.K. Ekenel, Cycle-Dehaze: Enhanced CycleGAN for Single Image Dehazing, in: 2018 IEEECVF Conf. Comput. Vis. Pattern Recognit. Workshop CVPRW, IEEE, Salt Lake City, UT, USA, 2018: pp. 938–9388. <a href="https://doi.org/10.1109/CVPRW.2018.00127">https://doi.org/10.1109/CVPRW.2018.00127</a>.</p><p>[27] J. Dong, J. Pan, Physics-Based Feature Dehazing Networks, in: A. Vedaldi, H. Bischof, T. Brox, J.-M. Frahm (Eds.), Comput. Vis. – ECCV 2020, Springer International Publishing, Cham, 2020: pp. 188–204. <a href="https://doi.org/10.1007/978-3-030-58577-8_12">https://doi.org/10.1007/978-3-030-58577-8_12</a>.</p><p>[28] Z. Chen, Z. He, Z.-M. Lu, DEA-Net: Single image dehazing based on detail-enhanced convolution and content-guided attention, (2023). <a href="http://arxiv.org/abs/2301.04805">http://arxiv.org/abs/2301.04805</a> (accessed March 17, 2023).</p><p>[29] Z. Liu, B. Xiao, M. Alrabeiah, K. Wang, J. Chen, Generic Model-Agnostic Convolutional Neural Network for Single Image Dehazing, (2019). <a href="http://arxiv.org/abs/1810.02862">http://arxiv.org/abs/1810.02862</a> (accessed March 5, 2023).</p><p>[30] Z. Fang, M. Zhao, Z. Yu, M. Li, Y. Yang, A guiding teaching and dual adversarial learning framework for a single image dehazing, Vis. Comput. 38 (2022) 3563–3575. <a href="https://doi.org/10.1007/s00371-021-02184-5">https://doi.org/10.1007/s00371-021-02184-5</a>.</p><p>[31]  </p><p>引用（总共需要接近40篇）</p><p>Introduction引用 可能要接近20篇</p><p>关于雾气的介绍</p><p>[1]   R.T. Tan, Visibility in bad weather from a single image, in, IEEE Conference on Computer Vision and Pattern Recognition 2008 (2008) 1–8</p><p>[2]   E.J. McCartney, Optics of the atmosphere: scattering by molecules and particles, John Wiley and Sons Inc, New York, 1976, p. 421.</p><p>[3]   S.G. Narasimhan, S.K. Nayar, Removing weather effects from monochrome images, in: Proceedings of the 2001 IEEE Computer Society Conference on Computer Vision and Pattern Recognition. CVPR 2001, Vol. 2, 2001, pp. II–II..</p><p>[4]   S.K. Nayar, S.G. Narasimhan, Vision in bad weather, in: Proceedings of the Seventh IEEE International Conference on Computer Vision, Vol. 2, 1999, pp. 820–827 vol 2..</p><p>[5]   S.G. Narasimhan, S.K. Nayar, Contrast restoration of weather degraded images, IEEE Trans. Pattern Anal. Mach. Intell. 25 (6) (2003) 713–724. </p><p>[6]   Y.Y. Schechner, S.G. Narasimhan, S.K. Nayar, Polarization-based vision through haze, Appl. Opt. 42 (3) (2003) 511–525</p><p>过往研究</p><p>[1]   Cai, B., Xu, X., Jia, K., Qing, C., Tao, D.: DehazeNet: an endto-end system for single image haze removal. IEEE Trans. Image Process. 25(11), 5187–5198 (2016)     DehazeNet</p><p>[2]   Li, B., Peng, X., Wang, Z., Xu, J., Feng, D.: AOD-Net: all-in-one dehazing network. In: Proceedings of the 2017 IEEE International Conference on Computer Vision (ICCV), pp. 4780–4788 (2017).                                            AOD-Net</p><p>[3]   Ren, W., Liu, S., et al.: Single image dehazing via multi-scale convolutional neural networks. In: ECCV (2016).                                              MSCNN</p><p>[4]   Yuan, K., Wei, J., Lu, W., Xiong, N.: Single image dehazing via nin-dehazenet. IEEE Access 7, 181348–181356 (2019).                                     nin-dehazenet</p><p>[5]   Fattal, R.: Single image dehazing. ACM Trans. Graph. 27(3), 72 (2008) 10.      fattal</p><p>[6]   Raikwar, S.C., Tapaswi, S.: Tight lower bound on transmission for single image dehazing. Vis. Comput. 36, 191–209 (2020)</p><p>[7]   Zhao, D., Xu, L., Yan, Y., et al.: Multi-scale optimal fusion model for single image dehazing. Signal Process. Image Commun. 74, 253–265 (2019)</p><p>[8]   Salazar-Colores, S., Cabal-Yepez, E., Ramos-Arreguin, J.M., Botella, G., Ledesma-Carrillo, L.M., Ledesma, S.: A fast image dehazing algorithm using morphological reconstruction. IEEE Trans. Image Process. 28(5), 2357–2366 (2019)</p><p>[9]   Z. Li, J. Zheng, Single image de-hazing using globally guided image filtering, IEEE Trans. Image Process. 27 (1) (2018) 442–450.</p><p>[10] Zhu, Y., Tang, G., Zhang, X., et al.: Haze removal method for natural restoration of images with sky. Neurocomputing 275(31), 499–510 (2017)</p><p>[11] Y. Liu, J. Shang, L. Pan, A. Wang, M. Wang, A unified variational model for single image dehazing, IEEE Access 7 (2019) 15722–15736.</p><p>[12] Salazar-Colores, S., Moya-Sánchez, E.U., Ramos-Arreguín, J.M., Cabal-Yépez, E., Flores, G., Cortés, U.: Fast single image defogging with robust sky detection. IEEE Access 8, 149176–149189 (2020)</p><p>[13] J. Wang, K. Lu, J. Xue, N. He, L. Shao, Single image dehazing based on the physical model and msrcr algorithm, IEEE Trans. Circuits Syst. Video Technol. 28 (9) (2018) 2190–2199.</p><p>[14] Raikwar, S.C., Tapaswi, S.: Lower bound on transmission using non-linear bounding function in single image dehazing. IEEE Trans. Image Process. 29, 4832–4847 (2020)</p><p>[15] S. Hong, M. Kim, M.G. Kang, Single image dehazing via atmospheric scattering model-based image fusion, Signal Process. 178 (2021) 107798.</p><p>[16] Ngo, D., Lee, S., Nguyen, Q.H., et al.: Single image haze removal from image enhancement perspective for real-time vision-based systems. Sensors 20(18), 5170–5191 (2020)</p><p>[17] W. Ren, J. Pan, H. Zhang, X. Cao, M.-H. Yang, Single image dehazing via multiscale convolutional neural networks with holistic edges, Int. J. Comput. Vision 128 (1) (2020) 240–259.</p><p>[18] Liu, X., Li, H., Zhu, C.: Joint contrast enhancement and exposure fusion for real-world image dehazing. IEEE Trans. Multimedia (2021).</p><p>[19] Fang, Z., Zhao, M., Yu, Z., et al.: A guiding teaching and dual adversarial learning framework for a single image dehazing. Vis. Comput. (2021).</p><p>[20] Zhao, S., Zhang, L., Shen, Y., Zhou, Y.: RefineDNet: a weakly supervised refinement framework for single image dehazing. IEEE Trans. Image Process. 30, 3391–3404 (2021)</p><p>[21] Chen, Z., Hu, Z., Sheng, B., et al.: Simplified non-locally dense network for single-image dehazing. Vis. Comput. 36, 2189–2200 (2020)</p><p>[22]  </p><p>Preview word。</p><p>对比方法引用</p><p>Psnr</p><p>Ssim</p><p>对比方法的引用</p><p>[1]   Zhu, Q., Mai, J., Shao, L. A fast single image haze removal algorithm using color attenuation prior. IEEE Trans. Image Process. 24 (11), 3522–3533 (2015).                   cap</p><p>[2]   Kaiming, H., Jian, S., Xiaoou, T. Single image haze removal using dark channel prior. In: IEEE Conference on Computer Vision and Pattern Recognition, pp. 1956–1963 (2009)     dcp</p><p>[3]   Berman, D., Treibitz, T., Avidan, S. Non-local image dehazing. In: IEEE Conference on Computer Vision and Pattern Recognition, pp. 1674–1682 (2016) </p><p>[4]   He, K., Sun, J., Tang, X.. Guided image filtering. IEEE Trans. Pattern Anal. Mach. Intell. 35 (6), 1397–1409 (2013).                                            dcpGuide</p><p>[5]   A. B. Petro, C. Sbert, J.-M. Morel, Multiscale Retinex, Image Process. Line, 4 71–88 (2014).  </p><p>[6]   Meng, G., et al.: Efficient image dehazing with boundary constraint and contextual regularization. In: IEEE International Conference on Computer Vision (2013)         bccr</p><p>[7]   D. J. Jobson, Z. Rahman, G. A. Woodell, A multiscale retinex for bridging the gap between color images and the human observation of scenes, IEEE Trans. Image Process. 6 (7) , 965–976 (1997).                                                     amsr</p><p>[8]   Fattal, R.: Single image dehazing. ACM Trans. Graph. 27(3), 72 (2008) 10.      fattal</p><p>[9]   Fattal, R.: Dehazing using color-lines. ACM Trans. Graph. 34(1), 13:1-13:14 (2014) 11. Berman, D., Treibitz.                           fattal</p><p>[10] A. B. Petro, C. Sbert, J.-M. Morel, Multiscale Retinex, Image Process. Line, 4, 71–88, 2014. </p><p>msrcr msrcp</p><p>[11] G. Meng, Y. Wang, J. Duan, S. Xiang, C. Pan, Efficient Image Dehazing with Boundary Constraint and Contextual Regularization, 2013 IEEE International Conference on Computer Vision, Sydney, Australia, 12月 2013, 617–624.               efficient</p><p>[12] Li, B., Peng, X., Wang, Z., Xu, J., Feng, D.: AOD-Net: all-in-one dehazing network. In: Proceedings of the 2017 IEEE International Conference on Computer Vision (ICCV), pp. 4780–4788 (2017).                                       aod</p><p>[13] Z. Liu, B. Xiao, M. Alrabeiah, K. Wang, J. Chen. Generic Model-Agnostic Convolutional Neural Network for Single Image Dehazing, IEEE Transactions on Image Processing, 29 2692-2701, 2020                                              gman</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暗通道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-暗通道去雾算法总结</title>
      <link href="/2022/10/23/%E7%AE%97%E6%B3%95-%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E6%80%BB%E7%BB%93/"/>
      <url>/2022/10/23/%E7%AE%97%E6%B3%95-%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h2><p>何凯明发现，凡是无雾的算法都有一个规律，就是每一幅图像的非天空的区域里的每一个像素的rbg三个通道，一定有一个通道是很低的值。这个也很容易理解，比如大红的玫瑰翠绿的草等等。</p><h2 id="去雾模型"><a href="#去雾模型" class="headerlink" title="去雾模型"></a>去雾模型</h2><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/QQ20221023-132042@2x.png" alt="df"></p><p>i(x) 是现在有的图像，等待去雾，而j(x)是要恢复的无雾图像，A是全球大气光成分，t(x)则是透射率，所以现在有的就是ix，求jx，所以我们还需要去得到tx和A。</p><h2 id="暗通道怎么求"><a href="#暗通道怎么求" class="headerlink" title="暗通道怎么求"></a>暗通道怎么求</h2><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023134357882.png" alt="image-20221023134357882"></p><p>其中c表示rgb三通道中的某一通道。上式表示在一幅输入图像中，先取图像中每一个像素的三通道中的灰度值的最小值，得到一幅灰度图像，再在这幅灰度图像中，以每一个像素为中心取一定大小的矩形窗口，取矩形窗口中灰度值最小值代替中心像素灰度值（最小值滤波），从而得到该雾天图像的暗通道图像。</p><h2 id="如何去估计全局大气光值A？"><a href="#如何去估计全局大气光值A？" class="headerlink" title="如何去估计全局大气光值A？"></a>如何去估计全局大气光值A？</h2><p>估计全局大气光的方法有很多，有的是直接找全局最亮的点，比如天空这种雾气感最强的。</p><p>但是何凯明认为，有可能这样子找的只是白色的物体，而不是雾气最密集的区域。所以何凯明提出一种找大气光的方法：<strong>从观测图像的暗通道</strong>中选取最亮的前 0.1%的点，这些点对应到原图中再去找最亮的点作为 A 的估计。</p><h2 id="如何估计t-x"><a href="#如何估计t-x" class="headerlink" title="如何估计t(x)?"></a>如何估计t(x)?</h2><p>其实还是依赖于暗通道，在有雾气的暗通道里面，非天空区域的亮度值主要就是大气光贡献的，场景本身的暗通道的亮度应该趋于0，所以用暗通道估计雾气的传输率。</p><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023135440803.png" alt="image-20221023135440803"></p><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023135544543.png" alt="image-20221023135544543"></p><p>但是现实生活中，空气中总是有颗粒，所以看远方的物体还是能感受到雾气，所以保留一部分雾气</p><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023135641640.png" alt="image-20221023135641640"></p><h2 id="Soft-Matting"><a href="#Soft-Matting" class="headerlink" title="Soft Matting"></a>Soft Matting</h2><p>利用Soft Matting，优化原有的透射图。</p><p>可见<a href="https://mp.weixin.qq.com/s/pUcuPMaT2bFuT5d0PD4xxQ">走出寂静岭！何恺明经典去雾论文分析</a></p><p>参考文献为2006年CVPR《A closed form solution to natural image matting.》后期何恺明在2010年ECCV上《Guided image filtering》提出了导向滤波的方法。</p><h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><p>上面我们获得了大气光值以及透射率，那么根据雾天退化模型我们就可以获得去雾后的结果图了。一般来说，去雾后的结果图可能会偏暗，因此可以适当进行一些后处理如采用<strong>自动对比度增强，亮度增强，伽马校正</strong> 等图像处理方法进行处理，以便得效果更佳的无雾图像。数字图像处理 |区域生长法之初印象</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暗通道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目-养生打卡健康小程序</title>
      <link href="/2022/10/04/%E9%A1%B9%E7%9B%AE-%E5%85%BB%E7%94%9F%E6%89%93%E5%8D%A1%E5%81%A5%E5%BA%B7%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2022/10/04/%E9%A1%B9%E7%9B%AE-%E5%85%BB%E7%94%9F%E6%89%93%E5%8D%A1%E5%81%A5%E5%BA%B7%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">TOC</a></p><p>非工作室，大学生自敲</p><h1 id="一、展示"><a href="#一、展示" class="headerlink" title="一、展示"></a>一、展示</h1><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p><img src="/../images/%E5%85%BB%E7%94%9F%E6%89%93%E5%8D%A1%E5%81%A5%E5%BA%B7%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227161014349.png" alt="在这里插入图片描述"></p><h2 id="五脏六腑食疗法"><a href="#五脏六腑食疗法" class="headerlink" title="五脏六腑食疗法"></a>五脏六腑食疗法</h2><p>中上是轮播图，左侧栏快速点击，可上下滑动<br><img src="/../images/%E5%85%BB%E7%94%9F%E6%89%93%E5%8D%A1%E5%81%A5%E5%BA%B7%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227161014535.png" alt="在这里插入图片描述"></p><h2 id="四季食谱"><a href="#四季食谱" class="headerlink" title="四季食谱"></a>四季食谱</h2><p>由于云开发欠费，所以图像没了，不过这是小事<br>每个季节的食谱都实现了点赞收藏等功能，与云开发数据库相连接。<br><img src="/../images/%E5%85%BB%E7%94%9F%E6%89%93%E5%8D%A1%E5%81%A5%E5%BA%B7%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227161014402.png" alt="在这里插入图片描述"><br><img src="/../images/%E5%85%BB%E7%94%9F%E6%89%93%E5%8D%A1%E5%81%A5%E5%BA%B7%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227161014375.png" alt="在这里插入图片描述"></p><h2 id="十二时辰养生"><a href="#十二时辰养生" class="headerlink" title="十二时辰养生"></a>十二时辰养生</h2><p>卡片左右滑动，同样中间由于欠费图像无法显示<br><img src="https://img-blog.csdnimg.cn/0d86e47452254a57ad7cc6427eeb7130.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="养生闹钟"><a href="#养生闹钟" class="headerlink" title="养生闹钟"></a>养生闹钟</h2><p><img src="/../images/%E5%85%BB%E7%94%9F%E6%89%93%E5%8D%A1%E5%81%A5%E5%BA%B7%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227161014342.png" alt="在这里插入图片描述"><br>点击新建按钮<br><img src="/../images/%E5%85%BB%E7%94%9F%E6%89%93%E5%8D%A1%E5%81%A5%E5%BA%B7%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227161014378.png" alt="在这里插入图片描述"></p><h2 id="我的收藏"><a href="#我的收藏" class="headerlink" title="我的收藏"></a>我的收藏</h2><p>同样因为欠费，数据库调取不了，所以没显示，本来是有的<br><img src="/../images/%E5%85%BB%E7%94%9F%E6%89%93%E5%8D%A1%E5%81%A5%E5%BA%B7%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227161014512.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>自己动手打的小程序还挺有意思的。</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目-日常打卡积分制自律小程序</title>
      <link href="/2022/10/04/%E9%A1%B9%E7%9B%AE-%E6%89%93%E5%8D%A1%E7%A7%AF%E5%88%86%E5%88%B6%E8%87%AA%E5%BE%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2022/10/04/%E9%A1%B9%E7%9B%AE-%E6%89%93%E5%8D%A1%E7%A7%AF%E5%88%86%E5%88%B6%E8%87%AA%E5%BE%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">TOC</a></p><h1 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h1><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p>挑战积分 和挑战次数，与云开发有关<br><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901669.png" alt="在这里插入图片描述"></p><h2 id="自律广场"><a href="#自律广场" class="headerlink" title="自律广场"></a>自律广场</h2><p>具备点赞和收藏功能，图片可放大查看详情<br>有发布地址<br><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901621.png" alt="在这里插入图片描述"><br><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901854.png" alt="在这里插入图片描述"><br><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="发布功能"><a href="#发布功能" class="headerlink" title="发布功能"></a>发布功能</h2><p><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901529.png" alt="在这里插入图片描述"><br><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901628.png" alt="在这里插入图片描述"></p><h2 id="日常页面"><a href="#日常页面" class="headerlink" title="日常页面"></a>日常页面</h2><p>可发布今日任务，小程序会在该时间段微信通知你打卡<br><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901754.png" alt="在这里插入图片描述"><br><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901624.png" alt="在这里插入图片描述"></p><h2 id="我的页面"><a href="#我的页面" class="headerlink" title="我的页面"></a>我的页面</h2><p><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901602.png" alt="在这里插入图片描述"></p><h3 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h3><p><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901797.png" alt="在这里插入图片描述"></p><h3 id="我的点赞"><a href="#我的点赞" class="headerlink" title="我的点赞"></a>我的点赞</h3><p><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901642.png" alt="在这里插入图片描述"></p><h3 id="我的收藏"><a href="#我的收藏" class="headerlink" title="我的收藏"></a>我的收藏</h3><p><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901757-3664541.png" alt="在这里插入图片描述"></p><h3 id="其余三个功能"><a href="#其余三个功能" class="headerlink" title="其余三个功能"></a>其余三个功能</h3><p>其余三个功能就是清除和反馈功能<br><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901732.png" alt="在这里插入图片描述"><br><img src="/../images/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6IOh5qGD5qKF6Iqx55y8,size_12,color_FFFFFF,t_70,g_se,x_16-20231227160901757.png" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一次做微信小程序，很有意思的经历</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oauth2-认证服务篇</title>
      <link href="/2022/04/01/Oauth2-%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87/"/>
      <url>/2022/04/01/Oauth2-%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Auth认证服务"><a href="#Auth认证服务" class="headerlink" title="Auth认证服务"></a><strong>Auth认证服务</strong></h1><h2 id="1、AuthorizationServerConfig"><a href="#1、AuthorizationServerConfig" class="headerlink" title="1、AuthorizationServerConfig"></a><strong>1、AuthorizationServerConfig</strong></h2><h3 id="【事先准备】："><a href="#【事先准备】：" class="headerlink" title="【事先准备】："></a><strong>【事先准备】：</strong></h3><h4 id="方法、LoadRolePermissionService-调用—-gt-PermissionServiceImpl"><a href="#方法、LoadRolePermissionService-调用—-gt-PermissionServiceImpl" class="headerlink" title="方法、LoadRolePermissionService  调用—&gt; PermissionServiceImpl"></a><strong>方法、LoadRolePermissionService  调用—&gt; PermissionServiceImpl</strong></h4><p><strong>作用：从数据库中将url-&gt;角色对应关系加载到Redis中</strong></p><ul><li>**方法1:listRolePermission **</li><li><ul><li>先从数据库获取permissons</li><li>根据roleid从数据库中找权限数据</li><li>根据permissionid从数据库中找数据</li><li>到此为止，构造了每一个permission对应所需要的权限一共后续使用</li><li>简化一下，放入redis</li></ul></li></ul><h3 id="【1】AuthorizationServerConfig-继承—-gt-AuthorizationServerConfigurerAdapter"><a href="#【1】AuthorizationServerConfig-继承—-gt-AuthorizationServerConfigurerAdapter" class="headerlink" title="【1】AuthorizationServerConfig 继承—&gt; AuthorizationServerConfigurerAdapter"></a><strong>【1】AuthorizationServerConfig 继承—&gt; AuthorizationServerConfigurerAdapter</strong></h3><p><strong>作用：配置认证中心，就是授权服务器配置</strong></p><h4 id="方法1：-configure-ClientDetailsServiceConfigurer-clients"><a href="#方法1：-configure-ClientDetailsServiceConfigurer-clients" class="headerlink" title="方法1： configure(ClientDetailsServiceConfigurer clients)"></a><strong>方法1： configure(ClientDetailsServiceConfigurer clients)</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 配置客户端详情，并不是所有的客户端都能接入授权服务</span><br><span class="line"> * 用来配置客户端详情服务（ClientDetailsService），</span><br><span class="line"> * 客户端详情信息在这里进行初始化，</span><br><span class="line"> * 你能够把客户端详情信息写死在这里或者是通过数据库来存储调取详情信息</span><br><span class="line"> </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h5 id="一、重写configure-ClientDetailsServiceConfigurer-clients-方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的-，"><a href="#一、重写configure-ClientDetailsServiceConfigurer-clients-方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的-，" class="headerlink" title="**一、重写configure(ClientDetailsServiceConfigurer clients)方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的**，"></a>**一、<u>重写configure(ClientDetailsServiceConfigurer clients)方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的</u>**，</h5><ol><li>定义两个client_id，及客户端可以通过不同的client_id来获取不同的令牌；</li><li>client_id为test1的令牌有效时间为3600秒，client_id为test2的令牌有效时间为7200秒；</li><li>client_id为test1的refresh_token（下面会介绍到）有效时间为864000秒，即10天，也就是说在这10天内都可以通过refresh_token来换取新的令牌；</li><li>在获取client_id为test1的令牌的时候，scope只能指定为all，a，b或c中的某个值，否则将获取失败；</li><li>只能通过密码模式(password)来获取client_id为test1的令牌，而test2则无限制。</li></ol><h5 id="二、导入方法有以下几种："><a href="#二、导入方法有以下几种：" class="headerlink" title="二、导入方法有以下几种："></a><strong>二、导入方法有以下几种：</strong></h5><ul><li><strong>内存</strong>，自己测试的时候比较推荐，后续数据库啊什么的</li><li><strong>数据库</strong>，使用JdbcClientDetailsService，JdbcClientDetailsService自己是有一个默认的字段的表的，所以程序是从数据库中的oauth_client_details表中加载客户端信息，</li><li>总而言之，就是配置把客户端信息从数据源拿过来。后面需要授权验证，要用到，所以先配。</li></ul><h4 id="方法2：-configure-AuthorizationServerEndpointsConfigurer-endpoints-——"><a href="#方法2：-configure-AuthorizationServerEndpointsConfigurer-endpoints-——" class="headerlink" title="方法2： configure(AuthorizationServerEndpointsConfigurer endpoints)——"></a><strong>方法2： configure(AuthorizationServerEndpointsConfigurer endpoints)——</strong></h4><p>上面和客户端有关，而这个则直接和令牌有关，比如<u><strong>配置授权（authorization）</strong></u>以及<u><strong>令牌（token）的访问端点</strong></u>和<u><strong>令牌服务(token services)</strong></u>，还有一些其他的，比如异常啊什么的，下面有例子。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 配置令牌访问的端点</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>令牌端点可用于以编程方式请求令牌（非常重要，四种方式）,下面是配置的例子</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">endpoints</span><br><span class="line">        <span class="comment">//设置异常WebResponseExceptionTranslator，用于处理用户名，密码错误、授权类型不正确的异常</span></span><br><span class="line">        .exceptionTranslator(<span class="keyword">new</span> <span class="title class_">OAuthServerWebResponseExceptionTranslator</span>())</span><br><span class="line">        <span class="comment">//授权码模式所需要的authorizationCodeServices</span></span><br><span class="line">        .authorizationCodeServices(authorizationCodeServices())</span><br><span class="line">        <span class="comment">//密码模式所需要的authenticationManager</span></span><br><span class="line">        .authenticationManager(authenticationManager)</span><br><span class="line">        <span class="comment">//令牌管理服务，无论哪种模式都需要</span></span><br><span class="line">        .tokenServices(tokenServices())</span><br><span class="line">        <span class="comment">//添加进入tokenGranter</span></span><br><span class="line">        .tokenGranter(<span class="keyword">new</span> <span class="title class_">CompositeTokenGranter</span>(tokenGranters))</span><br><span class="line">        <span class="comment">//只允许POST提交访问令牌，uri：/oauth/token</span></span><br><span class="line">        .allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br></pre></td></tr></table></figure><h5 id="一、authenticationManager-（建议必须配置）-（密码授权管理器），见文件SecurityConfig这个配置类"><a href="#一、authenticationManager-（建议必须配置）-（密码授权管理器），见文件SecurityConfig这个配置类" class="headerlink" title="一、authenticationManager （建议必须配置）  （密码授权管理器），见文件SecurityConfig这个配置类"></a><strong>一、<u>authenticationManager （建议必须配置）  （密码授权管理器），见文件SecurityConfig这个配置类</u></strong></h5><ul><li>在Spring Security中，AuthenticationManager的默认实现是ProviderManager，而且它不直接自己处理认证请求，而是委托给其所配置的AuthenticationProvider列表，然后会依次使用每一个AuthenticationProvider进行认证，如果有一个AuthenticationProvider认证后的结果不为null，则表示该AuthenticationProvider已经认证成功，之后的AuthenticationProvider将不再继续认证。然后直接以该AuthenticationProvider的认证结果作为ProviderManager的认证结果。如果所有的AuthenticationProvider的认证结果都为null，则表示认证失败，将抛出一个ProviderNotFoundException。<br>校验认证请求最常用的方法是根据请求的用户名加载对应的UserDetails，然后比对UserDetails的密码与认证请求的密码是否一致，一致则表示认证通过。<br>Spring Security内部的DaoAuthenticationProvider就是使用的这种方式。其内部使用UserDetailsService来负责加载UserDetails。在认证成功以后会使用加载的UserDetails来封装要返回的Authentication对象，加载的UserDetails对象是包含用户权限等信息的。认证成功返回的Authentication对象将会保存在当前的SecurityContext中</li></ul><h5 id="二、令牌本身内容的配置（建议必须配置）"><a href="#二、令牌本身内容的配置（建议必须配置）" class="headerlink" title="二、令牌本身内容的配置（建议必须配置）"></a><u><strong>二、令牌本身内容的配置（建议必须配置）</strong></u></h5><h6 id="I、-两种方式，"><a href="#I、-两种方式，" class="headerlink" title="I、 两种方式，"></a><u><strong>I、 两种方式，</strong></u></h6><p>【1】直接在endpoint这里配。</p><p>【2】自己写个bean注入，举个例子：</p><h6 id="II、tokenServices-就在本文件注入-由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里"><a href="#II、tokenServices-就在本文件注入-由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里" class="headerlink" title="II、tokenServices()  就在本文件注入,由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里"></a><strong>II、tokenServices()</strong>  <strong>就在本文件注入,由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里</strong></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public AuthorizationServerTokenServices tokenServices() &#123;</span><br><span class="line">    System.out.println(&quot;令牌管理服务的配置&quot;);</span><br><span class="line">    DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">    //客户端端配置策略</span><br><span class="line">    services.setClientDetailsService(clientDetailsService);</span><br><span class="line">    //支持令牌的刷新</span><br><span class="line">    services.setSupportRefreshToken(true);</span><br><span class="line">    //令牌服务</span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    //access_token的过期时间</span><br><span class="line">    services.setAccessTokenValiditySeconds(60 * 60 * 24 * 3);</span><br><span class="line">    //refresh_token的过期时间</span><br><span class="line">    services.setRefreshTokenValiditySeconds(60 * 60 * 24 * 3);</span><br><span class="line"></span><br><span class="line">    //设置令牌增强，使用JwtAccessTokenConverter进行转换</span><br><span class="line">    services.setTokenEnhancer(jwtAccessTokenConverter);</span><br><span class="line">    return services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt-自定义内容。"><a href="#III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt-自定义内容。" class="headerlink" title="III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt+自定义内容。"></a><strong><u>III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt+自定义内容。</u></strong></h6><ul><li><p>把令牌变成jwt格式很简单，按下面2两步操作即可，反正就是</p><ul><li><p>~~~<br>@Configuration<br>public class JWTokenConfig {</p><pre><code>@Beanpublic TokenStore jwtTokenStore() &#123;    return new JwtTokenStore(jwtAccessTokenConverter());&#125;@Beanpublic JwtAccessTokenConverter jwtAccessTokenConverter() &#123;    JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();    accessTokenConverter.setSigningKey(&quot;test_key&quot;); // 签名密钥    return accessTokenConverter;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* ~~~java</span><br><span class="line">      services.setTokenStore(tokenStore);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>自定义的话，同样简单，按下面的操作来做，无非就是先写一些配置，然后把配置注入adapter</p><ul><li>&#96;&#96;&#96;java<br>@Component<br>public class JwtTokenEnhancer implements TokenEnhancer {<br>@Override<br>public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {<br>    SecurityUser securityUser &#x3D; (SecurityUser) authentication.getPrincipal();<br>    Map&lt;String, Object&gt; info &#x3D; new HashMap&lt;&gt;();<br>    &#x2F;&#x2F;把用户ID设置到JWT中<br>    info.put(“id”, securityUser.getId());<br>    info.put(“client_id”,securityUser.getClientId());<br>    ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);<br>    return accessToken;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * ~~~</span><br><span class="line">    tokenEnhancer(enhancerChain)</span><br><span class="line">    ~~~</span><br><span class="line"></span><br><span class="line">##### **三、tokenGranter(new CompositeTokenGranter(tokenGranters))    自定义授权  非常重要**</span><br><span class="line"></span><br><span class="line">作用：自定义授权获取token，下面我们来看一看源码是怎么获取token的，在我们发起oauth/token，请求获取token时，实际上是请求Tokenpoint类的postAccessToken或者getacesstoken方法，相当于调用了一个controller方法，根据请求的方法是get还是post，但其实内部还是调用post的方法。</span><br><span class="line"></span><br><span class="line">在TokenEndPoint 获取令牌过程中, 有个这样的步骤:</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">OAuth2AccessToken token = getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">postAccessToken这个方法中，在这个方法的132行调用TokenGranter类的grant方法来获取token，**&lt;u&gt;这个方法也是最重要的&lt;/u&gt;**，通过这个方法我们可以对请求的参数进行校验是否合法，是否给予令牌。</span><br><span class="line"></span><br><span class="line">TokenGranter是一个接口，它有多个实现类，CompositeTokenGranter是其中之一，在grant方法中，会循环遍历所有的授权方式，根据请求参数携带的授权方式码，来匹配对应的授权处理实现类，调用实现类中的grant方法。那么关键点来了，请求参数中携带的是我们**&lt;u&gt;自定义的授权方式码&lt;/u&gt;**，如果要匹配上，那么首先我们要创建自定义的授权处理类，然后把这个授权处理类放入Spring Security默认的授权处理集合中，这样才能循环匹配上，进行下一步。</span><br><span class="line"></span><br><span class="line">和以前的做法一样：创建自定义授权处理类，我们可以继承TokenGranter来实现自定义的身份验证以便获取token，而AbstractTokenGranter是一个继承TokenGranter的实现类，一般我们都会继承这个类进行使用。这一点已经得到验证，可以看下面的流程。</span><br><span class="line"></span><br><span class="line">| 实现类                            | 对应的授权模式  |</span><br><span class="line">| --------------------------------- | --------------- |</span><br><span class="line">| AuthorizationCodeTokenGranter     | 授权码模式      |</span><br><span class="line">| ClientCredentialsTokenGranter     | 客户端模式      |</span><br><span class="line">| ImplicitTokenGranter              | implicit 模式   |</span><br><span class="line">| RefreshTokenGranter               | 刷新 token 模式 |</span><br><span class="line">| ResourceOwnerPasswordTokenGranter | 密码模式        |</span><br><span class="line"></span><br><span class="line">**这些类都继承了AbstractTokenGranter** </span><br><span class="line"></span><br><span class="line">**AbstractTokenGranter   调用-------&gt;getAccessToken --------&gt;getOAuth2Authentication**</span><br><span class="line"></span><br><span class="line">**根据 client、tokenRequest 从 OAuth2RequestFactory 中创建一个 OAuth2Request, 进而可得到 OAuth2Authentication (存放着用户的认证信息)。**</span><br><span class="line"></span><br><span class="line">**通过 tokenService 去创建 OAuth2AccessToken (存放着用户的 token信息、过期时间)。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### **I、————所以，这里加入自定的tokenGrant，也就是要自定义自己的授权方法 去 授权 自定义的令牌——————**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自定义至关重要的一点就是修改**getOAuth2Authentication**方法 （主要文件见sms文件夹和即可）</span><br><span class="line"></span><br><span class="line">具体修改不讲，修改的流程就是1、**组装自定义模式的认证信息** 2、**用authenticationManager去调用内部自定义的Provider认证这个认证信息，认证规则自然是写在Provider里面**。可借鉴 https://blog.csdn.net/m0_38031406/article/details/89316342</span><br><span class="line"></span><br><span class="line">###### **II、&lt;u&gt;所以实现方式：继承AbstractTokenGranter + 重写 getOAuth2Authentication方法。&lt;/u&gt;**</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">@Override</span><br><span class="line">protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) &#123;</span><br><span class="line">    Map&lt;String, String&gt; parameters = new LinkedHashMap&lt;&gt;(tokenRequest.getRequestParameters());</span><br><span class="line">    String mobile = parameters.get(&quot;mobile&quot;);</span><br><span class="line">    String password = parameters.get(&quot;password&quot;);</span><br><span class="line">    //将其中的密码移除</span><br><span class="line">    parameters.remove(&quot;password&quot;);</span><br><span class="line">    //自定义的token类</span><br><span class="line">    Authentication userAuth = new MobilePasswordAuthenticationToken(mobile, password);</span><br><span class="line"></span><br><span class="line">    ((AbstractAuthenticationToken) userAuth).setDetails(parameters);</span><br><span class="line">    //调用AuthenticationManager进行认证，内部会根据MobileAuthenticationToken找到对应的Provider进行认证</span><br><span class="line">    userAuth = authenticationManager.authenticate(userAuth);</span><br><span class="line">    if (userAuth == null || !userAuth.isAuthenticated()) &#123;</span><br><span class="line">        throw new InvalidGrantException(&quot;Could not authenticate mobile: &quot; + mobile);</span><br><span class="line">    &#125;</span><br><span class="line">    OAuth2Request storedOAuth2Request = getRequestFactory().createOAuth2Request(client, tokenRequest);</span><br><span class="line">    return new OAuth2Authentication(storedOAuth2Request, userAuth);</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">这里调用了AuthenticationManager认证，后面回调用自定义的XXXXXAuthenticationProvider</span><br><span class="line"></span><br><span class="line">###### **III、注入**</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">.tokenGranter(new CompositeTokenGranter(tokenGranters))</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **四、new OAuthServerWebResponseExceptionTranslator()**  也是自己配置的见文件夹**Exception**</span><br><span class="line"></span><br><span class="line">自定义异常翻译器，针对用户名、密码异常，授权类型不支持的异常进行处理-----**关键是用户**</span><br><span class="line"></span><br><span class="line">##### **五、authorizationCodeServices()就在本文件注入**</span><br><span class="line"></span><br><span class="line">##### **六、待续**。。。。。。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### **方法3： configure(AuthorizationServerSecurityConfigurer security)**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * 配置令牌访问的安全约束（）</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证"><a href="#一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证" class="headerlink" title="一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证"></a><strong>一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 客户端异常处理</span></span><br><span class="line"><span class="comment"> * 自定义的客户端认证的过滤器，根据客户端的id、秘钥进行认证</span></span><br><span class="line"><span class="comment"> * 重写这个过滤器用于自定义异常处理</span></span><br><span class="line"><span class="comment"> * 具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;配置令牌访问的安全约束&quot;</span>);</span><br><span class="line">      <span class="comment">//自定义ClientCredentialsTokenEndpointFilter，用于处理客户端id，密码错误的异常</span></span><br><span class="line">        <span class="type">OAuthServerClientCredentialsTokenEndpointFilter</span> <span class="variable">endpointFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OAuthServerClientCredentialsTokenEndpointFilter</span>(security,authenticationEntryPoint);</span><br><span class="line">        endpointFilter.afterPropertiesSet();</span><br><span class="line">        security.addTokenEndpointAuthenticationFilter(endpointFilter);</span><br><span class="line"></span><br><span class="line">        security</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                <span class="comment">//开启/oauth/token_key验证端口权限访问</span></span><br><span class="line">                .tokenKeyAccess(<span class="string">&quot;permitAll()&quot;</span>)</span><br><span class="line">                <span class="comment">//开启/oauth/check_token验证端口认证权限访问</span></span><br><span class="line">                .checkTokenAccess(<span class="string">&quot;permitAll()&quot;</span>);</span><br><span class="line">                <span class="comment">//一定不要添加allowFormAuthenticationForClients，否则自定义的OAuthServerClientCredentialsTokenEndpointFilter不生效</span></span><br><span class="line"><span class="comment">//                .allowFormAuthenticationForClients();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制"><a href="#I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制" class="headerlink" title="I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制"></a><strong>I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制</strong></h6><p><strong>既然如此，我们就去看自定义的AuthenticationEntryPoint</strong>，这里没改，实际中可以改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OAuthServerAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证失败处理器会调用这个方法返回提示信息</span></span><br><span class="line"><span class="comment">     * TODO 实际开发中可以自己定义，此处直接返回JSON数据：客户端认证失败错误提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ResponseUtils.result(response,<span class="keyword">new</span> <span class="title class_">ResultMsg</span>(ResultCode.CLIENT_AUTHENTICATION_FAILED.getCode(),ResultCode.CLIENT_AUTHENTICATION_FAILED.getMsg(),<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="II、endpointFilter-afterPropertiesSet-认证成功怎么办，认真失败怎么办，这里可以自定义哈哈"><a href="#II、endpointFilter-afterPropertiesSet-认证成功怎么办，认真失败怎么办，这里可以自定义哈哈" class="headerlink" title="II、endpointFilter.afterPropertiesSet(); 认证成功怎么办，认真失败怎么办，这里可以自定义哈哈"></a><strong>II、endpointFilter.afterPropertiesSet();</strong> 认证成功怎么办，认真失败怎么办，这里可以自定义哈哈</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置AuthenticationEntryPoint主要逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;设置AuthenticationEntryPoint主要逻辑&quot;</span>);</span><br><span class="line">    <span class="comment">//TODO 定制认证失败处理器，开发中可以自己修改</span></span><br><span class="line">    setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">            exception = <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(exception.getMessage(), <span class="keyword">new</span> <span class="title class_">BadClientCredentialsException</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//成功处理器，和父类相同，为空即可。</span></span><br><span class="line">    setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="III、security-addTokenEndpointAuthenticationFilter-endpointFilter"><a href="#III、security-addTokenEndpointAuthenticationFilter-endpointFilter" class="headerlink" title="III、security.addTokenEndpointAuthenticationFilter(endpointFilter);"></a><strong>III、security.addTokenEndpointAuthenticationFilter(endpointFilter);</strong></h6><ul><li>注入 自定义相应异常的过滤链</li></ul><h2 id="2、springconfig"><a href="#2、springconfig" class="headerlink" title="2、springconfig"></a><strong>2、springconfig</strong></h2><h3 id="介绍一个比较完整的securityconfig配置"><a href="#介绍一个比较完整的securityconfig配置" class="headerlink" title="介绍一个比较完整的securityconfig配置"></a><strong>介绍一个比较完整的securityconfig配置</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//开启判断用户对某个控制层的方法是否具有访问权限的功能</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//注入自定义的UserDetailService</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsServiceImpl userDetailsServiceImpl;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换默认AuthenticationManager中的UserDetailService，使用数据库用户认证方式登录</span></span><br><span class="line">    <span class="comment">//1. 一旦通过 configure 方法自定义 AuthenticationManager实现 就回将工厂中自动配置AuthenticationManager 进行覆盖</span></span><br><span class="line">    <span class="comment">//2. 一旦通过 configure 方法自定义 AuthenticationManager实现 需要在实现中指定认证数据源对象 UserDetailService 实例</span></span><br><span class="line">    <span class="comment">//3. 一旦通过 configure 方法自定义 AuthenticationManager实现 这种方式创建AuthenticationManager对象工厂内部本地一个 AuthenticationManager 对象 不允许在其他自定义组件中进行注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder builder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        builder.userDetailsService(userDetailsServiceImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BCryptPasswordEncoder相关知识：</span></span><br><span class="line"><span class="comment">     * 用户表的密码通常使用MD5等不可逆算法加密后存储，为防止彩虹表破解更会先使用一个特定的字符串（如域名）加密，然后再使用一个随机的salt（盐值）加密。</span></span><br><span class="line"><span class="comment">     * 特定字符串是程序代码中固定的，salt是每个密码单独随机，一般给用户表加一个字段单独存储，比较麻烦。</span></span><br><span class="line"><span class="comment">     * BCrypt算法将salt随机并混入最终加密后的密码，验证时也无需单独提供之前的salt，从而无需单独处理salt问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将自定义AuthenticationManager在工厂中进行暴露,可以在任何位置注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HttpSecurity配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.cors(withDefaults())</span><br><span class="line">                <span class="comment">// 禁用 CSRF</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 指定的接口直接放行</span></span><br><span class="line">                <span class="comment">// swagger</span></span><br><span class="line">                .antMatchers(SecurityConstants.SWAGGER_WHITELIST).permitAll()</span><br><span class="line">                .antMatchers(SecurityConstants.H2_CONSOLE).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, SecurityConstants.SYSTEM_WHITELIST).permitAll()</span><br><span class="line">                <span class="comment">// 其他的接口都需要认证后才能请求</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//添加自定义Filter</span></span><br><span class="line">                .addFilter(<span class="keyword">new</span> <span class="title class_">JwtAuthorizationFilter</span>(authenticationManager(), stringRedisTemplate))</span><br><span class="line">                <span class="comment">// 不需要session（不创建会话）</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                <span class="comment">// 授权异常处理</span></span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                <span class="comment">// json提示用户没有登录不需要用户跳转到登录页面去</span></span><br><span class="line">                .authenticationEntryPoint(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationEntryPoint</span>())</span><br><span class="line">                <span class="comment">// 权限拦截器，提示用户没有当前权限</span></span><br><span class="line">                .accessDeniedHandler(<span class="keyword">new</span> <span class="title class_">JwtAccessDeniedHandler</span>());</span><br><span class="line">        <span class="comment">// 防止H2 web 页面的Frame 被拦截</span></span><br><span class="line">        http.headers().frameOptions().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cors配置优化</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">        org.springframework.web.cors.<span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        configuration.setAllowedOrigins(singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="comment">// configuration.setAllowedOriginPatterns(singletonList(&quot;*&quot;));</span></span><br><span class="line">        configuration.setAllowedHeaders(singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line">        configuration.setExposedHeaders(singletonList(SecurityConstants.TOKEN_HEADER));</span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">false</span>);</span><br><span class="line">        configuration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-基础阅读</title>
      <link href="/2022/02/13/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E9%98%85%E8%AF%BB/"/>
      <url>/2022/02/13/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>截止2022&#x2F;02&#x2F;13</p><p><strong>（1）Lane departure warning algorithm based on probability statistics of driving habits</strong></p><p><strong>（1）Vehicle routing in urban areas based on the OCW-Dijkstra algorithm</strong></p><p><strong>（1）</strong> <strong>Integration of scanning and image processing algorithms for lane detection based on fuzzy method</strong></p><ul><li><p>数字图像处理 |区域生长法之初印象</p></li><li><p>数字图像处理|区域生长法总结</p></li><li><p>数字图像处理|透视变换法数学原理</p></li><li><p>数字图像处理|透视变换总结</p></li><li><p>基于自适应显着性的图像分割（源码开放）</p></li><li><p>干货|卷积有多少种？一文读懂深度学习中的各种卷积</p></li><li><p>使用OpenCV进行模糊检测（拉普拉斯算子）</p></li><li><p>计算机视觉应用场景与实践</p></li><li><p>关于对自动驾驶传感器的理解</p></li><li><p>“敏捷”适用于汽车软件开发吗？</p></li><li><p>读懂自动驾驶卷积神经网络的数学原理</p></li><li><p>汽车电子电气架构工程师妄语</p></li><li><p>自动驾驶中的9种传感器融合算法</p></li><li><p>图文解析TCP协议</p></li><li><p>LiDAR 从基础入门到数据处理总结归纳</p></li><li><p>关于对自动驾驶传感器的理解</p></li><li><p>详解视觉几何三维重建：稠密重建，曲面重建，点云融合，纹理贴图</p></li><li><p>低成本测距方案：单目深度估计(下)</p></li><li><p>低成本测距方案：单目深度估计(上)</p></li><li><p>超越ReLU！SMU：一种新的激活函数，让CNN性能涨点！</p></li><li><p>NeurIPS 2021 | 英伟达提出Transformer-LS：CV和NLP通吃！</p></li><li><p>开发岗和算法岗有什么区别？</p></li><li><p>自动驾驶之点云与图像融合综述</p></li><li><p>激光雷达和点云处理的四个工作流程</p></li><li><p>视觉传感器：2D感知算法</p></li><li><p>自动驾驶的路线变化：从 L4 无人车到「车路云」的落地</p></li><li><p>自动驾驶传感器创新的困境</p></li><li><p>一文概括机器视觉常用算法以及常用开发库</p></li><li><p>代码实战 | 用LeGO-LOAM实现地面提取</p></li><li><p>代码实战 | 用LeGO-LOAM实现BFS点云聚类和噪点剔除</p></li><li><p>神经网络系列 || 单个感知器</p></li><li><p>马尔科夫蒙特卡洛采样方法分析</p></li><li><p>一文讲清自动驾驶中的时空坐标系</p></li><li><p>如何掌握好图像分割算法？值得你看的技术综述</p></li><li><p>真实的产品案例：实现文档边缘检测</p></li><li><p>10分钟掌握异常检测</p></li><li><p>ICCV 2021 口罩人物身份鉴别全球挑战赛冠军方案分享</p></li><li><p>一文概括机器视觉常用算法以及常用开发库</p></li><li><p>视觉的机制</p></li><li><p>自适应亮度调节的图像增强技术</p></li><li><p>高性能自动驾驶域控制器的关键要素设计</p></li><li><p>深度学习以及卷积基础</p></li><li><p>深度图像检测算法总结与对比</p></li><li><p>目标检测之Corner Net</p></li><li><p>目标检测之Center Net（可用于CPU，triplet point）</p></li><li><p>CaDDN：基于单目的3D目标检测新方法</p></li><li><p>用于小目标检测的一个简单高效的网络</p></li><li><p>OpenCV实现失焦模糊图像恢复</p></li><li><p>综述：如何给模型加入先验知识</p></li><li><p>大数据与AI时代</p></li><li><p>Waymo自动驾驶解读</p></li><li><p>基于OpenCV提取特定区域方法汇总</p></li><li><p>关于对汽车ECU软件测试的理解</p></li><li><p>图像算法原理与实践——图像复原之噪声模型</p></li><li><p>神经网络其实和人一样懒惰，喜欢走捷径……</p></li><li><p>AI技术改善农业的十种路径，未来可期！</p></li><li><p>面部识别算法是如何工作的？</p></li><li><p>决策树、随机森林、bagging、boosting、Adaboost、GBDT、XGBoost总结（一）</p></li><li><p>自动驾驶的困境与选择</p></li><li><p>用于提高车牌识别的单幅噪声图像去噪和校正</p></li><li><p>使用OpenCV实现图像覆盖</p></li><li><p>基于OpenCV的实时停车地点查找</p></li><li><p>小白也能看懂的Matplotlib简明教程（一）</p></li><li><p>基于 OpenCV 和 OpenPose 的棒球挥杆人体姿势估计</p></li><li><p>使用OpenCV进行颜色分割</p></li><li><p>软件正在吞噬汽车，传统汽车业面临淘汰？</p></li><li><p>突破网络和屏幕的限制，超分算法让图片和视频秒变清晰</p></li><li><p>如何选择最优的图像尺寸来训练卷积神经网络？（附代码）</p></li><li><p>实例分割研究综述总结</p></li><li><p>机器视觉需要掌握哪些知识？</p></li><li><p>差分卷积在计算机视觉中的应用</p></li><li><p>深度估计相关原理（计算机视觉和深度学习基础）</p></li><li><p>深入理解KNN扩展到ANN</p></li><li><p>YOLOv5瓷砖表面瑕疵质检</p></li><li><p>轻松学Pytorch-使用STN网络实现旋转对象检测</p></li><li><p>舍弃谱归一化，这篇ICCV’21论文用梯度归一化训练GAN，效果极好</p></li><li><p>字节跳动大佬的Python自学笔记.pdf</p></li><li><p>基于Python使用OpenCV进行车牌检测</p></li><li><p>机器学习算法常用指标总结</p></li><li><p>在智能家庭用OpenCV实现人员检测</p></li><li><p>基于opencv的图像融合</p></li><li><p>基于opencv的显著图绘制</p></li><li><p>基于opencv的图像镜像和翻转</p></li><li><p>基于opencv的二维码分割</p></li><li><p>基于Opencv的图像颜色分析（源码）</p></li><li><p>如何从零开始构建深度学习项目？这里有一份详细的教程</p></li><li><p>一个像素的旅程：CNN可视化项目</p></li><li><p>实用 ：一文带你零基础入行深度学习</p></li><li><p>机器视觉外观瑕疵检测基础</p></li><li><p>如何使用 OpenCV Python 检测颜色</p></li><li><p>计算机视觉方法概述</p></li><li><p>图像滤波常用算法实现及原理解析</p></li><li><p>计算机视觉：你必须了解的图像数据底层技术</p></li><li><p>收藏 | CNN网络结构发展最全整理</p></li><li><p>卷积神经网络（CNN）数学原理解析</p></li><li><p>使用Python+OpenCV探索鲸鱼识别</p></li><li><p>pytorch学习 | 提取参数及自定义初始化</p></li><li><p>计算机视觉中的传统特征提取方法总结</p></li><li><p>使用OpenCV进行图像全景拼接</p></li><li><p>主成分分析（PCA）：通过图像可视化深入理解</p></li><li><p>干货 | 浅谈 Softmax 函数</p></li><li><p>超像素、语义分割、实例分割、全景分割 傻傻分不清？</p></li><li><p>目标检测：Anchor-Free时代</p></li><li><p>推荐5最佳免费图像注释工具</p></li><li><p>计算机视觉新手指南</p></li><li><p>建议收藏】16个OpenCV函数开始你的计算机视觉之旅</p></li><li><p>汽车有必要装3D360环视吗？</p></li><li><p>3D360发展趋势</p></li><li><p>十年磨砺，扬帆起航</p></li><li><p>汽车盲区解决方案分析</p></li><li><p>汽车盲区测试及事故危害</p></li><li><p>层次聚类算法原理总结</p></li><li><p>使用OpenCV实现图像增强</p></li><li><p>基于opencv的路面质量检测</p></li><li><p>gPTP，自动驾驶时间同步里的“有趣灵魂”</p></li><li><p>一文详解激光雷达</p></li><li><p>CANXL和CANFD数据链路层的主要区别</p></li><li><p>CMS影像清晰度</p></li><li><p>CMS摄像机成像质量评价指标</p></li><li><p>CMS摄像机安装导致的影像变形</p></li><li><p>CMS 控制器</p></li><li><p>显示器系列</p></li><li><p>自动驾驶的控制过程还需要解决哪些规控问题</p></li><li><p>从功能安全视角看软件架构设计</p></li><li><p>基于Python的OpenCV轮廓检测聚类</p></li><li><p>基于python和OpenCV构建智能停车系统</p></li><li><p>OpenCV二值分析中的角度计算与旋转技巧</p></li><li><p>HOG+SVM实现图像识别</p></li><li><p>论文：「小样本深度学习图像识别」最新2022综述</p></li><li><p>最先进的图像分类算法：FixEfficientNet-L2</p></li><li><p>关于双目立体视觉的三大基本算法及发展现状的总结</p></li><li><p>使用计算机视觉算法检测钢板中的焊接缺陷</p></li><li><p>机器视觉算法之光学字符识别（OCR）</p></li><li><p>公交行驶场景与安全痛点分析</p></li><li><p>房车盲区分析</p></li><li><p>公交、卡车、房车、乘用车cms方案</p></li><li><p>激光雷达与相机—哪种更适合自动驾驶？</p></li><li><p>自动驾驶的视觉感知包括哪些内容？</p></li><li><p>AI图像识别遇上对抗性图像竟变“瞎子”</p></li><li><p>OpenCV的实用图像处理操作案例分享</p></li><li><p>Python高级特性：切片、迭代、列表生成式、生成器与迭代器</p></li><li><p>基于opencv的图像阴影去除</p></li><li><p>自动驾驶算法技术分析与后续发展的思考</p></li><li><p>谈谈对汽车OTA的理解</p></li><li><p>100个盲区，1000种解决方案，牛逼的智目云视！</p></li><li><p>商用车专业电子后视镜</p></li><li><p>CMS核心之一、光学影像</p></li><li><p>自动驾驶中的多传感器融合感知技术</p></li><li><p>3D相机及应用</p></li><li><p>自动驾驶的深度多模态目标检测和语义分割</p></li><li><p>汇总 | 深度学习中图像语义分割基准数据集详解</p></li><li><p>轻量化模型系列–GhostNet：廉价操作生成更多特征</p></li><li><p>机器视觉尺寸检测基础</p></li><li><p>从自动驾驶事故中探索有效的性能提升及判责策略</p></li><li><p>上汽零束SOA电子电器架构</p></li><li><p>自动驾驶多目视觉感知</p></li><li><p>各种编程语言的优缺点</p></li><li><p>深度学习再登Science：万物皆可做神经网络处理器，你甚至可以用锅碗瓢盆</p></li><li><p>一文读懂机器学习：基本概念、五大流派与九种常见算法</p></li><li><p>十分钟理解Transformer</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
