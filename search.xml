<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>springboot整合elasticsearch8.2.0</title>
      <link href="/2022/10/04/springboot%E6%95%B4%E5%90%88elasticsearch8-2-0/"/>
      <url>/2022/10/04/springboot%E6%95%B4%E5%90%88elasticsearch8-2-0/</url>
      
        <content type="html"><![CDATA[<h1 id="java-整合elasticsearch8-2-0"><a href="#java-整合elasticsearch8-2-0" class="headerlink" title="java 整合elasticsearch8.2.0"></a>java 整合elasticsearch8.2.0</h1><p>[TOC]</p><h3 id="一、application-yml或者其他的配置文件皆可"><a href="#一、application-yml或者其他的配置文件皆可" class="headerlink" title="一、application.yml或者其他的配置文件皆可"></a>一、application.yml或者其他的配置文件皆可</h3><p>两种方式：【1】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elasticsearch:</span><br><span class="line">  hosts: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>     # 如果有多个IP就自己加逗号吧</span><br></pre></td></tr></table></figure><p>【2】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring：</span><br><span class="line">elasticsearch:</span><br><span class="line">    uris: localhost:<span class="number">9200</span>   #这样子自动配置了</span><br></pre></td></tr></table></figure><h3 id="二、config类"><a href="#二、config类" class="headerlink" title="二、config类"></a>二、config类</h3><p>不同的版本会有不同的config类要求，这里只提供es8.2.0的，对应着上面两种application文件，此处也提供两种对应的config类，至于之后和springboot整合就不会出现分类了。</p><h5 id="【1】自定义属性"><a href="#【1】自定义属性" class="headerlink" title="【1】自定义属性"></a>【1】自定义属性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Caosen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/22 10:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EsUtilConfigClint2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;elasticsearch.hosts&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String hosts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpHost[] getHttpHost()&#123;</span><br><span class="line">        <span class="keyword">if</span> (hosts.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(hosts);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] hosts_array = hosts.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">//用string类型创建host的集合</span></span><br><span class="line"></span><br><span class="line">        HttpHost[] httpHosts = <span class="keyword">new</span> <span class="title class_">HttpHost</span>[hosts_array.length];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : hosts_array) &#123;</span><br><span class="line">            <span class="comment">//这里解析端口</span></span><br><span class="line">            String[] hosts_array_in = s.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="comment">//到这里就有了id和端口两个东西</span></span><br><span class="line">            <span class="type">HttpHost</span> <span class="variable">http</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHost</span>(hosts_array_in[<span class="number">0</span>], Integer.parseInt(hosts_array_in[<span class="number">1</span>]), <span class="string">&quot;http&quot;</span>);</span><br><span class="line">            httpHosts[i++] = http;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;目前的配置加入了&quot;</span> + i + <span class="string">&quot;个id及其端口&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> httpHosts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ElasticsearchClient <span class="title function_">configClint</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// Create the low-level client</span></span><br><span class="line">        HttpHost[] httpHosts = getHttpHost();</span><br><span class="line">        <span class="type">RestClient</span> <span class="variable">restClient</span> <span class="operator">=</span> RestClient.builder(httpHosts).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the transport with a Jackson mapper</span></span><br><span class="line">        <span class="type">ElasticsearchTransport</span> <span class="variable">transport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestClientTransport</span>(</span><br><span class="line">                restClient, <span class="keyword">new</span> <span class="title class_">JacksonJsonpMapper</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端</span></span><br><span class="line">        <span class="type">ElasticsearchClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElasticsearchClient</span>(transport);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="【2】使用自带的属性"><a href="#【2】使用自带的属性" class="headerlink" title="【2】使用自带的属性"></a>【2】使用自带的属性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Caosen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/18 15:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EsUtilConfigClint</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ElasticsearchClient <span class="title function_">configClint</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// Create the low-level client</span></span><br><span class="line">        <span class="type">RestClient</span> <span class="variable">restClient</span> <span class="operator">=</span> RestClient.builder(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9200</span>)).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the transport with a Jackson mapper</span></span><br><span class="line">        <span class="type">ElasticsearchTransport</span> <span class="variable">transport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestClientTransport</span>(</span><br><span class="line">                restClient, <span class="keyword">new</span> <span class="title class_">JacksonJsonpMapper</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端</span></span><br><span class="line">        <span class="type">ElasticsearchClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElasticsearchClient</span>(transport);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h3><h5 id="【1】service接口"><a href="#【1】service接口" class="headerlink" title="【1】service接口"></a>【1】service接口</h5><p>由于作者是直接在项目里面加内容的，可能会出现一些不相关的东西，我尽量截取相关代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 从数据库中导入所有商品到ES</span><br><span class="line">     */</span><br><span class="line">    int importAll();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新建指定名称的索引</span><br><span class="line">     * @param name</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    void addIndex(String name) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 检查指定名称的索引是否存在</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    boolean indexExists(String name) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除指定索引</span><br><span class="line">     * @param name</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    void delIndex(String name) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建索引，指定setting和mapping</span><br><span class="line">     * @param name 索引名称</span><br><span class="line">     * @param settingFn 索引参数</span><br><span class="line">     * @param mappingFn 索引结构</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    void create(String name,</span><br><span class="line">                Function&lt;IndexSettings.Builder, ObjectBuilder&lt;IndexSettings&gt;&gt; settingFn,</span><br><span class="line">                Function&lt;TypeMapping.Builder, ObjectBuilder&lt;TypeMapping&gt;&gt; mappingFn) throws IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="【2】serviceImpl，主要看create-，add，exsits-delete"><a href="#【2】serviceImpl，主要看create-，add，exsits-delete" class="headerlink" title="【2】serviceImpl，主要看create ，add，exsits, delete"></a>【2】serviceImpl，主要看create ，add，exsits, delete</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    private EsProductDao esProductDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductRepository esProductRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ElasticsearchClient elasticsearchClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int importAll() &#123;</span><br><span class="line">        List&lt;EsProduct&gt; allEsProductList = esProductDao.getAllEsProductList(null);</span><br><span class="line">        Iterable&lt;EsProduct&gt; esProducts = esProductRepository.saveAll(allEsProductList);</span><br><span class="line">        Iterator&lt;EsProduct&gt; iterator = esProducts.iterator();</span><br><span class="line">        int result = 0;</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addIndex(String name) throws IOException &#123;</span><br><span class="line">        elasticsearchClient.indices().create(b -&gt; b.index(name));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean indexExists(String name) throws IOException &#123;</span><br><span class="line">        return elasticsearchClient.indices().exists(b -&gt; b.index(name)).value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delIndex(String name) throws IOException &#123;</span><br><span class="line">        elasticsearchClient.indices().delete(b -&gt; b.index(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void create(String name, Function&lt;IndexSettings.Builder, ObjectBuilder&lt;IndexSettings&gt;&gt; setting, Function&lt;TypeMapping.Builder, ObjectBuilder&lt;TypeMapping&gt;&gt; mapping) throws IOException &#123;</span><br><span class="line">        elasticsearchClient.indices()</span><br><span class="line">                .create(b -&gt; b</span><br><span class="line">                        .index(name)</span><br><span class="line">                        .settings(setting)</span><br><span class="line">                        .mappings(mapping));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="【3】测试"><a href="#【3】测试" class="headerlink" title="【3】测试"></a>【3】测试</h5><p>测试可以用controller 或者 用test伪装controller，自己测试的时候还是用postman接口比较合适。这里测试两种创建index，一种简单，一种稍微复杂，结果都是通过，见图。其他的删除啊，导入数据库的数据（repository）都是可以查到的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    void addIndexSimple() throws IOException &#123;</span><br><span class="line">        String s = &quot;simple&quot;;</span><br><span class="line"></span><br><span class="line">        esProductService.addIndex(s);</span><br><span class="line">        System.out.println(&quot;创建success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    void addIndexComplicated() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        String s = &quot;complicated&quot;;</span><br><span class="line">        Function&lt;IndexSettings.Builder, ObjectBuilder&lt;IndexSettings&gt;&gt; setting = builder -&gt; builder</span><br><span class="line">                .index(i -&gt; i.numberOfShards(&quot;3&quot;).numberOfReplicas(&quot;1&quot;));</span><br><span class="line">        Property keywordproperty = Property.of(p -&gt; p.keyword(k -&gt; k.ignoreAbove(256)));</span><br><span class="line">        Property testproperty = Property.of(p -&gt; p.text(builder -&gt; builder));</span><br><span class="line">        Property integerproperty = Property.of(builder -&gt; builder.integer(i -&gt; i));</span><br><span class="line"></span><br><span class="line">        Function&lt;TypeMapping.Builder, ObjectBuilder&lt;TypeMapping&gt;&gt; mapping = builder -&gt; builder</span><br><span class="line">                .properties(&quot;name&quot;, keywordproperty)</span><br><span class="line">                .properties(&quot;description&quot;, testproperty)</span><br><span class="line">                .properties(&quot;price&quot;, integerproperty);</span><br><span class="line">        esProductService.create(s, setting, mapping);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220922113434674.png" alt="image-20220922113434674"></p>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合kafka3.1-基本配置和操作</title>
      <link href="/2022/10/04/springboot%E6%95%B4%E5%90%88kafka3-1-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/10/04/springboot%E6%95%B4%E5%90%88kafka3-1-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>这篇是单机的zookeeper形式，适用于入门。等有时间会更新kraft搭建。</p><p>博主自己装了双系统，虚拟机刚刚删了，所以没去做集群，不过当大家的kafka版本来到3.1，建议大家去学习KRaft集群搭建而不是去整合zookeeper。下面介绍一下怎么整合，正所谓举一反三，这个会了，到时候换个环境就ok，讲的不好的地方还请见谅。</p><p>[toc]</p><h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><h3 id="1、springboot"><a href="#1、springboot" class="headerlink" title="1、springboot"></a>1、springboot</h3><p>博主自己用的是2.7版本的</p><p>一般关于springboot我会引入一下依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2、kafka"><a href="#2、kafka" class="headerlink" title="2、kafka"></a>2、kafka</h3><h4 id="1、kafka下载"><a href="#1、kafka下载" class="headerlink" title="1、kafka下载"></a>1、kafka下载</h4><p><a href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a>  这里下载，这里再提一句，建议直接放到d盘e盘一级子目录里面，否则有可能出现启动的时候名字太长的问题</p><p>下载之后修改配置文件server.properties</p><p>log.dirs&#x3D;E:\kafka_2.13-3.2.3\kafka-logs</p><h4 id="2、项目引入依赖"><a href="#2、项目引入依赖" class="headerlink" title="2、项目引入依赖"></a>2、项目引入依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;根据自己的版本选择&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里提一句：不一样的springboot对应的kafka依赖版本也不一样，所以先去官网查看依赖版本。</p><p><a href="https://spring.io/projects/spring-kafka">https://spring.io/projects/spring-kafka</a>   点这个链接去找对应的，别自己乱下最新的。</p><h5 id="新版本的kafka命令和老版本的不一样。"><a href="#新版本的kafka命令和老版本的不一样。" class="headerlink" title="新版本的kafka命令和老版本的不一样。"></a>新版本的kafka命令和老版本的不一样。</h5><p>试着启动，命令看你在哪个文件夹，如果是kafka，用下面的，如果是linux，把bat换成sh</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-server-start.bat config\server.properties</span><br></pre></td></tr></table></figure><p>简单使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test（自己取）</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure><h3 id="3、zookeeper"><a href="#3、zookeeper" class="headerlink" title="3、zookeeper"></a>3、zookeeper</h3><p>新版本的kafka其实自己集成了zookeeper，博主这里同样介绍两种方式，一种自己重新去下个zookeeper，一种用kafka自带的。</p><h4 id="1、自带的"><a href="#1、自带的" class="headerlink" title="1、自带的"></a>1、自带的</h4><p>修改配置zookeeper.properties</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataDir=/opt/kafka/zookeeper/data/dataDir</span><br><span class="line">dataLogDir=/opt/kafka/zookeeper/data/dataLogDir</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line"># disable the per-ip limit on the number of connections since <span class="built_in">this</span> is a non-production config</span><br><span class="line">maxClientCnxns=<span class="number">100</span></span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line">initLimit=<span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br></pre></td></tr></table></figure><h4 id="2、自己下载zookeeper"><a href="#2、自己下载zookeeper" class="headerlink" title="2、自己下载zookeeper"></a>2、自己下载zookeeper</h4><p>由于是自己下载所以也不用去配置kafka文件中的zookeeper.properties</p><p><a href="https://zookeeper.apache.org/releases.html#download">https://zookeeper.apache.org/releases.html#download</a>  这是下载地址</p><p>进去之后很简单，一样改配置，进入conf目录下，将<code>zoo_example.cfg</code>重命名为<code>zoo.cfg</code></p><p>同样修改dataDir和log， 我的是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">example sakes.</span><br><span class="line"></span><br><span class="line">dataDir=E:\\java-configuration\\apache-zookeeper-<span class="number">3.7</span><span class="number">.1</span>-bin\\data</span><br><span class="line"></span><br><span class="line">存放事务日志目录</span><br><span class="line"></span><br><span class="line">dataLogDir=E:\\java-configuration\\apache-zookeeper-<span class="number">3.7</span><span class="number">.1</span>-bin\\logs</span><br></pre></td></tr></table></figure><p>然后运行zkserver.cmd和zkcli.cmd, 一个是启动我们的zookeeper服务器，一个是客户端。</p><h2 id="springboot整合操作kafka"><a href="#springboot整合操作kafka" class="headerlink" title="springboot整合操作kafka"></a>springboot整合操作kafka</h2><p><img src="C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220924153503966.png" alt="image-20220924153503966"></p><p>这里用一张图作为流程讲解如何整合。</p><h3 id="1、config"><a href="#1、config" class="headerlink" title="1、config"></a>1、config</h3><p>其实可以把下面的conponent exception filter什么的都丢进来，可以配一些生产者消费者的信息，想配什么都可以，这个就不展示了。</p><h3 id="2、回调（conponent）"><a href="#2、回调（conponent）" class="headerlink" title="2、回调（conponent）"></a>2、回调（conponent）</h3><p>回调有多种写法，这里介绍三种</p><h4 id="1、较为泛用的"><a href="#1、较为泛用的" class="headerlink" title="1、较为泛用的"></a>1、较为泛用的</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class KafkaSendResultHandler implements ProducerListener &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSuccess(ProducerRecord producerRecord, RecordMetadata recordMetadata) &#123;</span><br><span class="line">        System.out.println(&quot;Message send success : &quot; + producerRecord.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(ProducerRecord producerRecord, RecordMetadata recordMetadata, Exception exception) &#123;</span><br><span class="line">        System.out.println(&quot;Message send error : &quot; + producerRecord.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在生产者里面使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private KafkaSendResultHandler kafkaSendResultHandler;</span><br><span class="line"></span><br><span class="line">。。。。。省略</span><br><span class="line"></span><br><span class="line">kafkaTemplate.setProducerListener(kafkaSendResultHandler);    </span><br></pre></td></tr></table></figure><h4 id="2、一个方法对应一个特定的回调"><a href="#2、一个方法对应一个特定的回调" class="headerlink" title="2、一个方法对应一个特定的回调"></a>2、一个方法对应一个特定的回调</h4><h5 id="1、第一种写法"><a href="#1、第一种写法" class="headerlink" title="1、第一种写法"></a>1、第一种写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(<span class="string">&quot;topic1&quot;</span>, callbackMessage).addCallback(success -&gt;&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> success.getRecordMetadata().topic();</span><br><span class="line">    <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> success.getRecordMetadata().partition();</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> success.getRecordMetadata().offset();</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息成功:&quot;</span> + topic + <span class="string">&quot;-&quot;</span> + partition + <span class="string">&quot;-&quot;</span> + offset);</span><br><span class="line"></span><br><span class="line">&#125;, failure -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息失败:&quot;</span> + failure.getMessage());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="2、第二种写法"><a href="#2、第二种写法" class="headerlink" title="2、第二种写法"></a>2、第二种写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(<span class="string">&quot;topic1&quot;</span>, callbackMessage).addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;SendResult&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息失败：&quot;</span>+ex.getMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult&lt;String, Object&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：&quot;</span> + result.getRecordMetadata().topic() + <span class="string">&quot;-&quot;</span></span><br><span class="line">                + result.getRecordMetadata().partition() + <span class="string">&quot;-&quot;</span> + result.getRecordMetadata().offset());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3、consumer-消费者"><a href="#3、consumer-消费者" class="headerlink" title="3、consumer(消费者)"></a>3、consumer(消费者)</h3><p>使用KafkaListener，指定消息类型（必选）和groupid，partitions offset（可选）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, groupId = &quot;felix-group0&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage1(ConsumerRecord&lt;?,?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;简单消费：&quot; + record.topic() + &quot;--&quot; + record.partition() + &quot;--&quot; + record.value());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@KafkaListener(id = &quot;comsumer1&quot;, groupId = &quot;felix-group1&quot;, topicPartitions = &#123;</span><br><span class="line">        @TopicPartition(topic = &quot;topic1&quot;, partitions = &#123;&quot;0&quot;&#125;),</span><br><span class="line">        @TopicPartition(topic = &quot;topic2&quot;, partitionOffsets = @PartitionOffset(partition = &quot;0&quot;, initialOffset = &quot;8&quot;))</span><br><span class="line">&#125; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage2(ConsumerRecord&lt;?, ?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;topic:&quot;+record.topic()+&quot;|partition:&quot;+record.partition()+&quot;|offset:&quot;+record.offset()+&quot;|value:&quot;+record.value());</span><br><span class="line">&#125;</span><br><span class="line">@KafkaListener(id = &quot;consumer2&quot;,groupId = &quot;felix-group2&quot;, topics = &quot;topic1&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage3(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records) &#123;</span><br><span class="line">    System.out.println(&quot;&gt;&gt;&gt;批量消费一次，records.size()=&quot;+records.size());</span><br><span class="line">    for (ConsumerRecord&lt;?, ?&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、controller生产者（produces）"><a href="#4、controller生产者（produces）" class="headerlink" title="4、controller生产者（produces）"></a>4、controller生产者（produces）</h3><h4 id="1、同步发送"><a href="#1、同步发送" class="headerlink" title="1、同步发送"></a>1、同步发送</h4><p>如果需要使用同步发送，可以在每次发送之后使用get方法，因为producer.send方法返回一个Future类型的结果，Future的get方法会一直阻塞直到该线程的任务得到返回值，也就是broker返回发送成功。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(&quot;test&quot;, message).get();</span><br></pre></td></tr></table></figure><h4 id="2、异步发送"><a href="#2、异步发送" class="headerlink" title="2、异步发送"></a>2、异步发送</h4><p>可以从返回的future对象中稍后获取发送的结果，ProducerRecord、RecordMetadata包含了返回的结果信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(&quot;test&quot;, message);</span><br></pre></td></tr></table></figure><h4 id="3-使用ack机制实现可靠"><a href="#3-使用ack机制实现可靠" class="headerlink" title="3. 使用ack机制实现可靠"></a>3. 使用ack机制实现可靠</h4><p>producers可以一步的并行向kafka发送消息，但是通常producer在发送完消息之后会得到一个响应，返回的是offset值或者发送过程中遇到的错误。这其中有个非常重要的参数“request.required.acks”，这个参数决定了producer要求leader partition收到确认的副本个数：</p><ul><li>如果acks设置为0，表示producer不会等待broker的相应，所以，producer无法知道消息是否发生成功，这样有可能导致数据丢失，但同时，acks值为0会得到最大的系统吞吐量。</li><li>若acks设置为1，表示producer会在leader partition收到消息时得到broker的一个确认，这样会有更好的可靠性，因为客户端会等待知道broker确认收到消息。</li><li>若设置为-1，producer会在所有备份的partition收到消息时得到broker的确认，这个设置可以得到最高的可靠性保证。</li></ul><h3 id="5、exception"><a href="#5、exception" class="headerlink" title="5、exception"></a>5、exception</h3><p>bean注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ConsumerAwareListenerErrorHandler consumerAwareErrorHandler() &#123;</span><br><span class="line">    return (message, exception, consumer) -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;消费异常：&quot;+message.getPayload());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费异常配置注解实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, groupId = &quot;felix-group0&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage1(ConsumerRecord&lt;?,?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;简单消费：&quot; + record.topic() + &quot;--&quot; + record.partition() + &quot;--&quot; + record.value());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、filter"><a href="#6、filter" class="headerlink" title="6、filter"></a>6、filter</h3><p>bean注入factory的时候配置好消息过滤策略</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置消息过滤策略</span><br><span class="line">    @Bean(value = &quot;filterContainerFactory&quot;)</span><br><span class="line">    public ConcurrentKafkaListenerContainerFactory concurrentKafkaListenerContainerFactory() &#123;</span><br><span class="line">        ConcurrentKafkaListenerContainerFactory factory = new ConcurrentKafkaListenerContainerFactory();</span><br><span class="line">        factory.setConsumerFactory(consumerFactory);</span><br><span class="line">        // 被过滤的消息将被丢弃</span><br><span class="line">        factory.setAckDiscarded(true);</span><br><span class="line">        // 消息过滤策略</span><br><span class="line">        factory.setRecordFilterStrategy(consumerRecord -&gt; &#123;</span><br><span class="line">            if (Integer.parseInt(consumerRecord.value().toString()) % 2 == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return factory;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>消费异常配置注解实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息过滤监听</span><br><span class="line">    @KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, containerFactory = &quot;filterContainerFactory&quot;)</span><br><span class="line">    public void onMessage6(ConsumerRecord&lt;?, ?&gt; record) &#123;</span><br><span class="line">        System.out.println(record.value());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="7、序列化编码解码"><a href="#7、序列化编码解码" class="headerlink" title="7、序列化编码解码"></a>7、序列化编码解码</h3><p>序列化器都实现了接口（<code>org.apache.kafka.common.serialization.Serializer</code>）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Serializer&lt;T&gt; extends Closeable &#123;</span><br><span class="line">default void configure(Map&lt;String, ?&gt; configs, Boolean isKey) &#123;</span><br><span class="line">&#125;</span><br><span class="line">byte[] serialize(String var1, T var2);</span><br><span class="line">default byte[] serialize(String topic, Headers headers, T data) &#123;</span><br><span class="line">return this.serialize(topic, data);</span><br><span class="line">&#125;</span><br><span class="line">default void close() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以我们只用去实现serialize即可</p><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><pre><code>public class MySerializer implements Serializer &#123;    @Override    public byte[] serialize(String s, Object o) &#123;        String json = JSON.toJSONString(o);        return json.getBytes();&#125;&#125;</code></pre><h4 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyDeserializer implements Deserializer &#123;</span><br><span class="line">    private final static Logger logger = LoggerFactory.getLogger(MyDeserializer.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object deserialize(String s, byte[] bytes) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String json = new String(bytes,&quot;utf-8&quot;);</span><br><span class="line">            return JSON.parse(json);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后在application中配置key-serializer 和 value-serializer</p><h3 id="8、分区策略"><a href="#8、分区策略" class="headerlink" title="8、分区策略"></a>8、分区策略</h3><p>分区策略一般分为四种情况：</p><ul><li>有分区号，直接将数据发送到指定的分区里面去</li><li>没有分区号，但是给了数据的key值，根据key取hashCode进行分区</li><li>分区号和key值都没有，直接使用默认的轮循分区</li><li>自定义分区</li></ul><h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试</span><br><span class="line">        kafkaTemplate.send(&quot;test&quot;, 0, key, &quot;key=&quot; + key + &quot;，msg=指定0号分区&quot;);</span><br><span class="line">        kafkaTemplate.send(&quot;test&quot;, key, &quot;key=&quot; + key + &quot;，msg=不指定分区&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line"><span class="comment">//        定义自己的分区策略</span></span><br><span class="line"><span class="comment">//                如果key以0开头，发到0号分区</span></span><br><span class="line"><span class="comment">//                其他都扔到1号分区</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyStr</span> <span class="operator">=</span> key+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (keyStr.startsWith(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitionTemplate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.kafka.bootstrap-servers&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKafkaTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);</span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        <span class="comment">//注意分区器在这里！！！</span></span><br><span class="line">        props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, MyPartitioner.class);</span><br><span class="line">        <span class="built_in">this</span>.kafkaTemplate = <span class="keyword">new</span> <span class="title class_">KafkaTemplate</span>&lt;String, String&gt;(<span class="keyword">new</span> <span class="title class_">DefaultKafkaProducerFactory</span>&lt;&gt;(props));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> KafkaTemplate <span class="title function_">getKafkaTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试自定义分区发送</span><br><span class="line">@RestController</span><br><span class="line">public class MyPartitionProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    MyPartitionTemplate template;</span><br><span class="line"></span><br><span class="line">//    使用0开头和其他任意字母开头的key发送消息</span><br><span class="line">//    看控制台的输出，在哪个分区里？</span><br><span class="line">    @GetMapping(&quot;/kafka/myPartitionSend/&#123;key&#125;&quot;)</span><br><span class="line">    public void setPartition(@PathVariable(&quot;key&quot;) String key) &#123;</span><br><span class="line">        template.getKafkaTemplate().send(&quot;test&quot;, key,&quot;key=&quot;+key+&quot;，msg=自定义分区策略&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合OAuth2认证服务</title>
      <link href="/2022/10/04/springboot%E6%95%B4%E5%90%88OAuth2%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/10/04/springboot%E6%95%B4%E5%90%88OAuth2%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="1、AuthorizationServerConfig"><a href="#1、AuthorizationServerConfig" class="headerlink" title="1、AuthorizationServerConfig"></a><strong>1、AuthorizationServerConfig</strong></h2><h3 id="【事先准备】："><a href="#【事先准备】：" class="headerlink" title="【事先准备】："></a><strong>【事先准备】：</strong></h3><h4 id="方法、LoadRolePermissionService-调用—-gt-PermissionServiceImpl"><a href="#方法、LoadRolePermissionService-调用—-gt-PermissionServiceImpl" class="headerlink" title="方法、LoadRolePermissionService  调用—&gt; PermissionServiceImpl"></a><strong>方法、LoadRolePermissionService  调用—&gt; PermissionServiceImpl</strong></h4><p><strong>作用：从数据库中将url-&gt;角色对应关系加载到Redis中</strong></p><ul><li>**方法1:listRolePermission **</li><li><ul><li>先从数据库获取permissons</li><li>根据roleid从数据库中找权限数据</li><li>根据permissionid从数据库中找数据</li><li>到此为止，构造了每一个permission对应所需要的权限一共后续使用</li><li>简化一下，放入redis</li></ul></li></ul><h3 id="【1】AuthorizationServerConfig-继承—-gt-AuthorizationServerConfigurerAdapter"><a href="#【1】AuthorizationServerConfig-继承—-gt-AuthorizationServerConfigurerAdapter" class="headerlink" title="【1】AuthorizationServerConfig 继承—&gt; AuthorizationServerConfigurerAdapter"></a><strong>【1】AuthorizationServerConfig 继承—&gt; AuthorizationServerConfigurerAdapter</strong></h3><p><strong>作用：配置认证中心，就是授权服务器配置</strong></p><h4 id="方法1：-configure-ClientDetailsServiceConfigurer-clients"><a href="#方法1：-configure-ClientDetailsServiceConfigurer-clients" class="headerlink" title="方法1： configure(ClientDetailsServiceConfigurer clients)"></a><strong>方法1： configure(ClientDetailsServiceConfigurer clients)</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 配置客户端详情，并不是所有的客户端都能接入授权服务</span><br><span class="line"> * 用来配置客户端详情服务（ClientDetailsService），</span><br><span class="line"> * 客户端详情信息在这里进行初始化，</span><br><span class="line"> * 你能够把客户端详情信息写死在这里或者是通过数据库来存储调取详情信息</span><br><span class="line"> </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h5 id="一、重写configure-ClientDetailsServiceConfigurer-clients-方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的-，"><a href="#一、重写configure-ClientDetailsServiceConfigurer-clients-方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的-，" class="headerlink" title="**一、重写configure(ClientDetailsServiceConfigurer clients)方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的**，"></a>**一、<u>重写configure(ClientDetailsServiceConfigurer clients)方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的</u>**，</h5><ol><li>定义两个client_id，及客户端可以通过不同的client_id来获取不同的令牌；</li><li>client_id为test1的令牌有效时间为3600秒，client_id为test2的令牌有效时间为7200秒；</li><li>client_id为test1的refresh_token（下面会介绍到）有效时间为864000秒，即10天，也就是说在这10天内都可以通过refresh_token来换取新的令牌；</li><li>在获取client_id为test1的令牌的时候，scope只能指定为all，a，b或c中的某个值，否则将获取失败；</li><li>只能通过密码模式(password)来获取client_id为test1的令牌，而test2则无限制。</li></ol><h5 id="二、导入方法有以下几种："><a href="#二、导入方法有以下几种：" class="headerlink" title="二、导入方法有以下几种："></a><strong>二、导入方法有以下几种：</strong></h5><ul><li><strong>内存</strong>，自己测试的时候比较推荐，后续数据库啊什么的</li><li><strong>数据库</strong>，使用JdbcClientDetailsService，JdbcClientDetailsService自己是有一个默认的字段的表的，所以程序是从数据库中的oauth_client_details表中加载客户端信息，</li><li>总而言之，就是配置把客户端信息从数据源拿过来。后面需要授权验证，要用到，所以先配。</li></ul><h4 id="方法2：-configure-AuthorizationServerEndpointsConfigurer-endpoints-——"><a href="#方法2：-configure-AuthorizationServerEndpointsConfigurer-endpoints-——" class="headerlink" title="方法2： configure(AuthorizationServerEndpointsConfigurer endpoints)——"></a><strong>方法2： configure(AuthorizationServerEndpointsConfigurer endpoints)——</strong></h4><p>上面和客户端有关，而这个则直接和令牌有关，比如<u><strong>配置授权（authorization）</strong></u>以及<u><strong>令牌（token）的访问端点</strong></u>和<u><strong>令牌服务(token services)</strong></u>，还有一些其他的，比如异常啊什么的，下面有例子。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 配置令牌访问的端点</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>令牌端点可用于以编程方式请求令牌（非常重要，四种方式）,下面是配置的例子</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">endpoints</span><br><span class="line">        <span class="comment">//设置异常WebResponseExceptionTranslator，用于处理用户名，密码错误、授权类型不正确的异常</span></span><br><span class="line">        .exceptionTranslator(<span class="keyword">new</span> <span class="title class_">OAuthServerWebResponseExceptionTranslator</span>())</span><br><span class="line">        <span class="comment">//授权码模式所需要的authorizationCodeServices</span></span><br><span class="line">        .authorizationCodeServices(authorizationCodeServices())</span><br><span class="line">        <span class="comment">//密码模式所需要的authenticationManager</span></span><br><span class="line">        .authenticationManager(authenticationManager)</span><br><span class="line">        <span class="comment">//令牌管理服务，无论哪种模式都需要</span></span><br><span class="line">        .tokenServices(tokenServices())</span><br><span class="line">        <span class="comment">//添加进入tokenGranter</span></span><br><span class="line">        .tokenGranter(<span class="keyword">new</span> <span class="title class_">CompositeTokenGranter</span>(tokenGranters))</span><br><span class="line">        <span class="comment">//只允许POST提交访问令牌，uri：/oauth/token</span></span><br><span class="line">        .allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br></pre></td></tr></table></figure><h5 id="一、authenticationManager-（建议必须配置）-（密码授权管理器），见文件SecurityConfig这个配置类"><a href="#一、authenticationManager-（建议必须配置）-（密码授权管理器），见文件SecurityConfig这个配置类" class="headerlink" title="一、authenticationManager （建议必须配置）  （密码授权管理器），见文件SecurityConfig这个配置类"></a><strong>一、<u>authenticationManager （建议必须配置）  （密码授权管理器），见文件SecurityConfig这个配置类</u></strong></h5><ul><li>在Spring Security中，AuthenticationManager的默认实现是ProviderManager，而且它不直接自己处理认证请求，而是委托给其所配置的AuthenticationProvider列表，然后会依次使用每一个AuthenticationProvider进行认证，如果有一个AuthenticationProvider认证后的结果不为null，则表示该AuthenticationProvider已经认证成功，之后的AuthenticationProvider将不再继续认证。然后直接以该AuthenticationProvider的认证结果作为ProviderManager的认证结果。如果所有的AuthenticationProvider的认证结果都为null，则表示认证失败，将抛出一个ProviderNotFoundException。<br>校验认证请求最常用的方法是根据请求的用户名加载对应的UserDetails，然后比对UserDetails的密码与认证请求的密码是否一致，一致则表示认证通过。<br>Spring Security内部的DaoAuthenticationProvider就是使用的这种方式。其内部使用UserDetailsService来负责加载UserDetails。在认证成功以后会使用加载的UserDetails来封装要返回的Authentication对象，加载的UserDetails对象是包含用户权限等信息的。认证成功返回的Authentication对象将会保存在当前的SecurityContext中</li></ul><h5 id="二、令牌本身内容的配置（建议必须配置）"><a href="#二、令牌本身内容的配置（建议必须配置）" class="headerlink" title="二、令牌本身内容的配置（建议必须配置）"></a><u><strong>二、令牌本身内容的配置（建议必须配置）</strong></u></h5><h6 id="I、-两种方式，"><a href="#I、-两种方式，" class="headerlink" title="I、 两种方式，"></a><u><strong>I、 两种方式，</strong></u></h6><p>【1】直接在endpoint这里配。</p><p>【2】自己写个bean注入，举个例子：</p><h6 id="II、tokenServices-就在本文件注入-由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里"><a href="#II、tokenServices-就在本文件注入-由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里" class="headerlink" title="II、tokenServices()  就在本文件注入,由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里"></a><strong>II、tokenServices()</strong>  <strong>就在本文件注入,由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里</strong></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public AuthorizationServerTokenServices tokenServices() &#123;</span><br><span class="line">    System.out.println(&quot;令牌管理服务的配置&quot;);</span><br><span class="line">    DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">    //客户端端配置策略</span><br><span class="line">    services.setClientDetailsService(clientDetailsService);</span><br><span class="line">    //支持令牌的刷新</span><br><span class="line">    services.setSupportRefreshToken(true);</span><br><span class="line">    //令牌服务</span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    //access_token的过期时间</span><br><span class="line">    services.setAccessTokenValiditySeconds(60 * 60 * 24 * 3);</span><br><span class="line">    //refresh_token的过期时间</span><br><span class="line">    services.setRefreshTokenValiditySeconds(60 * 60 * 24 * 3);</span><br><span class="line"></span><br><span class="line">    //设置令牌增强，使用JwtAccessTokenConverter进行转换</span><br><span class="line">    services.setTokenEnhancer(jwtAccessTokenConverter);</span><br><span class="line">    return services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt-自定义内容。"><a href="#III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt-自定义内容。" class="headerlink" title="III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt+自定义内容。"></a><strong><u>III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt+自定义内容。</u></strong></h6><ul><li><p>把令牌变成jwt格式很简单，按下面2两步操作即可，反正就是</p><ul><li><p>~~~<br>@Configuration<br>public class JWTokenConfig {</p><pre><code>@Beanpublic TokenStore jwtTokenStore() &#123;    return new JwtTokenStore(jwtAccessTokenConverter());&#125;@Beanpublic JwtAccessTokenConverter jwtAccessTokenConverter() &#123;    JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();    accessTokenConverter.setSigningKey(&quot;test_key&quot;); // 签名密钥    return accessTokenConverter;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* ~~~java</span><br><span class="line">      services.setTokenStore(tokenStore);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>自定义的话，同样简单，按下面的操作来做，无非就是先写一些配置，然后把配置注入adapter</p><ul><li>&#96;&#96;&#96;java<br>@Component<br>public class JwtTokenEnhancer implements TokenEnhancer {<br>@Override<br>public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {<br>    SecurityUser securityUser &#x3D; (SecurityUser) authentication.getPrincipal();<br>    Map&lt;String, Object&gt; info &#x3D; new HashMap&lt;&gt;();<br>    &#x2F;&#x2F;把用户ID设置到JWT中<br>    info.put(“id”, securityUser.getId());<br>    info.put(“client_id”,securityUser.getClientId());<br>    ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);<br>    return accessToken;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * ~~~</span><br><span class="line">    tokenEnhancer(enhancerChain)</span><br><span class="line">    ~~~</span><br><span class="line"></span><br><span class="line">##### **三、tokenGranter(new CompositeTokenGranter(tokenGranters))    自定义授权  非常重要**</span><br><span class="line"></span><br><span class="line">作用：自定义授权获取token，下面我们来看一看源码是怎么获取token的，在我们发起oauth/token，请求获取token时，实际上是请求Tokenpoint类的postAccessToken或者getacesstoken方法，相当于调用了一个controller方法，根据请求的方法是get还是post，但其实内部还是调用post的方法。</span><br><span class="line"></span><br><span class="line">在TokenEndPoint 获取令牌过程中, 有个这样的步骤:</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">OAuth2AccessToken token = getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">postAccessToken这个方法中，在这个方法的132行调用TokenGranter类的grant方法来获取token，**&lt;u&gt;这个方法也是最重要的&lt;/u&gt;**，通过这个方法我们可以对请求的参数进行校验是否合法，是否给予令牌。</span><br><span class="line"></span><br><span class="line">TokenGranter是一个接口，它有多个实现类，CompositeTokenGranter是其中之一，在grant方法中，会循环遍历所有的授权方式，根据请求参数携带的授权方式码，来匹配对应的授权处理实现类，调用实现类中的grant方法。那么关键点来了，请求参数中携带的是我们**&lt;u&gt;自定义的授权方式码&lt;/u&gt;**，如果要匹配上，那么首先我们要创建自定义的授权处理类，然后把这个授权处理类放入Spring Security默认的授权处理集合中，这样才能循环匹配上，进行下一步。</span><br><span class="line"></span><br><span class="line">和以前的做法一样：创建自定义授权处理类，我们可以继承TokenGranter来实现自定义的身份验证以便获取token，而AbstractTokenGranter是一个继承TokenGranter的实现类，一般我们都会继承这个类进行使用。这一点已经得到验证，可以看下面的流程。</span><br><span class="line"></span><br><span class="line">| 实现类                            | 对应的授权模式  |</span><br><span class="line">| --------------------------------- | --------------- |</span><br><span class="line">| AuthorizationCodeTokenGranter     | 授权码模式      |</span><br><span class="line">| ClientCredentialsTokenGranter     | 客户端模式      |</span><br><span class="line">| ImplicitTokenGranter              | implicit 模式   |</span><br><span class="line">| RefreshTokenGranter               | 刷新 token 模式 |</span><br><span class="line">| ResourceOwnerPasswordTokenGranter | 密码模式        |</span><br><span class="line"></span><br><span class="line">**这些类都继承了AbstractTokenGranter** </span><br><span class="line"></span><br><span class="line">**AbstractTokenGranter   调用-------&gt;getAccessToken --------&gt;getOAuth2Authentication**</span><br><span class="line"></span><br><span class="line">**根据 client、tokenRequest 从 OAuth2RequestFactory 中创建一个 OAuth2Request, 进而可得到 OAuth2Authentication (存放着用户的认证信息)。**</span><br><span class="line"></span><br><span class="line">**通过 tokenService 去创建 OAuth2AccessToken (存放着用户的 token信息、过期时间)。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### **I、————所以，这里加入自定的tokenGrant，也就是要自定义自己的授权方法 去 授权 自定义的令牌——————**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自定义至关重要的一点就是修改**getOAuth2Authentication**方法 （主要文件见sms文件夹和即可）</span><br><span class="line"></span><br><span class="line">具体修改不讲，修改的流程就是1、**组装自定义模式的认证信息** 2、**用authenticationManager去调用内部自定义的Provider认证这个认证信息，认证规则自然是写在Provider里面**。可借鉴 https://blog.csdn.net/m0_38031406/article/details/89316342</span><br><span class="line"></span><br><span class="line">###### **II、&lt;u&gt;所以实现方式：继承AbstractTokenGranter + 重写 getOAuth2Authentication方法。&lt;/u&gt;**</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">@Override</span><br><span class="line">protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) &#123;</span><br><span class="line">    Map&lt;String, String&gt; parameters = new LinkedHashMap&lt;&gt;(tokenRequest.getRequestParameters());</span><br><span class="line">    String mobile = parameters.get(&quot;mobile&quot;);</span><br><span class="line">    String password = parameters.get(&quot;password&quot;);</span><br><span class="line">    //将其中的密码移除</span><br><span class="line">    parameters.remove(&quot;password&quot;);</span><br><span class="line">    //自定义的token类</span><br><span class="line">    Authentication userAuth = new MobilePasswordAuthenticationToken(mobile, password);</span><br><span class="line"></span><br><span class="line">    ((AbstractAuthenticationToken) userAuth).setDetails(parameters);</span><br><span class="line">    //调用AuthenticationManager进行认证，内部会根据MobileAuthenticationToken找到对应的Provider进行认证</span><br><span class="line">    userAuth = authenticationManager.authenticate(userAuth);</span><br><span class="line">    if (userAuth == null || !userAuth.isAuthenticated()) &#123;</span><br><span class="line">        throw new InvalidGrantException(&quot;Could not authenticate mobile: &quot; + mobile);</span><br><span class="line">    &#125;</span><br><span class="line">    OAuth2Request storedOAuth2Request = getRequestFactory().createOAuth2Request(client, tokenRequest);</span><br><span class="line">    return new OAuth2Authentication(storedOAuth2Request, userAuth);</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">这里调用了AuthenticationManager认证，后面回调用自定义的XXXXXAuthenticationProvider</span><br><span class="line"></span><br><span class="line">###### **III、注入**</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">.tokenGranter(new CompositeTokenGranter(tokenGranters))</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **四、new OAuthServerWebResponseExceptionTranslator()**  也是自己配置的见文件夹**Exception**</span><br><span class="line"></span><br><span class="line">自定义异常翻译器，针对用户名、密码异常，授权类型不支持的异常进行处理-----**关键是用户**</span><br><span class="line"></span><br><span class="line">##### **五、authorizationCodeServices()就在本文件注入**</span><br><span class="line"></span><br><span class="line">##### **六、待续**。。。。。。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### **方法3： configure(AuthorizationServerSecurityConfigurer security)**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * 配置令牌访问的安全约束（）</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证"><a href="#一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证" class="headerlink" title="一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证"></a><strong>一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 客户端异常处理</span></span><br><span class="line"><span class="comment"> * 自定义的客户端认证的过滤器，根据客户端的id、秘钥进行认证</span></span><br><span class="line"><span class="comment"> * 重写这个过滤器用于自定义异常处理</span></span><br><span class="line"><span class="comment"> * 具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;配置令牌访问的安全约束&quot;</span>);</span><br><span class="line">      <span class="comment">//自定义ClientCredentialsTokenEndpointFilter，用于处理客户端id，密码错误的异常</span></span><br><span class="line">        <span class="type">OAuthServerClientCredentialsTokenEndpointFilter</span> <span class="variable">endpointFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OAuthServerClientCredentialsTokenEndpointFilter</span>(security,authenticationEntryPoint);</span><br><span class="line">        endpointFilter.afterPropertiesSet();</span><br><span class="line">        security.addTokenEndpointAuthenticationFilter(endpointFilter);</span><br><span class="line"></span><br><span class="line">        security</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                <span class="comment">//开启/oauth/token_key验证端口权限访问</span></span><br><span class="line">                .tokenKeyAccess(<span class="string">&quot;permitAll()&quot;</span>)</span><br><span class="line">                <span class="comment">//开启/oauth/check_token验证端口认证权限访问</span></span><br><span class="line">                .checkTokenAccess(<span class="string">&quot;permitAll()&quot;</span>);</span><br><span class="line">                <span class="comment">//一定不要添加allowFormAuthenticationForClients，否则自定义的OAuthServerClientCredentialsTokenEndpointFilter不生效</span></span><br><span class="line"><span class="comment">//                .allowFormAuthenticationForClients();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制"><a href="#I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制" class="headerlink" title="I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制"></a><strong>I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制</strong></h6><p><strong>既然如此，我们就去看自定义的AuthenticationEntryPoint</strong>，这里没改，实际中可以改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OAuthServerAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证失败处理器会调用这个方法返回提示信息</span></span><br><span class="line"><span class="comment">     * TODO 实际开发中可以自己定义，此处直接返回JSON数据：客户端认证失败错误提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ResponseUtils.result(response,<span class="keyword">new</span> <span class="title class_">ResultMsg</span>(ResultCode.CLIENT_AUTHENTICATION_FAILED.getCode(),ResultCode.CLIENT_AUTHENTICATION_FAILED.getMsg(),<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="II、endpointFilter-afterPropertiesSet-认证成功怎么办，认真失败怎么办，这里可以自定义哈哈"><a href="#II、endpointFilter-afterPropertiesSet-认证成功怎么办，认真失败怎么办，这里可以自定义哈哈" class="headerlink" title="II、endpointFilter.afterPropertiesSet(); 认证成功怎么办，认真失败怎么办，这里可以自定义哈哈"></a><strong>II、endpointFilter.afterPropertiesSet();</strong> 认证成功怎么办，认真失败怎么办，这里可以自定义哈哈</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置AuthenticationEntryPoint主要逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;设置AuthenticationEntryPoint主要逻辑&quot;</span>);</span><br><span class="line">    <span class="comment">//TODO 定制认证失败处理器，开发中可以自己修改</span></span><br><span class="line">    setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">            exception = <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(exception.getMessage(), <span class="keyword">new</span> <span class="title class_">BadClientCredentialsException</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//成功处理器，和父类相同，为空即可。</span></span><br><span class="line">    setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="III、security-addTokenEndpointAuthenticationFilter-endpointFilter"><a href="#III、security-addTokenEndpointAuthenticationFilter-endpointFilter" class="headerlink" title="III、security.addTokenEndpointAuthenticationFilter(endpointFilter);"></a><strong>III、security.addTokenEndpointAuthenticationFilter(endpointFilter);</strong></h6><ul><li>注入 自定义相应异常的过滤链</li></ul><h2 id="2、springconfig"><a href="#2、springconfig" class="headerlink" title="2、springconfig"></a><strong>2、springconfig</strong></h2><h3 id="介绍一个比较完整的securityconfig配置"><a href="#介绍一个比较完整的securityconfig配置" class="headerlink" title="介绍一个比较完整的securityconfig配置"></a><strong>介绍一个比较完整的securityconfig配置</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//开启判断用户对某个控制层的方法是否具有访问权限的功能</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//注入自定义的UserDetailService</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsServiceImpl userDetailsServiceImpl;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换默认AuthenticationManager中的UserDetailService，使用数据库用户认证方式登录</span></span><br><span class="line">    <span class="comment">//1. 一旦通过 configure 方法自定义 AuthenticationManager实现 就回将工厂中自动配置AuthenticationManager 进行覆盖</span></span><br><span class="line">    <span class="comment">//2. 一旦通过 configure 方法自定义 AuthenticationManager实现 需要在实现中指定认证数据源对象 UserDetailService 实例</span></span><br><span class="line">    <span class="comment">//3. 一旦通过 configure 方法自定义 AuthenticationManager实现 这种方式创建AuthenticationManager对象工厂内部本地一个 AuthenticationManager 对象 不允许在其他自定义组件中进行注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder builder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        builder.userDetailsService(userDetailsServiceImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BCryptPasswordEncoder相关知识：</span></span><br><span class="line"><span class="comment">     * 用户表的密码通常使用MD5等不可逆算法加密后存储，为防止彩虹表破解更会先使用一个特定的字符串（如域名）加密，然后再使用一个随机的salt（盐值）加密。</span></span><br><span class="line"><span class="comment">     * 特定字符串是程序代码中固定的，salt是每个密码单独随机，一般给用户表加一个字段单独存储，比较麻烦。</span></span><br><span class="line"><span class="comment">     * BCrypt算法将salt随机并混入最终加密后的密码，验证时也无需单独提供之前的salt，从而无需单独处理salt问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将自定义AuthenticationManager在工厂中进行暴露,可以在任何位置注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HttpSecurity配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.cors(withDefaults())</span><br><span class="line">                <span class="comment">// 禁用 CSRF</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 指定的接口直接放行</span></span><br><span class="line">                <span class="comment">// swagger</span></span><br><span class="line">                .antMatchers(SecurityConstants.SWAGGER_WHITELIST).permitAll()</span><br><span class="line">                .antMatchers(SecurityConstants.H2_CONSOLE).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, SecurityConstants.SYSTEM_WHITELIST).permitAll()</span><br><span class="line">                <span class="comment">// 其他的接口都需要认证后才能请求</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//添加自定义Filter</span></span><br><span class="line">                .addFilter(<span class="keyword">new</span> <span class="title class_">JwtAuthorizationFilter</span>(authenticationManager(), stringRedisTemplate))</span><br><span class="line">                <span class="comment">// 不需要session（不创建会话）</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                <span class="comment">// 授权异常处理</span></span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                <span class="comment">// json提示用户没有登录不需要用户跳转到登录页面去</span></span><br><span class="line">                .authenticationEntryPoint(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationEntryPoint</span>())</span><br><span class="line">                <span class="comment">// 权限拦截器，提示用户没有当前权限</span></span><br><span class="line">                .accessDeniedHandler(<span class="keyword">new</span> <span class="title class_">JwtAccessDeniedHandler</span>());</span><br><span class="line">        <span class="comment">// 防止H2 web 页面的Frame 被拦截</span></span><br><span class="line">        http.headers().frameOptions().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cors配置优化</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">        org.springframework.web.cors.<span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        configuration.setAllowedOrigins(singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="comment">// configuration.setAllowedOriginPatterns(singletonList(&quot;*&quot;));</span></span><br><span class="line">        configuration.setAllowedHeaders(singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line">        configuration.setExposedHeaders(singletonList(SecurityConstants.TOKEN_HEADER));</span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">false</span>);</span><br><span class="line">        configuration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="鉴权服务"><a href="#鉴权服务" class="headerlink" title="鉴权服务"></a>鉴权服务</h1><p>和授权服务，许多程序都是围绕着配置类进行的，所以我们直接看配置类</p><h2 id="【1】AccessTokenConfig-令牌的一些配置"><a href="#【1】AccessTokenConfig-令牌的一些配置" class="headerlink" title="【1】AccessTokenConfig  令牌的一些配置"></a><strong>【1】AccessTokenConfig</strong>  令牌的一些配置</h2><ul><li>和授权服务一致，因为令牌要从授权服务到网关，再到客户端，不管是为了现在的还是后续的操作，最好配置，当然，用不到也可以不配，看你用不用得到。</li></ul><h2 id="【2】JwtAuthenticationManager-token认证管理器"><a href="#【2】JwtAuthenticationManager-token认证管理器" class="headerlink" title="【2】JwtAuthenticationManager token认证管理器"></a><strong>【2】JwtAuthenticationManager token认证管理器</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 公众号：码猿技术专栏</span></span><br><span class="line"><span class="comment"> * JWT认证管理器，主要的作用就是对携带过来的token进行校验，比如过期时间，加密方式等</span></span><br><span class="line"><span class="comment"> * 一旦token校验通过，则交给鉴权管理器进行鉴权</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Authentication&gt; <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;第六步***来到JWT认证管理器 检验token&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Mono.justOrEmpty(authentication)</span><br><span class="line">            .filter(a -&gt; a <span class="keyword">instanceof</span> BearerTokenAuthenticationToken)</span><br><span class="line">            .cast(BearerTokenAuthenticationToken.class)</span><br><span class="line">            .map(BearerTokenAuthenticationToken::getToken)</span><br><span class="line">            .flatMap((accessToken -&gt; &#123;</span><br><span class="line">                <span class="type">OAuth2AccessToken</span> <span class="variable">oAuth2AccessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.tokenStore.readAccessToken(accessToken);</span><br><span class="line">                <span class="comment">//根据access_token从数据库获取不到OAuth2AccessToken</span></span><br><span class="line">                <span class="keyword">if</span> (oAuth2AccessToken == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;无效的token！&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oAuth2AccessToken.isExpired()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;token已过期！&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">OAuth2Authentication</span> <span class="variable">oAuth2Authentication</span> <span class="operator">=</span> <span class="built_in">this</span>.tokenStore.readAuthentication(accessToken);</span><br><span class="line">                <span class="keyword">if</span> (oAuth2Authentication == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;无效的token！&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.just(oAuth2Authentication);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)).cast(Authentication.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【3】JwtAccessManagerV2——-认证管理器自定义"><a href="#【3】JwtAccessManagerV2——-认证管理器自定义" class="headerlink" title="【3】JwtAccessManagerV2——-认证管理器自定义"></a><strong>【3】JwtAccessManagerV2——-认证管理器自定义</strong></h2><ul><li>作用：认证管理的作用就是获取传递过来的令牌，对其进行解析、验签、过期时间判定。就是作为的鉴权</li><li>获取调用方法【get&#x2F;post…】+uri.getPath()  合成完整路径例如：【uri.getPath()】</li><li>从redis里面获取获取所有的uri-&gt;角色对应关系</li><li>去链接里面找到和自己这次申请链接完全一致的那一个键值对，而这个键值对的值恰恰就是【权限集合】</li><li>把自己的权限先从mono中解析出来，然后匹配，如果超级管理员，放行；如果存在交集，则通过；否则失败</li></ul><p>异常</p><ul><li><p>RequestAuthenticationEntryPoint</p><ul><li>用于处理没有登录或token过期时的自定义返回结果</li></ul></li><li><p>RequestAccessDeniedHandler</p><ul><li>自定义返回结果：没有权限访问时</li></ul></li><li><p>RequestAuthenticationEntryPoint</p><ul><li>用于处理没有登录或token过期时的自定义返回结果</li></ul></li></ul><h2 id="【4】-SecurityConfig-在webflux中使用security"><a href="#【4】-SecurityConfig-在webflux中使用security" class="headerlink" title="【4】 SecurityConfig  在webflux中使用security"></a><strong>【4】 SecurityConfig  在webflux中使用security</strong></h2><h3 id="1、webFluxSecurityFilterChain——把之前的配置整合链路"><a href="#1、webFluxSecurityFilterChain——把之前的配置整合链路" class="headerlink" title="1、webFluxSecurityFilterChain——把之前的配置整合链路"></a><strong>1、webFluxSecurityFilterChain——把之前的配置整合链路</strong></h3><ul><li><strong>这里使用的是webFluxSecurityFilterChain</strong></li><li>http下的功能可以借鉴<a href="http://events.jianshu.io/p/8ad366b97e18">http://events.jianshu.io/p/8ad366b97e18</a></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    SecurityWebFilterChain webFluxSecurityFilterChain(ServerHttpSecurity http) throws Exception&#123;</span><br><span class="line">    //认证过滤器，放入认证管理器tokenAuthenticationManager</span><br><span class="line">    AuthenticationWebFilter authenticationWebFilter = new AuthenticationWebFilter(tokenAuthenticationManager);</span><br><span class="line">    System.out.println(&quot;认证过滤器，放入认证管理器tokenAuthenticationManager&quot;);</span><br><span class="line">    authenticationWebFilter.setServerAuthenticationConverter(new ServerBearerTokenAuthenticationConverter());</span><br><span class="line"></span><br><span class="line">    http</span><br><span class="line">            .httpBasic().disable()</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .authorizeExchange()</span><br><span class="line">            //白名单直接放行</span><br><span class="line">            .pathMatchers(ArrayUtil.toArray(sysConfig.getIgnoreUrls(),String.class)).permitAll()</span><br><span class="line">            //其他的请求必须鉴权，使用鉴权管理器</span><br><span class="line">            .anyExchange().access(accessManager)</span><br><span class="line">            //鉴权的异常处理，权限不足，token失效</span><br><span class="line">            .and().exceptionHandling()</span><br><span class="line">            .authenticationEntryPoint(requestAuthenticationEntryPoint)</span><br><span class="line">            .accessDeniedHandler(requestAccessDeniedHandler)</span><br><span class="line">            .and()</span><br><span class="line">            // 跨域过滤器</span><br><span class="line">            .addFilterAt(corsFilter, SecurityWebFiltersOrder.CORS)</span><br><span class="line">            //token的认证过滤器，用于校验token和认证</span><br><span class="line">            .addFilterAt(authenticationWebFilter, SecurityWebFiltersOrder.AUTHENTICATION);</span><br><span class="line">    return http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一、加入了【2】的自定义令牌认证管理器"><a href="#一、加入了【2】的自定义令牌认证管理器" class="headerlink" title="一、加入了【2】的自定义令牌认证管理器"></a><strong>一、加入了【2】的自定义令牌认证管理器</strong></h4><h4 id="二、加入了【3】的鉴权管理器"><a href="#二、加入了【3】的鉴权管理器" class="headerlink" title="二、加入了【3】的鉴权管理器"></a><strong>二、加入了【3】的鉴权管理器</strong></h4><h3 id="2、白名单放行"><a href="#2、白名单放行" class="headerlink" title="**2、白名单放行 **"></a>**2、白名单放行 **</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//白名单直接放行</span><br><span class="line">.pathMatchers(ArrayUtil.toArray(sysConfig.getIgnoreUrls(),String.class)).permitAll()</span><br><span class="line">//其他的请求必须鉴权，使用鉴权管理器</span><br><span class="line">.anyExchange().access(accessManager)</span><br></pre></td></tr></table></figure><h3 id="3、鉴权的异常处理"><a href="#3、鉴权的异常处理" class="headerlink" title="3、鉴权的异常处理"></a><strong>3、鉴权的异常处理</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//鉴权的异常处理，权限不足，token失效</span><br><span class="line">.and().exceptionHandling()</span><br><span class="line">.authenticationEntryPoint(requestAuthenticationEntryPoint)</span><br><span class="line">.accessDeniedHandler(requestAccessDeniedHandler)</span><br></pre></td></tr></table></figure><h1 id="异常配置"><a href="#异常配置" class="headerlink" title="异常配置"></a>异常配置</h1><h2 id="【1】认证服务的异常"><a href="#【1】认证服务的异常" class="headerlink" title="【1】认证服务的异常"></a>【1】认证服务的异常</h2><ul><li>用户名，密码错误异常、授权类型异常</li><li>客户端ID、秘钥异常</li></ul><h3 id="1、用户名，密码错误异常、授权类型异常"><a href="#1、用户名，密码错误异常、授权类型异常" class="headerlink" title="1、用户名，密码错误异常、授权类型异常"></a><strong>1、用户名，密码错误异常、授权类型异常</strong></h3><p>针对用户名、密码、授权类型错误的异常解决方式比较复杂，需要定制的比较多。</p><h4 id="一、定制提示信息、响应码"><a href="#一、定制提示信息、响应码" class="headerlink" title="一、定制提示信息、响应码"></a><strong>一、定制提示信息、响应码</strong></h4><p>这部分根据自己业务需要定制，举个例子，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    CLIENT_AUTHENTICATION_FAILED(<span class="number">1001</span>,<span class="string">&quot;客户端认证失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    USERNAME_OR_PASSWORD_ERROR(<span class="number">1002</span>,<span class="string">&quot;用户名或密码错误&quot;</span>),</span><br><span class="line"></span><br><span class="line">    UNSUPPORTED_GRANT_TYPE(<span class="number">1003</span>, <span class="string">&quot;不支持的认证模式&quot;</span>),</span><br><span class="line"></span><br><span class="line">    NO_PERMISSION(<span class="number">1005</span>,<span class="string">&quot;无权限访问！&quot;</span>),</span><br><span class="line">    UNAUTHORIZED(<span class="number">401</span>, <span class="string">&quot;系统错误&quot;</span>),</span><br><span class="line"></span><br><span class="line">    INVALID_TOKEN(<span class="number">1004</span>,<span class="string">&quot;无效的token&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="二、自定义WebResponseExceptionTranslator"><a href="#二、自定义WebResponseExceptionTranslator" class="headerlink" title="二、自定义WebResponseExceptionTranslator"></a><strong>二、自定义WebResponseExceptionTranslator</strong></h4><ul><li><p>需要自定义一个异常翻译器，默认的是<strong>DefaultWebResponseExceptionTranslator</strong>，此处必须重写，其中有一个需要实现的方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;T&gt; <span class="title function_">translate</span><span class="params">(Exception e)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure><p>这个方法就是根据传递过来的<strong>Exception</strong>判断不同的异常返回特定的信息，这里需要判断的异常的如下：</p><ul><li><strong>UnsupportedGrantTypeException</strong>：不支持的授权类型异常</li><li><strong>InvalidGrantException</strong>：用户名或者密码错误的异常</li></ul></li><li><p>创建一个<strong>OAuthServerWebResponseExceptionTranslator</strong>实现<strong>WebResponseExceptionTranslator</strong>，代码如下：</p></li><li><p>&#96;&#96;&#96;java<br>public class OAuthServerWebResponseExceptionTranslator implements WebResponseExceptionTranslator{<br>&#x2F;**<br> * 业务处理方法，重写这个方法返回客户端信息<br> <em>&#x2F;<br>@Override<br>public ResponseEntity<ResultMsg> translate(Exception e){<br>    ResultMsg resultMsg &#x3D; doTranslateHandler(e);<br>    return new ResponseEntity&lt;&gt;(resultMsg, HttpStatus.UNAUTHORIZED);<br>}<br><br>&#x2F;</em>*<br> * 根据异常定制返回信息<br> * TODO 自己根据业务封装<br> *&#x2F;<br>private ResultMsg doTranslateHandler(Exception e) {<br>    &#x2F;&#x2F;初始值，系统错误，<br>    ResultCode resultCode &#x3D; ResultCode.UNAUTHORIZED;<br>    &#x2F;&#x2F;判断异常，不支持的认证方式<br>    if(e instanceof UnsupportedGrantTypeException){<br>        resultCode &#x3D; ResultCode.UNSUPPORTED_GRANT_TYPE;<br>        &#x2F;&#x2F;用户名或密码异常<br>    }else if(e instanceof InvalidGrantException){<br>        resultCode &#x3D; ResultCode.USERNAME_OR_PASSWORD_ERROR;<br>    }<br>    return new ResultMsg(resultCode.getCode(),resultCode.getMsg(),null);<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### **三、认证服务配置文件中配置**</span><br><span class="line"></span><br><span class="line">需要将自定义的异常翻译器**OAuthServerWebResponseExceptionTranslator**在配置文件中配置，很简单，一行代码的事。</span><br><span class="line"></span><br><span class="line">在**AuthorizationServerConfig**配置文件指定，代码如下：</span><br><span class="line"></span><br><span class="line">![image-20220906203102659](C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203102659.png)</span><br><span class="line"></span><br><span class="line">#### **四、这么配置的原因**</span><br><span class="line"></span><br><span class="line">* 我们知道获取令牌的接口为 **/oauth/token**，这个接口定义在**TokenEndpoint#postAccessToken()**（POST请求）方法中，如下图</span><br><span class="line">* ![image-20220906203752062](C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203752062.png)</span><br><span class="line">* 是不是都继承了**OAuth2Exception**，那么尝试在**TokenEndpoint**这个类中找找有没有处理**OAuth2Exception**这个异常的处理器，果然找到了一个 **handleException()** 方法，如下：</span><br><span class="line">* ![image-20220906203840232](C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203840232.png)</span><br><span class="line">* 可以看到，这里的异常翻译器已经使用了我们自定义的**OAuthServerWebResponseExceptionTranslator**。可以看下默认的异常翻译器是啥，代码如下：</span><br><span class="line"></span><br><span class="line">### **2、客户端ID、秘钥异常**</span><br><span class="line"></span><br><span class="line">这部分比较复杂，想要理解还是需要些基础的，解决这个异常的方案很多，陈某只是介绍其中一种，下面详细介绍。</span><br><span class="line"></span><br><span class="line">#### **一、定制提示信息、响应码**</span><br><span class="line"></span><br><span class="line">这部分根据自己业务需要定制，和第一步一样。</span><br><span class="line"></span><br><span class="line">#### **二、自定义AuthenticationEntryPoint**</span><br><span class="line"></span><br><span class="line">这个**AuthenticationEntryPoint**是不是很熟悉，前面的文章已经介绍过了，此处需要自定义来返回定制的提示信息。</span><br><span class="line"></span><br><span class="line">创建**OAuthServerAuthenticationEntryPoint**，实现AuthenticationEntryPoint，重写其中的方法，代码如下：</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  public class OAuthServerAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line">  </span><br><span class="line">      /**</span><br><span class="line">       * 认证失败处理器会调用这个方法返回提示信息</span><br><span class="line">       * TODO 实际开发中可以自己定义，此处直接返回JSON数据：客户端认证失败错误提示</span><br><span class="line">       */</span><br><span class="line">      @Override</span><br><span class="line">      public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException &#123;</span><br><span class="line">          ResponseUtils.result(response,new ResultMsg(ResultCode.CLIENT_AUTHENTICATION_FAILED.getCode(),ResultCode.CLIENT_AUTHENTICATION_FAILED.getMsg(),null));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="三、改造ClientCredentialsTokenEndpointFilter"><a href="#三、改造ClientCredentialsTokenEndpointFilter" class="headerlink" title="三、改造ClientCredentialsTokenEndpointFilter"></a><strong>三、改造ClientCredentialsTokenEndpointFilter</strong></h4><p><strong>ClientCredentialsTokenEndpointFilter</strong>这个过滤器的主要作用就是校验客户端的ID、秘钥，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuthServerClientCredentialsTokenEndpointFilter extends ClientCredentialsTokenEndpointFilter &#123;</span><br><span class="line"></span><br><span class="line">    private final AuthorizationServerSecurityConfigurer configurer;</span><br><span class="line"></span><br><span class="line">    private AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     * @param configurer AuthorizationServerSecurityConfigurer对昂</span><br><span class="line">     * @param authenticationEntryPoint 自定义的AuthenticationEntryPoint</span><br><span class="line">     */</span><br><span class="line">    public OAuthServerClientCredentialsTokenEndpointFilter(AuthorizationServerSecurityConfigurer configurer, AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">        System.out.println(&quot;自定义的客户端认证的过滤器的构造方法&quot;);</span><br><span class="line">        this.configurer = configurer;</span><br><span class="line">        this.authenticationEntryPoint=authenticationEntryPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setAuthenticationEntryPoint(AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">        System.out.println(&quot;setAuthenticationEntryPoint&quot;);</span><br><span class="line">        this.authenticationEntryPoint = authenticationEntryPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 需要重写这个方法，返回AuthenticationManager</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationManager getAuthenticationManager() &#123;</span><br><span class="line">        System.out.println(&quot;getAuthenticationManager&quot;);</span><br><span class="line">        return configurer.and().getSharedObject(AuthenticationManager.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置AuthenticationEntryPoint主要逻辑</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        System.out.println(&quot;设置AuthenticationEntryPoint主要逻辑&quot;);</span><br><span class="line">        //TODO 定制认证失败处理器，开发中可以自己修改</span><br><span class="line">        setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;</span><br><span class="line">            if (exception instanceof BadCredentialsException) &#123;</span><br><span class="line">                exception = new BadCredentialsException(exception.getMessage(), new BadClientCredentialsException());</span><br><span class="line">            &#125;</span><br><span class="line">            authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">        &#125;);</span><br><span class="line">        //成功处理器，和父类相同，为空即可。</span><br><span class="line">        setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个重要的部分需要讲一下，如下：</p><ul><li>构造方法中需要传入第2步自定义的 <strong>OAuthServerAuthenticationEntryPoint</strong></li><li>重写 <strong>getAuthenticationManager()</strong> 方法返回IOC中的AuthenticationManager</li><li>重写<strong>afterPropertiesSet()</strong> 方法，用于自定义认证失败、成功处理器，失败处理器中调用<strong>OAuthServerAuthenticationEntryPoint</strong>进行异常提示信息返回</li></ul><h4 id="四、OAuth配置文件中指定过滤器"><a href="#四、OAuth配置文件中指定过滤器" class="headerlink" title="四、OAuth配置文件中指定过滤器"></a><strong>四、OAuth配置文件中指定过滤器</strong></h4><p>只需要将自定义的过滤器添加到<strong>AuthorizationServerSecurityConfigurer</strong>中，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) &#123;</span><br><span class="line">        System.out.println(&quot;配置令牌访问的安全约束&quot;);</span><br><span class="line">        //自定义ClientCredentialsTokenEndpointFilter，用于处理客户端id，密码错误的异常</span><br><span class="line">        ①OAuthServerClientCredentialsTokenEndpointFilter endpointFilter = new OAuthServerClientCredentialsTokenEndpointFilter(security,authenticationEntryPoint);</span><br><span class="line">       ① endpointFilter.afterPropertiesSet();</span><br><span class="line">        ①security.addTokenEndpointAuthenticationFilter(endpointFilter);</span><br><span class="line"></span><br><span class="line">        security</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                //开启/oauth/token_key验证端口权限访问</span><br><span class="line">                .tokenKeyAccess(&quot;permitAll()&quot;)</span><br><span class="line">                //开启/oauth/check_token验证端口认证权限访问</span><br><span class="line">                .checkTokenAccess(&quot;permitAll()&quot;);</span><br><span class="line">               ② //一定不要添加allowFormAuthenticationForClients，否则自定义的OAuthServerClientCredentialsTokenEndpointFilter不生效</span><br><span class="line">//                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第<strong>①</strong>部分是添加过滤器，其中<strong>authenticationEntryPoint</strong>使用的是第2步自定义的<strong>OAuthServerAuthenticationEntryPoint</strong></p><p>第<strong>②</strong>部分一定要注意：一定要去掉这行代码，具体原因源码解释。</p><h4 id="五、源码追踪"><a href="#五、源码追踪" class="headerlink" title="五、源码追踪"></a><strong>五、源码追踪</strong></h4><h6 id="I、OAuthServerAuthenticationEntryPoint在何时调用？"><a href="#I、OAuthServerAuthenticationEntryPoint在何时调用？" class="headerlink" title="I、OAuthServerAuthenticationEntryPoint在何时调用？"></a><strong>I、OAuthServerAuthenticationEntryPoint在何时调用？</strong></h6><p>OAuthServerAuthenticationEntryPoint这个过滤器继承了 <strong>AbstractAuthenticationProcessingFilter</strong> 这个抽象类，一切的逻辑都在 <strong>doFilter()</strong> 中，陈某简化了其中的关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)</span><br><span class="line">throws IOException, ServletException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //调用子类的attemptAuthentication方法，获取参数并且认证</span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line">&#125;</span><br><span class="line">catch (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">            //一旦认证异常，则调用unsuccessfulAuthentication方法，通过failureHandler处理</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">catch (AuthenticationException failed) &#123;</span><br><span class="line">            //一旦认证异常，则调用unsuccessfulAuthentication方法，通过failureHandler处理</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//认证成功，则调用successHandler处理</span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码在 <strong>unsuccessfulAuthentication()</strong> 这个方法中，代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;</span><br><span class="line">    SecurityContextHolder.clearContext();</span><br><span class="line">    if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">        this.logger.debug(&quot;Authentication request failed: &quot; + failed.toString(), failed);</span><br><span class="line">        this.logger.debug(&quot;Updated SecurityContextHolder to contain null Authentication&quot;);</span><br><span class="line">        this.logger.debug(&quot;Delegating to authentication failure handler &quot; + this.failureHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.rememberMeServices.loginFail(request, response);</span><br><span class="line">    this.failureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="II、自定义的过滤器如何生效的？"><a href="#II、自定义的过滤器如何生效的？" class="headerlink" title="II、自定义的过滤器如何生效的？"></a><strong>II、自定义的过滤器如何生效的？</strong></h6><p>这个就要看 <strong>AuthorizationServerSecurityConfigurer#configure()</strong> 这个方法了，其中有一段代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(var2.hasNext()) &#123;</span><br><span class="line">    Filter filter = (Filter)var2.next();</span><br><span class="line">    http.addFilterBefore(filter, BasicAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，我们自定义的过滤链被加到了BasicAuthenticationFilter里面</p><h6 id="III、为什么不能加-allowFormAuthenticationForClients-？"><a href="#III、为什么不能加-allowFormAuthenticationForClients-？" class="headerlink" title="III、为什么不能加.allowFormAuthenticationForClients()？"></a><strong>III、为什么不能加.allowFormAuthenticationForClients()？</strong></h6><p>还是在 <strong>AuthorizationServerSecurityConfigurer#configure()</strong> 这个方法中，一旦设置了 <strong>allowFormAuthenticationForClients</strong> 为true，则会创建 <strong>ClientCredentialsTokenEndpointFilter</strong>，此时自定义的自然失效了。</p><h2 id="【2】资源服务自定义异常信息"><a href="#【2】资源服务自定义异常信息" class="headerlink" title="【2】资源服务自定义异常信息"></a><strong>【2】资源服务自定义异常信息</strong></h2><p>下面针对上述两种异常分别定制异常提示信息，这个比认证服务定制简单。</p><h3 id="1、自定义返回结果：没有权限访问时"><a href="#1、自定义返回结果：没有权限访问时" class="headerlink" title="1、自定义返回结果：没有权限访问时"></a><strong>1、自定义返回结果：没有权限访问时</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">ServerAccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange, AccessDeniedException denied)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;RequestAccessDeniedHandler&quot;</span>);</span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.OK);</span><br><span class="line">        response.getHeaders().add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        System.out.println(<span class="string">&quot;wuquan2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String body= JSONUtil.toJsonStr(<span class="keyword">new</span> <span class="title class_">ResultMsg</span>(ResultCode.NO_PERMISSION.getCode(),ResultCode.NO_PERMISSION.getMsg(),<span class="literal">null</span>));</span><br><span class="line">        <span class="type">DataBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span>  response.bufferFactory().wrap(body.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、用于处理没有登录或token过期时的自定义返回结果"><a href="#2、用于处理没有登录或token过期时的自定义返回结果" class="headerlink" title="2、用于处理没有登录或token过期时的自定义返回结果"></a><strong>2、用于处理没有登录或token过期时的自定义返回结果</strong></h3><h1 id="令牌配置"><a href="#令牌配置" class="headerlink" title="令牌配置"></a>令牌配置</h1><h2 id="【1】令牌本身的配置"><a href="#【1】令牌本身的配置" class="headerlink" title="【1】令牌本身的配置"></a>【1】令牌本身的配置</h2><ul><li>令牌相关的配置都放在了AccessTokenConfig这个配置类中，代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 令牌的存储策略</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public TokenStore tokenStore() &#123;</span><br><span class="line">        //使用JwtTokenStore生成JWT令牌</span><br><span class="line">        return new JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JwtAccessTokenConverter</span><br><span class="line">     * TokenEnhancer的子类，在JWT编码的令牌值和OAuth身份验证信息之间进行转换。</span><br><span class="line">     * TODO：后期可以使用非对称加密</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAccessTokenConverter jwtAccessTokenConverter()&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = new JwtAccessTokenEnhancer();</span><br><span class="line">        // 设置秘钥</span><br><span class="line">        converter.setSigningKey(TokenConstant.SIGN_KEY);</span><br><span class="line">        /*</span><br><span class="line">         * 设置自定义得的令牌转换器，从map中转换身份信息</span><br><span class="line">         * fix(*)：修复刷新令牌无法获取用户详细信息的问题</span><br><span class="line">         */</span><br><span class="line">        converter.setAccessTokenConverter(new JwtEnhanceAccessTokenConverter());</span><br><span class="line">        return converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JWT令牌增强，继承JwtAccessTokenConverter</span><br><span class="line">     * 将业务所需的额外信息放入令牌中，这样下游微服务就能解析令牌获取</span><br><span class="line">     */</span><br><span class="line">    public static class JwtAccessTokenEnhancer extends JwtAccessTokenConverter &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 重写enhance方法，在其中扩展</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) &#123;</span><br><span class="line">            Object principal = authentication.getUserAuthentication().getPrincipal();</span><br><span class="line">            if (principal instanceof SecurityUser)&#123;</span><br><span class="line">                //获取userDetailService中查询到用户信息</span><br><span class="line">                SecurityUser user=(SecurityUser)principal;</span><br><span class="line">                //将额外的信息放入到LinkedHashMap中</span><br><span class="line">                LinkedHashMap&lt;String,Object&gt; extendInformation=new LinkedHashMap&lt;&gt;();</span><br><span class="line">                //设置用户的userId</span><br><span class="line">                extendInformation.put(TokenConstant.USER_ID,user.getUserId());</span><br><span class="line">                //添加到additionalInformation</span><br><span class="line">                ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(extendInformation);</span><br><span class="line">            &#125;</span><br><span class="line">            return super.enhance(accessToken, authentication);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>1、JwtAccessTokenConverter</strong></li></ul><p>令牌增强类，用于JWT令牌和OAuth身份进行转换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public JwtAccessTokenConverter jwtAccessTokenConverter()&#123;</span><br><span class="line">    JwtAccessTokenConverter converter = new JwtAccessTokenEnhancer();</span><br><span class="line">    // 设置秘钥</span><br><span class="line">    converter.setSigningKey(TokenConstant.SIGN_KEY);</span><br><span class="line">    /*</span><br><span class="line">     * 设置自定义得的令牌转换器，从map中转换身份信息</span><br><span class="line">     * fix(*)：修复刷新令牌无法获取用户详细信息的问题</span><br><span class="line">     */</span><br><span class="line">    converter.setAccessTokenConverter(new JwtEnhanceAccessTokenConverter());</span><br><span class="line">    return converter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>2、TokenStore</strong></li></ul><p>令牌的存储策略，这里使用的是JwtTokenStore，使用JWT的令牌生成方式，其实还有以下两个比较常用的方式</p><ul><li><ul><li>RedisTokenStore：将令牌存储到Redis中，此种方式相对于内存方式来说性能更好</li><li>JdbcTokenStore：将令牌存储到数据库中，需要新建从对应的表，有兴趣的可以尝试</li></ul></li><li><p><strong>3</strong>、<strong>SIGN_KEY</strong></p></li></ul><p>JWT签名的秘钥，这里使用的是对称加密，资源服务中也要使用相同的秘钥进行校验和解析JWT令牌。</p><h2 id="【2】令牌管理服务的配置"><a href="#【2】令牌管理服务的配置" class="headerlink" title="【2】令牌管理服务的配置"></a>【2】令牌管理服务的配置</h2><p><strong>这个放在了AuthorizationServerConfig这个配置类中，代码如下：</strong></p><ul><li><strong>使用的是DefaultTokenServices这个实现类，其中可以配置令牌相关的内容，比如access_token、refresh_token的过期时间，默认时间分别为12小时、30天。</strong></li><li><strong>最重要的一行代码当然是设置令牌增强，使用JWT方式生产令牌，如下：services.setTokenEnhancer(jwtAccessTokenConverter);</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> AuthorizationServerTokenServices <span class="title function_">tokenServices</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;令牌管理服务的配置&quot;</span>);</span><br><span class="line">    <span class="type">DefaultTokenServices</span> <span class="variable">services</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTokenServices</span>();</span><br><span class="line">    <span class="comment">//客户端端配置策略</span></span><br><span class="line">    services.setClientDetailsService(clientDetailsService);</span><br><span class="line">    <span class="comment">//支持令牌的刷新</span></span><br><span class="line">    services.setSupportRefreshToken(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//令牌服务</span></span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    <span class="comment">//access_token的过期时间</span></span><br><span class="line">    services.setAccessTokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//refresh_token的过期时间</span></span><br><span class="line">    services.setRefreshTokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置令牌增强，使用JwtAccessTokenConverter进行转换</span></span><br><span class="line">    services.setTokenEnhancer(jwtAccessTokenConverter);</span><br><span class="line">    <span class="keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【3】、令牌访问端点添加tokenServices"><a href="#【3】、令牌访问端点添加tokenServices" class="headerlink" title="【3】、令牌访问端点添加tokenServices"></a>【3】、令牌访问端点添加tokenServices</h2><h1 id="前置知识：security"><a href="#前置知识：security" class="headerlink" title="前置知识：security"></a>前置知识：security</h1><h2 id="security的核心，Spring-Security使用了springSecurityFilterChain作为了安全过滤的入口"><a href="#security的核心，Spring-Security使用了springSecurityFilterChain作为了安全过滤的入口" class="headerlink" title="security的核心，Spring Security使用了springSecurityFilterChain作为了安全过滤的入口"></a>security的核心，Spring Security使用了springSecurityFilterChain作为了安全过滤的入口</h2><h2 id="【1】Spring-Security过滤器"><a href="#【1】Spring-Security过滤器" class="headerlink" title="【1】Spring Security过滤器"></a>【1】Spring Security过滤器</h2><h3 id="1、核心过滤器概述"><a href="#1、核心过滤器概述" class="headerlink" title="1、核心过滤器概述"></a>1、核心过滤器概述</h3><p>从控制台打印过滤器可见</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.security.web.util.matcher.AnyRequestMatcher@<span class="number">1</span>,</span><br><span class="line">[</span><br><span class="line">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@184de357,</span><br><span class="line">    org.springframework.security.web.context.SecurityContextPersistenceFilter@521ba38f,</span><br><span class="line">    org.springframework.security.web.header.HeaderWriterFilter@77bb916f,</span><br><span class="line">    org.springframework.security.web.csrf.CsrfFilter@76b305e1,</span><br><span class="line">    org.springframework.security.web.authentication.logout.LogoutFilter@17c53dfb,</span><br><span class="line">    org.springframework.security.web.savedrequest.RequestCacheAwareFilter@2086d469,</span><br><span class="line">    org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter<span class="meta">@b1d19ff</span>,</span><br><span class="line">    org.springframework.security.web.authentication.AnonymousAuthenticationFilter<span class="meta">@efe49ab</span>,</span><br><span class="line">    org.springframework.security.web.session.SessionManagementFilter@5a48d186,</span><br><span class="line">    org.springframework.security.web.access.ExceptionTranslationFilter@273aaab7</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>SecurityContextPersistenceFilter 两个主要职责：请求来临时，创建SecurityContext安全上下文信息，请求结束时清空SecurityContextHolder。</li><li>HeaderWriterFilter (文档中并未介绍，非核心过滤器) 用来给http响应添加一些Header,比如X-Frame-Options, X-XSS-Protection*，X-Content-Type-Options.</li><li>CsrfFilter 在spring4这个版本中被默认开启的一个过滤器，用于防止csrf攻击，了解前后端分离的人一定不会对这个攻击方式感到陌生，前后端使用json交互需要注意的一个问题。</li><li>LogoutFilter 顾名思义，处理注销的过滤器</li><li>UsernamePasswordAuthenticationFilter 这个会重点分析，表单提交了username和password，被封装成token进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。</li><li>RequestCacheAwareFilter (文档中并未介绍，非核心过滤器) 内部维护了一个RequestCache，用于缓存request请求</li><li>SecurityContextHolderAwareRequestFilter 此过滤器对ServletRequest进行了一次包装，使得request具有更加丰富的API</li><li>AnonymousAuthenticationFilter 匿名身份过滤器，这个过滤器个人认为很重要，需要将它</li><li>UsernamePasswordAuthenticationFilter 放在一起比较理解，spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。</li><li>SessionManagementFilter 和session相关的过滤器，内部维护了一个SessionAuthenticationStrategy，两者组合使用，常用来防止session-fixation protection attack，以及限制同一用户开启多个会话的数量</li><li>ExceptionTranslationFilter 直译成异常翻译过滤器，还是比较形象的，这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理，具体是那些类下面详细介绍</li><li>FilterSecurityInterceptor 这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的</li></ul><h2 id="【2】Spring-Security核心过滤器解析"><a href="#【2】Spring-Security核心过滤器解析" class="headerlink" title="【2】Spring Security核心过滤器解析"></a>【2】Spring Security核心过滤器解析</h2><h3 id="1、SecurityContextPersistenceFilter"><a href="#1、SecurityContextPersistenceFilter" class="headerlink" title="1、SecurityContextPersistenceFilter"></a>1、SecurityContextPersistenceFilter</h3><p>SecurityContextPersistenceFilter的两个主要作用便是请求来临时，创建SecurityContext安全上下文信息和请求结束时清空SecurityContextHolder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILTER_APPLIED</span> <span class="operator">=</span> <span class="string">&quot;__spring_security_scpf_applied&quot;</span>;</span><br><span class="line">   <span class="comment">//安全上下文存储的仓库</span></span><br><span class="line">   <span class="keyword">private</span> SecurityContextRepository repo;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">SecurityContextPersistenceFilter</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//HttpSessionSecurityContextRepository是SecurityContextRepository接口的一个实现类</span></span><br><span class="line">      <span class="comment">//使用HttpSession来存储SecurityContext</span></span><br><span class="line">      <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">HttpSessionSecurityContextRepository</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">      <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">      <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// ensure that filter is only applied once per request</span></span><br><span class="line">         chain.doFilter(request, response);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">      <span class="comment">//包装request，response</span></span><br><span class="line">      <span class="type">HttpRequestResponseHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpRequestResponseHolder</span>(request,</span><br><span class="line">            response);</span><br><span class="line">      <span class="comment">//从Session中获取安全上下文信息</span></span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> repo.loadContext(holder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//请求开始时，设置安全上下文信息，这样就避免了用户直接从Session中获取安全上下文信息</span></span><br><span class="line">         SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">         chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">//请求结束后，清空安全上下文信息</span></span><br><span class="line">         <span class="type">SecurityContext</span> <span class="variable">contextAfterChainExecution</span> <span class="operator">=</span> SecurityContextHolder</span><br><span class="line">               .getContext();</span><br><span class="line">         SecurityContextHolder.clearContext();</span><br><span class="line">         repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">               holder.getResponse());</span><br><span class="line">         request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">         <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;SecurityContextHolder now cleared, as request processing completed&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、SecurityContextPersistenceFilter"><a href="#2、SecurityContextPersistenceFilter" class="headerlink" title="2、SecurityContextPersistenceFilter"></a>2、SecurityContextPersistenceFilter</h3><p>内部调用了authenticationManager完成认证，根据认证结果执行successfulAuthentication或者unsuccessfulAuthentication，无论成功失败，一般的实现都是转发或者重定向等处理，不再细究AuthenticationSuccessHandler和AuthenticationFailureHandler，有兴趣的朋友，可以去看看两者的实现类。</p><h3 id="2-3-AnonymousAuthenticationFilter"><a href="#2-3-AnonymousAuthenticationFilter" class="headerlink" title="2.3 AnonymousAuthenticationFilter"></a>2.3 AnonymousAuthenticationFilter</h3><p>匿名认证过滤器，可能有人会想：匿名了还有身份？我自己对于Anonymous匿名身份的理解是Spring Security为了整体逻辑的统一性，即使是未通过认证的用户，也给予了一个匿名身份。而AnonymousAuthenticationFilter该过滤器的位置也是非常的科学的，它位于常用的身份认证过滤器（如UsernamePasswordAuthenticationFilter、BasicAuthenticationFilter、RememberMeAuthenticationFilter）之后，意味着只有在上述身份过滤器执行完毕后，SecurityContext依旧没有用户信息，AnonymousAuthenticationFilter该过滤器才会有意义—-基于用户一个匿名身份。</p><h3 id="2-4-ExceptionTranslationFilter"><a href="#2-4-ExceptionTranslationFilter" class="headerlink" title="2.4 ExceptionTranslationFilter"></a>2.4 ExceptionTranslationFilter</h3><p>ExceptionTranslationFilter异常转换过滤器位于整个springSecurityFilterChain的后方，用来转换整个链路中出现的异常，将其转化，顾名思义，转化以意味本身并不处理。一般其只处理两大类异常：AccessDeniedException访问异常和AuthenticationException认证异常。</p><p>这个过滤器非常重要，因为它将Java中的异常和HTTP的响应连接在了一起，这样在处理异常时，我们不用考虑密码错误该跳到什么页面，账号锁定该如何，只需要关注自己的业务逻辑，抛出相应的异常便可。如果该过滤器检测到AuthenticationException，则将会交给内部的AuthenticationEntryPoint去处理，如果检测到AccessDeniedException，需要先判断当前用户是不是匿名用户，如果是匿名访问，则和前面一样运行AuthenticationEntryPoint，否则会委托给AccessDeniedHandler去处理，而AccessDeniedHandler的默认实现，是AccessDeniedHandlerImpl。所以ExceptionTranslationFilter内部的AuthenticationEntryPoint是至关重要的，顾名思义：认证的入口点。</p><h3 id="2-5-FilterSecurityInterceptor"><a href="#2-5-FilterSecurityInterceptor" class="headerlink" title="2.5 FilterSecurityInterceptor"></a>2.5 FilterSecurityInterceptor</h3><p>我们已经有了认证，有了请求的封装，有了Session的关联，还缺一个：由什么控制哪些资源是受限的，这些受限的资源需要什么权限，需要什么角色…这一切和访问控制相关的操作，都是由FilterSecurityInterceptor完成的。</p><p>FilterSecurityInterceptor的工作流程可以理解如下：FilterSecurityInterceptor从SecurityContextHolder中获取Authentication对象，然后比对用户拥有的权限和资源所需的权限。前者可以通过Authentication对象直接获得，而后者则需要引入我们之前一直未提到过的两个类：SecurityMetadataSource，AccessDecisionManager。理解清楚决策管理器的整个创建流程和SecurityMetadataSource的作用需要花很大一笔功夫，这里，暂时只介绍其大概的作用</p>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线性表</title>
      <link href="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"/>
      <url>/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/</url>
      
        <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ul><li><p>线性结构特点：在数据元素的非空有限集合中</p><ul><li>(1)存在唯一的一个被称做“第一个”的数据元素；</li><li>(2)存在唯一的一个被称做“最后一个”的数据元素；</li></ul></li><li><p>(3)除第一个之外，集合中的每个数据元素均只有一个前驱；(4)除最后一个之外，集合中每个数据元素均只有一个后继。</p></li><li><p>线性表定义：有限个性质相同的数据元素组成的序列。</p><span id="more"></span></li><li><p>线性表的存储结构：顺序存储结构和链式存储结构</p></li></ul><blockquote><p>顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。</p><p>通常用一维数组来描述数据结构中的顺序存储结构。</p></blockquote><blockquote><p>链式存储结构: 其结点在存储器中的位置是随意的，即逻辑上相邻的数据元素在物理上不一定相邻。通过指针来实现。</p></blockquote><p><img src="/../img/2-1.png"></p><ul><li><p>顺序表<br>顺序表把线性表的所有元素按照其逻辑顺序，依次存储到从指定的存储位置开始的一块连续的存储结构空间中中。</p></li><li><p>链表<br>在存储链表中，每个节点不仅包含所存元素的信息，还包含元素之间逻辑关系的信息。可以通过前驱结点中的地址信息找到后继结点的位置。</p></li><li><p>两者存储结构比较</p><ul><li>顺序表的特性：(其实就是数组)<br><strong>随机</strong>访问特性。<br>占用<strong>连续</strong>的存储空间。</li><li>链表的特性：<br><strong>不支持随机访问</strong>的特性。<br>结点的存储空间利用率较顺序表稍微低一些。<br>不需要一次性划分所有结点所需空间给链表。</li><li>链表支持存储空间的动态分配。<br>顺序表在做插入操作的时候需要移动多个元素<br>链表进行插入操作无需移动元素</li></ul></li><li><p>4.链表的5种形式</p><ul><li><p>1 单链表</p><ul><li>带<strong>头结点</strong>与<strong>不带头结点</strong>的区别：</li></ul><p>带头结点的单链表有一个结点不存储信息，而不带头结点的单链表所有结点都存储信息。</p><p><img src="/../img/2-2.png"></p></li><li><p>2 双链表</p><p>- </p></li><li><p>3 循环单链表</p><ul><li><p>环单链表可以实现从任一结点出发访问链表的任何结点，而单链表从任一结点出发后只能访问这个结点本身及其后边的所有结点。带头结点的循环单链表，<em><strong>链表空</strong></em>，head&#x3D;head-&gt;next;不带头结点，<strong>链表空</strong>，head&#x3D;NULL</p><p><img src="/../img/2-4.png"></p></li></ul></li><li><p>4 循环双链表</p><ul><li><p>循环双链表即终端结点的next指针指向链表中的第一个结点，将链表中第一个结点的prior指针指向终端结点</p><p><img src="/../img/2-5.png"></p></li></ul></li><li><p>5 静态链表</p><ul><li><p>静态链表借助一维数组来表示。静态链表来自于一个<strong>结构体数组</strong>，数组中每一个结点含有两个分量：一个数据元素分量data;另个一个是指针分量，指示了当前结点的直接后继结点在数组中的位置。</p><p><img src="/../img/2-6.png"></p></li></ul><h3 id="考研中遇到考顺序表和链表的比较："><a href="#考研中遇到考顺序表和链表的比较：" class="headerlink" title="考研中遇到考顺序表和链表的比较："></a>考研中遇到考顺序表和链表的比较：</h3><ul><li>基于空间的比较</li></ul><p>1.存储方式的比较：</p><p>顺序表的存储空间是一次性分配，链表的存储空间是多次分配。</p><p>2.存储密度：(存储密度&#x3D;结点值域所占存储量&#x2F;结点结构所占的存储量)：</p><p>顺序表的存储密度&#x3D;1，链表的存储密度&lt;1(因为结点中有指针域)</p><ul><li>基于时间的比较</li></ul><p>1.存储方式：</p><p>顺序表可以随机存储，也可以顺序存储，链表只能顺序存储</p><p>2.插入、删除时移动元素的个数:</p><p>顺序表平均需要移动一半的元素；链表不需要移动，只需要修改指针。</p><p>对顺序表平均需要移动近一半元素，链表不需要移动元素，只需要修改指针。</p><p>具有n个元素的顺序表，插入一个元素所进行的平均移动个数是多少，</p><p>1）求概率，是随机的，可能性相同，有n个可插入位置，所以任何一个位置被插入元素的概率为p&#x3D;1&#x2F;n；</p><p>2）求对应于每个插入位置需要移动元素个数。</p><p>假设要把新元素插入在表中第i个圆度之后，则需要将第i个元素之后的所有元素往后移动一个为置，因此移动元素个数为n-i。</p><p>由1和2可知，移动元素个数的期望E为：</p><p>E&#x3D;n-1&#x2F;2</p><p>插入和删除算法的平均时间复杂度为O（n).</p></li></ul><h4 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">1.</span>线性表的顺序存储又称顺序表</span><br><span class="line">&gt; <span class="number">2.</span>元素的逻辑顺序与物理顺序相同</span><br><span class="line">&gt; <span class="number">3.</span>顺序存储结构是一种随机存储结构</span><br><span class="line">&gt; <span class="number">4.</span>特点：</span><br><span class="line">&gt; <span class="number">1</span>）顺序表的随机访问：通过首地址和元素符号在<span class="built_in">O</span>(<span class="number">1</span>)时间内找到指定的元素</span><br><span class="line">&gt;<span class="number">2</span>）储存密度高，每个节点只存储数据元素</span><br><span class="line">&gt;<span class="number">3</span>）由于逻辑相邻与物理相邻，所以插入和删除操作需要移动大量的元素</span><br><span class="line">一维数组可以是静态分配的，也可以是动态分配的。</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50  <span class="comment">//定义线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">ElemType data[MaxSize];   <span class="comment">//顺序表的元素</span></span><br><span class="line"><span class="type">int</span> length;  <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;  <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line">动态分配时，存储数组的空间是在程序执行过程中通过动态存储语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为顺序表一次性划分所有空间。</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100  <span class="comment">//表长度的初始定义</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">ElemType *data;   <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line"><span class="type">int</span> MaxSize,length;  <span class="comment">//数组最大容量和当前定义</span></span><br><span class="line">&#125;SeqList;  <span class="comment">//动态分配数组顺序表的类型定义</span></span><br><span class="line">分配存储空间的语句</span><br><span class="line">C：  L.data=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*InitSize);</span><br><span class="line">C++： L.data=<span class="keyword">new</span> <span class="built_in">ElemType</span>(InitSize);</span><br><span class="line">注意：动态分配并不是链式存储，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时动态决定。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>插入操作 【在顺序表L的第i（<span class="number">1</span>&lt;i&lt;L.length+<span class="number">1</span>）个位置插入新元素e】</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>)  <span class="comment">// 判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(L.length&gt;=MaxSize)<span class="comment">//当前存储空间已满不能插入</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)  <span class="comment">//将第i个即以后元素往后移</span></span><br><span class="line">L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">L.data[i<span class="number">-1</span>]=e;   <span class="comment">//在位置i放置e</span></span><br><span class="line">L.lenght++;      <span class="comment">//线性表长度+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">................</span><br><span class="line">&#125;</span><br><span class="line">注意：区别顺序表的位序和数组下标。为何判断插入位置是否合法时 <span class="keyword">if</span>语句中用length+<span class="number">1</span>，而移动元素的<span class="keyword">for</span>语句中只用length？</span><br><span class="line">答：</span><br><span class="line"><span class="number">1.</span>首先明确，位序从 <span class="number">1</span> 开始，数组下标从 <span class="number">0</span> 开始；这里 i 是指 位序；</span><br><span class="line"><span class="number">2.</span><span class="keyword">if</span>语句：分析两种种情况(前提：线性表未满)：</span><br><span class="line"><span class="number">1</span>）length+<span class="number">2</span>的情况：i的范围是[<span class="number">1</span>，length+<span class="number">2</span>],length+<span class="number">2</span>所插入的位置在顺序表上是断档，违背顺序表定义（一组地址连续的存储单元逻辑上相邻的两个元素的物理位置上也相邻）</span><br><span class="line"><span class="number">2</span>）length的情况：i的范围是[<span class="number">1</span>，length],顺序表上length+<span class="number">1</span>位置是空的</span><br><span class="line"></span><br><span class="line"><span class="number">3.f</span><span class="keyword">or</span>语句：到<span class="keyword">for</span>语句时，说明至少有一个可插入的位置；</span><br><span class="line">   j=L.length时，保证最后一个数组元素可以移到数组的后一个位置而不产生数组越界异常</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>在不同位置进行插入操作的时间复杂度（n为length）</span><br><span class="line"><span class="number">1</span>)最好情况：表尾插入（i=n+<span class="number">1</span>），元素后移语句不执行，复杂度<span class="built_in">O</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">2</span>)最坏情况：表头插入(i=<span class="number">1</span>)，元素后移语句执行n次，复杂度<span class="built_in">O</span>(n);</span><br><span class="line"><span class="number">3</span>)平均情况：略，复杂度<span class="built_in">O</span>(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>删除操作 【删除顺序表L中第<span class="built_in">i</span>(<span class="number">1</span>&lt;=i&lt;=L.length)个位置的元素，用引用变量e返回】</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">reutrn <span class="literal">false</span>;</span><br><span class="line">e=L.data[i<span class="number">-1</span>];     <span class="comment">//e保存将要被删的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)    <span class="comment">//第i个位置后的元素前移</span></span><br><span class="line">L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">................</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>在不同位置进行删除操作的时间复杂度（n为length）</span><br><span class="line"><span class="number">1</span>)最好情况：删除表尾元素(i=n)，元素前移语句不执行，复杂度<span class="built_in">O</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">2</span>)最坏情况：删除表头元素（i=<span class="number">1</span>），元素前移语句执行n次，复杂度<span class="built_in">O</span>(n);</span><br><span class="line"><span class="number">3</span>)平均情况：略，复杂度<span class="built_in">O</span>(n);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>按值查找（顺序查找）【在顺序表L中查找第一个元素值等于e的元素，并返回其位序】</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,Elem e)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line"><span class="keyword">if</span>(L.data[i]===e)</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">................</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>时间复杂度（n为length）</span><br><span class="line"><span class="number">1</span>)最好情况：查找的元素就在表头，仅需比较<span class="number">1</span>次，复杂度为<span class="built_in">O</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">2</span>)最坏情况：查找的元素就在表尾，需比较n次，复杂度为<span class="built_in">O</span>(n);</span><br><span class="line"><span class="number">3</span>)平均情况：略，<span class="built_in">O</span>(n);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h3><p>例题将AB，插入C中 归并，尾插</p><p><img src="/../img/2-7.png"></p><p><img src="/../img/2-8.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span><br><span class="line">&#123;</span><br><span class="line"> LNode *P=A-&gt;next;<span class="comment">//p来跟踪A的最小值结点。A-&gt;next表示A链表的开始结点（头结点后边一个结点），A链表是递增，所以最前面的是最小节点。</span></span><br><span class="line">    LNode *q=B-&gt;next;</span><br><span class="line">    LNode *r;<span class="comment">//r始终指向C的终端结点</span></span><br><span class="line">    C=A;<span class="comment">//用A的头结点做C的头结点</span></span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);<span class="comment">//B头结点无用，释放掉</span></span><br><span class="line">    r=C;<span class="comment">//r指向C，因此头结点是终端结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)<span class="comment">//当p与q不空时，选取p与q所指结点中较小的插入c的尾部，</span></span><br><span class="line">       <span class="comment">//以下的if else语句中，r始终指向当前链表终端结点，作为接纳新结点的一个媒介，通过他，新节点被链接入c并且重新指向新的终端接点，以便接受下一个新节点，这里是尾插法的思想</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next=p;p=p-&gt;next;</span><br><span class="line">            r=er-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next=q;q=q-&gt;next</span><br><span class="line">                r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>；</span><br><span class="line">        <span class="comment">//以下两个语句将还有剩余的结点的链表连接在C的尾部</span></span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) r-&gt;next=p;</span><br><span class="line">        <span class="keyword">if</span>(q!=<span class="literal">NULL</span>) r-next=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>假设有n个元素已经存储数组a中，用尾插法建立链表c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createlistR</span><span class="params">(LNode *&amp;C,<span class="type">int</span> a[],<span class="type">int</span> n)</span><span class="comment">//要改变的变量用引用型</span></span><br><span class="line">&#123;</span><br><span class="line">LNode *s,*r;<span class="comment">//s用来指向新申请的结点，r始终指向c的终端</span></span><br><span class="line">    <span class="type">int</span> i;<span class="comment">///</span></span><br><span class="line">    C=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//申请C的头结点空间</span></span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    r=c;<span class="comment">//r指向头结点，因为此时头结点就是终端结点</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++<span class="number">1</span>)<span class="comment">//循环申请n个结点来接受数组a中元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//s指向新申请的结点</span></span><br><span class="line">        s-&gt;data=a[i];<span class="comment">//用新申请的结点来接受a中的一个元素</span></span><br><span class="line">        r-&gt;next=s;<span class="comment">//用r来接纳新结点</span></span><br><span class="line">        r=r-&gt;next;<span class="comment">//r指向终端结点，以便于接纳下一个新到来的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;<span class="comment">//数组a中所有的元素都已经装入链表c中，c的终端结点的指针域置为为null，c建立完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>头插法建表</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createlistF</span><span class="params">(LNode *&amp;C,<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    C=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=a[i];</span><br><span class="line">        <span class="comment">//下面两句是头插法的关键</span></span><br><span class="line">        s-&gt;next=C-&gt;next;<span class="comment">//s所指新节点的指针域next指向C中的开始结点</span></span><br><span class="line">        C-&gt;next=s;<span class="comment">//头指针的指针域next指向s结点，使得s成为新的开始结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>归并成递减的单链表的算法</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span><br><span class="line">&#123;</span><br><span class="line">LNode *p=A-&gt;next;</span><br><span class="line">    LNode *q=B-&gt;next;</span><br><span class="line">    LNode *s;</span><br><span class="line">    C=A;</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="comment">//头插法</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            s=p;p=p-&gt;next;</span><br><span class="line">            s-&gt;next=C-&gt;next;</span><br><span class="line">            C-next=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s=q;q=q-&gt;next;</span><br><span class="line">            s-&gt;next=C-&gt;next;</span><br><span class="line">            C-&gt;next=s;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下边这两个循环是和求增递归并序列不同的地方，必须将剩余元素逐个插入c的头部才能得到最终递减序列</span></span><br><span class="line">    <span class="keyword">while</span>(p!<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=q;</span><br><span class="line">        q=q-&gt;next;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入操作</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-next=s;</span><br></pre></td></tr></table></figure><p><strong>删除操作</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure><h3 id="双链表的操作"><a href="#双链表的操作" class="headerlink" title="双链表的操作"></a>双链表的操作</h3><p><strong>1.采用尾插法建立双链表</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createDlistR</span><span class="params">(DLNode *&amp;L.<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    DLNode *s,*r;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    L=(DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">    L-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    r=L;<span class="comment">//和单链表一样，r始终指向终端结点，开始头结点也是尾结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));<span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data=a[i];</span><br><span class="line">       <span class="comment">//下面3句将s插入到L的尾部，并且r指向s。</span></span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        s-&gt;prior=r;</span><br><span class="line">        r=s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.查找结点的算法</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">在双链表中查找第一个值为x的结点，从第一个结点开始，边扫描边比较，若找到这样的结点，则返回结点指针，否则返回<span class="literal">NULL</span>。</span><br><span class="line"></span><br><span class="line">DLNode* <span class="title function_">findNode</span><span class="params">(DLNode *C.,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    DLNode *p=C-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-data==x)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//如果找到，则p中内容是结点地址（循环因break结束）；如果没找到，则p中内容是Null(循环因p等于NULL而结束)。因此这一句话将要求的两种返回值得情况统一起来。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.插入结点的算法</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">假设在双链表中p所指的结点之后插入一个结点s.</span><br><span class="line"></span><br><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">s-&gt;prior=p;</span><br><span class="line">p-&gt;next=s;</span><br><span class="line">s-&gt;next-&gt;prior=s;<span class="comment">//加入p指向最后一个结点，则本行可去掉</span></span><br></pre></td></tr></table></figure><p><img src="/../img/2-9.png"></p><p><strong>4.删除结点算法</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">设要删除双链表中p结点的后继结点</span><br><span class="line"></span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior=p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure><p><img src="/../img/2-10.png"></p><p>5.循环链表的操作<br>循环单链表和循环双链表是有对应的单链表和双链表改造来得，只需在终端结点和头结点建立联系即可。循环单链表终端结点的next结点指针向表头结点；循环双链表终端接结点的next指针指向表头结点，头结点的prior指针向表尾结点。需要注意的是，如果p指针压着循环链表行走，则判断p走到表尾结点的条件是p-&gt;next&#x3D;&#x3D;head.</p><p>6.逆置问题<br>给定一个线性表，如何将其中的元素逆置？可设置两个整型变量i和j，i指向最后一个元素，边交换i和j所指元素，边让i和j相向而行，直到遇到，实现代码如下：</p><p>假设元素存在于数组a[]中，left和right是数组两端元素的下标。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=left,j=right;i&lt;j;++i,--j)</span><br><span class="line">&#123;</span><br><span class="line">temp=a[i];</span><br><span class="line">a[i]=a[j];</span><br><span class="line">a[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/2-11.png"></p><p>分析：</p><p>（1）只需要逆置整个数组，即可满足前端k个元素逆序后放到数组的后端，如下图：</p><p><img src="/../img/2-12.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=left,j=right;i&lt;left+k;&amp;&amp;i&lt;j;++i,--j)</span><br><span class="line">&#123;</span><br><span class="line">temp=a[i];</span><br><span class="line">a[j]=a[j];</span><br><span class="line">a[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)只需要将前端k个元素逆置，然后将整个数组逆置，即满足前端k个元素保持原序放到数组后端，如下图</p><p><img src="/../img/2-13.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveToEnd</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//调用（1）中的实现的reverse()函数：</span></span><br><span class="line">reverse(a,<span class="number">0</span>,k<span class="number">-1</span>,k);</span><br><span class="line">reverse(a,<span class="number">0</span>,n<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)只需要将0p-1位置逆置，在将pn-1位置元素逆置，然后再将整个数组逆置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">movep</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//调用（1）中实现的reverse（）函数：</span></span><br><span class="line">reverse(a,<span class="number">0</span>,p<span class="number">-1</span>,p);</span><br><span class="line">reverse(a,p,n<span class="number">-1</span>,n-p);</span><br><span class="line">reverse(a,<span class="number">0</span>,n<span class="number">-1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构的基本概念</title>
      <link href="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="信息化时代"><a href="#信息化时代" class="headerlink" title="信息化时代"></a>信息化时代</h2><p><img src="/./../img/1-1.png" alt="xinxihua"></p><hr><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><span id="more"></span><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</p><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul><li><p>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的</p></li><li><p>数据的逻辑结构分为线性结构和非线性结构</p><ul><li>线性结构 （线性表 栈 数字 队列 ）</li><li>非线性结构<ul><li>集合</li><li>树形结构</li><li>图结构（网状结构）</li><li>二维数组、多维数组、广义表</li></ul></li></ul></li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。</p><ul><li>顺序存储：存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。）</li><li>链接存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。</li><li>索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。</li><li>散列存储：通过关键字直接计算出元素的物理地址（hash）。</li></ul><h3 id="算法的五个特征"><a href="#算法的五个特征" class="headerlink" title="算法的五个特征"></a>算法的五个特征</h3><ul><li>1，有穷性：有限步之后结束</li><li>2，确定性：不存在二义性，即没有歧义</li><li>3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。</li><li>4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。</li><li>5，输出：一至多个程序输出结果</li></ul><h3 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h3><ul><li>时间复杂度：<ul><li>• 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢；</li><li>• 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级</li><li>• T(n)&#x3D;O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度</li></ul></li><li>空间复杂度：<ul><li>• 它用来衡量算法随着问题规模增大，算法所需空间的快慢；</li><li>• 是问题规模的函数：S(n)&#x3D;O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/03/hello-world/"/>
      <url>/2022/10/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
