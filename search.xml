<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>是把使用算法的责任和算法本身分割开来，用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换。<strong>翻译一下就是</strong>，运行时我给你这个类的方法传不同的“key”，你这个方法会执行不同的业务逻辑。<strong>细品一下，这不就是 if else 干的事吗？</strong></p><p>但是原始的策略模式，他如果遇到参数是可变的，那他依旧会尽力if else的阶段，那就意义不大。所以我们的</p><p>优化方法就是枚举类+map（原先的环境类变成map），然后通过这个参数，去map里面找就可以了，在我的项目里面也是这样的，</p><p>抽奖的时候根据抽奖算法的id是1还是2，直接去map里面get就可以；生成订单id的时候用雪花还是美团哪一种方法，直接去map里面找</p><h2 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h2><p>模版模式的主要思路就是把自己要实现的功能抽象成一组<strong>步骤</strong>，也就是在抽象类中定义算法的骨架，具体实现留给子类。但是这里有一点非常重要，就是模版类的流程是定义好的，或者说定死了，子类就是在每一个步骤中实现自己的个性化。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式包含三块，工厂：负责实现创建实例的内部逻辑；抽象产品：负责描述所有实例共有的接口；具体产品：被创建的对象，简单工厂只适合单一产品的生产。其实思路很简单，就是把根据不同信息new出不同对象的这一个过程抽象出来了，不然每次都要走一遍这种代码就比较繁琐。</p><p>我的项目里面就是对于发放奖品的时候选用哪一个奖品用到了简单工厂。</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式一般用来描述整体与部分的关系 ，它将对象组织到树形结构中 ，最顶层的节点称为根节点 ，根节点下面可以包含树枝节点和叶子节点 ，树枝节点下面又可以包含树枝节点和叶子节点。宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示 ，使得客户对单个对象和组合对象的使用具有一致性</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理分成静态代理和动态代理，静态代理需要自己实现对每一个方法对代理，非常繁琐。动态代理更加灵活，不需要你一个一个的对方法进行代理。</p><p><strong>动态代理</strong>是代理类在程序运行时创建的代理方式被成为动态代理。</p><p>动态代理有两种方式一种是jdk方法，一种是cglib方法</p><p><strong>我们先来讲jdk代理：</strong></p><p>在java的<strong>java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口</strong>，<strong>通过这个类和这个接口可以生成JDK动态代理类和动态代理对象</strong>。</p><p>而代理类就需要一个执行器去帮你做这些事情，那这个执行器就是InvocationHandler接口，他只有一个invoke方法，三个参数是代理类，被代理方法，方法参数组</p><p>而这三个参数其实是可以变化的，被代理方法参数组是可以变化的，这三个参数里面代理方法和参数组其实我们可以依赖于最基础反射得到。那这样就成功的实现了动态的含义。</p><p>那我们怎么去调用这个方法呢？依赖于Proxy类和他的方法newproxyInstance，getProxyClass0(loader, intfs)这个类的产生就是整个动态代理的关键，产生的类反编译之后得到，调用代理对象的方法其实会直接调用我们InvocationHandler接口的invoke方法，在invoke方法中调用了被代理对象的相应方法。</p><p><strong>下面来讲CGLIB代理</strong></p><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。你可以通过 <code>Enhancer</code>类来动态获取被代理类，</strong></p><p>  CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，每次调用代理类的方法都会被方法<a href="https://so.csdn.net/so/search?q=%E6%8B%A6%E6%88%AA%E5%99%A8&spm=1001.2101.3001.7020">拦截器</a>拦截，在拦截器中才是调用目标类的该方法的逻辑。所以我们说，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p><p>为什么JDK动态代理只能代理接口实现类，原因是JDK动态代理是基于接口实现的。</p><p>有两个原因，一个是继承Proxy。第二个是当你使用Proxy类创建代理对象时，你需要指定一个接口列表来表示理对象的类型。代理对象的类型是由接口列表决定的，因此只有实现了接口的类才能被代理。如果你想代理一个类而不是一个接口，你需要使用其他的代理技术，比如CGLIB。</p><p><strong>二者区别</strong><br>总结一下两者的区别吧：</p><p>JDK 动态代理基于接口，CGLIB 动态代理基于类。因为 JDK 动态代理生成的代理类需要继承 java.lang.reflect.Proxy，所以，只能基于接口；CGLIB 动态代理是根据类创建此类的子类，所以，此类不能被 final 修饰<br>JDK 和 CGLIB 动态代理都是在运行期生成字节码。而 JDK 是直接写 Class 字节码；而 CGLIB 使用 ASM 框架写 Class 字节码（不鼓励直接使用ASM，因为它要求你必须对 JVM 内部结构包括 class 文件的格式和指令集都很熟悉）<br>JDK 通过反射调用方法，CGLIB 通过 FastClass 机制（下一篇再将）直接调用方法。所以，CGLIB 执行的效率较高<br>JDK 核心是实现 InvocationHandler接口，使用 invoke()方法进行面向切面的处理，调用相应的通知；CGLIB 动态代理是利用 asm 开源包，对代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。核心是实现 MethodInterceptor 接口，使用 intercept() 方法进行面向切面的处理，调用相应的通知。</p><h2 id="策略模式-1"><a href="#策略模式-1" class="headerlink" title="策略模式"></a>策略模式</h2><ul><li><h2 id="讲一讲策略模式以及在项目的应用？"><a href="#讲一讲策略模式以及在项目的应用？" class="headerlink" title="讲一讲策略模式以及在项目的应用？"></a><strong>讲一讲策略模式以及在项目的应用？</strong></h2></li></ul><p>一个问题基于对象的某个特征的不同而有不同的解决方案，传统的方法就是ifif，策略模式就是为了解决这种问题。</p><p>策略模式具体的实验需要三个部分，一个是策略接口这个很简单，一个是环境类，包含策略接口，他的作用就是把具体的算法和用户分开；一个是具体的策略类（ <em>接口回调（向上转型</em>）。比如初级中级高级会员打折力度不一样，</p><p>但是，策略模式有一个问题就是，如果我传进来的策略是一个参数，是一个可变的值，那么这个策略模式还是需要经历if else，所以我的优化方法就是枚举类+map（原先的环境类变成map），然后通过这个参数，去map里面找就可以了，在我的项目里面也是这样的，</p><p>抽奖的时候根据抽奖算法的id是1还是2，直接去map里面get就可以；生成订单id的时候用雪花还是美团哪一种方法，直接去map里面找</p><h2 id="模版模式-1"><a href="#模版模式-1" class="headerlink" title="模版模式"></a>模版模式</h2><ul><li><h2 id="讲一讲模版模式以及在项目的应用？"><a href="#讲一讲模版模式以及在项目的应用？" class="headerlink" title="讲一讲模版模式以及在项目的应用？"></a><strong>讲一讲模版模式以及在项目的应用？</strong></h2></li></ul><p>模版模式的主要思路就是把自己要实现的功能抽象成一组<strong>步骤</strong>，也就是在抽象类中定义算法的骨架，具体实现留给子类。但是这里有一点非常重要，就是模版类的流程是定义好的，或者说定死了，子类就是在每一个步骤中实现自己的个性化。</p><p>在我的项目中，我对抽奖流程用了模版模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获取抽奖策略</span></span><br><span class="line"><span class="comment">// 2. 校验抽奖策略是否已经初始化到内存</span></span><br><span class="line"><span class="comment">// 3. 获取不在抽奖范围内的列表，包括：奖品库存为空、风控策略、临时调整等</span></span><br><span class="line"><span class="comment">// 4. 执行抽奖算法</span></span><br><span class="line"><span class="comment">// 5. 包装中奖结果</span></span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul><li><h2 id="讲一讲简单工厂模式以及在项目中的应用？"><a href="#讲一讲简单工厂模式以及在项目中的应用？" class="headerlink" title="讲一讲简单工厂模式以及在项目中的应用？"></a><strong>讲一讲简单工厂模式以及在项目中的应用？</strong></h2></li></ul><p>简单工厂模式包含三块，工厂：负责实现创建实例的内部逻辑；抽象产品：负责描述所有实例共有的接口；具体产品：被创建的对象，简单工厂只适合单一产品的生产。其实思路很简单，就是把根据不同信息new出不同对象的这一个过程抽象出来了，不然每次都要走一遍这种代码就比较繁琐。</p><p>我的项目里面就是对于发放奖品的时候选用哪一个奖品用到了简单工厂。</p><h2 id="组合模式-1"><a href="#组合模式-1" class="headerlink" title="组合模式"></a>组合模式</h2><ul><li><h2 id="讲一讲组合模式以及在项目中的应用"><a href="#讲一讲组合模式以及在项目中的应用" class="headerlink" title="讲一讲组合模式以及在项目中的应用"></a><strong>讲一讲组合模式以及在项目中的应用</strong></h2></li></ul><p>组合模式一般用来描述整体与部分的关系 ，它将对象组织到树形结构中 ，最顶层的节点称为根节点 ，根节点下面可以包含树枝节点和叶子节点 ，树枝节点下面又可以包含树枝节点和叶子节点。宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示 ，使得客户对单个对象和组合对象的使用具有一致性</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p>享元模式的本质:分离与共享。</p></blockquote><p>享元模式的关键之处就在于分离变和不变，把不变的部分作为享元对象的内部状态，而变化部分则作为外部状态，由外部来维护，这样享元对象就能够被共享，从而减少对象数量，并节省大量的内存空间。</p><ul><li>Flyweight:享元接口，通过这个接口 Flyweight可以接受并作用于外部状态。通过这个接口传入外部的状态，在享元对象的方法处理中可能会使用这些外部的数据。</li><li>ConcreteFlyweight:具体的享元实现对象</li><li>FlyweightFactory:享元工厂，主要用来创建并管理共享的享元对象，并对外提供访问共享享元的接口。</li></ul><p>你要得到一个共享的类，先去享元池里面找，找得到就返回享元池里面的那个实例。找不到就创建加入享元池。</p><p>如果你要得到一个不共享的，因为是不共享的每次都返回一个新的类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by njy on 2023/6/21</span></span><br><span class="line"><span class="comment"> * 1.抽象享元类（FlyWeight）：单车</span></span><br><span class="line"><span class="comment"> * 单车有很多共同的信息比如：价格、颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Bike</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> String color;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> price;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bike</span><span class="params">(String color,<span class="type">int</span> price)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.color=color;</span><br><span class="line">        <span class="built_in">this</span>.price=price;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//展示单车信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by njy on 2023/6/21</span></span><br><span class="line"><span class="comment"> * 2.具体享元类（ConcreteFlyWeight）：摩拜单车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mobike</span> <span class="keyword">extends</span> <span class="title class_">Bike</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mobike</span><span class="params">(String color,<span class="type">int</span> price)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(color,price);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产成功：摩拜单车——&quot;</span>+color+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;起步价&quot;</span>+price+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by njy on 2023/6/21</span></span><br><span class="line"><span class="comment"> * 2.具体享元类（ConcreteFlyWeight）：美团单车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MTBike</span> <span class="keyword">extends</span> <span class="title class_">Bike</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MTBike</span><span class="params">(String color,<span class="type">int</span> price)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(color,price);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产成功：小黄车——&quot;</span>+color+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;起步价&quot;</span>+price+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by njy on 2023/6/21</span></span><br><span class="line"><span class="comment"> * 3.享元工厂类（FlyWeightFactory）：单车工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BikeFactory</span> &#123;</span><br><span class="line">    <span class="comment">//map缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Bike&gt; bikeMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bike <span class="title function_">getBike</span><span class="params">(String color,String type)</span>&#123;</span><br><span class="line">        String key=color+<span class="string">&quot;_&quot;</span>+type;</span><br><span class="line">        <span class="keyword">if</span>(bikeMap.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//如果已经有该颜色和类型的单车，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> bikeMap.get(key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Bike bike=<span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//没有，创建并放入缓存</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;mobike&quot;</span>.equals(type))&#123;</span><br><span class="line">                bike=<span class="keyword">new</span> <span class="title class_">Mobike</span>(color,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;MT&quot;</span>.equals(type))&#123;</span><br><span class="line">                bike=<span class="keyword">new</span> <span class="title class_">MTBike</span>(color,<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;抛异常！没有该类型的单车&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//放入缓存</span></span><br><span class="line">            bikeMap.put(key,bike);</span><br><span class="line">            <span class="keyword">return</span> bike;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式的核心就是不改原有类的基础上给类新增功能。其实说白了就是在原本类的基础上包装一个装饰器类，这个类在执行源类的行为的前后再加入一些新的逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">抽象组件</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">具体组件（需要被装饰的组件）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体组件处理业务逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">抽象装饰器（继承、实现抽象组件，并持有抽象组件）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">     * 抽象组件</span><br><span class="line">    <span class="keyword">public</span> Component component;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        component.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">具体装饰器A继承抽象装饰器</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteDecorator前置操作....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteDecorator后置操作....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">组件本身执行的动作</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        component.execute();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decorator 通用写法测试</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建需要被装饰的组件</span></span><br><span class="line">        <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">        <span class="comment">//给对象透明的增加功能并调用</span></span><br><span class="line">        <span class="type">Decorator</span> <span class="variable">decorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecorator</span>(component);</span><br><span class="line">        decorator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul><li>目标角色（Target）：该角色定义把其他类转换为何种接口。</li><li>源角色（Adaptee）：被适配的对象</li><li>适配器角色（Adapter）：该对象将源对象转换成目标接口</li></ul><p>总结一下就是：我们在适配器里面实现目标角色的接口，然后在这个接口里面去调用源角色的方法。</p><p>如果这个源角色类需继承，那我们就叫类适配器。如果直接作为适配器的一个变量，那么就叫做对象适配器。</p><p>分为两类：类适配器和 对象适配器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 翻译</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source 母语</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 要翻译成的语种</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> words 内容</span></span><br><span class="line"><span class="comment"> */</span>’</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">translate</span><span class="params">(String source,String target,String words)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by njy on 2023/6/8</span></span><br><span class="line"><span class="comment"> * 源对象(source）：充当翻译</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Translator</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//英——》汉</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">translateInZh</span><span class="params">(String words)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;hello world！&quot;</span>.equals(words))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;翻译成中文：”你好世界！“&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//汉——》英</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">translateInEn</span><span class="params">(String words)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;你好世界！&quot;</span>.equals(words))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Translate in English：”hello world！“&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by njy on 2023/6/11</span></span><br><span class="line"><span class="comment"> * 类适配器：通过多重继承目标接口和被适配者类方式来实现适配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassAdapter</span> <span class="keyword">extends</span> <span class="title class_">Translator</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">translate</span><span class="params">(String source, String target, String words)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;中文&quot;</span>.equals(source) &amp;&amp; <span class="string">&quot;英文&quot;</span>.equals(target)) &#123;</span><br><span class="line">            <span class="comment">//汉--》英</span></span><br><span class="line">            <span class="built_in">this</span>.translateInEn(words);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//英--》汉</span></span><br><span class="line">            <span class="built_in">this</span>.translateInZh(words);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by njy on 2023/6/11</span></span><br><span class="line"><span class="comment"> * 对象适配器：使用组合的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Translator translator=<span class="keyword">new</span> <span class="title class_">Translator</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">translate</span><span class="params">(String source, String target, String words)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;中文&quot;</span>.equals(source) &amp;&amp; <span class="string">&quot;英文&quot;</span>.equals(target)) &#123;</span><br><span class="line">            <span class="comment">//汉--》英</span></span><br><span class="line">            translator.translateInEn(words);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//英--》汉</span></span><br><span class="line">            translator.translateInZh(words);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>1、将抽象部分与实体部分分离</p><p>2、处理多个独立变化的维度，在抽象层建立关联，其中抽象类作为桥</p><p>3、通过构造函数的方式将接口传入实现联系</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">支付接口 </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPay</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br><span class="line">wx支付</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WXPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;wx支付&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">zfb支付</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZFBPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;支付宝支付&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">解锁抽象类</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PayType</span> &#123;</span><br><span class="line">     <span class="keyword">protected</span> IPay iPay;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">PayType</span><span class="params">(IPay iPay)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.iPay = iPay;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br><span class="line">人脸解锁</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FacePay</span> <span class="keyword">extends</span> <span class="title class_">PayType</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">FacePay</span><span class="params">(IPay iPay)</span> &#123;</span><br><span class="line">         <span class="built_in">super</span>(iPay);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">         iPay.pay();</span><br><span class="line">         System.out.println(<span class="string">&quot;人脸识别&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">指纹解锁</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FingerPay</span> <span class="keyword">extends</span> <span class="title class_">PayType</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">FingerPay</span><span class="params">(IPay iPay)</span> &#123;</span><br><span class="line">         <span class="built_in">super</span>(iPay);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">         iPay.pay();</span><br><span class="line">         System.out.println(<span class="string">&quot;指纹识别&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式可以理解为转换一群接口，客户只要调用这一个接口而不用调用多个接口才能达到目的，也不需关心这个子系统的内部细节。就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis复习</title>
      <link href="/2023/10/09/Redis/"/>
      <url>/2023/10/09/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Redis数据结构"><a href="#1、Redis数据结构" class="headerlink" title="1、Redis数据结构"></a>1、Redis数据结构</h1><h1 id="2、Redis线程模型"><a href="#2、Redis线程模型" class="headerlink" title="2、Redis线程模型"></a>2、Redis线程模型</h1><h2 id="1、Redis是不是单线程的？"><a href="#1、Redis是不是单线程的？" class="headerlink" title="1、Redis是不是单线程的？"></a>1、Redis是不是单线程的？</h2><p>1、他有后台线程</p><p>2、Redis6之后，用 多IO线程 来处理网络请求的</p><p>所以他不是单线程的。</p><p>而我们之前说的单线程其实指的是：Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理</p><p><img src="/../images/Redis/70ca1c2378d64deb942e3dea580ceb7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h2 id="2、单线程是怎么样子的"><a href="#2、单线程是怎么样子的" class="headerlink" title="2、单线程是怎么样子的"></a>2、单线程是怎么样子的</h2><p>网络请求过来，会先创建一个服务端socket，然后把这个socket加入到epoll里面，让epoll去监听这个socket哪个有事件产生，一旦发现事件产生，就交给事件分发器，事件分发器会根据事件的类型调用不同的事件处理器。</p><h2 id="3、为什么这么快？"><a href="#3、为什么这么快？" class="headerlink" title="3、为什么这么快？"></a>3、为什么这么快？</h2><p>基于内存</p><p>单线程避免了上下文竞争</p><p>io多路复用</p><p>高效的数据结构</p><h2 id="4、采用单线程原因"><a href="#4、采用单线程原因" class="headerlink" title="4、采用单线程原因"></a>4、采用单线程原因</h2><ul><li>使用单线程模型是 Redis 的开发和维护更简单</li><li>即使使用单线程模型也并发的处理多客户端的请求，主要使用的是多路复用IO</li><li>对于 Redis 系统来说， 主要的<code>性能瓶颈是内存或者网络带宽而并非 CPU</code>。</li></ul><h2 id="5、引入多线程原因"><a href="#5、引入多线程原因" class="headerlink" title="5、引入多线程原因"></a>5、引入多线程原因</h2><p>内存问题比较好解决，因此Redis的瓶颈原因为网络IO</p><h2 id="多线程工作原理"><a href="#多线程工作原理" class="headerlink" title="多线程工作原理"></a>多线程工作原理</h2><p>I&#x2F;O 的读和写本身是堵塞的，比如当 socket 中有数据时，Redis 会通过调用先将数据从内核态空间拷贝到用户态空间，再交给 Redis 调用，而这个拷贝的过程就是阻塞的，当数据量越大时拷贝所需要的时间就越多，而这些操作都是基于单线程完成的。</p><p><img src="/../images/Redis/1f56d21bf7c44aec872e391ea1f052bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>在 Redis 6.0 中新增了<strong>多线程的功能来提高 I&#x2F;O 的读写性能</strong>，将最耗时的Socket的读取、请求解析、写入单独外包给一组线程，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。</p><p><img src="/../images/Redis/41070392631d4818a730d02b957517ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>流程简述如下：</p><ul><li>主线程获取 socket 放入等待列表</li><li>将 socket 分配给各个 IO 线程（并不会等列表满）</li><li>主线程<code>阻塞等待 IO 线程(多线程)</code>读取 socket 完毕</li><li>主线程执行命令 - <code>单线程</code>（如果命令没有接收完毕，会等 IO 下次继续）</li><li>主线程<code>阻塞等待 IO 线程(多线程)</code>将数据回写 socket 完毕（一次没写完，会等下次再写）</li></ul><p><img src="/../images/Redis/75394f2582e145fa842e31cdf3be550b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img.png"></p><p>Redis自身出道就是优秀，基于内存操作、数据结构简单、多路复用和非阻塞 I&#x2F;O、避免了不必要的线程上下文切换等特性，在单线程的环境下依然很快；</p><p>但对于大数据的 key 删除还是卡顿厉害，因此在 Redis 4.0 引入了多线程unlink key&#x2F;flushall async 等命令，主要用于 Redis 数据的异步删除；</p><p>而在 Redis 6.0 中引入了 I&#x2F;O 多线程的读写，这样就可以更加高效的处理更多的任务了， Redis 只是<code>将 I/O 读写变成了多线程</code> ，而 <code>命令的执行依旧是由主线程串行执行的</code> ，因此在多线程下操作 Redis <code>不会出现线程安全的问题</code>。 </p><h1 id="3、Redis持久化"><a href="#3、Redis持久化" class="headerlink" title="3、Redis持久化"></a>3、Redis持久化</h1><p>Redis 共有三种数据持久化的方式：</p><ul><li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li><li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li></ul><h2 id="1、AOF"><a href="#1、AOF" class="headerlink" title="1、AOF"></a>1、AOF</h2><p>执行一条写命令，就把这个命令往aof文件里面写</p><h3 id="1、为什么先执行命令，再把数据写入日志呢？"><a href="#1、为什么先执行命令，再把数据写入日志呢？" class="headerlink" title="1、为什么先执行命令，再把数据写入日志呢？"></a>1、为什么先执行命令，再把数据写入日志呢？</h3><blockquote><p>1、避免额外的开销</p><p>2、不会阻塞当前的写命令</p><p>缺点：</p><p>1、可能数据丢失，因为如果在执行完还没写入aof文件之间宕机，那就丢失</p><p>2、可能阻塞下一个命令</p></blockquote><h3 id="2、写回策略几种？"><a href="#2、写回策略几种？" class="headerlink" title="2、写回策略几种？"></a>2、写回策略几种？</h3><p>三种：Always everySec no，其实和mysql的binlog非常相似</p><p>第一种就是每次都同步</p><p>第二种就是每一秒都讲缓冲区里面的写会磁盘</p><p>第三种就是写到缓冲区里面，但是什么时候写到磁盘依赖于操作系统</p><h3 id="3、AOF-日志过大，会触发什么机制？"><a href="#3、AOF-日志过大，会触发什么机制？" class="headerlink" title="3、AOF 日志过大，会触发什么机制？"></a>3、AOF 日志过大，会触发什么机制？</h3><p>aof重写机制：读取当前数据库中的所有键值对，对每一键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p><p>aof是由后台子进程完成的。</p><p>这里有一个问题，就是如果aof重写过程中，主进程对内存进行了修改，怎么办？会触发写时复制</p><p>当aof重写过程中父进程修改内存，那我们执行一个写命令后，会写到aof缓冲区和aof重写缓冲区里面。当子进程完成重写，再去吧重写缓冲区里面的内容追加到aof文件</p><h2 id="2、RDB快照"><a href="#2、RDB快照" class="headerlink" title="2、RDB快照"></a>2、RDB快照</h2><p>快照就是记录一瞬间的意思。记录的是当前的实际数据。</p><p>有两种启动的方式，一个save阻塞住线程，一种bgsave，不阻塞主线程。</p><p>所以rdb快照不会想aof那样开辟一个缓冲区用于记录新操作。这里rdb用的是全量快照数据。</p><p>如果在rdb快照的时候，主线程修改了内容，那么这时候会出发写保护中断，写时复制，原本的物理内存A，复制一份A‘，然后主线程修改A’就好了</p><h2 id="3、混合持久化"><a href="#3、混合持久化" class="headerlink" title="3、混合持久化"></a>3、混合持久化</h2><p>混合持久化就是合并了aof和rdb的两个优点，rdb恢复数据块，aof丢失数据少</p><p>混合持久化，fork出来的子进程先去把共享内存以rdb的格式写入到aof文件里面，然后写入过程中主进程执行的命令会被记录到重写缓冲区里面，然后这些增量命令最后会以aof的格式增加到aof文件里面，所以aof文件里面前一部分时rdb，后一部分是aof。</p><h1 id="4、Redis集群"><a href="#4、Redis集群" class="headerlink" title="4、Redis集群"></a>4、Redis集群</h1><h1 id="5、Redis-过期删除与内存淘汰"><a href="#5、Redis-过期删除与内存淘汰" class="headerlink" title="5、Redis 过期删除与内存淘汰"></a>5、Redis 过期删除与内存淘汰</h1><h2 id="1、Redis过期策略"><a href="#1、Redis过期策略" class="headerlink" title="1、Redis过期策略"></a>1、Redis过期策略</h2><p>Redis 使用的过期删除策略是「<strong>惰性删除+定期删除</strong>」这两种策略配和使用。</p><blockquote><p>什么是惰性删除？</p><p>我不主动的删除，每当访问key的时候，我去判断一下是否过期，如果过期那么就删除该key</p><p>优点：占用比较少的资源，对cpu时间最友好</p><p>缺点：会导致缓存污染，浪费内存空间，对内存友好</p></blockquote><blockquote><p>什么是定期删除策略？</p><p>就是定期的数据库里面随机抽取一定数量的key，并删除其中的过期的key</p><p>抽取策略？</p><p>1、从过期字典里面随机找20个</p><p>2、然后判断是否过期，并删除已经过期的key</p><p>3、如果过期的key超过了25%，那么就重复这个过程，如果没有，那就等待下一轮的抽查</p><p>优点：通过限制删除操作的时长的频率可以减少一些无用的占用</p><p>缺点：很难确定删除的时长和频率，太频繁对cpu不好，太少又和惰性删除一样。</p></blockquote><h3 id="1、Redis-持久化时，对过期键会如何处理的？"><a href="#1、Redis-持久化时，对过期键会如何处理的？" class="headerlink" title="1、Redis 持久化时，对过期键会如何处理的？"></a>1、Redis 持久化时，对过期键会如何处理的？</h3><p>持久化有两种 aof和rdb</p><p>对于rdb，考虑生成和加载阶段</p><p>生成阶段：对于过期的key不写入rdb文件里面</p><p>加载阶段：这里分两种情况，一种是主服务器，另一种是从服务器。</p><p>​主服务器：加载阶段回去判断key是不是过期了，如果过期了那我就不加载这个</p><p>​从服务器：不管key是不是过期，全部加载。</p><p>aof：考虑aof写入阶段和重写阶段</p><p>写入阶段：如果这个key过期了，但是没有被删除，那么aof文件就会保留这个key，如果这个key被过期策略删除了，那么就会往aof文件里面追加一条del语句</p><p>重写阶段：重写阶段如果过期了，那么就直接删除，不会保留在新的aof文件里面</p><h3 id="2、Redis-主从模式中，对过期键会如何处理？"><a href="#2、Redis-主从模式中，对过期键会如何处理？" class="headerlink" title="2、Redis 主从模式中，对过期键会如何处理？"></a>2、Redis 主从模式中，对过期键会如何处理？</h3><p>主从模式中，从数据库完全依赖于主数据库，所以即使从库的key过期了，但是你查询，依旧能查到。只有主数据库在key到期的时候往aof文件里面增加del语句，同步到所有的从库，从库才会删除这个key。</p><h2 id="2、Redis-内存淘汰"><a href="#2、Redis-内存淘汰" class="headerlink" title="2、Redis 内存淘汰"></a>2、Redis 内存淘汰</h2><p>在 Redis 的运行内存达到了某个阀值，就会触发<strong>内存淘汰机制</strong>，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p><p>内存淘汰机制分为两类：一类是对有过期时间的内存淘汰机制；一类是对所有数据的淘汰机制。</p><p>对过期时间的内存淘汰机制可以分成四种：</p><p>1、volatile random</p><p>2、volatile lru 最近最少使用</p><p>3、volatile lfu <strong>最近最不常用的</strong></p><p>4、volatile ttl  最早时间</p><p>对所有数据的淘汰机制：</p><p>1、volatile random</p><p>2、volatile lru 最近最少使用</p><p>3、volatile lfu <strong>最近最不常用的</strong></p><h3 id="LRU-算法和-LFU-算法有什么区别？"><a href="#LRU-算法和-LFU-算法有什么区别？" class="headerlink" title="LRU 算法和 LFU 算法有什么区别？"></a>LRU 算法和 LFU 算法有什么区别？</h3><p>传统的lru算法依赖于一个链表，，数据被访问时候，链表中的节点会出现很多的移动操作，降低性能</p><p>Redis实现lru是在RedisObject里面新增一个字段，记录最后一次访问时间</p><p>进行淘汰的时候，随机选取五个，然后淘汰访问时间最早的</p><p>优点：节省空间，提高性能</p><p>缺点：无法解决缓存污染</p><p>LFU</p><p>lfu在RedisObject的基础上新增了一个字段，用于记录数据的访问频次。24位</p><p>高16位记录时间戳，后8位记录访问频次，默认5，会随着时间衰减</p><p>数据每次被访问的时候：</p><p>先做一个衰减操作，根据时间和上一次访问时间的差</p><p>然后做一次增加的操作，这个是基于一定的概率</p><p><img src="/../images/Redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5.jpg" alt="img"></p><p><img src="/../images/Redis/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.jpg" alt="img"></p><h1 id="6、Redis缓存设计"><a href="#6、Redis缓存设计" class="headerlink" title="6、Redis缓存设计"></a>6、Redis缓存设计</h1><h2 id="1、如何避免缓存雪崩？"><a href="#1、如何避免缓存雪崩？" class="headerlink" title="1、如何避免缓存雪崩？"></a>1、如何避免缓存雪崩？</h2><p>缓存雪崩是指在同一时间大量的key同时过期了</p><p>解决方法：</p><p>这里关键就是同时和过期，所以解决方法如下：</p><p>1、打乱过期的时间</p><p>2、设置缓存不过期</p><h2 id="2、缓存击穿"><a href="#2、缓存击穿" class="headerlink" title="2、缓存击穿"></a>2、缓存击穿</h2><p>对于一个热点数据过期了，导致请求全部打到数据库</p><p>1、设置缓存不过期，后台异步的去更新</p><p>2、互斥锁，分布式锁的方法。让同一时间只有一个线程去访问</p><h2 id="3、缓存穿透"><a href="#3、缓存穿透" class="headerlink" title="3、缓存穿透"></a>3、缓存穿透</h2><p>访问的值既不在redis 也不在mysql，所以很可能是那种黑客攻击之类的，解决方法的话</p><p>1、非法请求的限制</p><p>2、空值或者默认值</p><p>3、布隆过滤器</p><h3 id="4、说说常见的缓存更新策略？"><a href="#4、说说常见的缓存更新策略？" class="headerlink" title="4、说说常见的缓存更新策略？"></a>4、说说常见的缓存更新策略？</h3><blockquote><p>常见的缓存更新策略共有2种：</p></blockquote><ul><li><p>Cache Aside（旁路缓存）策略；</p></li><li><p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略；</p></li></ul><p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</p><p><strong>写策略的步骤：</strong></p><ul><li>先更新数据库中的数据，再删除缓存中的数据。</li></ul><p><strong>读策略的步骤：</strong></p><ul><li>如果读取的数据命中了缓存，则直接返回数据；</li><li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li></ul><blockquote><p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</p></blockquote><p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略原则是应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</p><p><em><strong>1、Read Through 策略</strong></em></p><p>先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。</p><p><em><strong>2、Write Through 策略</strong></em></p><p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p><ul><li>如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</li><li>如果缓存中数据不存在，直接更新数据库，然后返回；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java刷题</title>
      <link href="/2023/09/30/shua/"/>
      <url>/2023/09/30/shua/</url>
      
        <content type="html"><![CDATA[<h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><p>注意Integer和Int，基础和引用的&#x3D;&#x3D;是不一样的，在此基础上形成的stack vector，List也是这样</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h2><p>递归判断两个值是否相等或者对称这种题目，或者先判断两个空，然后判断一个空</p><p>if (root1 &#x3D;&#x3D; null &amp;&amp; root2 &#x3D;&#x3D; null) 两个都为空的情况</p><p>if(root1 &#x3D;&#x3D; null || root2 &#x3D;&#x3D; null || root1.val !&#x3D; root2.val) 一个为空的情况</p><p>结束条件判断中，建议判断已知的。</p><p>结束标志一般一个是null，一个是结束值。</p><p>递归中的凭据，如果是多个数组、Treenode、链表，用坐标也许会很麻烦，可以先尝试原本的类型，比如数组，就用子数组。因为数组如果用坐标判断长度是不是0会比较麻烦</p><p><img src="/../images/shua/image-20231001132922742.png" alt="image-20231001132922742"></p><p>如果能做一次这种就好了</p><p>递归函数体一般分三部分</p><p>1、结束</p><p>2、主要函数操作，比如visit【】&#x3D;true</p><p>3、列举 dfs</p><p>如果是两个匹配，可以用被匹配的长度作为结束判断条件之一,比如两个字符都匹配完，某个字符匹配完某个字符没有匹配完</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>状态定义：</p><p>状态转移函数：</p><p>状态初始化 如果是两个数组，那辅助表就是二维数组，最好比原来的宽长都多1位 </p><p>前面（第零列或者第零行 或者两个都）可能需要初始化</p><p>然后真正匹配的是从1到n；</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发知识</title>
      <link href="/2023/09/08/Java%E5%B9%B6%E5%8F%91/"/>
      <url>/2023/09/08/Java%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><strong>偏向锁</strong></p><p>java对象头后三位是101，然后把对象头的偏向线程id改为自己就好就代表自己获得了锁。当偏向锁的获取出现竞争，则偏向锁可能会升级为轻量级锁。</p><p>线程查看若锁标志位是为01，如果是01，并且偏向锁标志1的话。不是1直接升级轻量级，是1的话我们去看threadid，如果是本线程id，那就获得锁。如果不是，这时候CAS操作尝试将mark word的threadid改成线程A的id，如果当前threadid是0，那就替换成功获得锁，如果是线程B的id。这时候要去撤销偏向锁。先查看线程b的存活状态，如果存活并且还在执行，那就升级为轻量级，如果未存活或者没有在执行，那么我们就尝试重偏向。可以的话就让threadid偏向我们线程A，否则升级为轻量级锁。</p><p>偏向锁适合无竞争、竞争小的场景，理想的情况为总是由同一个线程去访问同步块、获取某个对象的锁。</p><p><strong>轻量级锁</strong></p><p>轻量级锁由偏向锁升级而来，特点是获取轻量级锁的是通过CAS原子操作进行的，失败的线程不会进入阻塞，而是自旋尝试再次CAS去获取锁。若失败的次数过多，则轻量级锁会膨胀为重量级锁。因为自旋也是要消耗cpu的，不能让线程一直自旋下去。</p><p>根据这些，可以看出 轻量级锁最适合场景是追求响应时间的情景，理想的情况是少量线程交替访问同步块、获取锁。若多个线程访问同步块的时间重合的比骄密集就会发生很多自旋造成cpu资源浪费。</p><p>1、无锁可以直接加锁，关于markword的初始状态0|01<br> 1、1 在当前线程的栈帧中创建锁记录<br> 1、2 将锁对象中的markword复制到锁记录中<br> 1、3 通过CAS方式将markword设置成指向锁记录的指针。<br>2、有锁状态下<br>  2、1如果是当前线程持有的轻量级锁，说明是可重入锁，由于每次获取轻量级锁都会创建一个锁记录，所以，除第一次锁记录存储markword外，后面均设置为null。<br>  2、2如果不是当前线程持有的锁，说明出现锁竞争，可能需要锁升级</p><p><strong>重量级锁</strong></p><p>重量级锁是轻量级锁受到激烈竞争时，为防止cpu被自旋的线程浪费膨胀而来，因此重量级锁肯定是应付大量线程同时访问同步块的情景。让申请锁失败的线程阻塞后，cpu的负担会减小不少，因此数据的吞吐量也就上来了。</p><h2 id="JAVA内存模型"><a href="#JAVA内存模型" class="headerlink" title="JAVA内存模型"></a>JAVA内存模型</h2><p>JMM定义了线程和主线程之间的抽奖关系。涉及到内存屏障 重排序等问题。它的基本方针就是：正确同步的情况下，尽可能为处理器打开方面之门。没有正确同步的情况下不保证执行结果和顺序一致性是一样的。</p><p>对于程序员来说，直接能感触到的是happers-before规则，包括程序规则、锁规则、volatile规则。而JMM实现这些规则依靠的就是处理器的重排序规则（禁止重排序）。重排序是一种优化性能的手段。它要求前一个操作的结果对后一个操作可见并且在前一个操作按顺序排在后一个操作前。</p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>我们可以从三个角度出发了解它。分别是本身的特性，内存语义，和内存语义的实现</p><p><strong>特性：</strong>得益于happensbefore规则，对一个volatile的读，总能看到对这个volatile最后的写入。</p><p><strong>内存语义：</strong></p><p>volatile写：当写一个volatile变量，jmm会把该线程对应的本地内存中共享变量刷新到主内存</p><p>volatile读：当读一个volatile变量，jmm会把该线程对应的本地内存置为无效，然后存主内存里面读</p><p><strong>内存语义的实现</strong></p><p>重排序分为编译器重排序和处理器重排序。</p><p>编译器方面有这么一个规定</p><p><img src="/../images/%E5%B9%B6%E5%8F%91/image-20230919132522971.png" alt="image-20230919132522971"></p><p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</p><p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p><p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p><p>为了实现这些语义，比那一起在生成字节码的时候会插入内存屏障。</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a><strong>锁</strong></h2><p>happendbefore<strong>规则</strong>：</p><p>对一个锁的解锁，happensbefore于随后对它的加锁</p><p><strong>锁的内存语义</strong></p><p>释放锁的时候，jmm把该线程对应的本地内存中的共享变量刷新到主内存，加锁的时候把该线程对应的本地内存置为无效。</p><p>ps：锁和volatile是一样的内存语义</p><p><strong>锁内存语义的实现</strong></p><p>分为公平锁和非公平锁</p><p>ReentrantLock的实现依赖于AbstractQueuedSynchronizer（AQS），AQS使用一个整形的volatile变量（state）来维护同步状态。这个volatile变量是ReentrantLock实现的关键。</p><p>　　编译器<strong>不会对volatile读与其后的任意内存操作重排序</strong>，<strong>不会对volatile写与其前的任意操作重排序</strong>。AQS提供了compareAndSetState()方法来对state进行原子操作。CAS同时具有volatile读和写的内存语义，编译器<strong>不会对CAS前和后的任意内存操作重排序</strong>，其是通过底层处理器缓存锁定实现原子性的。</p><p>CAS同时具有volatile读和写的内存语义，故Java线程之间的通信存在4种方式：</p><p>　　① A线程写volatile变量，随后B线程读该变量；</p><p>　　② A线程写volatile变量，随后B线程使用CAS更新该变量；</p><p>　　③ A线程使用CAS更新volatile变量，随后B线程使用CAS更新该变量；</p><p>　　④ A线程使用CAS更新volatile变量，随后B线程读该变量。</p><p>公平锁在释放锁的最后写volatile变量state，在获取锁的时候先读volatile变量，根据先行发生原则释放锁的线程对volatile变量的写，必须对volatile变量的读可见，也就是上节讲的volatile的可见性，所以公平锁本质是通过volatile变量和AQS（这里暂时不对AbstractQueuedSynchronizer讲解）来实现同步的；</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>本质是一个抽象类，用来构造锁或其他同步组件的基础框架</p><p>用state表示同步状态（volatile）</p><p>用一个同步队列来管理同步状态fifo双向队列，当线程获取同步状态失败，那就把这个线程和等待状态等信息狗造成一个节点加入同步队列，并且阻塞。</p><p>独占式，线程调用tryacquire获取同步状态，如果获取同步状态失败的话构造同步节点将该节点通过CAS加入到同步队列尾部，并处于死循环。</p><p>共享式和独占式最大的区别就局势同一时刻能够多个线程获取到同步状态</p><h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><p>用这个之前需要先创建 ReentrantLock 对象，然后使用 lock 方法进行加锁，使用完之后再调用 unlock 方法释放锁</p><p><strong>synchronized 是 JVM 层面通过监视器（Monitor）实现的，而 ReentrantLock 是通过 AQS（AbstractQueuedSynchronizer）程序级别的 API 实现</strong></p><p>这里涉及到aqs的两种实现一个公平锁一个非公平锁，她们两个的区别是，我的线程入栈的时候，公平锁直接往队列的末尾去加，非公平锁先看下我能不能通过cas的方式获得到锁，如果获取不到，这个时候我要进行入栈。入栈的时候也会判断一下，当前这个栈头是不是和我这个线程的id是一致的，如果是一致的，那我就获得到锁。</p><p>用state表示同步状态，state&#x3D;0表示初始状态可以占有锁，state&#x3D;1表示已有线程占有，大于1是重入锁。</p><p>用一个同步队列来管理同步状态fifo双向队列，</p><p>解锁的时候将state减一，看其是否为0，如果是的话将空闲标志置为true，将持有锁的线程设置为null。然后设置state。当这个线程已经没有持有state的时候就要唤醒下一个节点。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p><strong>锁 synchronized 和 ReentrantLock 默认都是非公平锁，当然我们在创建 ReentrantLock 时，可以手动指定其为公平锁</strong></p><p><strong>每个线程获取锁的顺序是按照线程访问锁的先后顺序获取的，最前面的线程总是最先获取到锁。</strong> </p><p>公平锁和非公平锁有两个判断的区别，非公平锁在acquire的之前会先用CAS的方式获取锁，拿不到我就走正常的逻辑。还有一个判断是tryacquire的时候，里面有一个步骤是获取同步状态时候，如果这个同步状态是0的话，说明现在没人拿，我可以去直接去拿，公平锁这里会多一个判断，会先看看自己是不是排队的第一个，如果不是的话，我就不抢占state了。如果state等于当前线程，说明当前线程已经持有锁的，触发可重入功能。如果没拿到就那就把这个线程和等待状态等信息狗造成一个节点加入同步队列，并且阻塞。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>特性</strong></p><p>原子性</p><p><strong>可见性</strong></p><ol><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li><li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存<br>中重新读取最新的值。</li><li>volatile 的可见性都是通过内存屏障（Memnory Barrier）来实现的。</li><li>synchronized 靠操作系统内核的Mutex Lock（互斥锁）实现，相当于 JMM 中的 lock、unlock。退出代码块时刷新变量到主内存。</li></ol><p><strong>实现原理</strong></p><blockquote><p>jvm基于进入和退出Monitor对象来实现方法同步和代码块同步</p></blockquote><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会常量池里面检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，方法完成释放monitor。</p><p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p><p><strong>synchronized的底层实现</strong></p><p>是完全依赖JVM虚拟机的,所以谈synchronized的底层实现，就不得不谈数据在JVM内存的存储：Java对象头，以及Monitor对象监视器。</p><p>HotSpot 虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、<br>实例数据（Instance Data）和对齐填充（Padding）。</p><p>对象头一般有两部分：Mark Word和对象类型数据的指针</p><p>Mark Word如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等,它是实现轻量级锁和偏向锁的关键.</p><p>我们发现当对象头中<code>锁状态</code>为<strong>重量级锁</strong>时，<strong>对象头的MarkWord存储了指向堆中的Monitor对象的指针</strong></p><p>monitor由ObjectMonitor实现，他有两个队列，一个是waitset一个是entrylist，用来保存 等待锁的线程</p><p>_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</p><p>前面已经分析了Monitor的机制，那么在Java中是如何实现的呢？<br><strong>即通过synchronized关键字实现线程同步来获取对象的Monitor。</strong><br>实现方式为：<strong>ACC_SYNCHRONIZED和monitorenter&#x2F;monitorexit</strong> *ACC_SYNCHRONIZED标识符会去隐式调用这两个指令：monitorenter和monitorexit</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="讲讲Java的代理"><a href="#讲讲Java的代理" class="headerlink" title="讲讲Java的代理"></a>讲讲Java的代理</h2><p>代理分成静态代理和动态代理，静态代理需要自己实现对每一个方法对代理，那么如果新增一个方法，那就要手动修改目标对象代理对象的代码，非常繁琐。动态代理更加灵活，不需要你一个一个的对方法进行代理。</p><p>动态代理就是运行的时候生成class。这个DynamicProxy其实就是一个Proxy，</p><p>动态代理有两种方式一种是jdk方法，一种是cglib方法</p><p><strong>我们先来讲jdk代理：</strong></p><p>首先，代理是一个代理类代理真正的对象去帮助你做一些操作，可以在原本的方法前后加一些操作。那代理类就需要一个执行器去帮你做这些事情，那这个执行器就是InvocationHandler接口，他只有一个invoke方法，三个参数是代理类，被代理方法，方法参数组</p><p>这三个参数里面代理方法和参数组其实我们可以依赖于最基础反射得到。而jdk代理又必须要实现InvocationHandler接口，而这个接口他又有这么三个参数，而这三个参数其实是可以变化的，被代理类被代理方法参数组是可以变化的，那这样就成功的实现了动态的代理。</p><p>那我们怎么去调用这个方法呢？依赖于Proxy类和他的方法newproxyInstance，得到的代理类，调用方法其实会直接调用我们实现InvocationHandler接口的invoke方法</p><p><strong>下面来讲CGLIB代理</strong></p><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。你可以通过 <code>Enhancer</code>类来动态获取被代理类，</strong></p><p>  CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，每次调用代理类的方法都会被方法<a href="https://so.csdn.net/so/search?q=%E6%8B%A6%E6%88%AA%E5%99%A8&spm=1001.2101.3001.7020">拦截器</a>拦截，在拦截器中才是调用目标类的该方法的逻辑。所以我们说，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p><p>为什么JDK动态代理只能代理接口实现类，原因是JDK动态代理是基于接口实现的。</p><p>有两个原因，一个是继承Proxy。第二个是当你使用Proxy类创建代理对象时，你需要指定一个接口列表来表示理对象的类型。代理对象的类型是由接口列表决定的，因此只有实现了接口的类才能被代理。如果你想代理一个类而不是一个接口，你需要使用其他的代理技术，比如CGLIB。</p><p><strong>二者区别</strong><br>总结一下两者的区别吧：</p><p>JDK 动态代理基于接口，CGLIB 动态代理基于类。因为 JDK 动态代理生成的代理类需要继承 java.lang.reflect.Proxy，所以，只能基于接口；CGLIB 动态代理是根据类创建此类的子类，所以，此类不能被 final 修饰<br>JDK 和 CGLIB 动态代理都是在运行期生成字节码。而 JDK 是直接写 Class 字节码；而 CGLIB 使用 ASM 框架写 Class 字节码（不鼓励直接使用ASM，因为它要求你必须对 JVM 内部结构包括 class 文件的格式和指令集都很熟悉）<br>JDK 通过反射调用方法，CGLIB 通过 FastClass 机制（下一篇再将）直接调用方法。所以，CGLIB 执行的效率较高<br>JDK 核心是实现 InvocationHandler接口，使用 invoke()方法进行面向切面的处理，调用相应的通知；CGLIB 动态代理是利用 asm 开源包，对代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。核心是实现 MethodInterceptor 接口，使用 intercept() 方法进行面向切面的处理，调用相应的通知。</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>重点是list和map，其中list比较简单，map需要重点掌握</p><h2 id="ArrayList-插入和删除元素的时间复杂度？"><a href="#ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度？"></a>ArrayList 插入和删除元素的时间复杂度？</h2><p>对于插入：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li></ul><p>对于删除：</p><ul><li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul><h2 id="LinkedList-插入和删除元素的时间复杂度？"><a href="#LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="LinkedList 插入和删除元素的时间复杂度？"></a>LinkedList 插入和删除元素的时间复杂度？</h2><ul><li>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul><h2 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h2><p> <strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p><p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p><p>**插入和删除是否受元素位置的影响：</p><p><strong>插入和删除是否受元素位置的影响：</strong></p><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）</p><h2 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h2><p>首先有三种初始化方式，无参数（空数组，没有分配空间），有数量参数，collections的列表（Arrays.copyOf）</p><p>再者讲一下扩容机制，add函数先会经历一次ensurecapacityInternal，确保容量能达到指定的最小容量，当容量不足的时候将新容量更新为旧容量的1.5倍，新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量。如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code></p><p>ps</p><ul><li>Java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>Java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>Java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h2 id="元素排序-Comparable-和-Comparator-有什么区别？"><a href="#元素排序-Comparable-和-Comparator-有什么区别？" class="headerlink" title="元素排序 Comparable 和 Comparator 有什么区别？"></a>元素排序 Comparable 和 Comparator 有什么区别？</h2><p>Comparable 接口只有一个方法 compareTo，实现 Comparable 接口并重写 compareTo 方法就可以实现某个类的排序了，它支持 Collections.sort 和 Arrays.sort 的排序。compareTo 方法接收的参数 p 是要对比的对象，排序规则是用当前对象和要对比的对象进行比较，然后返回一个 int 类型的值。正序从小到大的排序规则是：使用当前的对象值减去要对比对象的值；而倒序从大到小的排序规则刚好相反：是用对比对象的值减去当前对象的值。</p><p>Comparator 除了可以通过创建自定义比较器外，还可以通过<a href="https://so.csdn.net/so/search?q=%E5%8C%BF%E5%90%8D%E7%B1%BB&spm=1001.2101.3001.7020">匿名类</a>的方式，更快速、便捷的完成自定义比较器的功能，具体的代码实现如下：</p><p>Comparable 必须由自定义类内部实现排序方法，而 Comparator 是外部定义并实现排序的</p><h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法</p><h2 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h2><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h3 id="什么是-BlockingQueue？"><a href="#什么是-BlockingQueue？" class="headerlink" title="什么是 BlockingQueue？"></a>什么是 BlockingQueue？</h3><p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code>。<code>BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。<code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p><h1 id="Hashmap："><a href="#Hashmap：" class="headerlink" title="Hashmap："></a>Hashmap：</h1><h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><ul><li><strong>线程是否安全：</strong><code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）</li><li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li><li><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</li><li><strong>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</strong></li></ul><h2 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h2><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</p><p>HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p><code>HashMap</code> 链表到红黑树的转换。</p><p><strong>1、 <code>putVal</code> 方法中执行链表转红黑树的判断逻辑。</strong></p><p>链表的长度大于 8 的时候，就执行 <code>treeifyBin</code> （转换红黑树）的逻辑。</p><p><strong><code>treeifyBin</code> 方法中判断是否真的转换为红黑树。</strong></p><h2 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h2><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong>1111最后一位是1，散列平均</p><h2 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h2><p>扩容问题和头插法问题</p><p>假设两个线程同时对hashmap进行扩容，这时候两个都指向首节点A，后面的节点分别是bcd。</p><p>那么这时候线程1正常执行，线程2卡住了。但是A执行完后因为是头插法所以abc变成了cba，但是问题就在与线程2还是从a指向b，这样子就出现了问题。一个是c指向b指向a，一个是a指向 b。</p><p>解决的方法：concurrenthashmap，推荐；hashtable安全，不建议；或者直接加锁，也不建议。或者头插法改成尾插法。</p><h2 id="HashMap-为什么线程不安全？"><a href="#HashMap-为什么线程不安全？" class="headerlink" title="HashMap 为什么线程不安全？"></a>HashMap 为什么线程不安全？</h2><p>一方面就是多线程操作导致的死循环问题。</p><p>另一方面就是两个线程 1,2 进行 put 操作，线程1 、执行的时候通过判断发现没有出发hash碰撞，但是时间片用完了挂起，这时候线程2也判断有没有hash碰撞发现没有，因为线程1还没来得及插入。这时候线程2插入一个b值结束了，线程1重新获得时间片，因为之前已经成功判断过了，所以直接插入一个a值，那么这样b值就被a值覆盖了。</p><h2 id="Hashmap代码"><a href="#Hashmap代码" class="headerlink" title="Hashmap代码"></a>Hashmap代码</h2><p><strong>loadFactor 负载因子</strong></p><p>loadFactor 负载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><h2 id="hashmap插入"><a href="#hashmap插入" class="headerlink" title="hashmap插入"></a>hashmap插入</h2><p>扰动函数的得到散列值，将 hash 值右移16位（hash值的高16位）与 原 hash 值做异或运算（^），从而得到一个新的散列值</p><p>如果定位到的数组位置没有元素 就直接插入。</p><p>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。</p><p>如果不是就遍历链表插入(插入的是链表尾部)，并查看连标长度是不是大于等于8且数组长度是不是大于64，如果是的话转化成红黑树，如果链表长度大于等于8，数组长度小于64，那么先不转成红黑树，先扩容。</p><h2 id="hashmap扩容过程"><a href="#hashmap扩容过程" class="headerlink" title="hashmap扩容过程"></a>hashmap扩容过程</h2><p>首先判断扩容，插入数据后，如果容量大于threshold（容量*负载因子），则进行扩容；<br>获取当前容量，若当前容量大于0，并且大于MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30，则不进行扩容，将 threshold &#x3D; Integer.MAX_VALUE进行赋值。<br>否则创建新的数组，将容量进行两倍扩大，threshold也进行两倍扩容,下面截取部分源码；</p><p>扩容后将旧数组的元素进行迁移到新数组上，通过尾插法进行插入到新数组中新的位置。</p><p>扩容简单来说就是做了两件事。1：创建一个新数组，原来的两倍大。2：把旧数组的元素放入到新数组中</p><p>遍历老数组的每个槽位；<br>如果槽位中是一个普通节点，则将节点放在新数组中，所在新数组中的下标计算方式为：e.hash &amp; (newCap - 1);<br>如果槽位中是一个树节点，则进行红黑树的迁移操作，新数组中下标计算方式同普通节点；<br>如果槽位中是一个链表节点，则将链表拆为高位链表和低位链表，分别放入新数组的旧数组的下标位置和 （旧数组下标 + 旧数组容量）下标位置；<br>最后返回新数组。</p><h2 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h2><p><strong>实现线程安全的方式（重要）：</strong></p><p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p><p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p><p><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><strong>ConcurrentHashMap</strong></h2><p><code>ConcurrentHashMap</code>是线程安全的，<code>ConcurrentHashMap</code>并非锁住整个方法，而是通过原子操作和局部加锁的方法保证了多线程的线程安全，且尽可能减少了性能损耗</p><p>想要解析concurrenthashmap，我从他的底层具体原理和实际的代码层面讲一讲。</p><p>底层具体原理方面：</p><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p><p>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p><p>具体的代码层面：</p><p>代码层面做插入操作的时候</p><p>做插入操作时，<br>首先初始化则初始化容器，<br>如果已经初始化，则判断该hash位置的节点是否为空，如果为空，则通过CAS操作进行插入。<br>如果该节点不为空，再判断容器是否在扩容中，如果在扩容，则帮助其扩容。<br>如果没有扩容，则进行最后一步，先加锁，然后找到hash值相同的那个节点(hash冲突)，<br>循环判断这个节点上的链表，决定做覆盖操作还是插入操作。<br>循环结束，插入完毕。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习1</title>
      <link href="/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/"/>
      <url>/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<p>计算机网络整体的学习可以按照tcpip网络模型进行学习。我们的总结也是这样的</p><p>Tcp&#x2F;ip网络模型分别是应用层、传输层、网络层、数据链路层</p><p>这里面前三层比较重要，数据链路层复杂的方面涉及实际的物理知识所以我们只对逻辑思想上做一个学习，</p><p>那每一层分别学的是什么呢？</p><p>应用层：http  https tls</p><p>传输层：tcp udp </p><p>网络层：ipv4 v6</p><p>基本上就是这样子</p><p>TCP 连接传输协议，这是传输层的，很多应用层的协议在传输层都是使用这个的，比如http</p><p>那tcp和udp的差距是，tcp相比udp多了很多为了可靠的连接所增加的特性，比如流量控制，超时重传，拥塞控制，就是为了数据能可靠的传到对方，但是过程中究竟是请求-应答模式还是什么模式，那就是后面的不同版本做出的更新。</p><p>udp他不在乎这个数据究竟有没有到对面，只负责发送，所以实时性号，效率高。但是他并不是不能做到可靠传输，因为udp只是传输层，我们还可以在应用层做出一定的限制来保证传输是可靠的，比如quic协议，当然这是困难的。</p><p>除此之外，还有一个很大的不同就是tcp是会分片的，但是udp是不会分片。在这里我们还要知道的一点是在网络层，也就是ip协议中还是会分片的，MTU。但是对于tcp来说因为你要是在ip层才分片，我为了保证可靠，我假设12345 丢了一个2，那我就要12345全部重新发，这样不好，所以我们就在tcp层也分片，大小是mss。而udp不用可靠，所以他不用分片。</p><p>网络层，主要的作用其实就是路由和寻址，加上ip头，规定好源ip，目的ip等信息，</p><p>网络接口层，是提供链路级别的传输服务，因为源ip和目的ip知道了，但是在以太网中实际上是不行的，IP会变，我们需要一个确切的信息，这个就是mac地址，</p><p>那我们这里用输入网址到显示，来串联一下整体的流程：</p><h4 id="1、解析url"><a href="#1、解析url" class="headerlink" title="1、解析url"></a>1、解析url</h4><p>解析之后得到三个信息，一个协议，一个是web服务器地址，一个是请求文件的路径（可选）</p><p>那对于我们前两个是最重要的，</p><p>这时候我们客户端生产自己的http请求报文，格式如下，方法get，url没有默认index什么的，版本http1.1，字段名就很多，然后是数据，这个数据也是后面一种包装的根数据。</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728193306158.png" alt="image-20230728193306158"></p><p>如图所示，一个是请求一个是响应报文</p><p>到这里消息成功生产，那我们生产出一个消息之后就要开始发送？那应该怎么发？往哪里发？</p><p>这就需要下面的知识。</p><h2 id="地址查询-——-DNS"><a href="#地址查询-——-DNS" class="headerlink" title="地址查询 —— DNS"></a>地址查询 —— DNS</h2><p>基于我们已经拿到的web服务器域名，我们可以先去浏览器缓存里面找有没有，如果有，就直接返回，如果没有那就问操作系统的缓存再去看hosts文件，如果都没有，那就看走下面</p><p>客户端首先会发出一个 DNS 请求，问 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 是啥，发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</p><p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.xx.com,则它直接返回/">www.xx.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</p><p>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.xx.com/">www.xx.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</p><p>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？”</p><p>顶级域名服务器说：“我给你负责 <a href="http://www.xx.com/">www.xx.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</p><p>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.xx.com对应的IP是啥呀？”">www.xx.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</p><p>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</p><p>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728193808617.png" alt="image-20230728193808617"></p><p>通过dns或者缓存获取到ip地址之后，我们就要为发送做一些准备，首先浏览器通过调用 Socket 库，来委托协议栈工作。</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728193955912.png" alt="image-20230728193955912"></p><p>说是协议栈，其实就是中间tcp udp ip这些协议。那下面我们就来仔细的看看</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>tcp段的头如下所示：</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728194108402.png" alt="image-20230728194108402"></p><p>TCP 传输数据之前，要先三次握手建立连接</p><p>前提：客户端 为closed状态，服务端变成listen状态</p><p>连接：</p><p>1、客户端向服务端发送连接syn，之后客户端处于syn-sent状态；</p><p>2、服务端接收到这个消息之后，会返回一个syn+ack，之后服务端处于syn-rcvd状态</p><p>3、客户端收到这个之后，再给服务端发送一个对syn的ack，之后客户端处于establish状态</p><p>服务端收到ack也变成了establish状态</p><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><p>假设我们已经建立了连接，我们要发送消息，但是消息要遵循tcp协议，他的消息大小是有限制的，不是每一次都可以发送全部消息。具体要求如下：</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728195857751.png" alt="image-20230728195857751"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li></ul><p>所以如果http请求消息超过mss，那么就要分段发送。</p><p>到这里我们得到了一个tcp的报文段或者说包，下面我们就要把这个包发送给网络层，因为在传输层我们就是服务应用层，然后对好端口，确定好协议，之后的事情就不归传输层管控了。</p><p>到这里，我们的数据包的格式如下所示：</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728200405680.png" alt="image-20230728200405680"></p><h2 id="定位IP"><a href="#定位IP" class="headerlink" title="定位IP"></a>定位IP</h2><p>ip协议的最重要的功能就是寻址和路由，他要做到这两点就需要你遵循ip协议，那么遵循的要求就是你加一个ip头<img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728200452235.png" alt="image-20230728200452235"></p><p>加上ip头之后我们就知道了我们的源ip和目的ip地址，那么起点站和终点站就已经知道了</p><p>可以现在又有一个小问题，那就是路径怎么规划呢？这时候就需要用到Mac地址</p><h2 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h2><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728202408619.png" alt="image-20230728202408619"></p><ul><li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li><li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询</li></ul><p>也就是说到了网络接口层，要发了，结果不知道往哪里发，这时候就按照上面两步得到mac地址</p><p>因为上面已经得到了ip地址，所以直接喊话：这个 IP 地址是谁的？请把你的 MAC 地址告诉我，就得到mac地址了。</p><p>到这里数据包还差最后一层包装</p><h2 id="出口–网卡"><a href="#出口–网卡" class="headerlink" title="出口–网卡"></a>出口–网卡</h2><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728204942674.png" alt="image-20230728204942674"></p><p>最后一层包装就是上面图片提到的报头和起始帧分界符和fcs帧校验序列</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p>到这里数据包就真正的包装结束了，最后网卡会将包转为电信号，通过网线发送出去。！！</p><h2 id="送别者—交换机"><a href="#送别者—交换机" class="headerlink" title="送别者—交换机"></a>送别者—交换机</h2><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><p>一般在网线接口啊这些地方，其实路由器也可以作为交换机。</p><h3 id="交换机的包接收操作"><a href="#交换机的包接收操作" class="headerlink" title="交换机的包接收操作"></a>交换机的包接收操作</h3><p>交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的fcs校验错误，没问题就放到缓存区，这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><h3 id="查询MAC-地址表"><a href="#查询MAC-地址表" class="headerlink" title="查询MAC 地址表"></a>查询<strong>MAC 地址表</strong></h3><p>如果找到，就发送到相应的端口，如果找不到，那说明该mac地址的设备还没有向我们交换机发送过包，那这时候我们主动的向除了源端口的所有端口都发送一遍，因为后面的设备他自己都有检测功能，所以不需要担心</p><p>这时候要么就发送到位，要么就可能离开子网了，离开子网需要用到路由器</p><h2 id="出境大门–路由器"><a href="#出境大门–路由器" class="headerlink" title="出境大门–路由器"></a>出境大门–路由器</h2><h3 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h3><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p><p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p><p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p><h3 id="路由器的发送操作"><a href="#路由器的发送操作" class="headerlink" title="路由器的发送操作"></a>路由器的发送操作</h3><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>反正我们从路由表知道了ip地址，那么我们同样用这个地址去查mac地址</p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这边举个例子<img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230729000740012.png" alt="image-20230729000740012"></p><p>子网1某个设备想要发送数据给子网2的某个设备</p><p>首先源ip和目的ip是知道的，如果只是简单的arp群发这个ip问是谁的ip地址，其实是找不到的，所以判断是否为同一子网，如果不是，就把目的mac改成网关的mac，然后数据发送到网关，这时候官网一查mac地址，发现属于子网2的设备，这时候修改源mac为自己的mac，修改目的mac为设备的地址，从子网2的网卡发出。</p><p>大多数情况下一个子网的默认网关就是一个，就基本代表着出口。复杂情况就需要某种选择算法了</p><h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><p>下面我们来讲一下http 也叫超文本传输协议，就是两点之间超越普通文本范畴的文本（包括文本视频图片等等）的一种协议</p><h4 id="http常见状态码"><a href="#http常见状态码" class="headerlink" title="http常见状态码"></a>http常见状态码</h4><p>1XX 代表提示信息，表示这是处理的中间状体，后续还有操作</p><p>2XX 这个就是成功的状态吗</p><p>​200 普通的正常的成功</p><p>​204 没有body的成功，就是响应头里面没有body数据的意思</p><p>​206 用于分快下载，断点续传，</p><p>3XX 代表重定向</p><p>​ 301 永久重定向</p><p>​302 临时重定向</p><p>​304缓存重定向，也就是配合协商缓存那一块</p><p>4XX 带表客户端的报文错误</p><p>​400 比较笼统的</p><p>​403 禁止范围</p><p>​404 没找到</p><p>5XX 代表服务器端端报文错误</p><p>​500 同样比较笼统</p><p>​501 目前不支持</p><p>​502 自身服务器没问题，后续转发的服务器有问题</p><p>​503 请稍后再访问</p><h4 id="常见的字段"><a href="#常见的字段" class="headerlink" title="常见的字段"></a>常见的字段</h4><p>host</p><p>content-length</p><p>content-type</p><p>connection </p><p>content-encodeing</p><h4 id="Http缓存"><a href="#Http缓存" class="headerlink" title="Http缓存"></a>Http缓存</h4><p>包括强制缓存和协商缓存</p><p>强制缓存就是浏览器判断缓存没有过期，那我就直接使用浏览器的缓存</p><p>实现可以用两个响应头部的字段表示Cache-control和Expires，前者相对时间，后者绝对时间，前者优先级更高，更加精细</p><p>协商缓存也是有两种方法</p><p>1、请求头部里面的if modified since 和响应头部last- modified</p><p>先问浏览器缓存，如果没过期那就是强制缓存，如果过期了，响应信息的头部会有last modified，然后我们会带这个ifmodifiedsince：时间，去访问服务器，服务器看到之后，就拿自己的Last modified去对比 如果没改，返回304，如果改了，返回200</p><p>2、Etag 唯一标识</p><p>流程一样，但是etag优先级更高，因为 if modified since还是基于时间，而时间本身可能有一些限制。</p><p>1、有可能没有修改文件，但是文件的最后修改时间会变化</p><p>2、秒级以内的操作也许不能充分做出响应</p><h4 id="Http优缺点"><a href="#Http优缺点" class="headerlink" title="Http优缺点"></a>Http优缺点</h4><p>优点：简单，灵活易扩充，应用广泛跨平台</p><p>缺点：</p><p>1、http无状态的，所以导致一系列相联的操作可能每一次都要反问数据库，那就非常的繁琐</p><p>在此基础上出现了cookie技术，他就是通过在请求和响应报文里面增加cookie信息，来控制客户端的状态</p><p>2、明文传输。毫无隐私</p><p>3、不安全 也是最重要的原因</p><p>账号信息不安全</p><p>不验证对方的身份</p><p>无法证明报文的完整性</p><p>对于1.0改进：</p><p>1、http1.1在http1.0的基础上提出了长连接，之前是《请求-应答》模式就是你发完应答完，关闭连接，想要进行下一次通信，那就得重新建立连接，现在可以建立一次连接之后，就可以 发收发收发收 只要一方没有明确提出断开连接，那么就一直连着</p><p>2、管道通信，http1.1支持管道，就是所有请求都处于管道内部，我们可以发发发，而不需要等他先回复再发第二个，你可以发发发，减少了时间</p><p>但是这里有一个问题，http是基于tcp的所以服务端会按照顺序接收请求。</p><p>所以说，http1.1可以解决发送端的对头阻塞，但是无法解决接受端的对头阻塞</p><p>然而！然而！http1.1默认不开启管道，</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>但是安全性的那三个缺点依旧无法得到改善，所以提出了https &#x3D; http + tls</p><p>https完美的解决了：窃听风险、篡改风险、冒充风险，其实就是（防止号不会没，内容数据不会被插入一些垃圾广告，访问的网站不是冒充）</p><p>所以给予上面这句话，我们可以知道tls他其实做了三件事情：信息加密，校验机制，身份证书</p><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><h4 id="1、信息加密"><a href="#1、信息加密" class="headerlink" title="1、信息加密"></a>1、信息加密</h4><p>使用的是混合加密，采用对称加密和非对称加密的结合体，混合加密，就是两种都用到了，非对称加密是在tls握手的时候，对称加密是在传输数据的时候。</p><p>非对成加密安全，非对称加密速度更快。</p><h4 id="2、校验机制，身份证书，这两个可以一起讲"><a href="#2、校验机制，身份证书，这两个可以一起讲" class="headerlink" title="2、校验机制，身份证书，这两个可以一起讲"></a>2、校验机制，身份证书，这两个可以一起讲</h4><p>对内容先哈希算法，然后用私钥加密哈希结果得到的结果叫数字签名，把数字签名和原本的内容和在一起就相当于认证了</p><p>然后现在还是缺一个身份验证的问题，就是这个私钥到底对不对？</p><p>这时候需要一个权威机关，就叫CA</p><p>整体流程：服务器发送公钥和数字签名发到CA里面，CA用自己的私钥加密服务器的公钥和数字签名，这个就是证书！然后客户端发来请求的时候，服务器就把自己的证书发过去，客户端收到证书，用CA的公钥解密，得到了服务器的公钥和服务器的数字证签名，这个签名我们上面讲了一个是原始内容一个是私钥对于哈希值的加密，那我们怎么验证呢？就是用公钥去解密加密项得到一个哈希值，再对原始内容做同样的哈希操作，判断两个哈希值到底一不一样，一样代表认证成功，否则，认证失败。</p><h4 id="TLS的连接"><a href="#TLS的连接" class="headerlink" title="TLS的连接"></a>TLS的连接</h4><p>tls的密钥交换算法不同，那么连接步骤也不同，我们会介绍两种</p><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><h5 id="1、客户端-gt-服务端。client-随机数-tls版本好-密码套件，密码套件可以说是一组配置的整合信息罢了"><a href="#1、客户端-gt-服务端。client-随机数-tls版本好-密码套件，密码套件可以说是一组配置的整合信息罢了" class="headerlink" title="1、客户端 &gt; 服务端。client 随机数 + tls版本好+密码套件，密码套件可以说是一组配置的整合信息罢了"></a>1、客户端 &gt; 服务端。client 随机数 + tls版本好+密码套件，密码套件可以说是一组配置的整合信息罢了</h5><h5 id="2、客户端-lt-服务端。server随机数-确认版本号-确认密码套件-自己的数字证书Done"><a href="#2、客户端-lt-服务端。server随机数-确认版本号-确认密码套件-自己的数字证书Done" class="headerlink" title="2、客户端 &lt; 服务端。server随机数+确认版本号+确认密码套件+自己的数字证书Done"></a>2、客户端 &lt; 服务端。server随机数+确认版本号+确认密码套件+自己的数字证书Done</h5><p>当然这里收到之后，先校验，校验流程如下：</p><p>首先我们知道了数字签名有原始内容和对于哈希值加密的数字签名，我们对原始内容加密（签名算法），对数字签名解密（CA公钥）</p><p>当然，其中有一个问题就是证书的信任问题？为什么？</p><p>因为我们得到的证书不一定是CA签发的，假如是中间机构签发的百度证书，那么我们就不能用内置的本地CA证书中的公钥去认证，所以我们先找签发机构，发现是一个中间机构，我们向中间机构请求证书，收到证书后发现这个机构的签发者是CA，那么我们可以用CA去认证中间的这个证书，这个证书被认证了 ，那么百度的也没认证了。</p><h4 id="3、客户端-gt-服务端-使用服务器的公钥加密pre-master随机数发给服务端"><a href="#3、客户端-gt-服务端-使用服务器的公钥加密pre-master随机数发给服务端" class="headerlink" title="3、客户端 &gt; 服务端 使用服务器的公钥加密pre-master随机数发给服务端"></a>3、客户端 &gt; 服务端 使用服务器的公钥加密pre-master随机数发给服务端</h4><h5 id="4、客户端-lt-服务端-服务端发送-加密算法改变通知，和握手结束通知"><a href="#4、客户端-lt-服务端-服务端发送-加密算法改变通知，和握手结束通知" class="headerlink" title="4、客户端 &lt; 服务端 服务端发送 加密算法改变通知，和握手结束通知"></a>4、客户端 &lt; 服务端 服务端发送 加密算法改变通知，和握手结束通知</h5><p>这样，两边就都有了三个随机数，算出会话密钥</p><p>之后的通信就用会话密钥了</p><p>上面这个就是RSA的基本流程，但是基于RSA的https依旧存在《前向安全》的问题，如果服务端私钥泄密，那么所有的tls通讯就将被破解</p><h4 id="ECDHE"><a href="#ECDHE" class="headerlink" title="ECDHE"></a>ECDHE</h4><p>1、客户端 &gt; 服务端。client Hello消息。随机数+tls版本好+密码套件。</p><p>2、客户端 &lt; 服务端。serverhello消息，随机数+确认版本号+确认密码套件。certificate消息（证书）。ServerKeyExchange消息（选择名为25519的椭圆曲线基点G，生成随机数作为私钥保留本地，用G点和私钥算出公钥，对公钥做签名）。Server Hello Done。</p><p>3、客户端 &gt; 服务端 校验证书，用服务端给的信息生成自己的公钥，发送client key exchange发给服务端</p><p>至此，双方都有各自的公钥，自己的私钥，曲线基点，所以能算出x</p><p>最终的会话密钥（客户端随机数，服务端随机数，x）</p><p>算好后，客户端会发一个change cipher spec，开始使用对成算法加密通信</p><p>接着，客户端再发一个excryted handshake message消息，把之前的摘要加密，让服务端做个验证。</p><p>4、最后，服务端也会有一个同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。</p><p>RSA和ECDHE的区别</p><ul><li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；</li><li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间（这个是 RFC 文档规定的，具体原因文档没有说明，所以这点我也不太明白）；</li><li>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息</li></ul><h4 id="https怎么实现数据的完整性？"><a href="#https怎么实现数据的完整性？" class="headerlink" title="https怎么实现数据的完整性？"></a>https怎么实现数据的完整性？</h4><p>刚才我们提到了TLS可以解决三个问题，包括完整性，</p><p>其实TLS在实现上包括了握手协议和记录协议</p><p>​握手协议就是四次握手+后续加密来保护应用程序</p><p>​记录协议负责保护数据的完整性和来源</p><p>所以我们来看记录协议：，他的实现就是负责对消息（http数据）的压缩，加密和数据认证<img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230802185945107.png" alt=""></p><p>这里还是应用层，消息被分割后进行压缩，加上消息验证码，加密，加密后加上一个报头，后面就是交给tcp层，传输层</p><h4 id="HTTPS一定安全吗"><a href="#HTTPS一定安全吗" class="headerlink" title="HTTPS一定安全吗"></a>HTTPS一定安全吗</h4><p>理论上这个协议是安全的，https其实就是加了个tls协议，那就是问这个tls是不是安全的</p><p>而tls就是按四次握手</p><p>1、第一种方法：返回的证书，他大概率是伪造的，但是我们如果叫接受了，那就不一样了，你接受了服务器的证书，相当于信任了，那后面的通信就会被监听</p><p>2、直接植入根证书也会导致这种情况</p><p>所以关键就是对于证书的认证</p><h3 id="http1-1-gt-http-2-gt-http3"><a href="#http1-1-gt-http-2-gt-http3" class="headerlink" title="http1.1  -&gt; http 2 -&gt; http3"></a>http1.1  -&gt; http 2 -&gt; http3</h3><h5 id="http1-1在http1-0的基础上增了长连接和管道，解决了发送方的对头阻塞"><a href="#http1-1在http1-0的基础上增了长连接和管道，解决了发送方的对头阻塞" class="headerlink" title="http1.1在http1.0的基础上增了长连接和管道，解决了发送方的对头阻塞"></a>http1.1在http1.0的基础上增了长连接和管道，解决了发送方的对头阻塞</h5><p>缺点：header是没有压缩的，只压缩了body部分，接收方会有对头阻塞，服务端智能被动响应</p><h5 id="http2在是基于https的，所以安全性肯定有保障"><a href="#http2在是基于https的，所以安全性肯定有保障" class="headerlink" title="http2在是基于https的，所以安全性肯定有保障"></a>http2在是基于https的，所以安全性肯定有保障</h5><p>1、头部压缩</p><p>http1.1报文是【header+body】对于body部分可以通过content- encoding指定比如gzip，但是http1.1对Header不做出处理</p><p>http2会压缩头部，如果同时发送多个请求，头是一样的化，协议就会帮你压缩消除重复的部分</p><p>这就是HPACK算法，HPACK包括三个部分（静态字典、动态字典、huffman编码）</p><p>2、二进制格式</p><p>http2不像是http1是纯文本的报文，而是全部改成了二进制，头部和数据题都是二进制，统称帧</p><p>3、并发传输，引入了流的机制</p><p>一条tcp连接有多个流，每个流可以包含一个或者多个message，这个message就是请求或者响应，message里面有一个或者多个frame帧，不同的http请求有独一无二的帧，所以可以乱序发送，后面会按照streamid组装，<strong>同一 Stream 内部的帧必须是严格有序的</strong></p><p>4、服务器主动推送</p><p>缺点：</p><p>他是基于tcp协议的，tcp是字节流，所以必须保证收到的数据是完整连续的，才会把数据交给应用，如果有一个数据卡住了，那么后面的流都要卡住，那就会触发超时重传，一个tcp连接的http请求都要等待的这个重传成功。</p><h5 id="http3，就把tcp换成了udp，但是为了可靠，推出了QUIC"><a href="#http3，就把tcp换成了udp，但是为了可靠，推出了QUIC" class="headerlink" title="http3，就把tcp换成了udp，但是为了可靠，推出了QUIC"></a>http3，就把tcp换成了udp，但是为了可靠，推出了QUIC</h5><p>1、没有对头阻塞</p><p>借鉴了http2的流，就是每一个流都有一个自己的滑动窗口，某个流内部的确还是会阻塞，但是各个流之间是相互独立的，一个流阻塞了，另外的流不会阻塞，这样就保证了没有对头阻塞</p><p>2、更快连接</p><p>因为http2里面tcp和tls是分层的先三次握手然后四次握手，这样需要3个rtt</p><p>然后在http3厘米quic内部适合tls一起的，而且只需要一个rtt就可以完成密钥的协商，用的是tls1.3，1.3版本有话了过程，就是说，第一次发送的时候就已经把签名算法、随机数都发给服务端了。</p><p>，甚至在第二次可以达到0rtt</p><p>3、连接迁移</p><p>tcp是四元组，而quic是基于dcp的，他是考连接id来标记通信，所以ip换了也没事</p><p>4、头部压缩变成了QPACK，静态表变成91项，动态编码方式换了，</p><h4 id="http1-1请求怎么优化"><a href="#http1-1请求怎么优化" class="headerlink" title="http1.1请求怎么优化"></a>http1.1请求怎么优化</h4><p>一方面是http发送的问题，一方面是他本身数据的问题</p><p>1、首先肯定是避免http请求：缓存技术</p><p>2、减少重定向，这个就是把重定向请求交给代理服务器</p><p>3、合并请求，就是把多个访问小文件的请求合并成一个大的</p><p>4、延迟发送，只访问看得到的资源</p><p>5、无损压缩，accept- encoding：gzip br </p><p>6、有损压缩，webP png</p><h4 id="https怎么优化"><a href="#https怎么优化" class="headerlink" title="https怎么优化"></a>https怎么优化</h4><p>https对于http多了一个tls，关键就是通过非对成加密握手得到对成加密的会话密钥</p><ul><li>提高cpu</li><li>升级linux </li><li>对密钥交换过程进行优化</li><li>RSA要四次握手，慢，安全性不高，我们可以缓存eche密钥交换算法，曲线选择x25519，对成加密算法，也可以换aes128</li><li>tls升级1.3，升级的地方在于hello和公钥交换两个消息合并成一个消息</li><li>证书优化，分为传输优化和验证优化。</li></ul><p>传输：服务器证书选择椭圆曲线</p><p>验证：验证的过程中不仅需要ca还需要是否被ca吊销；crl是吊销列表，ca定期更新，但是实时性不好，ocsp，向ca fan song请求，返回状态，这个增加了请求开销，万一网络不好或者ca繁忙就会出现延迟；oscp stapling，服务器向ca定期查证书状态，然后在握手阶段就直接发给客户端，这样客户端就不用再去请求了。</p><ul><li>会话复用：session id 和session ticket</li></ul><p>session id：首次连接后，在内存缓存会话密钥，用session id标识，再次连接的时候，会在hello消息中带上这个，服务器收到这个就从缓存里面找，直接回复会话状态，跳过中间流程</p><p>缺点是，内存压力大</p><p>session ticket：类似于cookie，把缓存的工作交给客户端，首次连接，会加密这个发给客户端缓存起来，第二次连接，客户端会发送ticket，服务器解密后验证日期是否有效，没问题就恢复会话。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql复习1</title>
      <link href="/2023/07/08/MYSQL%E5%A4%8D%E4%B9%A01/"/>
      <url>/2023/07/08/MYSQL%E5%A4%8D%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<p>执行一个mysql语句会发生什么？</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>你要有一个和数据库的连接，这时候，接待你的就是连接器</p><p>mysql -h ip -P port -u user -p</p><p>然后这个连接是tcp连接，所以会比较麻烦，那这样子的话，我就们尽量使用长连接</p><p>然而在mysql在执行过程中临时使用的内内存是管理在连接对象里面的，这些资源只有在连接断开的时候才会释放，如果长连接一直进行，可能导致内存占用过大，被系统强行杀掉OOM，可以考虑两种方式解决：</p><p>1、定期的断开长连接，比如在程序中加一个判断内存是否占用过大的查询</p><p>2、如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>8.0以后不用了，因为缓存命中率很低的，比如一条更新语句会使得缓存里面的所有相关的表全部失效，</p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>包括词法分析和语法分析</p><p>词法分析就是分析是什么，代表什么意思</p><p>语法分析就是分析符不符合语法要求</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器就是确定一个执行效率高的执行方案，比如选择索引、连接表的顺序等等</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>真正的执行</p><p>但是更新操作还会涉及两个表的操作，一个是redo log 一个是binlog</p><p>这两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>这两个日志的配合是使用两阶段提交</p><p><img src="/Users/csen/Documents/Amusement/Sen-Blog/source/images/MYSQL1/image-20230805142953314.png" alt="image-20230805142953314"></p><p>可以发现将redo log的写入分成了两个阶段，一个是prepare 一个commit</p><p>在两阶段提交的情况下，是怎么实现崩溃恢复的呢？<br>首先比较重要的一点是，在写入redo log时，会顺便记录XID，即当前事务id。在写入binlog时，也会写入XID。</p><p>如果在写入redo log之前崩溃，那么此时redo log与binlog中都没有，是一致的情况，崩溃也无所谓。</p><p>如果在写入redo log prepare阶段后立马崩溃，之后会在崩恢复时，由于redo log没有被标记为commit。于是拿着redo log中的XID去binlog中查找，此时肯定是找不到的，那么执行回滚操作。</p><p>如果在写入binlog后立马崩溃，在恢复时，由redo log中的XID可以找到对应的binlog，这个时候直接提交即可。</p><p>总的来说，在崩溃恢复后，只要redo log不是处于commit阶段，那么就拿着redo log中的XID去binlog中寻找，找得到就提交，否则就回滚。</p><p>在这样的机制下，两阶段提交能在崩溃恢复时，能够对提交中断的事务进行补偿，来确保redo log与binlog的数据一致性。</p><h3 id="binlog-记录内容"><a href="#binlog-记录内容" class="headerlink" title="binlog 记录内容"></a>binlog <strong>记录内容</strong></h3><p>binlog应该说是Mysql里最核心的日志， 它记录了除了查询语句(select、show)之外的所有的 <code>DDL</code> 和 <code>DML</code> 语句,也就意味着我们基本上所有对数据库的操作变更都会记录到binlog里面。binlog以事件形式记录，不仅记录了操作的语句，同时还记录了语句所执行的消耗的时间。 binlog 有三种记录格式，分别是ROW、STATEMENT、MIXED。</p><p><strong>1、ROW：</strong> 基于变更的数据行进行记录，如果一个update语句修改一百行数据，那么这种模式下就会记录100行对应的记录日志。</p><p><strong>2、STATEMENT：</strong>基于SQL语句级别的记录日志，相对于ROW模式，STATEMENT模式下只会记录这个update 的语句。所以此模式下会非常节省日志空间，也避免着大量的IO操作。</p><p><strong>3、MIXED：</strong> 混合模式，此模式是ROW模式和STATEMENT模式的混合体，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。</p><p>这三种模式需要注意的是：使用 row 格式的 binlog 时，在进行数据同步或恢复的时候不一致的问题更容易被发现，因为它是基于数据行记录的。而使用 mixed 或者 statement 格式的 binlog 时，很多事务操作都是基于SQL逻辑记录，我们都知道一个SQL在不同的时间点执行它们产生的数据变化和影响是不一样的，所以这种情况下，数据同步或恢复的时候就容易出现不一致的情况。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>典型的使用场景就是做全库的逻辑备份，对所有的表进行 行锁定，从而获取一致性视图，保证数据的完整性。加了全局锁就是只能读</p><ul><li><p>一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性 和完整性 .</p></li><li><p>语法</p><p>1、加全局锁</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure><p>2、数据备份</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pxxx db_name <span class="operator">-</span><span class="operator">&gt;</span> xxx.sql;</span><br></pre></td></tr></table></figure><p>3、释放锁</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure></li></ul><h4 id="数据库中加全局锁，是一个比较重的操作，存在的问题有："><a href="#数据库中加全局锁，是一个比较重的操作，存在的问题有：" class="headerlink" title="数据库中加全局锁，是一个比较重的操作，存在的问题有："></a>数据库中加全局锁，是一个比较重的操作，存在的问题有：</h4><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致 性数据备份。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot -pxxx db_name -&gt; xxx.sql;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁，主要分为3类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ul><p>表锁</p><p>对于表锁，又可以分为2类：</p><ul><li>表共享读锁（read lock）</li><li>表独占写锁（write lock）</li></ul><p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞 其他客户端的写。</p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>再来说说<strong>元数据锁</strong>（MDL）。</p><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p><p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p><blockquote><p>MDL 不需要显示调用，那它是在什么时候释放的?</p></blockquote><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL 锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与 DDL冲突，保证读写的正确性。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>我觉得意向锁主要还是解决行锁和表锁之间的冲突问题。</p><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul><p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加行级独占锁。</p><p><img src="/../images/MYSQL%E5%A4%8D%E4%B9%A01/20e0f35589584352bd15e817668a0886.png" alt="img"></p><p><img src="/../images/MYSQL%E5%A4%8D%E4%B9%A01/6e6b275c2d6d4dfcbbb338be4f61bee9.png" alt="img"></p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他 锁</li></ul><p><img src="/Users/csen/Documents/Amusement/Sen-Blog/source/images/MYSQL1/image-20230805221422216.png" alt="image-20230805221422216"></p><h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><p><a href="https://blog.csdn.net/weixin_35794878/article/details/125741468">https://blog.csdn.net/weixin_35794878/article/details/125741468</a></p><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><h2 id="实现隔离级别的方式："><a href="#实现隔离级别的方式：" class="headerlink" title="实现隔离级别的方式："></a>实现隔离级别的方式：</h2><p>事务有四个隔离级别</p><p><strong>一级封锁协议 (对应 read uncommited)</strong> 　<br>一级封锁协议是：事务在对需要修改的数据上面（就是在发生修改的瞬间）对其加共享锁（其他事务不能更改，但是可以读取-导致“脏读”），直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。</p><p><strong>二级封锁协议 （对应read commited)</strong>　<br>二级封锁协议是：1）事务在对需要更新的数据上（就是发生更新的瞬间）加排他锁（直到事务结束），防止其他事务读取未提交的数据，这样，也就避免了“脏读”的情况。2）事务对当前被读取的数据上面加共享锁（当读到时加上共享锁），一旦读完该行，立即释放该该行的共享锁-从数据库的底层实现更深入的来理解，既是，数据库会对游标当前的数据上加共享锁，但是当游标离开当前行的时候，立即释放该行的共享锁。</p><p><strong>三级封锁协议 （对应reapetable read ）</strong>（默认）<br>三级封锁协议是：二级封锁协议加上事务在读取数据的瞬间必须先对其加共享锁，但是直到事务结束才释放，这样保证了可重复读（既是其他的事务职能读取该数据，但是不能更新该数据）。</p><p><strong>最强封锁协议（对应Serialization)</strong><br>四级封锁协议是对三级封锁协议的增强，其实现机制也最为简单，直接对事务中所读取或者更改的数据所在的表加表锁，也就是说，其他事务不能读写该表中的任何数据。这样所有的脏读，不可重复读，幻读，都得以避免</p><h3 id="MVCC。"><a href="#MVCC。" class="headerlink" title="MVCC。"></a>MVCC。</h3><p><strong>MVCC</strong> 在 <strong>MySQL InnoDB</strong> 中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。可认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此额外开销更低。</p><p>什么是当前读和快照读？<br>在学习 MVCC 多版本并发控制之前，我们必须先了解一下，什么是 MySQL InnoDB 下的当前读和快照读?</p><p>当前读<br>像 select lock in share mode (共享锁), select for update; update; insert; delete (排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</p><p>快照读<br>像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC ,可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p><p>说白了 MVCC 就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现<br>当前读，快照读和MVCC的关系</p><p>MVCC 多版本并发控制是 「维持一个数据的多个版本，使得读写操作没有冲突」 的概念，只是一个抽象概念，并非实现</p><p>因为 MVCC 只是一个抽象概念，要实现这么一个概念，MySQL 就需要提供具体的功能去实现它，「快照读就是 MySQL 实现 MVCC 理想模型的其中一个非阻塞读功能」。而相对而言，当前读就是悲观锁的具体功能实现</p><p>要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC 模型在 MySQL 中的具体实现则是由 3 个隐式字段，undo 日志 ， Read View 等去完成的，具体可以看下面的 MVCC 实现原理</p><p>MVCC 能解决什么问题，好处是？<br>数据库并发场景有三种，分别为：</p><p>读-读：不存在任何问题，也不需要并发控制<br>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读<br>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失<br>MVCC 带来的好处是？<br>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以 MVCC 可以为数据库解决以下问题</p><p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能<br>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题<br>小结一下咯<br>简而言之，MVCC 就是因为大佬们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了 MVCC，所以我们可以形成两个组合：</p><ul><li><code>MVCC + 悲观锁</code><br>MVCC解决读写冲突，悲观锁解决写写冲突</li><li><code>MVCC + 乐观锁</code><br>MVCC 解决读写冲突，乐观锁解决写写冲突</li></ul><p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p><p>MVCC只在repeatable read和read committed两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容，因为read uncommitted总是读取最新的数据行，而不是符合当前事务版本的数据行。而serializable则会对所有读取的行都加锁。</p><p><strong>READ COMMITTED —— 每次读取数据前都生成一个ReadView</strong></p><p><strong>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习3</title>
      <link href="/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A03/"/>
      <url>/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A03/</url>
      
        <content type="html"><![CDATA[<h3 id="这一章节就来学习IP协议"><a href="#这一章节就来学习IP协议" class="headerlink" title="这一章节就来学习IP协议"></a>这一章节就来学习IP协议</h3><p>我们知道两个不相连的网络之间的传输其实靠的是ip地址，两个直连的设备之间的用的协议MAC头，</p><p>ipv4是32位</p><p>我们把这些分成了5类，包括a类，b类，c类，d类，e类</p><p>a类是0开头，b类是10开头，c类是11开头，d类是1110开头，然后e类是1111开头</p><p>d类用于多播，多播是可以穿透网段的，e类用于留存</p><p>然后每个网络号对应的主机号的数量其实是2的主机号次幂-2，因为，主机号全为0指定某个网络，主机号全为1指代某个网络下的所有主机，用于广播</p><p>广播是用于对链路中相互连接的主机发送消息</p><p>在本网络中的广播叫做本地广播，不同网络之间的叫直接广播、</p><p>这种分类方式的好处就是简单，清晰</p><p>但是有缺点：</p><p>首先同一层次下，没有分类</p><p>第二，不能和现实网络很好的适配</p><p>所以提出了无分类地址cidr</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A03/image-20230804145043580.png" alt="image-20230804145043580"></p><p>我们知道可以通过子网掩码划分出网络号和主机号，那实际上子网掩码还有一个作用，那就是<strong>划分子网</strong>。</p><p><strong>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址</strong></p><p>其实就是在a类b类上再分而已</p><p>dhcp</p><p>先说明一点，DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号。</p><p>这 4 个步骤：</p><ul><li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP <strong>广播</strong>通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li><li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCP OFFER）</strong> 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 <strong>IP 地址租用期</strong>。</li><li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数。</li><li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数。</li></ul><p>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入网络，期间发生了什么？</title>
      <link href="/2023/07/08/%E8%BE%93%E5%85%A5%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2023/07/08/%E8%BE%93%E5%85%A5%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？"><a href="#输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？" class="headerlink" title="输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？"></a>输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？</h1><h2 id="1、解析url"><a href="#1、解析url" class="headerlink" title="1、解析url"></a>1、解析url</h2><p>首先，就是对我们输入的url进行解析，一般可以得到三个信息：协议，web服务器，文件的路径</p><p>拿到这三个信息之后我们就可以包装成一个http请求信息</p><p>![image-20230728193306158](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728193306158.png)</p><p>如图所示，一个是请求一个是响应报文</p><p>那我们生产出一个消息之后就要开始发送？那应该怎么发？往哪里发？</p><p>这就需要下面的知识。</p><h2 id="地址查询-——-DNS"><a href="#地址查询-——-DNS" class="headerlink" title="地址查询 —— DNS"></a>地址查询 —— DNS</h2><p>基于我们已经拿到的web服务器域名，我们可以先去浏览器缓存里面找有没有，如果有，就直接返回，如果没有那就问操作系统的缓存再去看hosts文件，如果都没有，那就看走下面</p><p>客户端首先会发出一个 DNS 请求，问 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</p><p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.xx.com,则它直接返回/">www.xx.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</p><p>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.xx.com/">www.xx.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</p><p>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？”</p><p>顶级域名服务器说：“我给你负责 <a href="http://www.xx.com/">www.xx.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</p><p>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.xx.com对应的IP是啥呀？”">www.xx.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</p><p>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</p><p>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接</p><p>![image-20230728193808617](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728193808617.png)</p><p>通过dns或者缓存获取到ip地址之后，我们就要为发送做一些准备，首先浏览器通过调用 Socket 库，来委托协议栈工作。</p><p>![image-20230728193955912](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728193955912.png)</p><p>说是协议栈，其实就是中间tcp udp ip这些协议。那下面我们就来仔细的看看</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>tcp段的头如下所示：</p><p>![image-20230728194108402](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728194108402.png)</p><p>TCP 传输数据之前，要先三次握手建立连接</p><p>前提：客户端 为closed状态，服务端变成listen状态</p><p>连接：</p><p>1、客户端向服务端发送连接syn，之后客户端处于syn-sent状态；</p><p>2、服务端接收到这个消息之后，会返回一个syn+ack，之后服务端处于syn-rcvd状态</p><p>3、客户端收到这个之后，再给服务端发送一个对syn的ack，之后客户端处于establish状态</p><p>服务端收到ack也变成了establish状态</p><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><p>假设我们已经建立了连接，我们要发送消息，但是消息要遵循tcp协议，他的消息大小是有限制的，不是每一次都可以发送全部消息。具体要求如下：</p><p>![image-20230728195857751](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728195857751.png)</p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li></ul><p>所以如果http请求消息超过mss，那么就要分段发送。</p><p>到这里我们得到了一个tcp的报文段或者说包，下面我们就要把这个包发送给网络层，因为在传输层我们就是服务应用层，然后对好端口，确定好协议，之后的事情就不归传输层管控了。</p><p>到这里，我们的数据包的格式如下所示：</p><p>![image-20230728200405680](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728200405680.png)</p><h2 id="定位IP"><a href="#定位IP" class="headerlink" title="定位IP"></a>定位IP</h2><p>ip协议的最重要的功能就是寻址和路由，他要做到这两点就需要你遵循ip协议，那么遵循的要求就是你加一个ip头![image-20230728200452235](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728200452235.png)</p><p>加上ip头之后我们就知道了我们的源ip和目的ip地址，那么起点站和终点站就已经知道了</p><p>可以现在又有一个小问题，那就是路径怎么规划呢？这时候就需要用到Mac地址</p><h2 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h2><p>![image-20230728202408619](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728202408619.png)</p><ul><li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li><li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询</li></ul><p>也就是说到了网络接口层，要发了，结果不知道往哪里发，这时候就按照上面两步得到mac地址</p><p>因为上面已经得到了ip地址，所以直接喊话：这个 IP 地址是谁的？请把你的 MAC 地址告诉我，就得到mac地址了。</p><p>到这里数据包还差最后一层包装</p><h2 id="出口–网卡"><a href="#出口–网卡" class="headerlink" title="出口–网卡"></a>出口–网卡</h2><p>![image-20230728204942674](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728204942674.png)</p><p>最后一层包装就是上面图片提到的报头和起始帧分界符和fcs帧校验序列</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p>到这里数据包就真正的包装结束了，最后网卡会将包转为电信号，通过网线发送出去。！！</p><h2 id="送别者—交换机"><a href="#送别者—交换机" class="headerlink" title="送别者—交换机"></a>送别者—交换机</h2><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><p>一般在网线接口啊这些地方，其实路由器也可以作为交换机。</p><h3 id="交换机的包接收操作"><a href="#交换机的包接收操作" class="headerlink" title="交换机的包接收操作"></a>交换机的包接收操作</h3><p>交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的fcs校验错误，没问题就放到缓存区，这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><h3 id="查询MAC-地址表"><a href="#查询MAC-地址表" class="headerlink" title="查询MAC 地址表"></a>查询<strong>MAC 地址表</strong></h3><p>如果找到，就发送到相应的端口，如果找不到，那说明该mac地址的设备还没有向我们交换机发送过包，那这时候我们主动的向除了源端口的所有端口都发送一遍，因为后面的设备他自己都有检测功能，所以不需要担心</p><p>这时候要么就发送到位，要么就可能离开子网了，离开子网需要用到路由器</p><h2 id="出境大门–路由器"><a href="#出境大门–路由器" class="headerlink" title="出境大门–路由器"></a>出境大门–路由器</h2><h3 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h3><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p><p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p><p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p><h3 id="路由器的发送操作"><a href="#路由器的发送操作" class="headerlink" title="路由器的发送操作"></a>路由器的发送操作</h3><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>反正我们从路由表知道了ip地址，那么我们同样用这个地址去查mac地址</p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这边举个例子![image-20230729000740012](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230729000740012.png)</p><p>子网1某个设备想要发送数据给子网2的某个设备</p><p>首先源ip和目的ip是知道的，如果只是简单的arp群发这个ip问是谁的ip地址，其实是找不到的，所以判断是否为同一子网，如果不是，就把目的mac改成网关的mac，然后数据发送到网关，这时候官网一查mac地址，发现属于子网2的设备，这时候修改源mac为自己的mac，修改目的mac为设备的地址，从子网2的网卡发出。</p><p>大多数情况下一个子网的默认网关就是一个，就基本代表着出口。复杂情况就需要某种选择算法了</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习2</title>
      <link href="/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/"/>
      <url>/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>tcp头的格式</p><p>源端口目的端口</p><p>序列号</p><p>确认应答号（也是希望你在一个发送的号）</p><p>首部长度 保留 六个控制位 窗口大小（用于流量控制那边的）</p><p>校验和 紧急指针</p><p>选项</p><p>数据</p><p>一个tcp连接是由四元组确定的</p><p>最大的tcp连接数&#x3D;客户端ip*客户端端口 </p><h4 id="UDP只有64位，源端口目的端口包长度校验和数据"><a href="#UDP只有64位，源端口目的端口包长度校验和数据" class="headerlink" title="UDP只有64位，源端口目的端口包长度校验和数据"></a>UDP只有64位，源端口目的端口包长度校验和数据</h4><p>区别：</p><p>tcpudp</p><p>一个需要连接 不需要连接</p><p>点对点 一对多&#x2F;多对多&#x2F;一对一</p><p>tcp有拥塞控制流量控制udp没有无所谓</p><p>首部长首部短</p><p>流式传输无边界包传输有边界</p><p>分片msstcpucp在ip分片</p><h4 id="UDP和TCP可以共用一个端口，因为是完全独立的两个软件模块"><a href="#UDP和TCP可以共用一个端口，因为是完全独立的两个软件模块" class="headerlink" title="UDP和TCP可以共用一个端口，因为是完全独立的两个软件模块"></a>UDP和TCP可以共用一个端口，因为是完全独立的两个软件模块</h4><h4 id="为什么不能两次握手？"><a href="#为什么不能两次握手？" class="headerlink" title="为什么不能两次握手？"></a>为什么不能两次握手？</h4><h4 id="1、在两次握手的时候，服务端没有中间状态给客户端来阻止历史连接，也就是服务端会多建立一个历史连接浪费资源，因为收到syn就变成established"><a href="#1、在两次握手的时候，服务端没有中间状态给客户端来阻止历史连接，也就是服务端会多建立一个历史连接浪费资源，因为收到syn就变成established" class="headerlink" title="1、在两次握手的时候，服务端没有中间状态给客户端来阻止历史连接，也就是服务端会多建立一个历史连接浪费资源，因为收到syn就变成established"></a>1、在两次握手的时候，服务端没有中间状态给客户端来阻止历史连接，也就是服务端会多建立一个历史连接浪费资源，因为收到syn就变成established</h4><h4 id="2、同步序列号"><a href="#2、同步序列号" class="headerlink" title="2、同步序列号"></a>2、同步序列号</h4><h4 id="3、避免资源浪费，因为万一第一个syn报文阻塞了，那么就要重复发送多次syn报文，如果是两次握手，那就需要建立多个连接"><a href="#3、避免资源浪费，因为万一第一个syn报文阻塞了，那么就要重复发送多次syn报文，如果是两次握手，那就需要建立多个连接" class="headerlink" title="3、避免资源浪费，因为万一第一个syn报文阻塞了，那么就要重复发送多次syn报文，如果是两次握手，那就需要建立多个连接"></a>3、避免资源浪费，因为万一第一个syn报文阻塞了，那么就要重复发送多次syn报文，如果是两次握手，那就需要建立多个连接</h4><h4 id="为什么，每次建立连接序列号都要求不一样？"><a href="#为什么，每次建立连接序列号都要求不一样？" class="headerlink" title="为什么，每次建立连接序列号都要求不一样？"></a>为什么，每次建立连接序列号都要求不一样？</h4><p>1、防止历史报文被下一个相同四元组的连接接受（主要原因）</p><p>2、防止黑客伪造的相同序列号被接受</p><h4 id="那这个序列号是怎么随机产生的？"><a href="#那这个序列号是怎么随机产生的？" class="headerlink" title="那这个序列号是怎么随机产生的？"></a>那这个序列号是怎么随机产生的？</h4><p>rfc提高了序列号ISN随机生成算法：ISN &#x3D; M + F</p><p>m是计时器，四微秒+1</p><p>F是哈希算法根据四元组推出来的</p><h4 id="为什么ip会分片tcp还分片，"><a href="#为什么ip会分片tcp还分片，" class="headerlink" title="为什么ip会分片tcp还分片，"></a>为什么ip会分片tcp还分片，</h4><p>因为ip不能超时重传，所以只能靠tcp，而万一ip层丢了一部分，那么ip层就不能组装成一个完整的tcp报文（头部+数据），也就不可能发给接收方tcp层，所以发送方的tcp层就会重发整个tcp报文，所以我们最好就是自己分片，然后缺什么发什么，直接以MSS为单位就可以了</p><p>第一次握手丢失，会发生什么？</p><p>其实就是重传，重传的序列号还是要一样的，然后重传的机制需要学习</p><p>就是靠tcp_syn_retries决定，假设是3，就要重传三次，<strong>每次超时的时间是上一次的 2 倍</strong>。</p><p>第二次握手丢失，会发生什么？</p><p>客户端和服务端就会认为自己的没发到，客户端和服务端都触发重传机制，tcp_synack_retries</p><p>第三次握手没收到，会发生什么</p><p>这里有一点很关键，就是ack报文是不会重传的，所以服务端会认为自己的syn+ack没发到，触发重传机制</p><h4 id="半连接状态和全连接状态"><a href="#半连接状态和全连接状态" class="headerlink" title="半连接状态和全连接状态"></a>半连接状态和全连接状态</h4><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p>正常流程：</p><ul><li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li><li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li></ul><p>所以这样子就出会先一些问题</p><p>受到SYN攻击怎么办？就是说半连接状态很多怎么办？</p><ul><li>调大 netdev_max_backlog；缓冲队列</li><li>增大 TCP 半连接队列；</li><li>开启 tcp_syncookies；不用建立半连接</li><li>减少 SYN+ACK 重传次数</li></ul><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803130523828.png" alt="image-20230803130523828"></p><p>为什么4次？关键是客户端给服务端发fin报文，说我已经没有数据要发个服务端了，但是这时候服务端可能还有数据要发给客户端，所以需要先处理自己的最后流程，然后给客户端发送一个fin报文，也就是说，第二次握手和第三次握手大概率是不同步的。</p><p>特定情况下，可以变成三次</p><p>第一次挥手丢失，会发生什么？</p><p>客户端收不到来自服务端的ack报文，那么就会触发超时重传，这个次数是由</p><p>tcp_orphan_retries决定的</p><p>第二次挥手丢失，会发生什么？</p><p>首先客户端还是会触发超时重传，这时候因为是单方向的，服务端不会触发超时重传</p><p>第三次丢失，会发生什么？</p><p>第三次丢失，相当于服务端一直收不到来自客户端的ack，那么服务端会触发超时重传，而客户端已经进入了wait2状态，一直等，如果超过设定的时间，自动关闭</p><p>第四次丢失，会发生什么？</p><p>服务端一直收不到，那么触发超时重传，这时候因为客户端已经是timewait状态，所以每一次重传都会重置2msl定时器，超过时间就close，而服务端同样的重传几次之后close</p><p>msl是报文最大生存时间，ip头有一个ttl字段，这个字段代表可以经历的最大路由数</p><p>msl大于等于ttl消耗为0的时间，默认60</p><h4 id="为什么需要这个timewait状态"><a href="#为什么需要这个timewait状态" class="headerlink" title="为什么需要这个timewait状态"></a>为什么需要这个timewait状态</h4><p>1、为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</strong></p><p>2、也就是说，TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p><h4 id="出现大量超连接的原因"><a href="#出现大量超连接的原因" class="headerlink" title="出现大量超连接的原因"></a>出现大量超连接的原因</h4><p>没有用长链接</p><p>长连接超时（keepalive）</p><h4 id="如果建立了连接，结果客户端故障了，不发送消息，但是服务端一直establish"><a href="#如果建立了连接，结果客户端故障了，不发送消息，但是服务端一直establish" class="headerlink" title="如果建立了连接，结果客户端故障了，不发送消息，但是服务端一直establish"></a>如果建立了连接，结果客户端故障了，不发送消息，但是服务端一直establish</h4><p>tcp搞了个保活机制，隔一段时间发送探测报文，没有得到相应则认为tcp死亡，</p><p>但是，这个保活机制时间太长了，我们自己在应用层实现一个心跳机制</p><p>一般web服务软件都会提供keepalive-timeout状态</p><h4 id="如果服务器的进程崩溃了，那发生什么"><a href="#如果服务器的进程崩溃了，那发生什么" class="headerlink" title="如果服务器的进程崩溃了，那发生什么"></a>如果服务器的进程崩溃了，那发生什么</h4><p>其实连接信息是由内核维护的，所以服务端的内核还是会发送fin报文进行四次挥手</p><h3 id="超时重传、快速重传、"><a href="#超时重传、快速重传、" class="headerlink" title="超时重传、快速重传、"></a>超时重传、快速重传、</h3><p>超时重传很正常，时间RTO，两倍两倍+</p><p>快速重传的问题在于传一个还是传所有，这里引入了SACK机制</p><p>SACK就是把收到的数据信息驾到tcp头部的选项里面，告诉发送发我收到了哪些</p><p>后面又出现了D-SACK，这是用来告诉发送方哪些被重复接受了了</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除</p><p>tcp头部里面既有一个字段叫窗口大小，就是用来告诉发送端自己还有多少缓冲区可以使用，所以窗口大小一般由接收方决定</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>避免发送方的数据填满接收方</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>避免发送方的网络填满整个网络，所以这个协议是很无私的，只要网络发生拥塞，那么tcp就会降低自己的发送量</p><p>慢启动 一开始是1，就是可以传1个mss，然后收到应答变成2，4，8，16…..</p><p>拥塞避免 触碰到慢启动门限就是用拥塞避免，变成线性的，收到一个ack cwnd增加1&#x2F;cwnd</p><p>超时重传，慢启动门限变成cwnd&#x2F;2，cwnd&#x3D;1重新开始慢启动</p><p>快速恢复，，cwnd &#x3D; cwnd&#x2F;2，慢启动门限&#x3D; cwnd</p><p>cwnd &#x3D; ssthresh + 3</p><p>收到重复的数据包 cwnd++</p><p>收到新的数据包说明重传成功，cwnd &#x3D; 慢启动门限，进入拥塞避免</p><p>如果优化tcp？</p><p>从三个方向，三次握手，四次挥手，还有中途的数据传输</p><p>三次握手，</p><p>客户端，减少重传次数</p><p>服务端，增大半连接队列的大小和全连接队列的大小，开启syncookie技术</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803161404210.png" alt="image-20230803161404210"></p><p>四次挥手</p><p>关闭连接的方式通常有两种，分别是 RST 报文关闭和 FIN 报文关闭。</p><p>如果进程收到 RST 报文，就直接关闭连接了，不需要走四次挥手流程，是一个暴力关闭连接的方式。</p><p>安全关闭连接的方式必须通过四次挥手，它由进程调用 <code>close</code> 和 <code>shutdown</code> 函数发起 FIN 报文（shutdown 参数须传入 SHUT_WR 或者 SHUT_RDWR 才会发送 FIN）。</p><blockquote><p>调用了 close 函数意味着完全断开连接，<strong>完全断开不仅指无法传输数据，而且也不能发送数据。 此时，调用了 close 函数的一方的连接叫做「孤儿连接」，如果你用 netstat -p 命令，会发现连接对应的进程名为空。</strong></p><p>使用 close 函数关闭连接是不优雅的。于是，就出现了一种优雅关闭连接的 <code>shutdown</code> 函数，<strong>它可以控制只关闭一个方向的连接</strong></p></blockquote><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803163142196.png" alt="image-20230803163142196"></p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803163236556.png" alt="image-20230803163236556"></p><h4 id="如何理解字节流"><a href="#如何理解字节流" class="headerlink" title="如何理解字节流"></a>如何理解字节流</h4><p>udp操作系统不会对齐拆分，所以每一个udp就是一个消息的边界，操作系统收到udp之后会把他查到队列里面，每一个队列他都是一个udp</p><p>然而tcp是会分片的，这时候，接收方如果不知道消息的长度或者边界，是无法读取消息的，</p><p>在发送端，当我们调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中。</p><p>至于什么时候真正被发送，<strong>取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>。也就是说，我们不能认为每次 send 调用发送的数据，都会作为一个整体完整地消息被发送出去</p><p>一般用特殊字符作为边界</p><p>自定义消息结构</p><h4 id="已经建立的tcp，收到syn会发生什么"><a href="#已经建立的tcp，收到syn会发生什么" class="headerlink" title="已经建立的tcp，收到syn会发生什么"></a>已经建立的tcp，收到syn会发生什么</h4><p>新的syn首先看看端口是不是一样，如果不一样的话，就建立新的连接，老的那个如果一直不发消息就会触发tcp保活机制</p><p>如果相同（可能就是宕机重传），其实会返回一个challenge ack，携带正确的序列号的确认号的ack报文，这时候客户端确认号收到这个，发现不是自己期望收到的，就会返回rst，这样，服务器就释放了连接</p><h3 id="如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗"><a href="#如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗" class="headerlink" title="如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗"></a>如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗</h3><p>先到的fin包其实是乱序的，所以会进入乱序队列，等数据真正的到了，才会回头检查这个fin，然后给服务端发这个。</p><h3 id="如果timewait状态收到syn？会怎么样？"><a href="#如果timewait状态收到syn？会怎么样？" class="headerlink" title="如果timewait状态收到syn？会怎么样？"></a>如果timewait状态收到syn？会怎么样？</h3><p>还是先看序列号时间戳吧，如果确实合法，那应该会重新进入三次握手阶段，</p><p>如果不合法，就会返回一个和第四次挥手一样的ack，这时候服务端收到发现不是自己的，就回复一个rst报文</p><h3 id="Tcp连接，断电和进程崩溃有什么区别？没有保活机制"><a href="#Tcp连接，断电和进程崩溃有什么区别？没有保活机制" class="headerlink" title="Tcp连接，断电和进程崩溃有什么区别？没有保活机制"></a>Tcp连接，断电和进程崩溃有什么区别？没有保活机制</h3><p>客户端主机崩溃，没有保活机制，那就无法感知到，一直处于establish</p><p>进程崩溃，内核还是会发送fin完成4次挥手</p><h4 id="客户端主机宕机，又迅速重启"><a href="#客户端主机宕机，又迅速重启" class="headerlink" title="客户端主机宕机，又迅速重启"></a>客户端主机宕机，又迅速重启</h4><p>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。</p><p>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</p><ul><li>如果客户端主机上<strong>没有</strong>进程绑定该 TCP 报文的目标端口号，那么客户端内核就会<strong>回复 RST 报文，重置该 TCP 连接</strong>；</li><li>如果客户端主机上<strong>有</strong>进程绑定该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。</li></ul><p>所以，<strong>只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</strong></p><h4 id="拔掉网线tcp连接还在吗"><a href="#拔掉网线tcp连接还在吗" class="headerlink" title="拔掉网线tcp连接还在吗"></a>拔掉网线tcp连接还在吗</h4><p>在的，tcp连接信息是存储于内核的一个结构体，网线断了，但是结构体不会改变</p><ul><li>拔掉网线后，有数据传输；<ul><li>如果在重传前网线插回去了，那我觉得应该什么事情都没发生</li><li>如果没插回去，那么就超时重传几次之后，认为此连接死亡，就断开连接，即使后面插回来了，客户端向服务端发送请求，也不是连接的状态，那么服务端就会返回rst</li></ul></li><li>拔掉网线后，没有数据传输<ul><li>如果开启了保活机制，那就探测几次，如果有工作就重制保活时间，如果客户端没有正常工作，就断开连接</li><li>如果没有开启保活机制，就一直连着</li></ul></li></ul><h4 id="HTTPS-中-TLS-和-TCP-能同时握手吗？"><a href="#HTTPS-中-TLS-和-TCP-能同时握手吗？" class="headerlink" title="HTTPS 中 TLS 和 TCP 能同时握手吗？"></a>HTTPS 中 TLS 和 TCP 能同时握手吗？</h4><p>可能，但是有条件</p><ul><li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li><li><strong>客户端和服务端已经完成过一次通信。</strong></li></ul><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803205908513.png" alt="image-20230803205908513"></p><p>TCP Fast Open定义<br>TCP Fast Open（TFO）是用来加速连续TCP连接的数据交互的TCP协议扩展，原理如下：在TCP三次握手的过程中，当用户首次访问Server时，发送SYN包，Server根据用户IP生成Cookie（已加密），并与SYN-ACK一同发回Client；当Client随后重连时，在SYN包携带TCP Cookie；如果Server校验合法，则在用户回复ACK前就可以直接发送数据；否则按照正常三次握手进行<br><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803210533146.png" alt="image-20230803210533146"></p><p>所以就是在第二次以后的通信过程中，tcp open fast在ack发回来之前直接进行tls1.3</p><h4 id="没有accept，能建立tcp连接吗"><a href="#没有accept，能建立tcp连接吗" class="headerlink" title="没有accept，能建立tcp连接吗"></a>没有accept，能建立tcp连接吗</h4><ul><li><strong>每一个</strong><code>socket</code>执行<code>listen</code>时，内核都会自动创建一个半连接队列和全连接队列。</li><li>第三次握手前，TCP连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。</li><li><code>accept方法</code>只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎<strong>毫无关系</strong>。</li><li>出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了<strong>哈希表</strong>，而全连接队列本质是链表。</li><li>全连接队列满了，再来第三次握手也会丢弃，此时如果<code>tcp_abort_on_overflow=1</code>，还会直接发<code>RST</code>给客户端。</li><li>半连接队列满了，可能是因为受到了<code>SYN Flood</code>攻击，可以设置<code>tcp_syncookies</code>，绕开半连接队列。</li><li>客户端没有半连接队列和全连接队列，但有一个<strong>全局hash</strong>，可以通过它实现自连接或TCP同时打开。</li></ul><h4 id="服务端没有-listen，客户端发起连接建立，会发生什么？"><a href="#服务端没有-listen，客户端发起连接建立，会发生什么？" class="headerlink" title="服务端没有 listen，客户端发起连接建立，会发生什么？"></a>服务端没有 listen，客户端发起连接建立，会发生什么？</h4><p><strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文</strong></p><h4 id="quic怎么实现可靠传输"><a href="#quic怎么实现可靠传输" class="headerlink" title="quic怎么实现可靠传输"></a>quic怎么实现可靠传输</h4><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803212833705.png" alt="image-20230803212833705"></p><p>packetheader分为两种</p><p>Packet Header 细分这两种：</p><ul><li>Long Packet Header 用于首次建立连接。</li><li>Short Packet Header 用于日常传输数据。</li></ul><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803213009597.png" alt="image-20230803213009597"></p><p>这里packet Number是递增的，即使重传也是递增，这样就可以分清是重传的还是延迟的，比较能清晰的计算出rtt，以及rto</p><p>![在前面介绍 Packet Header 时，说到 Packet Number 是严格递增，即使重传报文的 Packet Number 也是递增的，既然重传数据包的 Packet N+M 与丢失数据包的 Packet N 编号并不一致，我们怎么确定这两个数据包的内容一样呢？</p><p>所以引入 Frame Header 这一层，<strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong>，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。</p><h4 id="QUIC-是如何解决-TCP-队头阻塞问题的？"><a href="#QUIC-是如何解决-TCP-队头阻塞问题的？" class="headerlink" title="QUIC 是如何解决 TCP 队头阻塞问题的？"></a>QUIC 是如何解决 TCP 队头阻塞问题的？</h4><p><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。</p><h3 id="QUIC-是如何做流量控制的？"><a href="#QUIC-是如何做流量控制的？" class="headerlink" title="QUIC 是如何做流量控制的？"></a>QUIC 是如何做流量控制的？</h3><p>TCP 流量控制是通过让「接收方」告诉「发送方」，它（接收方）的接收窗口有多大，从而让「发送方」根据「接收方」的实际接收能力控制发送的数据量。</p><p>但是quic是基于udp的，所以他本身没有流量控制，因此需要实现自己的流量控制</p><p>QUIC 实现流量控制的方式：</p><ul><li>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。 如果消耗数据的长度大于了最大接收窗口的一半发送</li><li>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka知识</title>
      <link href="/2023/07/08/Kafka/"/>
      <url>/2023/07/08/Kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h1><p>分布式的基于发布订阅模式的消息队列</p><p>主要应用场景包括：<strong>缓存消峰</strong>、<strong>解耦</strong>和<strong>异步通信。</strong></p><p>消息队列有两种模式：</p><ul><li>点对点模式：一个主题，一个消费者，消费者主动拉取数据后，确认收到后会删除数据</li><li>发布订阅模式：多个主题，多个消费者独立，不会删除</li></ul><p><strong>基础架构</strong>：</p><p><img src="/../images/Kafka/708e86e70504f41234b05cb3cc30dea7.png" alt="image-20220902125656203"></p><p>1）Producer：消息生产者，就是向 Kafka broker 发消息的客户端。</p><p>（2）Consumer：消息消费者，向 Kafka broker 取消息的客户端。</p><p>（3）Consumer Group（CG）：消费者组，由多个 consumer 组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</p><p>（4）Broker：一台 Kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个broker 可以容纳多个 topic。</p><p>（5）Topic：可以理解为一个队列，生产者和消费者面向的都是一个 topic。</p><p>（6）Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。</p><p>（7）Replica：副本。一个 topic 的每个分区都有若干个副本，一个 Leader 和若干个Follower。</p><p>（8）Leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 Leader。</p><p>（9）Follower：每个分区多个副本中的“从”，实时从 Leader 中同步数据，保持和Leader 数据的同步。Leader 发生故障时，某个 Follower 会成为新的 Leader。</p><p>其实总的流程就是生产者发送数据到kafka，然后消费者从kafka拉取数据。所以架构中最主要的就是生产者、kafka集群和消费者这三个，其他的很多知识都是为了这三个服务的。</p><h1 id="2、生产者"><a href="#2、生产者" class="headerlink" title="2、生产者"></a>2、生产者</h1><p> 在消息发送的过程中，涉及到两个线程，main线程和sender线程，其中main线程是消息的生产线程，而sender线程是jvm单例的线程，专门用于消息的发送。</p><p> 在jvm的内存中开辟了一块缓存空间叫RecordAccumulator（消息累加器），用于将多条消息合并成一个批次，然后由sender线程发送给kafka集群。<br><img src="/../images/Kafka/cd41370a872e70b75435f35692925370.png" alt="image-20220902155220662"></p><p>当双端队列中的DQueue满足 batch.size 或者 linger.ms 条件时触发sender线程。</p><p>这里我们一步一步看</p><p>producer没什么意外，就是生产者，配置好就可以</p><p>然后拦截器，就是对这个消息做一个操作，末尾也会有一个，也没什么，相当于留了一个供我们修改的接口</p><p>序列化器：这个也没什么奇怪，发送消息，总要给消息一种形式，kafka有自带的</p><p>Partitioner：这个需要着重讲一下，我们事先其实是分好了区，但是发送消息的时候发送到那一个区？</p><p>这就涉及到发送消息分区策略：</p><ul><li><p>他有一个默认的分区器DefaultPartitioner，支持三种分区策略 1) 指定分区； 2）指定key，计算hash得分区； 3）指定随机粘性分区（下图）；<img src="/../images/Kafka/18a0b6ba56db8e5b16b3d6fac9ba7fb7.png" alt="image-20220902163808502"></p></li><li><p>还可以自定义分区器（见代码）</p></li><li><p>~~~<br>public class MyPartitioner implements Partitioner {<br>&#x2F;**<br> * @param topic 主题<br> * @param key 消息的 key<br> * @param keyBytes 消息的 key 序列化后的字节数组<br> * @param value 消息的 value<br> * @param valueBytes 消息的 value 序列化后的字节数组<br> * @param cluster 集群元数据可以查看分区信息<br> *&#x2F;<br>@Override<br>public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {<br>    String string &#x3D; value.toString();<br>    if (string.contains(“vi”)){<br>        return 2;<br>    }else{<br>        return 1;<br>    }<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">然后我们就要依赖</span><br><span class="line"></span><br><span class="line">## **消息累加器（RecordAccumulator）**</span><br><span class="line"></span><br><span class="line">![image-20220902174419992](../images/Kafka/f20e0b29414b41978048b0c263c2f6a4.png)</span><br><span class="line"></span><br><span class="line"> 为了提高生产者的吞吐量，我们通过累加器将多条消息合并成一批统一发送。在broker中将消息批量存入。减少多次的网络IO。</span><br><span class="line"></span><br><span class="line"> 消息累加器默认32m，如果生产者的发送速率大于sender发送的速率，消息就会堆满累加器。生产者就会阻塞，或者报错，报错取决于阻塞时间的配置。</span><br><span class="line"></span><br><span class="line"> 累加器的存储形式为ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt;，可以看出来就是一个分区对应一个双端队列，队列中存储的是ProducerBatch一般大小是16k根据batch.size配置，新的消息会append到ProducerBatch中，满16k就会创建新的ProducerBatch，并且触发sender线程进行发送。</span><br><span class="line"></span><br><span class="line"> 如果消息量非常大，生成了大量的ProducerBatch，在发送后，又需要JVM通过GC回收这些ProducerBatch就变得非常影响性能，所以kafka通过 BufferPool作为内存池来管理ProducerBatch的创建和回收，需要申请一个新的ProducerBatch空间时，调用 free.allocate(size, maxTimeToBlock)找内存池申请空间。</span><br><span class="line"></span><br><span class="line">如果单条消息大于16k，那么就不会复用内存池了，会生成一个更大的ProducerBatch专门存放大消息，发送完后GC回收该内存空间。</span><br><span class="line"></span><br><span class="line">接着就是</span><br><span class="line"></span><br><span class="line">## **消息发送线程（Sender）**</span><br><span class="line"></span><br><span class="line"> 消息保存在内存后，Sender线程就会把符合条件的消息按照批次进行发送， Sender线程默认容纳5个未确认的消息，消息发送失败后会进行重试。</span><br><span class="line"></span><br><span class="line">## 生产者提高吞吐量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> &#x2F;&#x2F; batch.size：批次大小，默认 16K<br>properties.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384);<br>&#x2F;&#x2F; linger.ms：等待时间，默认 0<br>properties.put(ProducerConfig.LINGER_MS_CONFIG, 1);<br>&#x2F;&#x2F; RecordAccumulator：缓冲区大小，默认 32M：buffer.memory<br>properties.put(ProducerConfig.BUFFER_MEMORY_CONFIG,33554432);</p></li></ul><p>&#x2F;&#x2F; compression.type：压缩，默认 none，可配置值 gzip、snappy、lz4 和 zstd<br>properties.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, “snappy”);</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">发送方发送消息到kafka集群，这一段路 也保证数据的可靠性</span><br><span class="line"></span><br><span class="line">## 生产经验—数据可靠性</span><br><span class="line"></span><br><span class="line">### 消息确认机制-ACK</span><br><span class="line"></span><br><span class="line">producer提供了三种消息确认的模式，通过配置acks来实现</span><br><span class="line"></span><br><span class="line">acks为0时， 表示生产者将数据发送出去就不管了，不等待任何返回。这种情况下数据传输效率最高，但是数据可靠性最低，当 server挂掉的时候就会丢数据；</span><br><span class="line"></span><br><span class="line">acks为1时（默认），表示数据发送到Kafka后，经过leader成功接收消息的的确认，才算发送成功，如果leader宕机了，就会丢失数据。</span><br><span class="line"></span><br><span class="line">acks为-1/all时，表示生产者需要等待ISR中的所有follower都确认接收到数据后才算发送完成，这样数据不会丢失，因此可靠性最高，性能最低。</span><br><span class="line"></span><br><span class="line">数据完全可靠条件 = ACK级别设置为-1 + 分区副本大于等于2 + ISR里应答的最小副本数量大于等于2</span><br><span class="line"></span><br><span class="line">![image-20220902172535966](../images/Kafka/a5c1a40450861d56bfc5cce44746a8a6.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AR = ISR + ORS</span><br><span class="line"></span><br><span class="line">ISR 表示在指定时间内和leader保存数据同步的集合；</span><br><span class="line"></span><br><span class="line">ORS表示不能在指定的时间内和leader保持数据同步集合，称为OSR(Out-Sync Relipca set)。</span><br><span class="line"></span><br><span class="line">### 数据去重-幂等性</span><br><span class="line"></span><br><span class="line">1）幂等性原理</span><br><span class="line"></span><br><span class="line">在一般的MQ模型中，常有以下的消息通信概念</span><br><span class="line"></span><br><span class="line">至少一次（At Least Once）： ACK级别设置为-1 + 分区副本大于等于2 + ISR里应答的最小副本数量&gt;=2。可以保证数据不丢失，但是不能保证数据不重复。</span><br><span class="line">最多一次（At Most Once）：ACK级别设置为0 。可以保证数据不重复，但是不能保证数据不丢失。•</span><br><span class="line">精确一次（Exactly Once）：至少一次 + 幂等性 。 Kafka 0.11版本引入一项重大特性：幂等性和事务。</span><br><span class="line"> 幂等性，简单地说就是对接口的多次调用所产生的结果和调用一次是一致的。生产者在进行重试的时候有可能会重复写入消息，而使用Kafka 的幂等性功能之后就可以避免这种情况。（不产生重复数据）</span><br><span class="line"></span><br><span class="line"> 重复数据的判断标准：具有&lt;PID, Partition, SeqNumber&gt;相同主键的消息提交时，Broker只会持久化一条。其</span><br><span class="line"></span><br><span class="line">中ProducerId（pid）是Kafka每次重启都会分配一个新的；Partition 表示分区号；Sequence Number 序列化号，是单调自增的。</span><br><span class="line"></span><br><span class="line"> broker中会在内存维护一个pid+分区对应的序列号。如果收到的序列号正好比内存序列号大一，才存储消息，如果小于内存序列号，意味着消息重复，那么会丢弃消息，并应答。如果远大于内存序列号，意味着消息丢失，会抛出异常。</span><br><span class="line"></span><br><span class="line">所以幂等解决的是sender到broker间，由于网络波动可能造成的重发问题。用幂等来标识唯一消息。</span><br><span class="line"></span><br><span class="line">并且幂等性只能保证的是在单分区单会话内不重复。</span><br><span class="line"></span><br><span class="line">2）如何使用幂等性</span><br><span class="line"></span><br><span class="line"> 开启幂等性功能的方式很简单，只需要显式地将生产者客户端参数enable.idempotence设置为true即可(这个参数的默认值为true)，并且还需要确保生产者客户端的retries、acks、max.in.filght.request.per.connection参数不被配置错，默认值就是对的。</span><br><span class="line"></span><br><span class="line">### 消息事务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">由于幂等性不能跨分区运作，为了保证同时发的多条消息，要么全成功，要么全失败。kafka引入了事务的概念。</span><br><span class="line"></span><br><span class="line">开启事务需要producer设置transactional.id的值并同时开启幂等性。</span><br><span class="line"></span><br><span class="line">通过事务协调器，来实现事务，工作流程如下：</span><br><span class="line"></span><br><span class="line">![image-20220902183826203](../images/Kafka/4d210e935a7af0d15c3caa53e08f4e9e.png)</span><br><span class="line"></span><br><span class="line">### 消息顺序</span><br><span class="line"></span><br><span class="line">kafka只能保证单分区下的消息顺序性，为了保证消息的顺序性，需要做到如下几点。</span><br><span class="line"></span><br><span class="line">如果未开启幂等性，需要 max.in.flight.requests.per.connection 设置为1。（缓冲队列最多放置1个请求）</span><br><span class="line"></span><br><span class="line">如果开启幂等性，需要 max.in.flight.requests.per.connection 设置为小于5。</span><br><span class="line"></span><br><span class="line">这是因为broker端会缓存producer主题分区下的五个request，保证最近5个request是有序的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3、Broker</span><br><span class="line"></span><br><span class="line">## Broker设计</span><br><span class="line"></span><br><span class="line"> 我们都知道kafka能堆积非常大的数据，一台服务器，肯定是放不下的。由此出现的集群的概念，集群不仅可以让消息负载均衡，还能提高消息存取的吞吐量。kafka集群中，会有多台broker，每台broker分别在不同的机器上。为了提高吞吐量，每个topic也会都多个分区，同时为了保持可靠性，每个分区还会有多个副本。这些分区副本被均匀的散落在每个broker上，其中每个分区副本中有一个副本为leader，其他的为follower。</span><br><span class="line"></span><br><span class="line">![image-20220902195939625](../images/Kafka/37643c8b56fe0f32a3b9d7c803f85b0b.png)</span><br><span class="line"></span><br><span class="line">## Zookeeper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Zookeeper在Kafka中扮演了重要的角色，kafka使用zookeeper进行元数据管理，保存broker注册信息，包括主题（Topic）、分区（Partition）信息等，选择分区leader。</span><br><span class="line"></span><br><span class="line">![image-20220902200249692](../images/Kafka/b1f0ebc535b00384be6bf81540c5f416.png)</span><br><span class="line"></span><br><span class="line">## Broker选举Leader</span><br><span class="line"></span><br><span class="line">Kafka由三个方面会涉及到选举：</span><br><span class="line"></span><br><span class="line">- broker（控制器）选leader</span><br><span class="line"></span><br><span class="line">- 分区多副本选leader</span><br><span class="line">- 消费者选Leader</span><br><span class="line"></span><br><span class="line"> 在kafka集群中由很多的broker（也叫做控制器），但是他们之间需要选举出一个leader，其他的都是follower。broker的leader有很重要的作用，诸如：创建、删除主题、增加分区并分配leader分区；集群broker管理，包括新增、关闭和故障处理；分区重分配（auto.leader.rebalance.enable=true，后面会介绍），分区leader选举。</span><br><span class="line"></span><br><span class="line"> 每个broker都有唯一的brokerId，他们在启动后会去竞争注册zookeeper上的Controller结点，谁先抢到，谁就是broker leader。而其他broker会监听该结点事件，以便后续leader下线后触发重新选举。</span><br><span class="line"></span><br><span class="line">- broker（控制器）选leader</span><br><span class="line"></span><br><span class="line">![image-20220902200901222](../images/Kafka/12b4f076e8f82c66b00ec8782433649f.png)</span><br><span class="line"></span><br><span class="line">- 分区多副本选leader![image-20220902201352868](../images/Kafka/e5c14b9c17123faf3eefa58a22ab0668-20230928225949575.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 副本机制</span><br><span class="line"></span><br><span class="line">- replica ：副本，同一分区的不同副本保存的是相同的消息，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失 ，提高副本可靠性，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。</span><br><span class="line"></span><br><span class="line">- Leader ：每个分区的多个副本中的&quot;主副本&quot;，生产者以及消费者只与 Leader 交互。</span><br><span class="line">- Follower ：每个分区的多个副本中的&quot;从副本&quot;，负责实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发生故障时，从 Follower 副本中重新选举新的 Leader 副本对外提供服务。</span><br><span class="line">- **LEO**:每个副本都有内部的LEO，代表当前队列消息的最后一条偏移量offset + 1。</span><br><span class="line">- **HW**:高水位，代表所有ISR中的LEO最低的那个offset，也是消费者可见的最大消息offset。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20220902201925254](../images/Kafka/1c5cd091fee1ef3c76fcc1c13dccf7de.png)</span><br><span class="line"></span><br><span class="line"> Kafka 集群中有一个 broker 的 Controller 会被选举为 Controller Leader (4.2.2) ，负责管理集群Broker 的上下线，所有 topic 的分区副本分配和 Leader 选举等工作</span><br><span class="line"></span><br><span class="line"> Broker中Controller 的信息同步工作是依赖于 Zookeeper 的 ./broker/topic 目录下的信息。</span><br><span class="line"></span><br><span class="line">## 副本故障处理</span><br><span class="line"></span><br><span class="line">### **1.follower故障流程**</span><br><span class="line"></span><br><span class="line">![image-20220902210759125](../images/Kafka/b01dad78f006b40d82e719fe71caeb78.png)</span><br><span class="line"></span><br><span class="line">### 2.leader故障流程</span><br><span class="line"></span><br><span class="line">旧Leader先被从ISR队列中踢出，然后从ISR中选出一个新的Leader来；此时为了保证多个副本之间的数据一致性，其他的follower会先将各自的log文件中高于HW的部分截取掉，然后从新的leader同步数据（由此可知这只能保证副本之间数据一致性，并不能保证数据不丢失或者不重复）。体现了设置ACK-all的重要性。</span><br><span class="line">![image-20220902210830344](../images/Kafka/1f96e55810be5ff8cbf64c04b5d37315.png)</span><br><span class="line"></span><br><span class="line">## kafka分区策略</span><br><span class="line"></span><br><span class="line">如果 kafka 服务器只有 4 个节点，那么设置 kafka 的分区数大于服务器台数，在 kafka底层如何分配存储副本呢？</span><br><span class="line"></span><br><span class="line">- 这里如果用默认的就是如下</span><br><span class="line"></span><br><span class="line">![image-20220902211334365](../images/Kafka/15514da0f22aca9e3017fa2305733ba4.png)</span><br><span class="line"></span><br><span class="line">- 也可以手动指定~~~</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$ vim increase-replication-factor.json<br>输入如下内容：<br>{<br>“version”:1,<br>“partitions”:[<br>{“topic”:”three”,”partition”:0,”replicas”:[0,1]},<br>{“topic”:”three”,”partition”:1,”replicas”:[0,1]},<br>{“topic”:”three”,”partition”:2,”replicas”:[1,0]},<br>{“topic”:”three”,”partition”:3,”replicas”:[1,0]}]<br>}</p><p>~~~</p><h4 id="分区自动调整"><a href="#分区自动调整" class="headerlink" title="分区自动调整"></a><strong>分区自动调整</strong></h4><p>随着一些broker故障，会慢慢出现leader集中在某台broker上的情况，造成集群负载不均衡，这时候就需要分区平衡。</p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h5 id="①文件存储机制"><a href="#①文件存储机制" class="headerlink" title="①文件存储机制"></a>①文件存储机制</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928232748011.png" alt="在这里插入图片描述"></p><h5 id="②思考：Topic-数据到底存储-在什么位置？"><a href="#②思考：Topic-数据到底存储-在什么位置？" class="headerlink" title="②思考：Topic 数据到底存储 在什么位置？"></a>②思考：Topic 数据到底存储 在什么位置？</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928232838576.png" alt="在这里插入图片描述"></p><h5 id="③index-文件和-log-文件详解"><a href="#③index-文件和-log-文件详解" class="headerlink" title="③index 文件和 log 文件详解"></a>③index 文件和 log 文件详解</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928233003817.png" alt="在这里插入图片描述"></p><h2 id="文件清理策略"><a href="#文件清理策略" class="headerlink" title="文件清理策略"></a>文件清理策略</h2><p>Kafka将消息存储在磁盘中，为了控制磁盘占用空间的不断增加就需要对消息做一定的清理操作。Kafka 中每一个分区副本都对应一个Log，而Log又可以分为多个日志分段，这样也便于日志的清理操作。Kafka提供了两种日志清理策略。</p><p>日志删除(delete) :按照一定的保留策略直接删除不符合条件的日志分段。<br>日志压缩(compact) :针对每个消息的key进行整合，对于有相同key的不同value值，只保留最后一个版本。</p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928233204011.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928233315113.png" alt="在这里插入图片描述"></p><h2 id="Kafka高效读数据"><a href="#Kafka高效读数据" class="headerlink" title="Kafka高效读数据"></a><strong>Kafka高效读数据</strong></h2><p>kafka之所以可以快速读写的原因如下：</p><ol><li>kafka是分布式集群，采用分区方式，并行操作</li><li>读取数据采用稀疏索引，可以快速定位消费数据</li><li>顺序写磁盘</li><li>页缓冲和零拷贝</li></ol><p><img src="/../images/Kafka/eeb8531c34ed091d57d9be10590839c5.png" alt="image-20220902214803709"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928233417216.png" alt="在这里插入图片描述"></p><h1 id="4、kafka消费者"><a href="#4、kafka消费者" class="headerlink" title="4、kafka消费者"></a>4、kafka消费者</h1><h2 id="1、Kafka-消费方式"><a href="#1、Kafka-消费方式" class="headerlink" title="1、Kafka 消费方式"></a>1、Kafka 消费方式</h2><p>​<img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928234825729.png" alt="在这里插入图片描述"></p><h2 id="2、消费者工作流程"><a href="#2、消费者工作流程" class="headerlink" title="2、消费者工作流程"></a>2、消费者工作流程</h2><h5 id="①消费者总体工作流程"><a href="#①消费者总体工作流程" class="headerlink" title="①消费者总体工作流程"></a>①消费者总体工作流程</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928234848009.png" alt="在这里插入图片描述"></p><h5 id="②消费者组原理"><a href="#②消费者组原理" class="headerlink" title="②消费者组原理"></a>②消费者组原理</h5><p> <img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235013969.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235020544.png" alt="在这里插入图片描述"></p><p><strong>消费者组初始化流程</strong></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235058845.png" alt="在这里插入图片描述"></p><p><strong>消费者组详细消费流程</strong></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235306060.png" alt="在这里插入图片描述"></p><h2 id="3、消费者api"><a href="#3、消费者api" class="headerlink" title="3、消费者api"></a>3、消费者api</h2><h2 id="4、生产经验-——-分区的分配"><a href="#4、生产经验-——-分区的分配" class="headerlink" title="4、生产经验 —— 分区的分配"></a>4、生产经验 —— 分区的分配</h2><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235523539.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235554746.png" alt="在这里插入图片描述"></p><p><strong>Range 分区分配策略案例</strong></p><p> <img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235731478.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/29f6564651824fe69bba934f8e5e83b6.png" alt="在这里插入图片描述"></p><h5 id="Range-分区分配再平衡案例"><a href="#Range-分区分配再平衡案例" class="headerlink" title="Range 分区分配再平衡案例"></a><strong>Range 分区分配再平衡案例</strong></h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235744058.png" alt="在这里插入图片描述"></p><h5 id="RoundRobin-以及再平衡原理"><a href="#RoundRobin-以及再平衡原理" class="headerlink" title="RoundRobin 以及再平衡原理"></a>RoundRobin 以及再平衡原理</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000334551.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000415710.png" alt="在这里插入图片描述"></p><h5 id="Sticky-以及再平衡"><a href="#Sticky-以及再平衡" class="headerlink" title="Sticky 以及再平衡"></a>Sticky 以及再平衡</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000640458.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000653360.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000715131.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000728390.png" alt="在这里插入图片描述"></p><h2 id="5、offset-位移"><a href="#5、offset-位移" class="headerlink" title="5、offset 位移"></a>5、offset 位移</h2><h5 id="1、offset-的默认维护"><a href="#1、offset-的默认维护" class="headerlink" title="1、offset 的默认维护"></a>1、offset 的默认维护</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000851750.png" alt="在这里插入图片描述"></p><p>__consumer_offsets 主题里面采用 key 和 value 的方式存储数据。</p><p>key 是group.id+topic+分区号，value 就是当前 offset 的值。</p><p>每隔一段时间，kafka 内部会对这个 topic 进行compact，也就是每个 group.id+topic+分区号就保留最新数据。</p><h5 id="①消费-offset-案例"><a href="#①消费-offset-案例" class="headerlink" title="①消费 offset 案例"></a>①消费 offset 案例</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000928260.png" alt="在这里插入图片描述"></p><h5 id="②自动提交-offset"><a href="#②自动提交-offset" class="headerlink" title="②自动提交 offset"></a>②自动提交 offset</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929001005340.png" alt="在这里插入图片描述"></p><h5 id="③手动交-提交-offset"><a href="#③手动交-提交-offset" class="headerlink" title="③手动交 提交 offset"></a>③手动交 提交 offset</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929001022624.png" alt="在这里插入图片描述"></p><h5 id="④指定-Offset-消费"><a href="#④指定-Offset-消费" class="headerlink" title="④指定 Offset 消费"></a>④指定 Offset 消费</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929001046545.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929001143065.png" alt="在这里插入图片描述"></p><h5 id="⑤指定时间消费"><a href="#⑤指定时间消费" class="headerlink" title="⑤指定时间消费"></a>⑤指定时间消费</h5><p>其实就是通过时间得到offset然后指定offset</p><h5 id="⑥漏消费和重复消费"><a href="#⑥漏消费和重复消费" class="headerlink" title="⑥漏消费和重复消费"></a>⑥漏消费和重复消费</h5><p><strong>重复消费</strong>：已经消费了数据，但是 offset没提交。</p><p><strong>漏消费</strong>：先提交 offset后消费，有可能会造成数据的漏消费</p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929001250173.png" alt="在这里插入图片描述"></p><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929001509066.png" alt="在这里插入图片描述"></p><h4 id="数据积压-（-消费者-如何提高吞吐量）"><a href="#数据积压-（-消费者-如何提高吞吐量）" class="headerlink" title="数据积压 （ 消费者 如何提高吞吐量）"></a>数据积压 （ 消费者 如何提高吞吐量）</h4><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929001531640.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql复习（mysql技术内幕 innodb存储引擎）</title>
      <link href="/2023/07/08/Mysql%E5%A4%8D%E4%B9%A0%EF%BC%88mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%20innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%89/"/>
      <url>/2023/07/08/Mysql%E5%A4%8D%E4%B9%A0%EF%BC%88mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%20innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>InnoDB最重要的点：行锁设计、MVCC、外键</p><p>首先来了解一下InnoDB的体系架构：</p><h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><p>![image-20231004235405057](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231004235405057.png)</p><p>InnoDB有很多内存块，组成内存池，负责的工作：</p><p>维护所有线程</p><p>缓存磁盘的数据</p><p>重做日志缓冲</p><p>后台线程的主要作用就是：刷新内存池中的数据，保证缓冲池里的是最新的数据。把已修改的数据文件刷新到磁盘文件，</p><p>我们看体系架构，可以从以下几点：</p><h2 id="1、后台线程"><a href="#1、后台线程" class="headerlink" title="1、后台线程"></a>1、后台线程</h2><p>主要有：</p><p>master thread：最重要的，脏页刷新、合并insert buffer，undo 页的回收。不过后来脏页回收放到了单独的线程，也就是page thread</p><p>本质是一个</p><p>IO thread</p><p>purge thread</p><p>page thread</p><h3 id="1、master-thread"><a href="#1、master-thread" class="headerlink" title="1、master thread"></a>1、master thread</h3><p>本质是一个循环</p><p>每秒都会进行一次操作：重做日志缓冲刷新、合并insertbuffer ，脏页刷新被放到了page clean 线程</p><p>每十秒会进行的操作：重做日志缓冲刷新、合并insertbuffer、脏页刷新被放到了page clean 线程、删除无用的undo 页</p><h2 id="2、内存"><a href="#2、内存" class="headerlink" title="2、内存"></a>2、内存</h2><p>内存方面就是缓冲池、lrulist freelist flushlist、redo log buffer 三块，还有一些额外内存池</p><h3 id="1、缓冲池"><a href="#1、缓冲池" class="headerlink" title="1、缓冲池"></a>1、缓冲池</h3><p>本质就是一块内存，就是为了缓解cpu和磁盘的差距，缓冲池里面有数据页、索引页、undo 页、insert buffer、自适应哈希索引、锁信息、数据字典。</p><p>所以修改操作，基本都是现修改缓冲池里面的数据，然后按照一定频率通过checkpoint刷回磁盘。</p><h3 id="2、List"><a href="#2、List" class="headerlink" title="2、List"></a>2、List</h3><p>缓冲池是通过改进的LRU算法（在原本的基础上加了midpoint，新加入的页放到这里，默认5&#x2F;8）进行管理的，方法就是LRUlist、freelist flushlist。如果缓冲池不能放新的，就把lru里面末尾的释放掉。</p><p>改进lru的原因：有可能新页仅仅是这次查询需要用到，并不是真正的热点数据，这样反而有可能将真正的热点数据淘汰。</p><p>flushlist就是脏页列表，就像上面说的，用checkpoiint机制刷新</p><p>一页16k</p><p>说了这么多checkpoint，什么是checkpoint？</p><h4 id="1、checkpoint"><a href="#1、checkpoint" class="headerlink" title="1、checkpoint"></a>1、checkpoint</h4><p>解决问题：</p><ul><li>缩短数据库恢复时间？</li></ul><p>即使发生宕机， 因为checkpoint之前多页已经刷新回磁盘，所以只需要对checkpoint之后对进行恢复</p><ul><li>缓冲池不够时，可以将脏页刷回磁盘？</li></ul><p>缓冲池不够用的时候，根据lru找lru末尾的页，如果是脏页，就强制执行checkpoint，讲脏页刷新回磁盘</p><ul><li>重做日志不可用，刷新脏页。</li></ul><p>重做日志两个文件是循环使用，为了不让他一直无限变大，不可用是指重做日志已经不被需要了可以被覆盖。如果宕机，数据库恢复操作不需要这部分的重做日志就可以覆盖重用。如果此时重做日志还需要用，就必须强制产生checkpoint将讲缓冲池的页至少刷新到当前重做日志的位置</p><p>所以总归checkpoint做的事情就是把脏页刷回磁盘。那怎么刷新？什么时候刷新？</p><p>这里有两种checkpoint，分别是：</p><p>sharp checkpoint</p><p>fuzzy checkpoint</p><p>sharp checkpoint就是在关闭的时候全部刷新到磁盘</p><p>fuzzy checkpoint是刷新部分脏页？刷新到时机如下：</p><p>master thread checkpoint</p><p>flushlrulist checkpoint：这饿是lru列表需要有100个空闲的页，否则一处lru末尾的页，如果有脏页就checkpoint</p><p>async sycn flush checkpoint：这个是重做日志i文件不可用的情况，需要强制将一些刷新回磁盘  </p><p>dirty page too much：这个是脏页数量太多了，强制checkpoint 75%</p><h3 id="3、Redo-log-buffer"><a href="#3、Redo-log-buffer" class="headerlink" title="3、Redo log buffer"></a>3、Redo log buffer</h3><p>这个是innodb独有的，重做日志信息 -&gt;Redo log buffer -〉 重做日志文件，为重做日志文件服务，重做日志文件本身是为了数据库的恢复功能，但是同样的，为了环节和磁盘的差距，我们给他加一个buffer。</p><p>刷回时机：</p><p>master thread 每秒</p><p>每个事务提交的时候</p><p>重做日志缓冲 剩余空间小雨1&#x2F;2</p><h1 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h1><p>1、插入缓冲</p><p>2、两次写</p><p>3、自适应哈希</p><p>4、异步io</p><p>5、刷新邻接页</p><h2 id="1、插入缓冲"><a href="#1、插入缓冲" class="headerlink" title="1、插入缓冲"></a>1、插入缓冲</h2><h3 id="1、insert-buffer"><a href="#1、insert-buffer" class="headerlink" title="1、insert buffer"></a>1、insert buffer</h3><p>插入缓冲是针对辅助索引的，数据在真正存放的时候还是按照主键顺序插入的，但是这个表如果有辅助索引，那么这条记录也会插入辅助索引，但是这时候他就不是顺序插入了，而是离散的插入访问。</p><p>为此，InnoDB开创性的提出了Insert buffer，insertbuffer不是缓存，而是实实在在的物理页。我们在对非聚集索引的插入的时候不会实时的插入，而是先判断有没有在缓冲池里面，有的话直接插入，没有的话，先放到一个insert buffer里面。后面再以一定的频率进行insertbuffer和非聚集索页子节点的merge操作。</p><h3 id="2、change-buffer"><a href="#2、change-buffer" class="headerlink" title="2、change buffer"></a>2、change buffer</h3><p>insert buffer 升级为了 change buffer，对插入更新删除操作都准备了缓冲</p><h3 id="3、insert-buffer的内部实现"><a href="#3、insert-buffer的内部实现" class="headerlink" title="3、insert buffer的内部实现"></a>3、insert buffer的内部实现</h3><p>全局唯一的b+树的形式，负责对所有表的辅助索引进行insert buffer，存放在共享表空间，就是ibdata1。但是我们知道，我们可以有独立表ibdata，但是恢复的时候最好用共享表里面的。</p><p>因为是树，所以有非叶子结点和叶子结点。</p><p>非叶子结点放的是searchkey，所以插入非聚集索引的时候，如果不在缓冲池，那么要加入这颗唯一的insertbuffer，实现构造一个searchkey，我想通过这个searchkey找到我要插入的位置，然后再构造一个叶子结点，放进去。</p><h3 id="4、Merge-insert-buffer"><a href="#4、Merge-insert-buffer" class="headerlink" title="4、Merge insert buffer"></a>4、Merge insert buffer</h3><p>所以后面就是合并操作，合并的时机：</p><p>1、master thread</p><p>2、辅助索引页被读到缓冲池里去，然后这个是要执行正常的查询语句了，就去检查这个insert buffer bitmap，确认这个该辅助索引是不是在insert buffer b+书里面，如果有，就把树里面的记录查到辅助索引里面。</p><h2 id="2、两次写"><a href="#2、两次写" class="headerlink" title="2、两次写"></a>2、两次写</h2><p>doublewrite的目的是为了数据的可靠性。</p><p>具体实现的话，是依赖于两个部分，一个是内存中的doublewrite buffer，2m。另一部分是磁盘里的共享表空间里面有一个连续的128页，也是2m。然后我们对脏页进行刷新到磁盘里面，我先不直接写磁盘，我先复制到这个内存的doublewrite buffer里面，然后分两次写入，每次1m写入共享表空间的物理磁盘，然后马上调用fsync函数，同步磁盘。所以，如果写的时候崩溃了，那就把这个共享表空间里面的副本拿出来配合redo log进行恢复。</p><h2 id="3、自适应哈希"><a href="#3、自适应哈希" class="headerlink" title="3、自适应哈希"></a>3、自适应哈希</h2><p>InnoDB会自动为某些访问频率非常高的页建立哈希索引，而哈希索引比起b+树更快，所以也是一种提高性能手段。</p><p>但是有一个比较大的痛点就是他只能用于做 等值查询，如果遇到范围查到，就无能为力。</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>文件包括mysql文件和innodb文件</p><p>1、参数文件</p><p>2、日志文件、</p><p>3、socket文件</p><p>4、pid文件</p><p>5、mysql表结构文件</p><p>6、存储引擎文件</p><p>我们这里只讲几个</p><h2 id="2、日志文件"><a href="#2、日志文件" class="headerlink" title="2、日志文件"></a>2、日志文件</h2><p>日志文件有错误日志、慢查询日志、查询日志、二进制日志，我们着重可以讲一下二进制日志</p><h3 id="1、二进制日志"><a href="#1、二进制日志" class="headerlink" title="1、二进制日志"></a>1、二进制日志</h3><p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），MySQL 给每个线程分配了一片内存用于缓冲 binlog，事务提交的时候，再把 binlog cache 写到 binlog 文件中</p><p>他是mysql 的日志，记录了对mysql数据库更改的所有操作。不包括selectshow这类操作</p><p>主要用于：</p><p>恢复：某些数据需要二进制日志。比如数据库全备文件恢复之后，通过二进制进行point-in-time的恢复</p><p>复制；主从同步，那canal也是通过这种方式去监听binlog</p><p>审计：用户通过二进制的信息判断是否有对数据库进行注入的攻击</p><p>然后二进制日志它肯定要落盘，但是他不是每一次写都要落盘，他有个参数sync—binlog，如果等于n，代表每次缓冲多少次就同步到磁盘里面。如果等于1，那就代表同步写磁盘。</p><p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p><ul><li>sync_binlog &#x3D; 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li><li>sync_binlog &#x3D; 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li><li>sync_binlog &#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li></ul><p>还有个需要关注的点就是它落盘的形式，就是怎么记录的？</p><p>这个是依赖于binlog——format这个参数，他就是记录二进制的格式，有三种、statement、row、mixed。</p><p>statement就是最简单的sql语句，但是他有个很大的问题就是如果用到了uuid rand udf这些函数或触发器，那么回导致主从不一致，那我们可以用row的格式，row的话就是记录表的行修改情况。同样的他也有一个很大问题就是要求的容量比较大。那还有一种mixed格式就是混用，正常情况下我按照statement记录sql语句，但是在uuid rand udf这些特殊情况我用row的格式进行纪记录。</p><h3 id="2、表结构定义文件"><a href="#2、表结构定义文件" class="headerlink" title="2、表结构定义文件"></a>2、表结构定义文件</h3><p>这个文件的后缀是.frm，每个文件都会有这个一个frm文件，记录了该表的表结构定义</p><h3 id="3、Innodb存储引擎文件"><a href="#3、Innodb存储引擎文件" class="headerlink" title="3、Innodb存储引擎文件"></a>3、Innodb存储引擎文件</h3><h4 id="1、表空间文件"><a href="#1、表空间文件" class="headerlink" title="1、表空间文件"></a>1、表空间文件</h4><p>首当其冲的就是表空间文件，次情况下我们会放到ibdata那个文件里面，但是我们可以通过设置一个参数去产生一个自己表的独立表空间，然后这些独立的表空间记录该表的数据，索引，insertbuffer等信息，其余的还是放在共享表空间里面。</p><h4 id="2、重做日志文件"><a href="#2、重做日志文件" class="headerlink" title="2、重做日志文件"></a>2、重做日志文件</h4><p>这个ib_logfile0 ib_logile1，先写logfile0，写完之后我们再去写logfile1.然后他有一个capacity容量参数，如果超过这个值，就必须从缓冲池里面的脏页列表去刷回一部分脏页。</p><p>binlog他是mysql的，所以很多其他引擎的操作都会记录，而redolog就是属于innodb的，然后她的记录格式也是大不相同的，binlog是逻辑日志，而redolog则是记录每个页的更改的物理情况</p><p>其次刷新的时间也不同，binlog是很明显，我事务提交之前进行一次提交，而redolog在事务执行过程中就会不多的写入redolog。</p><h1 id="索引前的准备知识"><a href="#索引前的准备知识" class="headerlink" title="索引前的准备知识"></a>索引前的准备知识</h1><p><a href="https://baijiahao.baidu.com/s?id=1709211669369376612&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1709211669369376612&amp;wfr=spider&amp;for=pc</a></p><p><strong>这里我们首先要问三个重要的问题去扒一扒MySQL的InnoDB存储引擎</strong></p><ol><li><strong>MySQL的记录是怎么存储的？</strong></li><li><strong>页内记录到底是怎么维护的？</strong></li><li><strong>页内查询过程是怎样的</strong></li></ol><h3 id="穿上第一件：Page页面"><a href="#穿上第一件：Page页面" class="headerlink" title="穿上第一件：Page页面"></a>穿上第一件：Page页面</h3><p>MySQL管理数据的一个单位叫Page页面，数据都是存在页面里的<strong>。</strong>那咱们想要知道数据是怎么存，就<strong>需要了解页面长什么样子</strong>。</p><p>直接爆照：</p><p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;42a98226cffc1e171d3b202cf4e9e50a728de9ae.jpeg)</p><p>页头（Page Header）：存一些统计信息，记录页面的控制信息，共占56字节，包括页面空间使用情况、页的左右兄弟页面指针（<strong>这个就是双向链表，把左右兄弟页面的指针给拿到了</strong>）等。</p><p>虚记录：分为最大虚记录与最小虚记录，<strong>它俩把这页里面存储的数据的范围框住了。</strong>那怎么比较谁大谁小？用的是主键去比较：最大虚记录比页内最大主键还大，最小虚记录比页内最小主键还小<strong>。</strong>那主键到底是怎么存的呢？InnoDB用的是聚簇索引——<strong>数据和主键存到一起、数据和索引存到一起，数据按主键顺序存储。</strong></p><p>记录堆：<strong>这部分就是存储记录的区域</strong>，分为有效记录和已删除记录。已被删除的记录构成一个链表，叫做自由空间链表<strong>，</strong>如图蓝色已经被删除的数据，<strong>用一个链表把它们连起来</strong>。</p><p>未分配空间：页面未使用的存储空间，除了用了一部分的橙色的区域和已删除的蓝色的数据，剩下的就是未分配空间了，<strong>后面有新的数据插入，往里放就行了</strong>。</p><p>Slog区：<strong>这一块对数据检索非常有用</strong>，卖个关子，后面详细说。</p><p>页尾（Page Tailer）：页面的最后部分，占8个字节，主要存储页面的校验信息。<strong>这一页如果写坏了，数据不对了，通过校验位可以检查出来。</strong></p><p>好了，到这里一个页面咱们了解了，了解数据大概是怎么分布的，<strong>那接下来需要考虑哪些点呢？</strong>我们接下来研究一下——页面记录是怎么维护的</p><h3 id="穿上第二件：聚簇索引"><a href="#穿上第二件：聚簇索引" class="headerlink" title="穿上第二件：聚簇索引"></a>穿上第二件：聚簇索引</h3><p>刚刚提到了主键顺序这个词，那这个顺序是怎么保证的？这里说的按什么顺序存储，不是说升序、降序这些，这些没有意义，实际上说的是<strong>在页里面数据是怎么组织起来的</strong>，还有就是插入数据的策略，<strong>我怎么插入数据</strong>，还有就是<strong>页内的查询是怎样的</strong>。</p><p>我们先来看看聚簇索引：</p><p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;c9fcc3cec3fdfc032a5c874b6446949da5c2269b.jpeg)</p><p>首先，聚簇索引是一棵B+树，那什么是聚簇呢？</p><p>图中下面绿色的部分是咱们的数据区域，数据是基于紫色部分的主键顺序去存储的，<strong>数据和主键存到一起没毛病，主键是按照树的顺序去组织的，这个结构就叫聚簇</strong>。</p><p>我们再看每一个Page，刚刚说到，Page里面有最大虚记录、最小虚记录，最大、最小这数据肯定是有个范围，<strong>那这个数据在里边到底是怎么存的</strong>？换个说法——数据的顺序是怎么保证的？<strong>到底是物理有序，还是逻辑有序？</strong></p><p>我们再回顾一下大学的知识——<strong>物理有序写入不友好，查询友好；逻辑有序查询不友好，插入友好</strong>，两者优缺点互补。</p><p>再回到正题，了解了这两种不同存储方式的特性，反观页面是怎么做的。</p><p>先看下面这幅图，思考一下插入主键为10，9，8的数据，是按物理有序存储还是逻辑有序存储：</p><p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;e850352ac65c103892bb2f180b68801ab27e89a2.jpeg)</p><p>数据插入是写入IO，数据查询是读IO，不管是写还是读，在分析存储的时候，无非是这四种：顺序写、随机写、顺序读、随机读。<strong>如果是顺序写，数据会有各种移动，写入性能肯定非常糟糕</strong>。但是没办法，<strong>优化写入的手段十分有限，不过呢我们却有很多办法优化读</strong>。</p><p><strong>所以想都不用想，页内数据存储的顺序就是逻辑有序</strong>。</p><p>重新梳理一下，Page与Page之间由双向链表连接，页内是用小的链表连起来的：</p><p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;9825bc315c6034a8191108a4766a5a5d082376a2.jpeg)</p><p>我们再来重新画一下这棵树：</p><p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;80cb39dbb6fd5266c5d8021702618422d5073647.jpeg)</p><p>这里要注意，每个Page的索引的每个节点，也就是树的每个节点，它也是一个Page。<strong>既然是个Page，也会有页头，也会有双向链表</strong>，如图蓝色与紫色相间那部分节点数据。</p><p><strong>接下来咱分析一下它的插入策略。</strong></p><p>蓝色部分已删除的空间（记录堆）怎么办呢？<strong>我们得想办法尽量把它们利用上</strong>，这个换谁做数据库设计都要这么设计<strong>。</strong></p><p>其实，插入策略就是先使用自由空间链表，再使用未使用空间，<strong>把数据库“空洞”给补上。</strong>不过呢，自由空间链表的空间也不能完全利用上，比如旧的数据占25个字节，新的数据假设都只有20个字节，<strong>那剩下这5个字节基本也利用不上，这样一来就会产生越来越多的“碎片”</strong>。经过长时间的插入删除插入删除以后，我们就得考虑给数据库做一次收缩，比如通过两次主从表的双向同步，<strong>把所有表数据重新插一遍</strong>。</p><p><strong>我们接下来研究一下——页内查询是怎么做的？</strong></p><h3 id="穿上第三件：Slot槽"><a href="#穿上第三件：Slot槽" class="headerlink" title="穿上第三件：Slot槽"></a>穿上第三件：Slot槽</h3><p><strong>页内的数据是遍历还是二分查找？</strong></p><p>无论数据是物理连续还是逻辑有序，都不能二分查找，都得用遍历的办法。如果我们设计一款数据库，通过索引找到数据在哪个Page里面，要是Page这一层通过遍历的方式，那效率实在是太低了，所以数据库肯定不能这样设计。</p><p>遍历不行，那就使用二分查找吧，提高一下效率。那MySQL是怎么做的呢？看看这张图：</p><p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;3b87e950352ac65c1fead4dc4c8ba11892138a30.jpeg)</p><p>如图，最小虚记录和最大虚记录之间形成一个链表，这时候Slot区就派上用场了，每个Slot槽指向链表中的某一个位置，每个槽的大小一样，可以理解为一个指针，<strong>这样我们只需要用一个算法把每个子链表的长度拆成差不多大小就行了</strong>。</p><p>在查找的时候，先基于Sn、S0找到指向的最大最小虚记录，在Slot区进行二分：<strong>先找到Sn和S0的中间位置，中间找到某个Slot，然后再一步步进行比较，通过几次二分后找到具体的子链表，最后，在子链表内进行遍历找到最终的记录</strong>。这样我们借助Slot区实现了一个近似二分查找的方法。这特别像Java里面的跳表结构，一次查找跳一次，再一次查找再跳一次，效率就特别高了</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>innodb最常见的索引就是：</p><p>b+树索引 （b+树只能找到数据行所在的页，然后把页读到内存里面，进行查找）</p><p>哈希索引（自动生成）</p><p>全文索引</p><h2 id="1、B-树索引"><a href="#1、B-树索引" class="headerlink" title="1、B+树索引"></a>1、B+树索引</h2><p>二叉查找树（左小于中小于右）-》平衡二叉树，任何结点的两个子树高度差小于等于1（性能比较高，但不是最高）（需要左旋右旋等等）</p><p>b+树是为了磁盘或其他直接存取辅助设备设计的一种平衡查找树</p><p>b+树的所有记录结点都是按照键值的大小顺序存放到同一层的叶子结点，他们之间通过叶子结点指针进行连接，中间的都是searchkey</p><h3 id="1、操作"><a href="#1、操作" class="headerlink" title="1、操作"></a>1、操作</h3><h4 id="1、插入"><a href="#1、插入" class="headerlink" title="1、插入"></a>1、插入</h4><p>![image-20231005201534270](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231005201534270.png)</p><h4 id="2、旋转"><a href="#2、旋转" class="headerlink" title="2、旋转"></a>2、旋转</h4><p>旋转发生在leaf page已经满了，但是左右兄弟还没有满，这时候会把记录平移到兄弟结点上面，左兄弟优先</p><h4 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h4><p>![image-20231005202324173](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231005202324173.png)</p><h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><p>b+树可以分成聚集索引、辅助索引，这两个到区别就是叶子结点放的到底是不是一行信息</p><h4 id="1、聚集索引"><a href="#1、聚集索引" class="headerlink" title="1、聚集索引"></a>1、聚集索引</h4><p>innodb引擎是索引组织表，按照主键顺序存放，而聚集索引就是按照主键构造的索引b+树，所以叶子结点存放的就是整张表的数据，叶子结点也叫做数据页。非叶子结点的索引页存放的仅仅是键值和指向数据页的偏移量。</p><h4 id="2、辅助索引"><a href="#2、辅助索引" class="headerlink" title="2、辅助索引"></a>2、辅助索引</h4><p>辅助索引的叶子结点不包含行记录的全部数据。叶子结点包含键值和书签，书签用来告诉引擎哪里能找到真正的行数据。由于innodb是索引组织表，所以辅助索引的书签就是行记录的聚集索引键。比如（文件名：页号：槽号），所以辅助索引就是包含了索引那列的值和主键的值</p><h3 id="3、B-树索引的管理"><a href="#3、B-树索引的管理" class="headerlink" title="3、B+树索引的管理"></a>3、B+树索引的管理</h3><h4 id="1、索引管理"><a href="#1、索引管理" class="headerlink" title="1、索引管理"></a>1、索引管理</h4><p>创建和删除可以通过两种方法。一种是alter table。另一种是create&#x2F;drop index。</p><p>查看：show index from XX</p><h4 id="2、fast-index-create"><a href="#2、fast-index-create" class="headerlink" title="2、fast index create"></a>2、fast index create</h4><p>对于一张大表进行索引的添加和删除操作，这会需要很长时间。所以就提出了这个快速创建索引的方式。只限制于辅助索引。</p><p>在创建索引的表加上一个S锁不需要重建表，删除索引只需要更新内部视图。</p><h4 id="3、Online-Schema-Change在线架构改变OSC"><a href="#3、Online-Schema-Change在线架构改变OSC" class="headerlink" title="3、Online Schema Change在线架构改变OSC"></a>3、Online Schema Change在线架构改变OSC</h4><p>在线的意思其实就是在DDL的过程中，可以有读写事务对表进行操作</p><h4 id="4、Online-DDL"><a href="#4、Online-DDL" class="headerlink" title="4、Online DDL"></a>4、Online DDL</h4><p>允许在辅助索引创建的同时，还允许insert update等DML操作</p><p>原理是：执行insert update delete这些操作的时候，先把操作日志写入一个缓存里面，然后，索引建立后重做表上面</p><p>新的alter table语法中，通过algorithm如果是 copy还是通过建立临时表的方式，如果是replace就是不需要临时表，如果是default，那就是根据old_alter_table判断，如果是off，那就是replace。</p><h4 id="5、cardinality值"><a href="#5、cardinality值" class="headerlink" title="5、cardinality值"></a>5、cardinality值</h4><p>优化器会根据这个值来判断我们用不用索引。表示索引中唯一值的数据的估计值，如果是性别这种，重复的非常多，我们叫低选择性，不适合做索引。反之高选择性就比较适合，尤其是在高选择性属性字段里面取出一小部分数据，那就更有必要了。</p><ul><li><strong>统计的方式</strong>？</li></ul><p>一张大表，每次统计的时间很长，这是不能接受的，所以我们用的是采样的方法。cardinality值的更新发生在insert和update操作，但是肯定不是每一次insertupdate都去更新，具体策略如下：</p><p>1、表中1&#x2F;16数据发生了变化</p><p>2、计数器超过20亿</p><ul><li><strong>采样的方法：</strong></li></ul><p>对八个叶子结点进行采样预估，取出平均值</p><h3 id="4、B-树索引的使用"><a href="#4、B-树索引的使用" class="headerlink" title="4、B+树索引的使用"></a>4、B+树索引的使用</h3><h4 id="1、联合索引"><a href="#1、联合索引" class="headerlink" title="1、联合索引"></a>1、联合索引</h4><p>本质也是一颗二叉树，之前是a,b,c,d现在是（a,b）(c,d)</p><p>第一个好处：对于联合查询和单列的第一列的查询都可以用联合查询</p><p>第二个好处：一句对第二个键值进行了排序处理，可以缩短某些情况的查询时间</p><h4 id="2、覆盖索引"><a href="#2、覆盖索引" class="headerlink" title="2、覆盖索引"></a>2、覆盖索引</h4><p>覆盖索引的意思是，从辅助索引中就直接可以得到想要查询的记录，不需要回表。</p><p>第一个好处是：辅助索引本身不包括整行记录，所以大小远小于聚集索引，减少io操作</p><p>第二个好处是：对于某些统计问题，存储引擎并不会通过积极索引，辅助索引远远小于聚集索引，</p><h4 id="3、优化器不选择索引的方式"><a href="#3、优化器不选择索引的方式" class="headerlink" title="3、优化器不选择索引的方式"></a>3、优化器不选择索引的方式</h4><p>多发生在范围查找、join链接操作</p><h4 id="4、MRR优化（只支持非聚集索引）（离散读变成顺序读）"><a href="#4、MRR优化（只支持非聚集索引）（离散读变成顺序读）" class="headerlink" title="4、MRR优化（只支持非聚集索引）（离散读变成顺序读）"></a>4、MRR优化（只支持非聚集索引）（离散读变成顺序读）</h4><p>工作方式：</p><ul><li>把辅助索引读出来放到一个缓存里面</li><li>把缓存中的键值更具rowid进行排序</li><li>然后根据rowid去找数据</li></ul><p>他还可以进行某些范围查找，就是把范围查找拆分成键值对的等值查找。直接就过滤了一些不符合条件的数据。</p><p>好处：</p><ul><li>数据访问更加顺序，</li><li>减少缓冲池页的替换</li></ul><h4 id="5、ICP优化（只支持非聚集索引）"><a href="#5、ICP优化（只支持非聚集索引）" class="headerlink" title="5、ICP优化（只支持非聚集索引）"></a>5、ICP优化（只支持非聚集索引）</h4><p>原本我们通过索引进行查询的时候，首先根据索引查找记录，然后根据where条件过滤记录。ICP是在取出索引的同时，判断是否可以进行where条件的过滤，也就是讲where的部分过滤操作放到了存储引擎层</p><p>场景：</p><p>假设表TB1上有索引IDX_C1_C2_C3(C1,C2,C3)，对于查询SELECT * FROM TB1 WHERE C1&#x3D;’XXX’ AND C3&#x3D;’XXX’</p><p>在MySQL 5.6版本以前，由于缺少C2的过滤条件，Innodb存储引擎层只能使用索引IDX_C1_C2_C3按照C1&#x3D;’XXX’条件找出所有满足条件的索引记录，再根据这些索引记录去聚集索引中查找，将找到的表数据返回给MySQL Server层，然后由MySQL Server层使用C3&#x3D;’XXX’条件进行过滤得到最终结果。</p><p>再MySQL 5.6版本中引入ICP特性，Innodb存储引擎层只能使用索引IDX_C1_C2_C3按照C1&#x3D;’XXX’条件去扫描所有满足条件的索引记录，再将这些索引记录按照C3&#x3D;’XXX’条件进行过滤，并按照过滤后的索引记录去去聚集索引中查找，将找到的表数据返回给MySQL Server层，得到最终结果。</p><p>假设满足C1&#x3D;’XXX’条件的数据行为100000条，而满足C1&#x3D;’XXX’ AND C3&#x3D;’XXX’的数据行为100条，则：</p><p>1、在MySQL 5.5版本中，需要对TB1的聚集索引进行100000次Index Seek操作，Innodb存储引擎层向MySQL Server层传递100000行数据。</p><p>2、在MySQL 5.6版本中，使用ICP仅需要对TB1的聚集索引进行100次的Index Seek操作，Innodb存储引擎层向MySQL Server层传递100行数据。</p><h4 id="6、自适应哈希索引"><a href="#6、自适应哈希索引" class="headerlink" title="6、自适应哈希索引"></a>6、自适应哈希索引</h4><p>InnoDB中的哈希用的字典进行查找，冲突用链表解决，哈希函数用除法散列</p><p>自适应哈希索引就是用的这种方法。</p><h4 id="7、全文检索"><a href="#7、全文检索" class="headerlink" title="7、全文检索"></a>7、全文检索</h4><p>全文检索一般使用倒排索引。</p><h5 id="1、倒排索引"><a href="#1、倒排索引" class="headerlink" title="1、倒排索引"></a>1、倒排索引</h5><p>它在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关键数组实现，其拥有两种表现形式：<br>inverted file index：其表现形式为{单词，单词所在文档的ID}<br>full inverted index：其表现形式为{单词，(单词所在文档的ID，在文档中的具体位置)}</p><h5 id="2、InnoDB全文检索的实现"><a href="#2、InnoDB全文检索的实现" class="headerlink" title="2、InnoDB全文检索的实现"></a>2、InnoDB全文检索的实现</h5><p><strong>InnoDB全文索引有3个非常重要的东西，一个是辅助表，一个是FTS Index Cache、一个是FTS DOUCUMENT id</strong></p><h6 id="1、Auxiliary-Table（辅助表）"><a href="#1、Auxiliary-Table（辅助表）" class="headerlink" title="1、Auxiliary Table（辅助表）"></a><strong>1、Auxiliary Table（辅助表）</strong></h6><p>辅助表是把文档，分词然后规范化后的白哦，</p><p>辅助表的话采用“full inverted index”的方式有两个列：<br>一个是word字段。在word字段上有设有索引，另一个是ilist字段，（DocumentId,Position）</p><h6 id="2、FTS-INDEX-Cache（全文检索缓存）"><a href="#2、FTS-INDEX-Cache（全文检索缓存）" class="headerlink" title="2、FTS INDEX Cache（全文检索缓存）"></a><strong>2、FTS INDEX Cache（全文检索缓存）</strong></h6><p>他是一个红黑树的结构：我执行插入操作，插入的数据已经更新了对应的表，但是我们的辅助表可能还没更新，这个更新还停留在FTS cache里面。如果没插一次就更新这是不合理的，那具体同步到辅助表的时机：</p><p>1、在我进行全文检索查询的时候，我把FTS INDEX cache里的word字段合并到辅助表，然后查询。有点类似于insert buffer</p><p>2、数据库关闭的时候会同步</p><p>3、cache满了</p><p>数据库宕机时：一些FTS InDEX Cache中的数据库可能未被同步到磁盘上。那么下次重启时，当用户对表进行全文检索（查询或者插入操作）时，InnoDB会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入到FTS Index Cache中</p><p>对于InnoDB来说，其总是在事务提交时将分词写入到FTS Index Cache。</p><h6 id="3、FTS-DOUCUMENT-ID"><a href="#3、FTS-DOUCUMENT-ID" class="headerlink" title="3、FTS DOUCUMENT ID"></a>3、FTS DOUCUMENT ID</h6><p>为了支持全文检索，<strong>必须有一个列与word进行映射：</strong></p><ul><li>在InnoDB中这个列<strong>被命名为FTS_DOC_ID</strong></li><li>其<strong>类型必须是</strong>bigint unsigned not null</li><li>并且InnoDB自动会在该列上加入一个<strong>名为FTS_DOC_ID_INDEX的unique index索引</strong></li><li><strong>用户也可以在建表时自动添加FTS_DOC_ID，以及相应的Unique Index</strong></li></ul><p>Deleted auxiliary table<br>文档中分词的插入操作是在事务提交时完成的，然而对于删除操作，其在事务提交时不删除磁盘Auxiliary Table中的记录，而只是删除FTS Index Cache中的记录。对于Auxiliary Table中被删除的记录，InnoDB会记录其FTS Document ID，并将其保存在Deleted auxiliary table中</p><p>由于文档的DML操作实际并不删除索引中的数据，相反还会在对应的DELETED表中插入记录，因此随着应用程序的允许，索引会变得非常大，即使索引列中的有些数据已经被删除，查询也不会使用到。为了，InnoDB存储引擎提供了一种方式，允许用户手动地将已删除的记录从索引中彻底删除，该命令就是OPTIMIZE TABLE</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁机制是用于管理对共享资源的并发访问，保证数据的完整性和一致性。</p><h2 id="1、锁的类型"><a href="#1、锁的类型" class="headerlink" title="1、锁的类型"></a>1、锁的类型</h2><h3 id="1、全局锁"><a href="#1、全局锁" class="headerlink" title="1、全局锁"></a>1、全局锁</h3><p>典型的使用场景就是做全库的逻辑备份</p><ul><li><p>一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态</p></li><li><p>语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;<span class="number">1</span>、加全局锁</span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pxxx db_name <span class="operator">-</span><span class="operator">&gt;</span> xxx.sql;<span class="number">2</span>、数据备份</span><br><span class="line">unlock tables;<span class="number">3</span>、释放锁</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、表级锁"><a href="#2、表级锁" class="headerlink" title="2、表级锁"></a>2、表级锁</h3><p>表级锁，主要分为3类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ul><h4 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h4><p>对于表锁，又可以分为2类：</p><ul><li>表共享读锁（read lock）</li><li>表独占写锁（write lock）</li></ul><p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞 其他客户端的写。</p><h4 id="2、、元数据锁"><a href="#2、、元数据锁" class="headerlink" title="2、、元数据锁"></a>2、、元数据锁</h4><p>再来说说<strong>元数据锁</strong>（MDL）。</p><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><blockquote><p>MDL 不需要显示调用，那它是在什么时候释放的?</p></blockquote><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL 锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与 DDL冲突，保证读写的正确性。</p><h4 id="3、意向锁"><a href="#3、意向锁" class="headerlink" title="3、意向锁"></a>3、意向锁</h4><p>我觉得意向锁主要还是解决行锁和表锁之间的冲突问题。</p><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul><p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加行级独占锁。</p><p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;20e0f35589584352bd15e817668a0886.png)</p><p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;6e6b275c2d6d4dfcbbb338be4f61bee9.png)</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><h4 id="4、自增锁"><a href="#4、自增锁" class="headerlink" title="4、自增锁"></a>4、自增锁</h4><p>主键设置成自增之后，在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p><p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增</p><p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p><ul><li>当 innodb_autoinc_lock_mode &#x3D; 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li><li>当 innodb_autoinc_lock_mode &#x3D; 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li><li>当 innodb_autoinc_lock_mode &#x3D; 1：<ul><li>普通 insert 语句，自增锁在申请之后就马上释放；</li><li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li></ul></li></ul><p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;innodb_autoinc_lock_mode&#x3D;2.png)</p><p>session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后<strong>两个 session 同时执行向表 t2 中插入数据</strong>。</p><p>如果 innodb_autoinc_lock_mode &#x3D; 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：</p><ul><li>session B 先插入了两个记录，(1,1,1)、(2,2,2)；</li><li>然后，session A 来申请自增 id 得到 id&#x3D;3，插入了（3,5,5)；</li><li>之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</li></ul><p>可以看到，<strong>session B 的 insert 语句，生成的 id 不连续</strong>。</p><p>当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format&#x3D;statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。</p><p>但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在<strong>从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致</strong>。</p><p>要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。</p><p>所以，<strong>当 innodb_autoinc_lock_mode &#x3D; 2 时，并且 binlog_format &#x3D; row，既能提升并发性，又不会出现数据一致性问题</strong>。</p><h3 id="3、行锁"><a href="#3、行锁" class="headerlink" title="3、行锁"></a>3、行锁</h3><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他 锁</li></ul><p>![image-20230805221422216](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20230805221422216.png)</p><h2 id="2、一致性非锁定读（快照读）"><a href="#2、一致性非锁定读（快照读）" class="headerlink" title="2、一致性非锁定读（快照读）"></a>2、一致性非锁定读（快照读）</h2><p>一致性非锁定读是指InnoDb通过多版本控制（MVCC）的方式读取当前执行时间里面数据库的数据。如果读取的那一行正在做一些dml操作，但是我不会去等，我会直接去读一个快照数据。不需要等待X锁的释放，那这个数据是哪里来的呢？这个快照数据是指该行之前版本的数据，他的实现是通过undo页完成的，而一个行记录它对应的可能不只有一个快照数据，所以我们把对于这些快照数据的管理，叫做多版本控制MVCC。当然这里提一嘴就是,读已提交和可重复读这两种级别是可以用一致性非锁定读，但是对于快照数据的定义不一样，读已提交总是读区被锁定行的最新的一份快照，可重复读总是读事务开始时候的数据版本，</p><h2 id="3、一致性锁定读（当前读）"><a href="#3、一致性锁定读（当前读）" class="headerlink" title="3、一致性锁定读（当前读）"></a>3、一致性锁定读（当前读）</h2><p>有时候用户需要些显式的对读操作进行加锁保证一致性。</p><h2 id="4、锁的算法"><a href="#4、锁的算法" class="headerlink" title="4、锁的算法"></a>4、锁的算法</h2><p>InnoDB有三种行锁的算法：</p><p>Record Lock：单个行记录的锁</p><p>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身</p><p>Next-Key Lock：Record Lock + Gap Lock</p><p>InnoDB就是用Next-Key去解决幻想问题（同一事务下，连续执行两次相同的sql语句可能导致不同的结果，第二次sql可能会返回之前不存在的行）</p><p>查询的索引如果是唯一性质，那么降级为Record Lock</p><h2 id="5、锁问题"><a href="#5、锁问题" class="headerlink" title="5、锁问题"></a>5、锁问题</h2><h3 id="1、脏读"><a href="#1、脏读" class="headerlink" title="1、脏读"></a>1、脏读</h3><p>读到了其他事务没有提交的数据，违反了隔离性。但是脏读发生的隔离级别最少也得是read uncommitted，而我们的数据库默认是可重复读，所以一般在生产环境中，发生的并不多。</p><h3 id="2、不可重复读"><a href="#2、不可重复读" class="headerlink" title="2、不可重复读"></a>2、不可重复读</h3><p>就是一个事务读两次，另一个事务在两次读之间作出修改，因为读是mvcc，不加锁，所以会出现不可重复读。innoDB的解决方法：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h3 id="3、丢失更新"><a href="#3、丢失更新" class="headerlink" title="3、丢失更新"></a>3、丢失更新</h3><p>是指一个事务的操作被另一个事务的操作覆盖了，但是当前数据库的任何隔离级别都对行或者粗粒度的对象加锁，所以还是比较难发生。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>事务级别</p><p><strong>类型一：RU（READ-UNCOMMITTED 表示读未提交）</strong></p><p>可以读取到事务未提交的数据，隔离性差，会出现脏读（当前内存读），不可重复读，幻读问题;</p><p><strong>类型二：RC（READ-COMMITTED 表示读已提交）</strong>可用</p><p>可以读取到事务已提交的数据，隔离性一般，不会出现脏读问题，但是会出现不可重复读，幻读问题；</p><p><strong>类型三：RR（REPEATABLE-READ 表示可重复读）</strong><code>默认</code></p><p>可以防止脏读（当前内存读），防止不可重复读问题，防止会出现的幻读问题，但是并发能力较差；</p><p>会使用next lock锁进制，来防止幻读问题，但是引入锁进制后，锁的代价会比较高，比较耗费CPU资源，占用系统性能；</p><p><strong>类型四：SR（SERIALIZABLE 可串行化）</strong></p><p>隔离性比较高，可以实现串行化读取数据，但是事务的并发度就没有了；</p><p>这是事务的最高级别，在每条读的数据上，加上锁，使之不可能相互冲突</p><h2 id="6、死锁"><a href="#6、死锁" class="headerlink" title="6、死锁"></a>6、死锁</h2><p>死锁是指两个或以上的事务争夺资源造成的一种互相等待的现象</p><p>解决方法：</p><p>1、设置超时的阈值，回滚一个事务</p><p>2、wait-for-graph 等待图。检测是否有回路。通常用深度优先。1.2版本开始就变成非递归</p><p>如果有死锁，那就回归undo量最少的</p><h2 id="7、锁升级"><a href="#7、锁升级" class="headerlink" title="7、锁升级"></a>7、锁升级</h2><p>InnoDB中不存在锁升级的问题，因为InnoDB不是更具每个记录来产生锁的，相反，其根据每个事务访问的每个页对锁进行管理，采用的是位图的方式。所以不管你锁住的是页中的一个记录或者多个记录，开销一样</p><p>![image-20231006204601132](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231006204601132.png)</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="1、认识事务"><a href="#1、认识事务" class="headerlink" title="1、认识事务"></a>1、认识事务</h2><h3 id="1、四个特性：acid。"><a href="#1、四个特性：acid。" class="headerlink" title="1、四个特性：acid。"></a>1、四个特性：acid。</h3><p>原子性：要么成功要么失败</p><p>一致性：讲数据库从一种状态转变为下一种一致的专题。</p><p>isolation：一个事务提交之前对其他事物不可见</p><p>durability：一旦提交，那么结果是永久性的</p><h3 id="2、分类-1"><a href="#2、分类-1" class="headerlink" title="2、分类"></a>2、分类</h3><p>扁平事务</p><p>带有保存点的扁平事务</p><p>链事务</p><p>嵌套事务</p><p>分布式事务</p><h2 id="2、事务的实现"><a href="#2、事务的实现" class="headerlink" title="2、事务的实现"></a>2、事务的实现</h2><p>事务的隔离性由锁机制来实现。</p><p>原子性、一致性、持久性通过redo log和undo log完成</p><p>redo log保证持久性</p><p>undo log保证事务的原子性，一致性</p><p>redolog恢复提交事务修改的页操作</p><p>undo回滚行记录道某个特定版本，事务</p><h3 id="1、redo"><a href="#1、redo" class="headerlink" title="1、redo"></a>1、redo</h3><p>有两部分组成：redo log buffer缓冲，redo log file</p><p>事务提交的时候必须把事务的所有日志写入重做日志文件进行持久化。这个的所有日志包括redo log 和undo log</p><p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p><p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p><p>![image-20231007131604938](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231007131604938.png)</p><p>![image-20231007131752781](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231007131752781.png)</p><p>![image-20231007131726290](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231007131726290.png)</p><blockquote><p>产生的 redo log 是直接写入磁盘的吗？</p></blockquote><p>不是的。</p><p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作，而且磁盘的运行速度远慢于内存。</p><p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图：</p><p>![image-20231007131921540](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231007131921540.png)</p><h3 id="redo-log-什么时候刷盘？"><a href="#redo-log-什么时候刷盘？" class="headerlink" title="redo log 什么时候刷盘？"></a>redo log 什么时候刷盘？</h3><p>缓存在 redo log buffer 里的 redo log 还是在内存中，它什么时候刷新到磁盘？</p><p>主要有下面几个时机：</p><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。</li></ul><p>由参数 <code>innodb_flush_log_at_trx_commit</code> 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：</p><ul><li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li><li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li><li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看<a href="https://xiaolincoding.com/os/6_file_system/pagecache.html">这篇 (opens new window)</a>），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li></ul><h3 id="2、undo-log"><a href="#2、undo-log" class="headerlink" title="2、undo log"></a>2、undo log</h3><p>undo log最主要的作用有两点：一个是事务回滚，保证原子性；还有一个是支持mvcc</p><p>那我们先讲第一个，就是事务提交之前，如果发生意外，这时候你用redolog是没有办法恢复的，所以我们可以使用undolog，他的做法是，假如我们去修改一个数据，上锁之后，我们把该行数据拷贝到 <code>undo log</code>作为旧版本。copy之后，那进行真正的修改操作，同时修改trxid 和roll_pointer。</p><p>另外一个大的作用是mvcc，mvcc他是基于undo log版本链和ReadView实现</p><p>然后每一行数据其实都有两个隐藏列，一个是trxid一个是rollpointer，trxid 表示修最新修改事务的id，rollpointer表示指向旧版本log</p><p>ReadView，里面有四个比较关键的东西：</p><p>一个是m_ids，这个就是说事务开启那一刻有哪些事务在Mysql里面执行还没有提交的；</p><p>一个是min_trx_id，就是m_ids里最小的事务id的值；</p><p>一个是max_trx_id，就是此刻mysql下一个要生成的事务id，就是最大事务id；</p><p>一个是creator_trx_id，就是你这个事务的id。</p><p>那我们只要对比mintexid，如果说比他小，说明已经事务已经提交了，我们可以看得见。</p><p>比如一条记录旧版本里面有三条记录：10，20，30。然后我们的事务id是15，m_ids里面有20，30。这里的min_trx_id就是20，我们的15比她小，说明还没有提交。因为隔离性所以肯定是看不到的，然后再去找更前面版本，我们就找到了10，发现10可以，所以我们这次读到的数据就是事务id为10的那一个版本。</p><p>rr：事务启动的时候创建readview</p><p>rc：每次查询都会创建一个readview</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis组件的整合理解2</title>
      <link href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/"/>
      <url>/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/</url>
      
        <content type="html"><![CDATA[<p>orm我们已经知道具体的做法了，那怎么把这个和我们的spring结合在一起呢？</p><p>其实我们要做的就是让他参与到Spring的事务管理之中，然后创建映射器和sqlsession并注入到bean里面，再把异常转化成Spring到dataaccessexception。以上的种种就是要把我们自己的orm交给spring管理。<img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427143800831.png" alt="image-20230427143800831"></p><p>orm结合spring的核心内容就是对需要注册对象的扫描，代理类的实现，bean的注册。</p><p>这里和orm框架一样，也有三个类非常重要：SqlSessionFactoryBean、MapperScannerConfigurer、MapperFactoryBean</p><p>先说SqlSessionFactoryBean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 在基本的 MyBatis 中，session 工厂可以使用 SqlSessionFactoryBuilder 来创建。而在 MyBatis-Spring 中,则使用 SqlSessionFactoryBean 来替代。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;SqlSessionFactory&gt;, InitializingBean &#123;</span><br><span class="line">    <span class="keyword">private</span> String resource;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> Resources.getResourceAsReader(resource)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlSessionFactory.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResource</span><span class="params">(String resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSessionFactoryBean实现InitializingBean主要适用于加载mybatis相关内容；解析xml、构造sqlsession、链接数据库等等，这三步就是我们orm框架中的核心部分，这也是为什么你只要引入一些数据库的依赖，你如果没有配置数据库，他在项目启动的时候就会报错，因为这个需要一开始就配置好。</p><p>MapperScannerConfigurer</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerConfigurer</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String basePackage;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + basePackage.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ResourcePatternResolver</span> <span class="variable">resourcePatternResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line"></span><br><span class="line">            Resource[] resources = resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMetadataReader</span>(resource, ClassUtils.getDefaultClassLoader());</span><br><span class="line"></span><br><span class="line">                <span class="type">ScannedGenericBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> Introspector.decapitalize(ClassUtils.getShortName(beanDefinition.getBeanClassName()));</span><br><span class="line"></span><br><span class="line">                beanDefinition.setResource(resource);</span><br><span class="line">                beanDefinition.setSource(resource);</span><br><span class="line">                beanDefinition.setScope(<span class="string">&quot;singleton&quot;</span>);</span><br><span class="line">                beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(beanDefinition.getBeanClassName());</span><br><span class="line">                beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(sqlSessionFactory);</span><br><span class="line">                beanDefinition.setBeanClass(MapperFactoryBean.class);</span><br><span class="line"></span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName);</span><br><span class="line">                registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBasePackage</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.basePackage = basePackage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个类要做的就是把Dao接口全部扫描出来（也就是所有的XXXdao），完成他们的代理，然后把他们注册到spring Bean容器</p><p>打个锻炼看看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postProcessBeanDefinitionRegistry</span><br></pre></td></tr></table></figure><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427145417700.png" alt="image-20230427145417700"></p><p>看这个packagesearchpath就明白了</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427145506491.png" alt="image-20230427145506491"></p><p>看resource，因为我们只有一个dao所以就扫描到了一个</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427145729295.png" alt="image-20230427145729295"></p><p>这里把他注册到容器中</p><p>mapperfactory：</p><p>这个类其实就是你所有dao接口类的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日常调用的 dao 层接口就是 MapperFactoryBean 实例化的</span><br></pre></td></tr></table></figure><p>我们虽然配置的是<code>MapperFactoryBean</code>的实列，但是根据id拿到的是<code>getObject</code>方法里面返回的的对象。其实在容器中创建的对象仍然是<code>MapperFactoryBean</code>的实列，只是在获取的时候会判断这个结果对象是不是派生于<code>FactoryBean</code>，如果是的话则返回<code>getObject</code>方法创建的对象，并且这个对象并不是容器初始化时创建的，而是使用<code>context.getBean()</code>方法时才创建。当然了，如果你确实想要获取<code>FactoryBean</code>实例，你需要这样写: <em><code>MapperFactoryBean mapper = context.getBean(&quot;&amp;mapper&quot;, MapperFactoryBean.class);</code></em> 只需要在bean的名字ID前加上&amp;符号。</p><p>所以究竟getObject获取的是什么呢？那就看他return了什么，后面的详细知识和加载流程，就涉及spring源码，所以可以看我的Spring ioc加载流程，保真有所收获！</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis-starter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis组件的整合理解3</title>
      <link href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A33/"/>
      <url>/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A33/</url>
      
        <content type="html"><![CDATA[<p>现在我们来把我们的成果整合到springboot中，但是我们又不想另起一个模块放我们的整合模块，那怎么做呢？诶，没错，就是依赖组件，我们开发自己的依赖组件，在项目中引入即可。</p><p>那么在springboot的starter的开发过程中，主要的核心在于自动加载autoconfiguration的使用，我们需要加载yml或者其他的配置文件，并结合配置信息注册相关的bean，因为spring和springboot的注册方式可以不同。</p><p>和myabtis组件的整合理解2中提到的mybatis-spring不同的在于，由于spring和springboot本身存在的区别所以加载配置和启动方式有所不同，所以这里我们需要修改的就是扫描方法，注册代码。</p><p>这个工程也主要分成三块：autoconfigure、mybatis、spring</p><p>●autoconfigure,读取自定义配置信息以及负责把相关mybatis、spring 中的Bean加载启动<br>●mybatis,这部分与我们之前实现的ORM框架源码几乎是一致的，只是对<br>SqlSessionFactoryBuilder做了符合yml配置方式的加载处理。<br>●spring,这一部分主要的变 动是MapperScannerConfigurer关于扫描定义Bean 信息时<br>addGenericArgumentValue入参信息的变更。</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis-starter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis组件的整合理解1</title>
      <link href="/2023/04/26/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/"/>
      <url>/2023/04/26/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/</url>
      
        <content type="html"><![CDATA[<p>其实这里最核心的还是做一个ORM对象关系映射，用于不同类型系统的数据之间的转换，也让我们更方便的使用数据库。</p><p>主要做法其实就是通过：参数映射、SQL解析和执行以及结果封装的整体方式对数据库进行操作。这也是ORM框架的核心内容。</p><p>这里我们注意三类 类，没错就是三个类的类</p><p>分别是，sqlsession、sqlsessionfactory、sqlsessionfactorybuilder</p><p>sqlseesion：定义了对数据库的操作，什么查询啊之类的。然后接口必须有一个实现类，这里我们用的是defaultsqlsession，实现了接口的方法，也包装了jdbc，这样就把数据库的jdbc包装起来了，我们敲代码也会方便。</p><p>sqlsessionfactory：你每次有数据库操作都需要开启一个sqlsession那么从谁那里获取呢，就是factory。他也有一个实现类defaultsqlsession factory，他的唯一方法就是返回上面我们的defaultsqlsession，通过传进去的参数返回sqlsession，不过这个类的构造函数传递了configuration配置，包括connection connection，Map dataSource， Map mapperElement。</p><p>sqlsessionfactorybuilder：这个类主要包括：build构建实例化元素，parseConfiguration解析构造，datasource获取数据库配置，connnection链接数据库，mapperElement解析sql语句。</p><p>build，创建解析xml文件的类，然后初始化Defaultsqlsessionfactory工厂类，但是这个工厂类需要configuration，那这个configuration则需要parseconfiguration，所以往下看</p><p>parseConfigtation：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        configuration.setDataSource(dataSource(root.selectNodes(<span class="string">&quot;//dataSource&quot;</span>)));</span><br><span class="line">        configuration.setConnection(connection(configuration.dataSource));</span><br><span class="line">        configuration.setMapperElement(mapperElement(root.selectNodes(<span class="string">&quot;mappers&quot;</span>)));</span><br></pre></td></tr></table></figure><p>首先，我们在build以及把xml文件扫描进来了，然后我们用扫描后的参数去设置数据库、链接、节点这三个关键。</p><p>datasource函数打断点看看：就是进去了这四个数据库的参数</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/E7B0BF9D-E780-405F-9FE7-85CECE47328F-2492888.png" alt="E7B0BF9D-E780-405F-9FE7-85CECE47328F"></p><p>connectin函数里面用这几个参数得到一个链接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(dataSource.get(<span class="string">&quot;driver&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> DriverManager.getConnection(dataSource.get(<span class="string">&quot;url&quot;</span>), dataSource.get(<span class="string">&quot;username&quot;</span>), dataSource.get(<span class="string">&quot;password&quot;</span>));</span><br></pre></td></tr></table></figure><p>mapperElement函数<img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426154547513.png" alt="image-20230426154547513"></p><p>拿到build扫描的参数，做循环</p><p>每次循环，先拿到resource，举个例子：</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426154908196.png" alt="image-20230426154908196"></p><p>先拿到mapper&#x2F;usermapper.xml，然后去读这个文件，拿到namespace</p><p>也就是对应的dao类，这里就是iuserdao</p><p>然后去读doc文件里面的各个操作，我们这个读取了select等等操作，反正就是把xnode放到map里面</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426155555163.png" alt="image-20230426155555163"></p><p>这个map就是我们的mapperelement，里面是一个namespace对应一个xnode。</p><p>所以mapperelement函数就是去拿到</p><p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426155850578.png" alt="image-20230426155850578">对应到我们的具体的mapper.xml文件，然后读取这个文件，去解析我们的sql语句，然后得到一个名称和sql的映射关系的map</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis-starter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DBRouter组件的整合理解</title>
      <link href="/2023/04/22/DBRouter%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/"/>
      <url>/2023/04/22/DBRouter%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/</url>
      
        <content type="html"><![CDATA[<p>这个项目我设计的初衷是考虑到业务体量的增加，为了避免原有的设计出现不能承载业务规模的情况发生，所以想设计分库分表， 因为想提高自己的理解，决定自己写一个小组件。</p><p><img src="/../images/DBRouter%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/image-20230428132828992.png" alt="image-20230428132828992"></p><p>主要考虑以下几个方面：</p><p>一是配置，分库分表需要配置连接池，这个依赖于配置文件，配置连接池之后要二是：考虑动态切换，所以需要去实现AbstractRoutingDataSource的deteemingCurrentlookKey方法。</p><p>三：数据库连接池和动态切换配置好了，就只剩下一个路由的计算模块了，从路由计算中获得分库分表的字段，通过哈希散列和扰动函数最终选择去哪个表，让数据均匀的散列到各个表。</p><p>首先讲一下：DataSourceAutoConfig，借助springboot自动配置机制，读取配置以及数据源的创建，包括yml自定义配置，JoinPoint、路由策略、路由配置、数据源、transactionTemplate.</p><p>举个例子：setEnvironment, 读取自定义配置，因为我们要设置的是一个在yml配置多组数据源，这个方法就是为了解析下面的配置信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router :</span><br><span class="line">jdbc:</span><br><span class="line">datasource :</span><br><span class="line">dbCount: 2</span><br><span class="line">tbCount: 4</span><br><span class="line">list: db01 , db02</span><br><span class="line">db01 :</span><br><span class="line">dr iver-class-name: com . mysql. jdbc .Driver</span><br><span class="line">url: jdbc :mysql://127.0.0.1:3306/bugstack_ 01?</span><br><span class="line">useUnicode-true</span><br><span class="line">username: root</span><br><span class="line">password: 123456</span><br><span class="line">db02 :</span><br><span class="line">dr iver-class-name: com. mysql. jdbc . Driver</span><br><span class="line">url: jdbc :mysql:/ /127.0.0.1:3306/bugstack_ 02?</span><br><span class="line">useUnicode-true</span><br><span class="line">username: root</span><br><span class="line">password: 123456</span><br></pre></td></tr></table></figure><p>动态数据源的切换如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;db&quot;</span> + DBContextHolder.getDBKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由计算：</p><p>路由结果会存储在DBConrtextHolder里面</p><p>路由计算首先需要一些前提</p><p>路由注解@DBRouter 路由的标识，目的是为了给切面提供切点，同时获取方法中入参属性点某个字段，这个字段会作为路由字段存在，比如某个dao接口的xxxdao方法上面就有这个</p><p>分表标记@DBRouterStrategy：目的是告诉路由组件要不要分表，默认false</p><p>最关键的，DBRouterJoinPoint切面类，进行路由选择</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DBRouter-starter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring整合mybatis</title>
      <link href="/2023/04/11/spring%E6%95%B4%E5%90%88mybatis/"/>
      <url>/2023/04/11/spring%E6%95%B4%E5%90%88mybatis/</url>
      
        <content type="html"><![CDATA[<h4 id="Spring整合Mybatis要解决的问题"><a href="#Spring整合Mybatis要解决的问题" class="headerlink" title="Spring整合Mybatis要解决的问题"></a>Spring整合Mybatis要解决的问题</h4><p>重点关注下的Mapper动态代理对象，因为Spring整合Mybatis的核心目标是：把某个Mapper的代理对象作为一个bean放入Spring容器中，使得能够像使用一个普通bean一样去使用这个代理对象，比如能被@Autowire自动注入。常用如下通过Ioc容器把UserMapper注入了UserService</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;    </span><br><span class="line">    @Autowired    </span><br><span class="line">    private UserMapper userMapper;    </span><br><span class="line">    </span><br><span class="line">    public UserEntity queryUser(int id)&#123;        </span><br><span class="line">        UserEntity userEntity = userMapper.getById(id);        </span><br><span class="line">        return userEntity;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    public void printServiceName()&#123;        </span><br><span class="line">        System.out.println(&quot;I&#x27;m UserService&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Spring启动过程中，bean的生命周期如下</p><ul><li>扫描指定的包路径下的class文件或解析xml文件</li><li>生成对应的BeanDefinition</li><li>BeanFactoryPostProcessor注册或修改BeanDefinition定义</li><li>根据BeanDefinition反射实例化Bean</li><li>BeanPostProcessor修改Bean定义</li><li>Bean的业务调用</li><li>Bean的销毁</li></ul><p>对于两个Service：UserService&#x2F;OrderInfoService定义如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"> </span><br><span class="line">    public void printServiceName()&#123;</span><br><span class="line">        System.out.println(&quot;I&#x27;m UserService&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">执行如下命令：</span><br><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">System.out.println(ctx.getBean(&quot;userService&quot;));</span><br><span class="line">结果如下：</span><br><span class="line">com.hobbit.service.UserService@4167d97b</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增加一个FactoryBean后置处理器，修改userService的BeanDefinition定义</span><br><span class="line">@Component</span><br><span class="line">public class RenameBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(&quot;userService&quot;);</span><br><span class="line">        beanDefinition.setBeanClassName(OrderInfoService.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">重新运行结果如下，生成了OrderInfoService对象。</span><br><span class="line">com.hobbit.service.OrderInfoService@57ad2aa7</span><br></pre></td></tr></table></figure><p><em><strong>所以在Spring中bean对象跟class或xml定义的bean无直接关系，跟最终的BeanDefinition有直接关系。</strong></em></p><p><em><strong>要想生成一个bean，首先要有一个BeanDefinition。那Mapper对应的BeanDefinition是？</strong></em></p><p>这就引出了下一个类</p><h4 id="MapperFactoryBean"><a href="#MapperFactoryBean" class="headerlink" title="MapperFactoryBean"></a>MapperFactoryBean</h4><p>Spring通过BeanDefinition的beanClassName生成对应的bean，那mapper的对应的beanClassName是什么？本可以有两个答案：</p><ul><li>代理对象对应的代理类</li><li>代理对象对应的接口</li></ul><p>因为代理类是动态生成的，spring启动时无法得知，无法使用。那么代理对象对应的接口？思路如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanDefinition bd = new BeanDefinitoin();</span><br><span class="line">// 注意这里，设置的是UserMapper</span><br><span class="line">bd.setBeanClassName(UserMapper.class.getName());</span><br><span class="line">SpringContainer.addBd(bd);</span><br></pre></td></tr></table></figure><p>实际上给BeanDefinition对应的类型设置为一个接口是行不通的，因为Spring没有办法根据这个BeanDefinition去new出对应类型的实例，接口是没法直接new出实例的。</p><p>所以想通过设置BeanDefinition的class类型，然后由Spring自动地帮助我们去生成对应的bean，但是这条路是行不通的。可以通过其它方<strong>MapperFactoryBean</strong>来实现。</p><p>MapperFactoryBean继承关系</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b00b1795cde71cbf838c42c2d7bd8d42.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  ...</span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public T getObject() throws Exception &#123;</span><br><span class="line">    return getSqlSession().getMapper(this.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public Class&lt;T&gt; getObjectType() &#123;</span><br><span class="line">    return this.mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getObjectType返回的是Mapper接口，通过 AbstractBeanDefinition.AUTOWIRE_BY_TYPE时，可自动注入使用。</p><p>getObject返回了动态代理对象，跟之前的使用一致。至此完成了Mapper对应BeanDefinition定义的问题，那这些BeanDefinition是如何注册到Ioc容器呢？</p><h4 id="Mapper-BeanDefinition加载"><a href="#Mapper-BeanDefinition加载" class="headerlink" title="Mapper BeanDefinition加载"></a>Mapper BeanDefinition加载</h4><p>Spring可通过多种方式加载BeanDefinition，从XmlBeanDefinitionReader到ClassPathBeanDefinitionScanner在到ConfigurationClassBeanDefinitionReader分别对应xml、@component、@configuration类定义的加载。Mapper BeanDefinition可通过2种形式加载MapperScannerConfigurer和@MapperScan注解，内部都是通过ClassPathMapperScanner实现。ClassPathMapperScanner继承了ClassPathBeanDefinitionScanner，类图如下</p><p>两种方式如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定要扫描的包，在此包下自动搜索映射器(接口) --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;basePackage&quot; value=&quot;com.hobbit.mapper&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用@MapperScan加载</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用MapperScannerConfigurer加载在配置MapperScannerConfigurer中主要是加载dao包中的所有dao接口，通过sqlsessionFactory获取sqlsession，然后创建所有dao接口对象，存储在spring容器</strong></p><p><strong>会在spring容器刷新refresh过程中被调用</strong></p><p>到此为止，Spring整合Mybatis的核心原理就结束了，再次总结一下：</p><p>定义MapperFactoryBean，用来封装Mapper对应的BeanDefinition<br>通过ClassPathMapperScanner重新定义BeanClass及AutowireMode，实现BeanDefinition加载及MapperInterface与MapperFactory整合<br>通过MapperScannerConfigurer或@MapperScan，分别扩展BeanDefinitionRegistryPostProcessor及ImportBeanDefinitionRegistrar 用来在启动Spring时执行调用ClassPathMapperScanner完成Mapper BeanDefinition的注册</p><h2 id="Spring的启动流程："><a href="#Spring的启动流程：" class="headerlink" title="Spring的启动流程："></a>Spring的启动流程：</h2><p><a href="https://blog.csdn.net/weixin_39559282/article/details/118255793">https://blog.csdn.net/weixin_39559282/article/details/118255793</a></p><h2 id="MyBatis与Spring的集成原理"><a href="#MyBatis与Spring的集成原理" class="headerlink" title="MyBatis与Spring的集成原理"></a>MyBatis与Spring的集成原理</h2><p><a href="https://blog.csdn.net/m0_73311735/article/details/129226313">https://blog.csdn.net/m0_73311735/article/details/129226313</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis-starter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考资料</title>
      <link href="/2023/04/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"/>
      <url>/2023/04/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<h3 id="2023-x2F-07-x2F-29更新"><a href="#2023-x2F-07-x2F-29更新" class="headerlink" title="2023&#x2F;07&#x2F;29更新"></a>2023&#x2F;07&#x2F;29更新</h3><p>鉴于最初版本部分网站已丢失，决定对所有网站进行全面清洗。</p><hr><h3 id="为防止意外情况，使用最简单的Base64编码："><a href="#为防止意外情况，使用最简单的Base64编码：" class="headerlink" title="为防止意外情况，使用最简单的Base64编码："></a>为防止意外情况，使用最简单的Base64编码：</h3><p>LS0tCnRpdGxlOiDlj4LogIPotYTmlpkKZGF0ZTogMjAyMy0wNC0xMQp0YWdzOiAKICAtIOeUn+eQhumcgOaxggpjYXRlZ29yaWVzOgogIC0g5a2m5Lmg6LWE5paZCgotLS0KCgoKIyMjIDIwMjMvMDcvMjnmm7TmlrAKCumJtOS6juacgOWIneeJiOacrOmDqOWIhue9keermeW3suS4ouWkse+8jOWGs+WumuWvueaJgOaciee9keermei&#x2F;m+ihjOWFqOmdoua4hea0l+OAggoKIyMjIyDml6DpnIDnv7vlopnvvJoKCkFW5aSp5aCC572R77yaaHR0cDovL2JiLjk5OTl5ZXMuY29tL25ld3NpdGUuaHRtbD9jPTQ5OTg4ODM4NDAgCgrmvKvom5nvvIjpn6nmvKvvvInvvJpodHRwczovL21hbndhLm1lLwoK5oCn5aWL6Imy5ZCD55Oc572R77yaaHR0cDovL3d3dy54ZnNlMTEuY29tLwoKNUflvbHpmaLvvJpodHRwczovLzVxd21iYS50b3AvCgrmnY9UVu+8mmh0dHBzOi8vMTh4aW5ndHYuY2MvCgrnnIvniYfop4bpopHvvJpodHRwczovL3d3dy5oazEycS50b3Avdm9kcGxheWh0bWwvMjI0LTEtMS5odG1sCgrkuLvmkq3op4bpopHvvJpodHRwczovL3d3dy51N3NiLmNvbS9lbnRlci9pbmRleC5odG1sCgp5b3Vwb3JuIEFTSUEgQ0hBTk5FTO+8mmh0dHA6Ly94MzM2OTkuY29tLwoKdjhrNG4uY29t77yaaHR0cHM6Ly93d3cudjhrNG4uY29tL2luZGV4L2hvbWUuaHRtbAoKIyMjIyDnv7vlopnvvJoKCnhoYW1zdGVy77yaaHR0cHM6Ly96aC54aGFtc3Rlci5jb20vCgrni7zlj4vpmIHvvJpodHRwczovLzAwNTFhdi5jb20vCgrpu5HmlpnmraPog73ph4&#x2F;vvJpodHRwczovL3d3dy5mdWxpMzQubHYvCgpQb3JuaHVi77yaaHR0cHM6Ly9jbi5wb3JuaHViLmNvbS8KCmLlvbHpmaLvvJpodHRwczovL2JiYnl1bi50b3AvCgojIyMjIOi9r+S7tu+8mgoK5YW25a6e6K645aSa572R56uZ55qE5Y+L6ZO+5Lit6YO95pyJ6L2v5Lu277yM6L+Z6YeM5Li+5LiA5L6LCgrpu5HmlpnnpL7vvJpodHRwczovL3Q2MnJvLmNvbS8&#x2F;ZGM9TUlZVTA0</p><h4 id="将上述内容复制（快速三击）到以下网站，点击BASE64解码，即可获得最新内容，将其保存就避免了频繁访问。"><a href="#将上述内容复制（快速三击）到以下网站，点击BASE64解码，即可获得最新内容，将其保存就避免了频繁访问。" class="headerlink" title="将上述内容复制（快速三击）到以下网站，点击BASE64解码，即可获得最新内容，将其保存就避免了频繁访问。"></a>将上述内容复制（快速三击）到以下网站，点击BASE64解码，即可获得最新内容，将其保存就避免了频繁访问。</h4><p><a href="https://www.iamwawa.cn/base64.html">https://www.iamwawa.cn/base64.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生理需求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring ioc加载流程</title>
      <link href="/2023/04/11/spring%20ioc%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/04/11/spring%20ioc%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>在功能上，SpringBoot的容器启动过程基本遵循了Spring的标准启动过程，但是在具体实现上，SpringBoot提供了一些特殊的机制来简化Spring容器的配置和启动。</strong></p><p><strong>首先，SpringBoot自动配置了很多常用的第三方库和框架，使得在大多数情况下，开发者不需要手动配置就能够使用这些库和框架。其次，SpringBoot提供了一些基础设施和约定来简化Spring的配置，例如默认的目录结构、默认的配置文件名、默认的属性配置等，这些都能够减少开发者的配置工作。最后，SpringBoot提供了一些自定义扩展机制，例如通过@ConfigurationProperties注解来绑定配置文件属性到Java对象，通过SpringApplication类的addListeners()方法来添加自定义的启动监听器等等，这些扩展机制能够让开发者更加方便地自定义和扩展SpringBoot的功能。</strong></p><p><strong>总的来说，SpringBoot并没有改变Spring的核心机制和启动过程，但是它在具体实现上提供了很多便利和简化，让开发者能够更加快速地开发和部署应用程序</strong></p><p>总体分成两个阶段；</p><ul><li>一、refresh之前</li><li>二、调用refresh()方法刷新容器</li></ul><h2 id="一、初始化流程"><a href="#一、初始化流程" class="headerlink" title="一、初始化流程"></a>一、初始化流程</h2><ol><li>创建并实例化一个 ApplicationContextInitializer 列表，用于对 Spring 应用上下文进行初始化。ApplicationContextInitializer 是 Spring 4.1 引入的一个新特性，允许用户在容器启动之前，对 Spring 应用上下文进行一些额外的初始化工作。</li><li>创建并实例化一个 ResourceLoader 对象，用于加载配置文件。ResourceLoader 是一个接口，它定义了资源加载的基本方法。Spring 容器默认使用 DefaultResourceLoader 作为 ResourceLoader 实现类。</li><li>创建并实例化一个 PropertyResolver 对象，用于解析配置文件中的属性。PropertyResolver 也是一个接口，它定义了属性解析的基本方法。Spring 容器默认使用 PropertySourcesPlaceholderConfigurer 作为 PropertyResolver 实现类。</li><li>加载和解析配置文件，将解析后的配置信息封装成一个 Environment 对象。Environment 是 Spring 中用于描述应用环境的一个抽象概念，它包含了各种配置属性和属性值。</li><li>将解析后的配置信息封装成一个 ConfigurableEnvironment 对象，并将其设置到容器中。ConfigurableEnvironment 是 Environment 的一个子接口，它定义了一些额外的操作，如添加属性、激活配置文件等。</li><li>创建并实例化一个 BeanFactoryPostProcessor 列表，用于在 BeanFactory 加载 Bean 定义之后，对 Bean 定义进行进一步的处理。BeanFactoryPostProcessor 是一个接口，它提供了在 BeanFactory 加载 Bean 定义之后，修改 Bean 定义的机会。</li><li>创建并实例化一个 BeanPostProcessor 列表，用于在 Bean 实例化之后，对 Bean 进行进一步的处理。BeanPostProcessor 是一个接口，它提供了在 Bean 实例化之后，修改 Bean 实例的机会。</li><li>注册并加载 BeanFactory 中的 Bean 定义。在这个阶段，Spring 容器会扫描指定的包，查找标注了 @Component、@Service、@Repository、@Controller 等注解的 Bean，将其封装成 BeanDefinition 对象，注册到 BeanFactory 中。</li><li>调用 BeanFactoryPostProcessor 的 postProcessBeanFactory() 方法，对 BeanFactory 中的 Bean 定义进行进一步的处理。</li><li>注册并加载 BeanFactoryPostProcessor 中的 Bean 定义。BeanFactoryPostProcessor 可以通过实现 BeanDefinitionRegistryPostProcessor 接口，向 BeanFactory 中注册新的 Bean 定义。</li><li>初始化并注册 ConversionService。ConversionService 是 Spring 中用于类型转换的一个组件，它可以将一个对象转换成另一个类型的对象。在这个阶段，Spring 容器会注册一些默认的转换器。</li><li>初始化并注册 LoadTimeWeaver。LoadTimeWeaver 是 Spring 中用于支持动态类加载和增强的一个组件。它可以将类的字节码在运行时进行增强，从而实现 AOP 等功能。</li><li>初始化并注册 Resource</li></ol><p><strong>中间第8步解析过程如下：</strong></p><p>这个步骤主要是用来解析用户传入的 Spring 配置类，解析成一个 BeanDefinition 然后注册到容器中，主要源码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span><br><span class="line">@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) &#123;</span><br><span class="line">// 解析传入的配置类，实际上这个方法既可以解析配置类，也可以解析 Spring bean 对象</span><br><span class="line">AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">// 判断是否需要跳过，判断依据是此类上有没有 @Conditional 注解</span><br><span class="line">if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));</span><br><span class="line">// 处理类上的通用注解</span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">if (qualifiers != null) &#123;</span><br><span class="line">for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">if (Primary.class == qualifier) &#123;</span><br><span class="line">abd.setPrimary(true);</span><br><span class="line">&#125;</span><br><span class="line">else if (Lazy.class == qualifier) &#123;</span><br><span class="line">abd.setLazyInit(true);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">abd.addQualifier(new AutowireCandidateQualifier(qualifier));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 封装成一个 BeanDefinitionHolder</span><br><span class="line">for (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">customizer.customize(abd);</span><br><span class="line">&#125;</span><br><span class="line">BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);</span><br><span class="line">// 处理 scopedProxyMode</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line"> </span><br><span class="line">// 把 BeanDefinitionHolder 注册到 registry</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「扫描」在XML/注解/JavaConfig 中需要被Spring管理的Bean信息</span><br><span class="line"></span><br><span class="line">随后，会将这些信息封装成BeanDefinition，最后会把这些信息放到一个beanDefinitionMap中</span><br><span class="line">那么BeanDefintiions是什么勒？</span><br><span class="line"></span><br><span class="line">BeanDefintiions其实就是对Bean的一些元数据定义</span><br><span class="line">包括parenName 父类名称 baenClassName：类名，scope bean的作用域。Abstract是否是抽象的等信息。</span><br><span class="line">通过 BeanDefinitionReader获取到BeanDefinition之后 。我们在通过BeanDefinitionRegistry将beanDefinition注册到BeanFacory中。存储在BeanFactory的一个conCurrentHashMap中。key为beanName,Value就是BeanDefinition元数据。</span><br><span class="line">Spring通过BeanDefinationReader将配置元信息加载到内存生成相应的BeanDefination之后，就将其注册到BeanDefinationRegistry中，BeanDefinationRegistry就是一个存放BeanDefination的大篮子，它也是一种键值对的形式，通过特定的Bean定义的id，映射到相应的BeanDefination</span><br></pre></td></tr></table></figure><p><strong>接着会遍历这个beanDefinitionMap，执行BeanFactoryPostProcessor这个Bean工厂后置处理器的逻辑，比如替换<code>$</code>占位符</strong></p><p><img src="https://img-blog.csdnimg.cn/690f5df98811421ab1dc6e1495375d71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ0Nxd2Fz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h2 id="三、refresh-容器刷新流程-最重要"><a href="#三、refresh-容器刷新流程-最重要" class="headerlink" title="三、refresh()容器刷新流程(最重要)"></a>三、refresh()容器刷新流程(最重要)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、prepareRefresh()刷新前的预处理：</span><br><span class="line"></span><br><span class="line">（1）initPropertySources()：初始化一些属性设置，子类自定义个性化的属性设置方法；</span><br><span class="line">（2）getEnvironment().validateRequiredProperties()：检验属性的合法性</span><br><span class="line">（3）earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;()：保存容器中的一些早期的事件；</span><br><span class="line">2、obtainFreshBeanFactory()：获取在容器初始化时创建的BeanFactory：</span><br><span class="line"></span><br><span class="line">（1）refreshBeanFactory()：刷新BeanFactory，设置序列化ID；</span><br><span class="line">（2）getBeanFactory()：返回初始化中的GenericApplicationContext创建的BeanFactory对象，即【DefaultListableBeanFactory】类型</span><br><span class="line">3、prepareBeanFactory(beanFactory)：BeanFactory的预处理工作，向容器中添加一些组件：</span><br><span class="line"></span><br><span class="line">（1）设置BeanFactory的类加载器、设置表达式解析器等等</span><br><span class="line">（2）添加BeanPostProcessor【ApplicationContextAwareProcessor】</span><br><span class="line">（3）设置忽略自动装配的接口：EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware；</span><br><span class="line">（4）注册可以解析的自动装配类，即可以在任意组件中通过注解自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext</span><br><span class="line">（5）添加BeanPostProcessor【ApplicationListenerDetector】</span><br><span class="line">（6）添加编译时的AspectJ；</span><br><span class="line">（7）给BeanFactory中注册的3个组件：environment【ConfigurableEnvironment】、systemProperties【Map&lt;String, Object&gt;】、systemEnvironment【Map&lt;String, Object&gt;】</span><br><span class="line">4、postProcessBeanFactory(beanFactory)：子类重写该方法，可以实现在BeanFactory创建并预处理完成以后做进一步的设置</span><br><span class="line"></span><br><span class="line">5、invokeBeanFactoryPostProcessors(beanFactory)：在BeanFactory标准初始化之后执行BeanFactoryPostProcessor的方法，即BeanFactory的后置处理器：</span><br><span class="line"></span><br><span class="line">（1）先执行BeanDefinitionRegistryPostProcessor： postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class="line"></span><br><span class="line">① 获取所有的实现了BeanDefinitionRegistryPostProcessor接口类型的集合</span><br><span class="line">② 先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor</span><br><span class="line">③ 再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor</span><br><span class="line">④ 最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors        </span><br><span class="line">（2）再执行BeanFactoryPostProcessor的方法：postProcessor.postProcessBeanFactory(beanFactory)</span><br><span class="line"></span><br><span class="line">① 获取所有的实现了BeanFactoryPostProcessor接口类型的集合</span><br><span class="line">② 先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor</span><br><span class="line">③ 再执行实现了Ordered顺序接口的BeanFactoryPostProcessor</span><br><span class="line">④ 最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor</span><br><span class="line">6、registerBeanPostProcessors(beanFactory)：向容器中注册Bean的后置处理器BeanPostProcessor，它的主要作用是干预Spring初始化bean的流程，从而完成代理、自动注入、循环依赖等功能</span><br><span class="line"></span><br><span class="line">（1）获取所有实现了BeanPostProcessor接口类型的集合：</span><br><span class="line">（2）先注册实现了PriorityOrdered优先级接口的BeanPostProcessor；</span><br><span class="line">（3）再注册实现了Ordered优先级接口的BeanPostProcessor；</span><br><span class="line">（4）最后注册没有实现任何优先级接口的BeanPostProcessor；</span><br><span class="line">（5）最r终注册MergedBeanDefinitionPostProcessor类型的BeanPostProcessor：beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">（6）给容器注册一个ApplicationListenerDetector：用于在Bean创建完成后检查是否是ApplicationListener，如果是，就把Bean放到容器中保存起来：applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">此时容器中默认有6个默认的BeanProcessor(无任何代理模式下)：【ApplicationContextAwareProcessor】、【ConfigurationClassPostProcessorsAwareBeanPostProcessor】、【PostProcessorRegistrationDelegate】、【CommonAnnotationBeanPostProcessor】、【AutowiredAnnotationBeanPostProcessor】、【ApplicationListenerDetector】</span><br><span class="line"></span><br><span class="line">7、initMessageSource()：初始化MessageSource组件，主要用于做国际化功能，消息绑定与消息解析：</span><br><span class="line"></span><br><span class="line">（1）看BeanFactory容器中是否有id为messageSource 并且类型是MessageSource的组件：如果有，直接赋值给messageSource；如果没有，则创建一个DelegatingMessageSource；</span><br><span class="line">（2）把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource；</span><br><span class="line">8、initApplicationEventMulticaster()：初始化事件派发器，在注册监听器时会用到：</span><br><span class="line"></span><br><span class="line">（1）看BeanFactory容器中是否存在自定义的ApplicationEventMulticaster：如果有，直接从容器中获取；如果没有，则创建一个SimpleApplicationEventMulticaster</span><br><span class="line">（2）将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件就可以直接自动注入</span><br><span class="line">9、onRefresh()：留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑</span><br><span class="line"></span><br><span class="line">10、registerListeners()：注册监听器：将容器中所有的ApplicationListener注册到事件派发器中，并派发之前步骤产生的事件：</span><br><span class="line"></span><br><span class="line"> （1）从容器中拿到所有的ApplicationListener</span><br><span class="line">（2）将每个监听器添加到事件派发器中：getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">（3）派发之前步骤产生的事件applicationEvents：getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">11、finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；</span><br><span class="line"></span><br><span class="line">（1）获取容器中的所有beanDefinitionName，依次进行初始化和创建对象</span><br><span class="line">（2）获取Bean的定义信息RootBeanDefinition，它表示自己的BeanDefinition和可能存在父类的BeanDefinition合并后的对象</span><br><span class="line">（3）如果Bean满足这三个条件：非抽象的，单实例，非懒加载，则执行单例Bean创建流程：    </span><br><span class="line">（4）所有Bean都利用getBean()创建完成以后，检查所有的Bean是否为SmartInitializingSingleton接口的，如果是；就执行afterSingletonsInstantiated()；</span><br><span class="line">12、finishRefresh()：发布BeanFactory容器刷新完成事件：</span><br><span class="line"></span><br><span class="line">（1）initLifecycleProcessor()：初始化和生命周期有关的后置处理器：默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】，如果没有，则创建一个DefaultLifecycleProcessor()加入到容器；</span><br><span class="line">（2）getLifecycleProcessor().onRefresh()：拿到前面定义的生命周期处理器（LifecycleProcessor）回调onRefresh()方法</span><br><span class="line">（3）publishEvent(new ContextRefreshedEvent(this))：发布容器刷新完成事件；</span><br><span class="line">（4）liveBeansView.registerApplicationContext(this);</span><br></pre></td></tr></table></figure><p>可以看到这个方法里面调用了很多的方法，我们从开始说起：</p><ul><li><p>首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；</p></li><li><p>接着往下看prepareRefresh();这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。</p></li><li><p>下一步ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();这个就很重要了，这一步是把配置文件解析成一个个BeanDefinition，并且注册到BeanFactory中，注意**<u>这里只是注册进去，并没有实例化</u>**。先继续往下看，等会展开这个方法详细解读</p></li><li><p>然后是prepareBeanFactory(beanFactory);这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看</p></li><li><p>postProcessBeanFactory(beanFactory);<strong><u>方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。</u></strong></p></li><li><p>接下来是invokeBeanFactoryPostProcessors(beanFactory);<u><strong>这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</strong></u></p></li><li><p>然后是registerBeanPostProcessors(beanFactory);这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。然后回到refresh()方法中继续往下看</p></li><li><p>initMessageSource();方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下</p></li><li><p>initApplicationEventMulticaster();方法初始化当前 ApplicationContext 的事件广播器继续往下</p></li><li><p>onRefresh();<u>方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下</u></p></li><li><p>registerListeners();方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下</p></li><li><h5 id="重点到了：finishBeanFactoryInitialization-beanFactory-初始化所有的-singleton-beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说"><a href="#重点到了：finishBeanFactoryInitialization-beanFactory-初始化所有的-singleton-beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说" class="headerlink" title="重点到了：finishBeanFactoryInitialization(beanFactory);初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说"></a>重点到了：finishBeanFactoryInitialization(beanFactory);<u>初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说</u></h5></li><li><p>finishRefresh();方法是最后一步，广播事件，ApplicationContext 初始化完成</p></li></ul><h3 id="我们重点来看ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory-和finishBeanFactoryInitialization-beanFactory-这两个方法"><a href="#我们重点来看ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory-和finishBeanFactoryInitialization-beanFactory-这两个方法" class="headerlink" title="我们重点来看ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();和finishBeanFactoryInitialization(beanFactory);这两个方法"></a>我们重点来看<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code>和<code>finishBeanFactoryInitialization(beanFactory);</code>这两个方法</h3><p>先说<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</code>; 这一步上面简单介绍过了，作用是把配置文件解析成一个个BeanBeanDefinition，并且注册到BeanFactory中，点进去源码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">return beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法中第一步refreshBeanFactory();方法的作用是关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等，然后getBeanFactory();就是返回刚刚创建的 BeanFactory(其实就是DefaultListableBeanFactory)，我们进入refreshBeanFactory();方法，在AbstractRefreshableApplicationContext类中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">if (hasBeanFactory()) &#123;</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line">synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">this.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException ex) &#123;</span><br><span class="line">throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个refreshBeanFactory()方法首先如果 ApplicationContext 中已经加载过 BeanFactory<br>了，销毁所有 Bean，关闭 BeanFactory；这里指的是当前ApplicationContext 是否有 BeanFactory。<br>然后createBeanFactory();初始化一个DefaultListableBeanFactory，这个DefaultListableBeanFactory是很重的一个类，为什么重要呢？可以看文章开头的BeanFactory继承图，DefaultListableBeanFactory是位于最下面的，他往上能走完BeanFactory继承图所有，所以他可以说是功能最大的BeanFactory。<br>beanFactory.setSerializationId(getId());方法用于 BeanFactory 的序列化<br>customizeBeanFactory(beanFactory);方法设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用，这个等会细说<br>loadBeanDefinitions(beanFactory);这个方法很重要：加载 Bean定义 到 BeanFactory 中，也是等会细说<br>下面看customizeBeanFactory(beanFactory);方法，这个方法作用：是否允许 Bean 覆盖、是否允许循环引用，这是什么意思呢？这就要说到BeanDefinition了，这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中，下面贴出来开头我说的大神的关于BeanDefinition接口的代码注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">AttributeAccessor</span>, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们可以看到，默认只提供 sington 和 prototype 两种，</span></span><br><span class="line">   <span class="comment">// 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span></span><br><span class="line">   <span class="comment">// 不过，它们属于基于 web 的扩展。</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 比较不重要，直接跳过吧</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_APPLICATION</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_SUPPORT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_INFRASTRUCTURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span></span><br><span class="line">   <span class="comment">// 一句话就是：继承父 Bean 的配置信息而已</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setParentName</span><span class="params">(String parentName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取父 Bean</span></span><br><span class="line">   String <span class="title function_">getParentName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setBeanClassName</span><span class="params">(String beanClassName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取 Bean 的类名称</span></span><br><span class="line">   String <span class="title function_">getBeanClassName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 bean 的 scope</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(String scope)</span>;</span><br><span class="line"></span><br><span class="line">   String <span class="title function_">getScope</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setLazyInit</span><span class="params">(<span class="type">boolean</span> lazyInit)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isLazyInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span></span><br><span class="line">   <span class="comment">// 是 depends-on=&quot;&quot; 属性设置的值。</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setDependsOn</span><span class="params">(String... dependsOn)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该 Bean 的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span></span><br><span class="line">   <span class="comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setAutowireCandidate</span><span class="params">(<span class="type">boolean</span> autowireCandidate)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 是否可以注入到其他 Bean 中</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAutowireCandidate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setPrimary</span><span class="params">(<span class="type">boolean</span> primary)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是 primary 的</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrimary</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span></span><br><span class="line">   <span class="comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   String <span class="title function_">getFactoryBeanName</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的 工厂方法名称</span></span><br><span class="line">   String <span class="title function_">getFactoryMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   ConstructorArgumentValues <span class="title function_">getConstructorArgumentValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   MutablePropertyValues <span class="title function_">getPropertyValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span></span><br><span class="line">   <span class="comment">// 常用于作为 父bean 用于继承，其实也很少用......</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAbstract</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getRole</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getResourceDescription</span><span class="params">()</span>;</span><br><span class="line">   BeanDefinition <span class="title function_">getOriginatingBeanDefinition</span><span class="params">()</span>;</span><br><span class="line">&#125;BeanDefinition 的覆盖问题就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 <span class="literal">null</span>，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</span><br><span class="line">循环引用：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</span><br><span class="line">默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</span><br></pre></td></tr></table></figure><p>再看loadBeanDefinitions(beanFactory) 方法，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。先贴上源码：AbstractXmlApplicationContext类中</p><pre><code>@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;    // Create a new XmlBeanDefinitionReader for the given BeanFactory.    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);  // Configure the bean definition reader with this context&#39;s  // resource loading environment.  beanDefinitionReader.setEnvironment(this.getEnvironment());  beanDefinitionReader.setResourceLoader(this);  beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));  // Allow a subclass to provide custom initialization of the reader,  // then proceed with actually loading the bean definitions.  initBeanDefinitionReader(beanDefinitionReader);  loadBeanDefinitions(beanDefinitionReader);</code></pre><p>}<br>这个源码中我们重点看loadBeanDefinitions(beanDefinitionReader);，再点进去源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">Resource[] configResources = getConfigResources();</span><br><span class="line"><span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configResources);</span><br><span class="line">&#125;</span><br><span class="line">String[] configLocations = getConfigLocations();</span><br><span class="line"><span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configLocations);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段源码中我么可以看到2个reader.loadBeanDefinitions()方法，其实两个最终都到了：AbstractBeanDefinitionReader类中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">counter += loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里面，for循环每一个文件是一个resource，最终返回 counter，表示总共加载了多少的 BeanDefinition。<br>进入loadBeanDefinitions(resource);方法，看源码：<br>XmlBeanDefinitionReader类中的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">&#125;</span><br><span class="line">  Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">  <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">    currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">        <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">      <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">        inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">        <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中可以看到try代码块中一开始是根据外层循环调用的每一个Resource解析成一个InputStream 然后根据这个输入流解析；<br>这段源码的核心在doLoadBeanDefinitions(inputSource, encodedResource.getResource());继续进源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line"><span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line"><span class="string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="string">&quot; in XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line"><span class="string">&quot;XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line"><span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line"><span class="string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line"><span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法里面可以看到doLoadDocument(inputSource, resource);方法是将 xml 文件(输入流和Resource)转换为 Document 对象，然后继续进源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"><span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个BeanDefinitionDocumentReader，然后spring通过BeanDefinitionDocumentReader 会进行委托bean定义的创建；<br>继续这个方法里面看：documentReader.registerBeanDefinitions(doc, createReaderContext(resource));点进去：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line"><span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的doRegisterBeanDefinitions(root);方法就是从 xml 根节点开始解析文件，经过很多的步骤，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，可以看到上面有个 for 循环的(loadBeanDefinitions(resource);是在for循环里面的)，进入doRegisterBeanDefinitions(root);方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line"><span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line"><span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line"><span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line"><span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line"><span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line"><span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line"><span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line"><span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">          profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">          logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">              <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">  postProcessXml(root);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中可以看到BeanDefinitionDocumentReader最终是创建了一个BeanDefinitionParserDelegate ，把bean定义的创建委托给了BeanDefinitionParserDelegate 进行创建，这就是委托模式的提现。<br>同时也可以看到这段代码中先把this.delegate给了一个parent，然后又创建了一个Delegate，然后执行最后又把这个parent给回去了this.delegate，这是为了处理<beans>标签嵌套<beans>的问题，其实是个类似递归的操作。这里大家可以debugger试试嵌套的情况就明白了。</p><h5 id="再看preProcessXml-root-，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式-模板方法模式不了解的可以看我的这篇文章-，同理postProcessXml-root-也一样，就是在Bean定义创建前后提供扩展点。"><a href="#再看preProcessXml-root-，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式-模板方法模式不了解的可以看我的这篇文章-，同理postProcessXml-root-也一样，就是在Bean定义创建前后提供扩展点。" class="headerlink" title="再看preProcessXml(root)，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式(模板方法模式不了解的可以看我的这篇文章)，同理postProcessXml(root)也一样，就是在Bean定义创建前后提供扩展点。"></a>再看preProcessXml(root)，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式(模板方法模式不了解的可以看我的这篇文章)，同理postProcessXml(root)也一样，就是在Bean定义创建前后提供扩展点。</h5><p>那继续进入parseBeanDefinitions(root, this.delegate);看重点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line"><span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是循环解析Element 的每一个节点，一般我们的普通bean都是走parseDefaultElement(ele, delegate);默认的解析流程。<br>但是这里有个else的自定义解析，这个很多人都忽略了，其实如果我们xml的配置文件中定义了<a href="aop:config">aop:config</a> 标签，他就会走这个自定义解析，然后解析aop内容，后续会在分析AOP源码，可以看这篇文章)说<a href="aop:config">aop:config</a>的时候讲这里。<br>这里我们还是走普通的beand解析逻辑parseDefaultElement(ele, delegate)，跟进去看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// recurse</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法见名知意，解析默认的Element，是4个if分支，第一个是解析import类型的，第二个是alias的，第三个是bean的(也就是我们普通bean默认的)，第四个是beans，也就是嵌套的(这里这个嵌套的就回到上面doRegisterBeanDefinitions方法了，也就是为什么说上面其实类似递归的原因)<br>这里我们只分析普通bean的解析处理，进入processBeanDefinition(ele, delegate);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register the final decorated instance.</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send registration event.</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码首先通过delegate创建一个bean定义的持有者BeanDefinitionHolder，<strong>这一步其实BeanDefinition也在里面已经创建出来了</strong>。进入delegate.parseBeanDefinitionElement(ele)看</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line"><span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"><span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"><span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line"><span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line"><span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line"><span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">!<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">aliases.add(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line"><span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">error(ex.getMessage(), ele);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这段代码中有一个parseBeanDefinitionElement(ele, beanName, containingBean)，<strong>返回了一个AbstractBeanDefinition，这个方法里面实际是创建了一个GenericBeanDefinition</strong>，这里就不跟进去看了，代码篇幅太长了，这个里面很简单没啥绕的逻辑，大家跟着点点就能看到了。创建完GenericBeanDefinition之后设置了Class属性、构造器等等一些创建Bean实例需要的东西之后就返回了。</p><p>然后回到processBeanDefinition(ele, delegate);看BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());，由于这个时候<strong>已经创建了BeanDefinition</strong>并且有持有者BeanDefinitionHolder进行注册，所以继续跟进</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line"><span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">      <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显继续跟进到registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());，这里是一个接口调用，肯定是到了DefaultListableBeanFactory，但是在这个接口调用时我们需要注意的是第二个参数，从BeanDefinitionHolder中获取到了BeanDefinition对象，这个就是创建Bean定义持有者的时候顺带获取的BeanDefinition，通过上面的解析我们知道这个时候BeanDefinition已经创建好了，然后跟进这个方法进去：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line"><span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line"><span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line"><span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line"><span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Still in startup registration phase</span></span><br><span class="line"><span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (existingDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">clearByTypeCache();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法里面就可以看到经过一系列验证等等操作，最后把BeanDefinition放入了beanDefinitionMap，到这里bean定义就完成并注册到org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap里面了</p><p>然后我们回到refresh() 方法，就是文章前部分的那个refresh() 方法…TvT<br>再贴一下refresh() 方法的源码吧，方便阅读：<br>我直接贴大神带注释的代码吧，看起来更方便一点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">   <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">  prepareRefresh();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">  <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">  <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">  <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">  <span class="comment">// 这块待会会展开说</span></span><br><span class="line">  prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">     <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">     <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">     postProcessBeanFactory(beanFactory);</span><br><span class="line">     <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span></span><br><span class="line">     invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">     <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">     <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span></span><br><span class="line">     registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">     initMessageSource();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">     initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span></span><br><span class="line">     <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">     onRefresh();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">     registerListeners();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 重点，重点，重点</span></span><br><span class="line">     <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">     <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">     finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span></span><br><span class="line">     finishRefresh();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">     <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">              <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">     <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">     destroyBeans();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">     cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 把异常往外抛</span></span><br><span class="line">     <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">     <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">     resetCommonCaches();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="到此为止，ConfigurableListableBeanFactory-beanFactory-x3D-obtainFreshBeanFactory-结束"><a href="#到此为止，ConfigurableListableBeanFactory-beanFactory-x3D-obtainFreshBeanFactory-结束" class="headerlink" title="到此为止，ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();结束"></a>到此为止，ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();结束</h4><hr><h3 id="下面我们来看finishBeanFactoryInitialization-beanFactory"><a href="#下面我们来看finishBeanFactoryInitialization-beanFactory" class="headerlink" title="下面我们来看finishBeanFactoryInitialization(beanFactory)"></a>下面我们来看finishBeanFactoryInitialization(beanFactory)</h3><p>到这一步为止BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些<strong>特殊的 Bean，如 ‘environment’、‘systemProperties’ 等</strong>。剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。点进去看源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">  <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">  <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在这段代码中：首先初始化名字为 “conversionService” 的 Bean，为什么是conversionService 呢？原因是注册这个bean之后，类似于前端传给后端的非基础类型和基础类型的包装类之外，其他的就可以考虑采用ConversionService来进行类型等的转换，初始化这个 “conversionService” 实在上面源码中的beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));进行的。然后直接跳过来到beanFactory.preInstantiateSingletons();这个方法，这里开始初始化。点进去：<br>DefaultListableBeanFactory这个类中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">  <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="type">boolean</span> isEagerInit;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li><p>迭代所有的BeanDefinitionNames集合，挨个初始化所有非懒加载的单例类。</p></li><li><p>BeanDefinitionNames是在注册BeanDefinitionMap时同时注册的集合。该集合，主要用在<strong>这里</strong>进行迭代初始化Spring Bean，并且也方便一些类似获取BeanDefinitionName的方法使用。</p></li><li><p>初始化的时候还对FactoryBean进行判断，因为默认FactoryBean默认是惰性初始化，如果实现SmartFactoryBean设置isEagerInit为true，则代表该类需要急切的进行初始化，会即刻开始初始化FactoryBean里getObject返回的类。</p></li><li><p>关于getMergedLocalBeanDefinition和getBean：Spring通过getBean来完成类的初始化并添加到Spring容器内（即Spring的一级缓存：单例池里面），而在初始化时需要当前类的相关信息：即BeanDefinition，而BeanDefinition是可以存在父子关系（并非真的继承，而是BeanDefinition可以设置父BeanDefinition），所以Spring通过getMergedLocalBeanDefinition来获取当前类的完整信息。</p></li></ol><p>getBean-》doGetBean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">// 1.转换beanName，主要处理别名、以&amp;开头的name</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.尝试从单例缓存中获取bean实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line"><span class="comment">// 3. 获取bean实例</span></span><br><span class="line"><span class="comment">// 3.1 缓存中已存在bean实例</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 省略日志输出代码...</span></span><br><span class="line"><span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 省略父工厂处理相关代码...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 省略dependsOn相关代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2 创建单例bean</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.3 创建原型bean实例</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.4 根据scope创建bean实例</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="comment">// 省略异常处理代码...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略其他代码.</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>}</p><p><strong>在可以看到上面有四种情况：缓存中存在bean实例、创建单例bean、创建原型bean、根据scope创建bean，都调用了getObjectForBeanInstance()方法，接下来我们就点进去看看。</strong></p><p><em><strong>getObjectForBeanInstance是从bean实例中获取对象（本章重点，获取实例中的对象）</strong></em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 如果是工厂引用(即name以&amp;开头)，但该实例又不是FactoryBean类型，则抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果该实例不是FactoryBean类型，或者是工厂引用都直接返回该实例</span></span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 尝试从缓存中加载bean</span></span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 把初始bean实例强转为FactoryBean</span></span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line"><span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否是用户自定义的beanDefinition(默认是false)</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line"><span class="comment">// 重点方法，跟进去</span></span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>从FactoryBean中获取对象：getObjectFromFactoryBean()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;</span><br><span class="line"><span class="comment">// 1. 单例模式</span></span><br><span class="line"><span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 真正获取对象的方法(重点方法)</span></span><br><span class="line">object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line"><span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;</span><br><span class="line">object = alreadyThere;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 调用bean的后置处理器(有兴趣的可以点进去看下，后面的章节会单独讲述)</span></span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 2. 原型模式</span></span><br><span class="line"><span class="comment">// 真正获取对象的方法(重点方法)</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>真正从FactoryBean中获取对象的逻辑：doGetObjectFromFactoryBean()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">Object object;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 权限验证</span></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> getAccessControlContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 终于看到你了！</span></span><br><span class="line">object = factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName, ex.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not accept a null value for a FactoryBean that&#x27;s not fully</span></span><br><span class="line"><span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line"><span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(</span><br><span class="line">beanName, <span class="string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">object = <span class="keyword">new</span> <span class="title class_">NullBean</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终发现其实获取对象的方法，就是一行调用FactoryBean的getObject()方法。</p><h4 id="在上面的方法中有个bean的实例化过程我们必须知道"><a href="#在上面的方法中有个bean的实例化过程我们必须知道" class="headerlink" title="在上面的方法中有个bean的实例化过程我们必须知道"></a>在上面的方法中有个bean的实例化过程我们必须知道</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//推断当前Beandefinition的beanClass</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 准备方法重写 包括lookup-method和replaced-method的处理，本文暂不展开</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 第一次调用后置处理器：初始化Bean之前，InstantiationAwareBeanPostProcessor,</span></span><br><span class="line">      <span class="comment">// 根据BeanDefinition获取到了对应的class类</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//创建Bean</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">      <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">      <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>}</p><p>docreatebean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">//从未完成的 FactoryBean 实例中移除</span></span><br><span class="line">instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//实例化对象(仅仅是生成对象，并非添加到spring单例池中，即目前并没有成为Spring Bean)，</span></span><br><span class="line"><span class="comment">//并且第二次调用 后置处理器 determineConstructorsFromBeanPostProcessors</span></span><br><span class="line"> instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> ... </span><br><span class="line">     ...  </span><br><span class="line">     ...   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先通过createBeanInstance方法调用后置处理器推断其构造函数，并反射创建BeanDefinition对应的实例。<strong>实例化 Bean</strong></p><p><strong>注意此时只是创建了类对象，但还没有添加到Spring的单例池中，即还没有加入到Spring容器内部。</strong><br><strong>可以理解为此时只是完成了类对象的声明：即类似于A a&#x3D;null</strong></p><p>添加到Spring的单例池是在getSingleton（）的addSingleton中。</p><p><a href="https://blog.csdn.net/qq_38289451/article/details/121965628">https://blog.csdn.net/qq_38289451/article/details/121965628</a></p><p>createBeanInstance() 方法是 spring 实例化 bean 的核心代码，它根据不同的情况会调用四种实例化方法</p><ul><li>obtainFromSupplier() ：通过 Supplier 实例化</li><li>instantiateUsingFactoryMethod()：通过工厂方法实例化</li><li>autowireConstructor()：用合适的构造函数实例化</li><li>instantiateBean()：用无参构造函数实例化</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;</span><br><span class="line">    </span><br><span class="line">// 确认需要创建的bean实例的类可以实例化</span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">// 确保class不为空，并且访问权限是public</span><br><span class="line">if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot; + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ----------1，通过Supplier实例化------------</span><br><span class="line"> */</span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">if (instanceSupplier != null) &#123;</span><br><span class="line">return obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">/**</span><br><span class="line"> * ----------2，通过工厂方法实例化------------</span><br><span class="line"> */</span><br><span class="line">if (mbd.getFactoryMethodName() != null) &#123;</span><br><span class="line">return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> * ----------3，用合适的构造函数实例化------------</span><br><span class="line"> *</span><br><span class="line"> *  一个类可能有多个构造器，所以Spring得根据参数个数、类型确定需要调用的构造器。</span><br><span class="line"> *  在使用构造器创建实例后，Spring会将解析过后确定下来的构造器或工厂方法保存在缓存中，</span><br><span class="line"> *  避免再次创建相同bean时再次解析</span><br><span class="line"> */</span><br><span class="line">// 标记下，防止重复创建同一个bean</span><br><span class="line">boolean resolved = false;</span><br><span class="line">// 是否需要自动装配，构造有参数的需要</span><br><span class="line">boolean autowireNecessary = false;</span><br><span class="line">// 如果没有参数</span><br><span class="line">if (args == null) &#123;</span><br><span class="line">synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">// 一个类中有多个构造函数，每个构造函数都有不同的参数，所以调用前需要先根据参数锁定构造函数或对应的工厂方法</span><br><span class="line">if (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class="line">resolved = true;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 有构造参数的或者工厂方法</span><br><span class="line">if (resolved) &#123;</span><br><span class="line">// 构造器有参数</span><br><span class="line">if (autowireNecessary) &#123;</span><br><span class="line">// 构造函数自动注入</span><br><span class="line">return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// 使用默认构造函数构造</span><br><span class="line">return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从bean后置处理器中为自动装配寻找构造方法</span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 找出最合适的默认构造方法</span><br><span class="line">ctors = mbd.getPreferredConstructors();</span><br><span class="line">if (ctors != null) &#123;</span><br><span class="line">// 构造函数自动注入</span><br><span class="line">return autowireConstructor(beanName, mbd, ctors, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> * ----------4，使用默认构造函数构造------------</span><br><span class="line"> */</span><br><span class="line">return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="新增ObjectFactory到第三级缓存"><a href="#新增ObjectFactory到第三级缓存" class="headerlink" title="新增ObjectFactory到第三级缓存"></a>新增ObjectFactory到第三级缓存</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">    throws BeanCreationException &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        //允许后置处理器重新定义beanDefinition</span><br><span class="line">synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">if (!mbd.postProcessed) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//第三次调用后置处理器 MergedBeanDefinitionPostProcessors</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否允许循环依赖，默认是允许的，可以通过代码修改的一般只有allowCircularReferences的值</span><br><span class="line">boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">if (earlySingletonExposure) &#123;</span><br><span class="line">if (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">&quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// getEarlyBeanReference里面包含了又一次后置处理器的调用，SmartInstantiationAwareBeanPostProcessor </span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="属性填充：populateBean"><a href="#属性填充：populateBean" class="headerlink" title="属性填充：populateBean"></a>属性填充：populateBean</h4><p>然后做一些处理比如循环依赖等，直到看到populateBean(beanName, mbd, instanceWrapper);这个代码，这一步负责属性装配，很重要，因为前面的实例只是实例化了，并没有设值，这里就是设值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//填充属性（即自动注入） 完成第五次和第六次后置处理器的调用</span></span><br><span class="line">        <span class="comment">// InstantiationAwareBeanPostProcessor.after</span></span><br><span class="line">        <span class="comment">// hasInstantiationAwareBeanPostProcessors</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">//完成第七次和第八次后置处理器的调用，</span></span><br><span class="line">        <span class="comment">//判断当前Bean，是否是BeanNameAware、BeanClassLoaderAware、BeanFactoryAware并分别设置相关内容</span></span><br><span class="line">        <span class="comment">//applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line">        <span class="comment">//applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">populateBean方法完成属性填充，跟进</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在设置属性之前，让任何 InstantiationAwareBeanPostProcessors 有机会修改 bean 的状态。例如，这可用于支持字段注入样式。</span></span><br><span class="line">  <span class="comment">//扩展点，又一次调用后置处理器，</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果后置处理器修改了Beandefinition，则判断是否已经修改过了属性值的相关配置</span></span><br><span class="line">   <span class="comment">//如果修改了，则按照器byName或byType的方式直接完成装载</span></span><br><span class="line">   <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">      <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   [] filteredPds = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">         pvs = mbd.getPropertyValues();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">//利用后置处理器，处理属性的获取</span></span><br><span class="line">            <span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">                  filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">               &#125;</span><br><span class="line">               pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">      <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">         filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      &#125;</span><br><span class="line">      checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//根据PropertyValues完成属性填充</span></span><br><span class="line">      applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>populateBean里面再次调用后置处理器，spring在这里提供了一个扩展点，允许开发者在属性填充这个阶段修改Bean的状态（使用后置处理器的方式）。并且可能直接依据byName和byType装载属性值。</p><p>我们知道，使用自动装载这一功能时，我们可以使用@Autowired和@Resource。这两个注解的功能也不一样。那么解析的方式也应当不一样。</p><h3 id="factorybean和beanfactory"><a href="#factorybean和beanfactory" class="headerlink" title="factorybean和beanfactory"></a>factorybean和beanfactory</h3><p>在我们的开发工作中应该都见过或使用过FactoryBean这个类，也许你会看成了BeanFactory这个类。FactoryBean和BeanFactory虽然长的很像，但是他们的作用确实完全不像。这里你可以想象一下，你会在什么样的场景下使用FactoryBean这个接口？FactoryBean是一个工厂Bean，可以生成某一个类型Bean实例，它最大的一个作用是：可以让我们自定义Bean的创建过程。BeanFactory是Spring容器中的一个基本类也是很重要的一个类，在BeanFactory中可以创建和管理Spring容器中的Bean，它对于Bean的创建有一个统一的流程。下面我们先看一下FactoryBean中有什么东西：</p><p>背景<br>假设我们有这种需求，像Mybaits需要将这些接口注入到Spring容器中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface OneTestDao &#123;</span><br><span class="line">    @Select(&quot;SELECT name FROM user WHERE id = 1&quot;)</span><br><span class="line">    String query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface TwoTestDao &#123;</span><br><span class="line">    @Select(&quot;SELECT name FROM user WHERE id = 2&quot;)</span><br><span class="line">    String query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先我们想将我们的自己的Bean(比如代理对象)注入到Spring容器中，有什么方式呢？</p><p>一般都是通过Spring扫描Resouce资源然后解析为BeanDefinition，才能从getBean时解析BeanDefinition实例化对象放入此单例缓存中.但是我们这里的是接口，没法直接注入到Spring容器中。</p><p>不过Spring提供了一些扩展接口来供我们在Bean加载、初始化、加载完提供了一些接口，供我们扩展。<br>比如BeanFactoryPostProcessor</p><p>从测试结果中得知，我们虽然配置的是<code>MapperFactoryBean</code>的实列，但是根据id拿到的是<code>getObject</code>方法创建的对象。其实在容器中创建的对象仍然是<code>MapperFactoryBean</code>的实列，只是在获取的时候会判断这个结果对象是不是派生于<code>FactoryBean</code>，如果是的话则返回<code>getObject</code>方法创建的对象，并且这个对象并不是容器初始化时创建的，而是使用<code>context.getBean()</code>方法时才创建。当然了，如果你确实想要获取<code>FactoryBean</code>实例，你需要这样写: <em><code>MapperFactoryBean mapper = context.getBean(&quot;&amp;mapper&quot;, MapperFactoryBean.class);</code></em> 只需要在bean的名字ID前加上&amp;符号。</p><p>非常重要：想知道factory流程，请结合</p><p><a href="https://blog.csdn.net/weixin_30881367/article/details/98567729?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mapperfactorybean%E7%9A%84%E4%BD%9C%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-98567729.nonecase&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_30881367/article/details/98567729?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mapperfactorybean%E7%9A%84%E4%BD%9C%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-98567729.nonecase&amp;spm=1018.2226.3001.4187</a></p><p><a href="https://blog.csdn.net/Roger_CX/article/details/120739214?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168111515116800192294702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168111515116800192294702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-120739214-null-null.142%5Ev82%5Ekoosearch_v1,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=FactoryBean%E4%BD%9C%E7%94%A8&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/Roger_CX/article/details/120739214?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168111515116800192294702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168111515116800192294702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-120739214-null-null.142^v82^koosearch_v1,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=FactoryBean%E4%BD%9C%E7%94%A8&amp;spm=1018.2226.3001.4187</a></p><p><strong>FactoryBean是一个能生产或修饰对象生成的工厂Bean</strong>。一个Bean如果实现了FactoryBean接口，那么<strong>根据该Bean的名称获取到的实际上是getObject返回的对象</strong>，而不是这个Bean自身实例，如果<strong>要获取这个Bean自身实例，那么需要在名称前面加上’&amp;’符号</strong>。</p><p>创建bean的两种方式：</p><p>第一种，单例在Spring容器初始化之前， 就已经创建了bean，且整个应用只有一个。</p><p>第二种，多例在用到对象的时候，才创建对象，当我们在A类中需要用到B类时，通过@Autowired注解注入用到时。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring勇攀高峰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待定</title>
      <link href="/2023/04/04/new%20page/"/>
      <url>/2023/04/04/new%20page/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> new </category>
          
      </categories>
      
      
        <tags>
            
            <tag> new </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>章节：10</title>
      <link href="/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A10/"/>
      <url>/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A10/</url>
      
        <content type="html"><![CDATA[<p>第十节我们可以从注解出发看项目。<br>DBRouter注解写好后，肯定要配备切面类DBRouterJoinPoint（这里面包括了路由策略和路由配置几库几表），里面有一个@Around注解，表示包围一个函数，也就是可以在函数执行前做一些事情，也可以在函数执行后做一些事情。</p><p>项目中是先拿到Key字段（uId），判断是不是空，是的话Runtime异常，不是的话就去拿uId这个字段对应的值，按照例子就是Uhdgkw766120d。</p><p>拿到值之后，那么下面就是拿着这个值去做路由了（该怎么走），这部分内容被写在DBRouterStrategyHashCode的doRouter里面。其实就是hash的扰动函数，通过设定的算法得到去拿个库哪个表，把这两个信息交给DBContextHolder（一个标识类，用来存储当前数据源的key及状态判断），下面就要向数据集里面写东西了，jp.process(),接下去就是mybatis拦截器的任务了。</p><p>自定义拦截器需要实现org.apache.ibatis.plugin.Interceptor接口, 并在接口上添加@Intercepts注解。<br>@Intercepts注解是通过一个@Signature注解(拦截点),来指定拦截那个对象里面的某个方法。<br>@Signature注解需要定义三个东西：</p><p>定义拦截的类 Executor、ParameterHandler、StatementHandler、ResultSetHandler当中的一个<br>Class&lt;?&gt; type();</p><p>在定义拦截类的基础之上，在定义拦截的方法<br>String method();</p><p>在定义拦截方法的基础之上在定义拦截的方法对应的参数，<br>因方法里面可能重载，不指定参数列表，不能确定是对应拦截的方法<br>Class&lt;?&gt;[] args();</p><p>我们查看代码，发现拦截的类选择的是StatementHandler，目前不太了解mybatis的源码，但是查询资料之后发现毫无疑问是四大对象最重要的一个，它的任务就是和数据库对话。在它这里会使用parameterHandler和ResultSetHandler对象为我们绑定SQL参数和组装最后的结果返回。</p><p>拦截的方法是prepare，预编译阶段</p><p>参数是{Connection.class, Integer.class}</p><p>回到那个自定义拦截器类 继承了Interceptor。intercept里面就放着怎么把sql变成我们想要的那种动态分库分表的逻辑。<br>首先几行代码拿到dbRouterStrategy注解，看他是不是true<br>如果是，我们去拿sql语句，如下所示：</p><p>INSERT INTO user_strategy_export<br>        (u_id, activity_id, order_id, strategy_id, strategy_mode,<br>         grant_type, grant_date, grant_state, award_id, award_type,<br>         award_name, award_content, uuid, create_time, update_time)<br>        VALUES<br>        (?,?,?,?,?,<br>         ?,?,?,?,?,<br>         ?,?,?,now(),now())</p><p>他利用一个matcher找到 INTO user_strategy_export这段语句。为什么？因为INTO后面跟着的就是表，至于是哪个表，在上面已经提到了，就是DBContextHolder。这里就实现了分表。</p><p>至于分库，我们重写了determineCurrentLookupKey方法，这个方法被determineTargetDataSource调用，determineTargetDataSource被getConnection调用，getConection可以追溯到DataSource接口的getConnection抽象方法。但是我还不知道determineCurrentLookupKey什么时候被调用？？</p><p>所以就去查了查多数据源的处理机制的一些文章，发现和自己想的有区别，我一直以为调用DAO层的方法，应该先切面再切换数据源最后才是DAO的逻辑（毕竟我看不到什么时候切换数据源，但是DBRouter注解就是直勾勾的放在DAO方法上面的），结果文章中提到其实是先切换数据源，然后切面方法，最后DAO逻辑。文章给出的原因是事务中不支持数据源切换。<br>但是我打断点还是没找到调用determineCurrentLookupKey的那段代码，可惜。</p><p>最后就是把这些配置到DataSourceAutoConfig，打包给我们的项目。</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lucky项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>章节：7-10，同时回顾一下4-6的内容</title>
      <link href="/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A7-10%EF%BC%8C%E5%90%8C%E6%97%B6%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8B4-6%E7%9A%84%E5%86%85%E5%AE%B9/"/>
      <url>/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A7-10%EF%BC%8C%E5%90%8C%E6%97%B6%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8B4-6%E7%9A%84%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>7-10，同时回顾一下4-6的内容</p><p>第六节的重点是模版模式。</p><p>模版模式是定义一个算法的骨架，并允许子类为一个或多个步骤提供实现。在第六节中这个算法骨架（抽象模版类）是AbstractDrawBase，这个类中有通用的比如对于抽奖结果的包装，也有抽象方法比如执行抽奖算法（这个在子类中实现）。小傅哥在这个基础上又把一些一些通用的数据服务抽象出新的一层DrawStrategySupport，这个算是一种优化，但是他本质也属于抽象模版类的一部分。</p><p>而我们抽奖则需要抽奖策略（怎么个抽法），这就是第五节的东西—策略模式：</p><p>对象的某个行为，在不同场景中有不同的实现方式，这样就可以将这些实现方式定义成一组策略，每个实现类对应一个策略，在不同的场景就使用不同的实现类，并且可以自由切换策略。</p><p>其实看完第六节会发现第五节和第六节很像，也是抽象出了一个接口和一个抽象模版类，其他的子类继承抽象模版类实现randomDraw（）方法，不同的实现对应不同的算法，具体算法我们自己可以修改逻辑、补充内容等操作。</p><p>在这时候我们发现策略模式和模版模式很像，但是是有一些区别的：</p><p>模板模式：问题处理的流程已经被定义好，父类实现通用的逻辑（当然你也可以再抽象出一层），子类实现个性化逻辑。</p><p>策略模式：父类定义一组抽象算法，子类自己实现自己的。每个策略完成的功能是重复的，同一时间，只能选择其中的一种，即互斥的</p><p>策略模式核心在使用者的策略，按照自己的策略去替换。模板方法模式核心在子类的怎么实现。</p><p>举个例子：</p><p>模版模式： 父类：早上6点吃饭，晚上6点吃面。子类1：早上6点吃稀饭，晚上6点吃泡面。子类2：早上6点吃干饭，晚上6点吃挂面。</p><p>策略模式：父类：早晚进食。子类1:早上5点吃面，晚上5点吃面。子类2:早上7点吃饭，晚上7点吃饭。子类3:早上不吃，晚上不吃…</p><p>第八节：状态模式</p><p>当一个对象的内在状态改变时，允许改变其行为，把不同状态当做一个类，解决对象在多种状态转换时，需要对外输出不同的行为的问题。</p><p>同样的有抽象模版类（AbstractState，当然你要自己提炼一个接口大概也没什么问题），多个具体实现的子类。要有一个Context类，这个类持有State，负责保持并切换当前的状态，当状态变化时，修改这个State。在项目中应该是活动创建的时候初始化状态，后续收到一些通知（比如：快递公司揽件，发送目的地，菜鸟驿站收到快递）修改活动中的状态变量就可以，非常方面。</p><p>第九节：ID生成策略</p><p>也是策略模型，因为目前就一个id生成的要求，也无需什么流程啊，也不涉及什么状态改变，不同情境下使用不同类型的id，所以策略模式最佳。</p><p>第十节：分库分表</p><p>内容多，也是这几天最花时间的，bug奇多，自己不小心把application.yml文件里面的配置写错了，然后报空指针，找不到bean，我还以为自己打包有问题呢；因为自己的版本和傅哥的不太一样，总报一些依赖错误，还有什么commons-lang、commons-beanutils依赖缺失。自己的的项目工程包名是自定义的，和傅哥的cn.itedus.lottery和那个cn.bugstack不一样，中途修改的时候感觉对理解还是有益处的。</p><p>之后再对第十节做一次总结，加深感悟。</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lucky项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>章节：11-13</title>
      <link href="/2023/04/03/%E7%AB%A0%E8%8A%82%EF%BC%9A11-13/"/>
      <url>/2023/04/03/%E7%AB%A0%E8%8A%82%EF%BC%9A11-13/</url>
      
        <content type="html"><![CDATA[<h1 id="11"><a href="#11" class="headerlink" title="11"></a>11</h1><p>如果一个请求，需要对多个表进行修改，那么大概率需要事务，因为也许第一个对表的操作成功了，但是第二个对表的操作失败，那就出问题了。</p><p>Spring支持两种事务管理方式：编程式事务管理以及声明式事务管理。</p><p>编程式事务方式需要是开发者在代码中手动的管理事务的开启、提交、回滚等操作<br>声明式事务管理方法允许开发者配置的帮助下来管理事务，而不需要依赖底层API进行硬编码。声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚</p><p>声明式事务的优点：对代码没有侵入性，方法内只需要写业务逻辑就可以了。<br>声明式事务的缺点：<br>如果在一个事务下，连续操作不同的DAO操作，那么就会涉及到在 DAO 上使用注解 @DBRouter(key &#x3D; “uId”) 反复切换路由的操作。比如你第一个DAO对某个库表操作，第二个DAO对另一个库表操作，这就不行，原因是网上查的不知道对不对：<br>1、Spring@Transactional不支持跨数据源事物，Spring 事务控制是基于数据库链接进行的，当数据源切换后，数据库链接切换，事物回滚只能回退，当前持有的链接<br>2、Spring开启事物后，会将当前数据库及数据库链接资源进行线程绑定，导致数据源切换失效（数据源切换执行后，并未获取到新的数据库链接）</p><p>我们把领取活动提炼成一个模版，这个模版里的流程是有的操作需要同时处理多个数据源加上我们还是分库分表，所以不适用声明式，应该用编程式。<br>spring事务配置总是由DataSource、TransactionManager和代理机制这三部分，new一个TransactionManager然后放入我们自己的DataSource。然后在transactionTemplate里放入新的TransactionManager。到这里基本就配置好了，至于什么路由策略啊这些其实和第十章的没什么区别。</p><p>回顾一下第十章，我们是在DAO上加上注解，配合路由组件中的一系列（数据路由切面），拦截被切面的方法。<br>但是在第十一章中，通用模版类中第四步我们使用了编程式事务，他需要同时对多个表进行操作。但是第一步第二步这种查询工作、校验工作这种对数据库没有修改的操作，小傅哥要么DBRouter要么直接就没加（分库分表）。所以声明式和编程式配合使用也许会更好。</p><h1 id="12"><a href="#12" class="headerlink" title="12"></a>12</h1><p>这章有一个问题就是，傅哥给的sql语句是2021年的，然后你执行test方法会报错，因为里面有一个活动信息校验处理模块，他会去判断你当前的时间是不是在活动期限里面，要么你直接把时间写死在2021年，要么你对数据库里面的数据进行一定修改，要么直接就把校验模块注释。</p><h1 id="13"><a href="#13" class="headerlink" title="13"></a>13</h1><p>运用组合模式搭建规则引擎领域服务，包括：logic 逻辑过滤器、engine 引擎执行器。<br>其实我们现在脑海中想到一棵规则树，那么这个数有根节点，子节点，连线，我们把这三部分分别弄成三张表放到数据库中，也就是数据库中的三张表就代表着我们的规则树。<br>理论知识有了那么接下来就是实践了——引擎执行。<br>我们参考ruleTest测试方法，他是直接给出请求，这个请求包括了规则树id，但是之后项目复杂之后，关于这个规则数id的选取可能也要做些文章，现在我们假设就是这个规则树id。<br>从请求req到获取活动id，分成三步。<br>1、从id到数据库里取到规则树详细的信息<br>2、根据这颗规则树拿到果实节点<br>3、提炼果实节点的信息，包装成结果返回，这个结果里面就包括了活动id<br>第一步无需事务，直接查询，返回结果，这个看似没什么好讲的，其实非常重要，我们要查果实节点，那就需要完整的树，刚才我们提到了，树被分成了三个表，那这一步中就对这三张表分别进行了一次查询，将结果聚合成我们的聚合对象。第二步就是在第一步的基础上拿出东西做循环。第三步就是包装一下。因为第一步三个表也没做分库分表，所以也用不上DBRouter，也不是特别适合用编程式路由，就是对特定表的简单查询。但是问题在于是否要给这三个表的查询加上事务呢？<br>感觉加上是不是更好呢？</p>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lucky项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>章节：小知识</title>
      <link href="/2023/04/03/%E7%AB%A0%E8%8A%82%EF%BC%9A%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/04/03/%E7%AB%A0%E8%8A%82%EF%BC%9A%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven的三种packaging方式-pom、jar、war"><a href="#Maven的三种packaging方式-pom、jar、war" class="headerlink" title="Maven的三种packaging方式(pom、jar、war)"></a>Maven的三种packaging方式(pom、jar、war)</h1><p>pom是maven依赖文件<br>jar是java普通项目打包<br>war是java web项目打包 </p><p>pom：打出来可以作为其他项目的maven依赖，在工程A中添加工程B的pom，A就可以使用B中的类。用在父级工程或聚合工程中。用来做jar包的版本控制。</p><p>jar包：通常是开发时要引用通用类，打成jar包便于存放管理。当你使用某些功能时就需要这些jar包的支持，需要导入jar包。</p><p>war包：是做好一个web网站后，打成war包部署到服务器。目的是节省资源，提供效率</p><h1 id="relativePath"><a href="#relativePath" class="headerlink" title="relativePath"></a>relativePath</h1><p>搭建<a href="https://so.csdn.net/so/search?q=maven&spm=1001.2101.3001.7020">maven</a>项目，子模块指定父模块试，经常会在parent下面出现relativePath类似下面：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;net.itxw&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;test&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>这个<parent>下面的<relativePath>属性是什么意思？</p><p>其实很明显，就是parent的路径，具体来说就是你引用这个parent项目，那parent项目的pom在哪里</p><h1 id="dependencyManagement"><a href="#dependencyManagement" class="headerlink" title="dependencyManagement"></a>dependencyManagement</h1><p>如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号。当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要逐个修改子项目；另外如果某个子项目需要另外的一个版本，只需要声明version即可。</p><p>dependencyManagement中定义的只是依赖的声明，并不实现引入，因此子项目需要显式的声明需要用的依赖。</p><p>在父项目的POM.xml中配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.2.3.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p>在子项目中配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="build"><a href="#build" class="headerlink" title="build"></a>build</h1><h3 id="1-约定的目录结构"><a href="#1-约定的目录结构" class="headerlink" title="1 约定的目录结构"></a>1 约定的目录结构</h3><p><code>build </code>标签的子标签大致包含三个主体部分：</p><p>2.2.1 约定的目录结构<br>参考附录中的如下部分：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;sourceDirectory&gt;D:\idea\maven-test\src\main\java&lt;/sourceDirectory&gt;</span><br><span class="line">&lt;scriptSourceDirectory&gt;D:\idea\maven-test\src\main\scripts&lt;/scriptSourceDirectory&gt;</span><br><span class="line">&lt;testSourceDirectory&gt;D:\idea\maven-test\src\test\java&lt;/testSourceDirectory&gt;</span><br><span class="line">&lt;outputDirectory&gt;D:\idea\maven-test\target\classes&lt;/outputDirectory&gt;</span><br><span class="line">&lt;testOutputDirectory&gt;D:\idea\maven-test\target\test-classes&lt;/testOutputDirectory&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;D:\idea\maven-test\src\main\resources&lt;/directory&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;testResources&gt;</span><br><span class="line">    &lt;testResource&gt;</span><br><span class="line">        &lt;directory&gt;D:\idea\maven-test\src\test\resources&lt;/directory&gt;</span><br><span class="line">    &lt;/testResource&gt;</span><br><span class="line">&lt;/testResources&gt;</span><br><span class="line">&lt;directory&gt;D:\idea\maven-test\target&lt;/directory&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>能看到各个目录的作用如下：</p><p>目录名作用<br>sourceDirectory主体源程序存放目录<br>scriptSourceDirectory脚本源程序存放目录<br>testSourceDirectory测试源程序存放目录<br>outputDirectory主体源程序编译结果输出目录<br>testOutputDirectory测试源程序编译结果输出目录<br>resources主体资源文件存放目录<br>testResources测试资源文件存放目录<br>directory构建结果输出目录</p><h3 id="2备用插件管理"><a href="#2备用插件管理" class="headerlink" title="2备用插件管理"></a>2备用插件管理</h3><p>pluginManagement 标签存放着几个极少用到的插件：</p><p>maven-antrun-plugin<br>maven-assembly-plugin<br>maven-dependency-plugin<br>maven-release-plugin<br>通过 pluginManagement 标签管理起来的插件就像 dependencyManagement 一样，子工程使用时可以省略版本号，起到在父工程中统一管理版本的效果，看下面例子：</p><p>被 spring-boot-dependencies 管理的插件信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;pluginManagement&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/pluginManagement&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line">子工程使用的插件信息：</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-生命周期插件"><a href="#3-生命周期插件" class="headerlink" title="3 生命周期插件"></a>3 生命周期插件</h3><h1 id="把cn-XXXX-改成自己的包名，发现也有蛮多地方需要修改，也能加深理解"><a href="#把cn-XXXX-改成自己的包名，发现也有蛮多地方需要修改，也能加深理解" class="headerlink" title="把cn.XXXX 改成自己的包名，发现也有蛮多地方需要修改，也能加深理解"></a>把cn.XXXX 改成自己的包名，发现也有蛮多地方需要修改，也能加深理解</h1><p> 比如application.xml，mybatis全局配置xml里的typeAliases，不过这个文件在第三章还没用到，configuration里面的注释里也能正常跑。</p><h1 id="第4节-策略"><a href="#第4节-策略" class="headerlink" title="第4节 策略"></a>第4节 策略</h1><p> 通常分库分表的几个常见方面；</p><ol><li>访问频率：对于高频访问的数据，可以将其存储在单独的数据库或表中，以提高读写性能。</li><li>数据大小：对于大量的数据，可以将其拆分到多个表中，以减少单表的数据量，降低存储开销。</li><li>数据类型：对于不同类型的数据，可以将其拆分到不同的数据库或表中，便于管理和查询。</li><li>数据范围：对于不同范围的数据，可以将其拆分到不同的数据库或表中，便于数据的管理和查询。</li></ol><p>分库分表的主要目的在于；数据分摊、提高QPS&#x2F;TPS、分摊压力、提高可扩展性。比如；比如数据库的读写性能下降，或者单表数据量过大，这时候您就需要考虑进行分库分表操作了。通过拆分数据库，可以将单个数据库的压力分摊到多个数据库上，从而避免单个数据库的性能瓶颈，提高系统的性能和可扩展性。此外，分库分表还可以解决数据库存储容量的限制，提高数据库的存储能力。</p><p>另外在分库分表之后，数据的一致性会受到影响，数据库的管理和维护成本也会增加。因此，在考虑分库分表时，需要仔细权衡利弊，确定是否真的需要进行分库分表操作。也就是你的开发成本问题。因为有分库分表就会相应的引入 canal binlog同步、es、mq、xxl-job等分布式技术栈。</p><h2 id="库表梳理"><a href="#库表梳理" class="headerlink" title="库表梳理"></a>库表梳理</h2><p>1、感觉从抽奖流程出发比较好理解，用户-&gt;抽奖-&gt;有无得奖-&gt;结果<br>抽奖单独提炼策略表，有无得奖提炼奖品表，策略表和奖品表可以联系成策略明细表（一个策略多个奖品1:n）。抽完后的结果肯定要弄出个结果表，包括奖品发放后续、抽奖明细，但是考虑到用户可以多抽几次，全放一张表肯定不行，那一个用户三个记录肯定不行，所以可以单独分出一个纯粹的参与活动记录表和用户活动抽奖次数表，至于发放奖品后续就可以一个用户一条记录，做成用户抽奖结果表，这样理解可以吗？<br>2、从什么角度出发对需求进行初步的库表梳理比较好的，就像傅哥说的怎么打好地基。</p><h1 id="第5节"><a href="#第5节" class="headerlink" title="第5节"></a>第5节</h1><p>原始mvc架构的一个服务可能对应多个实体类，多个服务可能对应一个实体类，那后面修改一个服务的时候可能造成牵一发而动全身的结果。<br>ddd架构中model（聚合对象）里的对象类只服务于这个领域的repository（数据仓储） service（领域服务），从包的结构区分问题。dao则是仓储的具体实现，repository是接口。</p><p>自增id</p><p>疑惑：不是说model放聚合对象吗，为什么award strategy这些在基础设施层呢，不是应该在strategy领域里面吗？<br>draw req res 这代表什么意思呢</p><p>思考：default抽奖算法，能不能直接在single每次抽奖完的基础上加一个判断，如果有一个奖品抽完了，那就重新更新rateTuple，这样是不是也可以呢，反正原本的default抽奖算法每次抽奖也是要循环奖品？</p><p>service层结构很清晰,DrawExecImpl为什么不自己申明一个变量作为抽奖类型，初始化的时候给他赋值。这样就不用每次抽奖都去数据库请求了。还是说为了防止抽奖方式的改变而这么做呢？</p><h1 id="第06节"><a href="#第06节" class="headerlink" title="第06节"></a>第06节</h1>]]></content>
      
      
      <categories>
          
          <category> 项目实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lucky项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暗通道去雾算法总结</title>
      <link href="/2022/10/23/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/10/23/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>何凯明的去雾算法重点都是围绕暗通道展开的。</p><h2 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h2><p>何凯明发现，凡是无雾的算法都有一个规律，就是每一幅图像的非天空的区域里的每一个像素的rbg三个通道，一定有一个通道是很低的值。这个也很容易理解，比如大红的玫瑰翠绿的草等等。</p><h2 id="去雾模型"><a href="#去雾模型" class="headerlink" title="去雾模型"></a>去雾模型</h2><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/QQ20221023-132042@2x.png" alt="df"></p><p>i(x) 是现在有的图像，等待去雾，而j(x)是要恢复的无雾图像，A是全球大气光成分，t(x)则是透射率，所以现在有的就是ix，求jx，所以我们还需要去得到tx和A。</p><h2 id="暗通道怎么求"><a href="#暗通道怎么求" class="headerlink" title="暗通道怎么求"></a>暗通道怎么求</h2><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023134357882.png" alt="image-20221023134357882"></p><p>其中c表示rgb三通道中的某一通道。上式表示在一幅输入图像中，先取图像中每一个像素的三通道中的灰度值的最小值，得到一幅灰度图像，再在这幅灰度图像中，以每一个像素为中心取一定大小的矩形窗口，取矩形窗口中灰度值最小值代替中心像素灰度值（最小值滤波），从而得到该雾天图像的暗通道图像。</p><h2 id="如何去估计全局大气光值A？"><a href="#如何去估计全局大气光值A？" class="headerlink" title="如何去估计全局大气光值A？"></a>如何去估计全局大气光值A？</h2><p>估计全局大气光的方法有很多，有的是直接找全局最亮的点，比如天空这种雾气感最强的。</p><p>但是何凯明认为，有可能这样子找的只是白色的物体，而不是雾气最密集的区域。所以何凯明提出一种找大气光的方法：<strong>从观测图像的暗通道</strong>中选取最亮的前 0.1%的点，这些点对应到原图中再去找最亮的点作为 A 的估计。</p><h2 id="如何估计t-x"><a href="#如何估计t-x" class="headerlink" title="如何估计t(x)?"></a>如何估计t(x)?</h2><p>其实还是依赖于暗通道，在有雾气的暗通道里面，非天空区域的亮度值主要就是大气光贡献的，场景本身的暗通道的亮度应该趋于0，所以用暗通道估计雾气的传输率。</p><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023135440803.png" alt="image-20221023135440803"></p><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023135544543.png" alt="image-20221023135544543"></p><p>但是现实生活中，空气中总是有颗粒，所以看远方的物体还是能感受到雾气，所以保留一部分雾气</p><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023135641640.png" alt="image-20221023135641640"></p><h2 id="Soft-Matting"><a href="#Soft-Matting" class="headerlink" title="Soft Matting"></a>Soft Matting</h2><p>利用Soft Matting，优化原有的透射图。</p><p>可见<a href="https://mp.weixin.qq.com/s/pUcuPMaT2bFuT5d0PD4xxQ">走出寂静岭！何恺明经典去雾论文分析</a></p><p>参考文献为2006年CVPR《A closed form solution to natural image matting.》后期何恺明在2010年ECCV上《Guided image filtering》提出了导向滤波的方法。</p><h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><p>上面我们获得了大气光值以及透射率，那么根据雾天退化模型我们就可以获得去雾后的结果图了。一般来说，去雾后的结果图可能会偏暗，因此可以适当进行一些后处理如采用<strong>自动对比度增强，亮度增强，伽马校正</strong> 等图像处理方法进行处理，以便得效果更佳的无雾图像。</p>]]></content>
      
      
      <categories>
          
          <category> 去雾算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暗通道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对权限校验和token的新理解</title>
      <link href="/2022/10/20/%E5%AF%B9%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%96%B0%E7%90%86%E8%A7%A3/"/>
      <url>/2022/10/20/%E5%AF%B9%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%96%B0%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="对权限校验和token的新理解"><a href="#对权限校验和token的新理解" class="headerlink" title="对权限校验和token的新理解"></a>对权限校验和token的新理解</h1><p>在我们前端页面发出请求的时候，会先发出一个预检请求，看看这个接口是否好用，但不会去检验这个接口是否正确。比如说：发出get请求，对info这个接口进行校验，所以他会先发一个get的预检验去看看你这个接口能不能收到我这个get。如果可以，get请求返回之后会告诉我们前端可以发送，这时候前端发出真正的请求（带着参数的那种）。</p><p>下面简单讲一下权限校验的流程，以防止自己忘记和供大家参考（勿喷）。</p><p>首先我们前端服务启动之后，假设端口是8090，我们输入账号密码点击登陆，这时候前端服务会<br>将其发送到另一个端口，这里涉及跨域了，一般前端会有个简单的处理，然后后端也会有一个允许跨域什么的配置（有可能是在security里面设置或者是自己configuration一个配置文件）。</p><p>假设我们转发到了8201接口，那么请问这个接口是什么服务的接口呢？答案揭晓，一般是网关服务这边借鉴我自己的项目，用的是gateway的。</p><p>然而我们知道gateway服务一般会进行拦截访问校验权限这类工作。那么这个gateway服务，对于这种登陆的接口访问，又会做出什么样子的判断呢？其实对于这类我们会把他列入白名单，所以举个login例子，我在8090端口发出&#x2F;admin&#x2F;login命令，然后遇到gateway网关，网关直接放行，那么我们假设admin端口是8080端口，那这时候request是不是通过转发变成了：8080&#x2F;admin&#x2F;login，然后带一些账号密码这类参数什么的。</p><p>下面很关键。</p><p>一般我们的login命令是不是首先要取得授权啊，你不授权你登陆各寂寞呢。那么这时候就要请出我们的授权服务了，Auth服务。我们可以直接在login的controller里面写调用获取授权的服务。</p><p>那用什么授权呢，举个例子token或者是token的变体。下面用spring security oauth2讲一下这个token怎么获取，又怎么调教。</p><p>其实大家不用吧授权服务想的很难，无非就是自己写了一些接口，你去调用，然后判断，如果对就通过，如果错误就失败。</p><p>那么这边我们举个例子<br>在login函数里面调用这个</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CommonResult restResult = authService.getAccessToken(params);</span><br></pre></td></tr></table></figure><p>然后authService如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(&quot;auth-server&quot;)</span><br><span class="line">public interface AuthService &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(value = &quot;/oauth/token&quot;)</span><br><span class="line">    CommonResult getAccessToken(@RequestParam Map&lt;String, String&gt; parameters);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候通过注解直接跑掉另一个端口服务了。</p><h1 id="Auth服务"><a href="#Auth服务" class="headerlink" title="Auth服务"></a>Auth服务</h1><h2 id="token的生成"><a href="#token的生成" class="headerlink" title="token的生成"></a>token的生成</h2><p>我们需要配置令牌访问的端点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void configure(AuthorizationServerEndpointsConfigurer endpoints)</span><br></pre></td></tr></table></figure><p>在这里我们可以自定义授权方式，比如说微信授权、手机号授权等等。当时我们先讲token的生成</p><p>1、用户发起获取token的请求，请求&#x2F;oauth&#x2F;token接口</p><p>2、首先要过一道关卡是ClientCredentialsTokenEndpointFilter</p><ol><li>通过clientId查询生成一个Authentication对象</li><li>将clientId和clientSecret构造成UsernamePasswordAuthenticationToken,交给ProviderManager，然后ProviderManager代理AuthenticationProvider去认证，最后真正执行的是DaoAuthenticationProvider，通过UserDetailsService.loadUserByUsername向表oauth_client_details查询clientDetails信息</li></ol><p>3、 以上认证客户端信息的逻辑全部通过后，会进入地址&#x2F;oauth&#x2F;token，即TokenEndpoint的postAccessToken方法(当然这个方法我们可以自定义)中。</p><p>4、 postAccessToken方法中会验证Scope，然后验证是否是refreshToken请求等</p><p>5、 AbstractTokenGranter(此时的实现类是ResourceOwnerPasswordTokenGranter)中的grant方法</p><p>6、 之后调用AbstractTokenGranter(此时的实现类ResourceOwnerPasswordTokenGranter)中的grant方法</p><p>7、 grant方法中调用getAccessToken方法，在这个方法中又逐步调用到WebSecurityConfigurerAdapter的AbstractUserDetailsAuthenticationProvider的authenticate方法（<br>非常关键的一点</p><ul><li>先看缓存有没有</li><li>看数据库UserDetails loadedUser &#x3D; this.getUserDetailsService().loadUserByUsername(username);</li></ul><p>），对username与password进行认证</p><p>8、 验证通过后，把得到Authentication认证结果对象包装成OAuth2Authentication认证对象。然后传给DefaultTokenServices类的tokenStore的getAccessToken方法，利用OAuth2Authentication对象中的信息查找tokenStore中是否已经存在token，存在则返回OAuth2AccessToken对象。如果不存在DefaultTokenServices则调用createAccessToken（增强方法就在这里实现，这个方法主要做了五件事情，</p><ul><li>使用UUID生成Token</li><li>判断Token是否过期，如果没过期，就把过期时间设为当前时间加1000s</li><li>设置刷新令牌</li><li>设置权限</li><li>判断是否有增强器，如果有就调用它的enhance方法）</li></ul><p>方法创建OAuth2AccessToken对象。</p><p>9、 然后将OAuth2AccessToken对象包装进响应流返回。</p><h2 id="token刷新"><a href="#token刷新" class="headerlink" title="token刷新"></a>token刷新</h2><p>刷新token（refresh token）的流程与获取token的流程只有8有所区别：</p><p>1.获取token调用的是AbstractTokenGranter中的getAccessToken方法，然后调用tokenStore中的getAccessToken方法获取token。</p><p>2.刷新token调用的是RefreshTokenGranter中的getAccessToken方法，然后使用tokenStore中的refreshAccessToken方法获取token。</p><h2 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h2><p>当我们拿到token之后我们会拿着这个token去访问其他的接口，比如说我们login接口成功返回之后，你马上紧接着就访问info接口，你直接8080&#x2F;admin&#x2F;info这么发过去，首先找到gateway，gateway首先要鉴定一下你这个是不是有权限是不是啊？那么这里就涉及了鉴权服务。<br>这个鉴权服务分为两个部分：</p><p>1、token 检验<br>首先调用下面这个代码，不过readaccesstoken具体的实现我们可以自定义。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OAuth2AccessToken oAuth2AccessToken = this.tokenStore.readAccessToken(accessToken);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总之就去去查你这个token有没有，没有的话，就返回没有token的信息错误。<br>如果有，继续判断是不是过期了，如果过期了，就返回过期的错误信息<br>然后通过这个token去缓存或者数据库里面找到OAuth2Authentication对象，如果没有再次返回无效异常，如果有，那我们就通过token的校验，进入到权限的校验。</p><p>OAuth2AccessToken和OAuth2Authentication是好基友，TokenStore同时存储OAuth2AccessToken和OAuth2Authentication</p><p>2、权限检验</p><p>进来之后如果是白名单，我们就放行，毕竟有些东西确实不需要什么权限。</p><p>跨域的预检也放行，这一点在上面也提到过，预检验，你要是把他拦下来，那就没必要了。</p><p>下面进入真正的检验从request获取token，提取信息组装成一个对象（dto）</p><p>非管理端直接放行，这个意思是，我们的后台服务不是所有人都能进来的，要是你一个用户能进我们的后台那就完蛋了。</p><p>去缓存里面拿到资源规则，然后对比两者的访问路径，要是匹配得上就把相应的权限加到一个集合里面。</p><p>这时候我们就得到访问这个路径需要的权限，那我们就用自己的权限去对比，要是比他高，那就通过，要是不如，那就拒绝。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot/cloud整合docker-compose</title>
      <link href="/2022/10/04/spring%E6%95%B4%E5%90%88docker-compose/"/>
      <url>/2022/10/04/spring%E6%95%B4%E5%90%88docker-compose/</url>
      
        <content type="html"><![CDATA[<p>docker-compose是一个定义复杂应用的工具，我们平时使用docker，一般是docker run ….</p><p>然而这样每次只能运行一个镜像，而且不能保证各个容器之间是能够正常通信的，如果想要用docker做到这种容器之间相互通信，要么你每次的命令加上一大串的参数，比如说同一个网络名字啊，link啊，dependon啊，如此之类的，然而单单跑一个容器的命令的够长了，这个容器要是和4、5个其他的容器通信，那怎么写？</p><p>这就引出了我们的第二种方法：docker-compose，<br>关于这个工具我们需要下载，如果我们使用的是docker-desktop这种可视化客户端，那么他已经安装好了：怎么判断自己是不是已经完成了docker-compose的下载？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose -v   即可</span><br></pre></td></tr></table></figure><p>博主跑一个微服务的项目一般喜欢先把环境搭好，然后在测试我么的项目正确性。<br>所以这里就分成了两个docker-compose文件，一个是env，一个是我们的项目app。</p><p>这里先介绍一下docker-compse的用法。<br>我们写好一个yml文件，然后docker-compose命令去执行，而这个文件就相当于pom配置文件。<br>具体举个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose -f XXXX.yml up 要是路径上面只有一个docker-compose.yml文件那么</span><br><span class="line">-f也可以不加上去，反正就是寻找的意思。</span><br></pre></td></tr></table></figure><p>先介绍docker-compose-env.yml, 这里截取一部分，来讲一讲都是什么含义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:8.0.26</span><br><span class="line">    container_name: mysql</span><br><span class="line">    command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 185450844 #设置root帐号密码</span><br><span class="line">    ports:</span><br><span class="line">      - 3307:3306</span><br><span class="line">    volumes:</span><br><span class="line">      - /Users/csen/dockerProject/mydata/mysql/data/db:/var/lib/mysql #数据文件挂载</span><br><span class="line">      - /Users/csen/dockerProject/mydata/mysql/data/conf:/etc/mysql/conf.d #配置文件挂载</span><br><span class="line">      - /Users/csen/dockerProject/mydata/mysql/log:/var/log/mysql #日志文件挂载</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>command：声明启动参数</li><li>image：你docker里面的镜像名字</li><li>container_name：启动后的容器名字</li><li>environment：设置容器中的环境变量</li><li>privileged：用来给容器root权限，不安全的</li><li>network_mode： 设置容器的网络模式</li><li>ports：端口</li><li>volumes：挂载，这个大家都没说清楚，就是用冒号前面的路径代替后面，这样一些数据啊配置啊就可以跟着你的要求走。前面的是自己的，后面的是容器的。</li></ul><p>下面介绍docker-compose-app.yml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  XXXX:</span><br><span class="line">    image: XXXX:latest</span><br><span class="line">    container_name: XXXX</span><br><span class="line">    ports:</span><br><span class="line">      - 8081:8081</span><br><span class="line">    volumes:</span><br><span class="line">      - /Users/csen/dockerProject/XXXX/logs:/var/logs</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br><span class="line">    environment:</span><br><span class="line">      - &#x27;TZ=&quot;Asia/Shanghai&quot;&#x27;</span><br><span class="line">    external_links:</span><br><span class="line">      - elasticsearch:es #可以用es这个域名访问elasticsearch服务</span><br><span class="line">      - mysql:db #可以用db这个域名访问mysql服务</span><br><span class="line">      - nacos-registry:nacos</span><br></pre></td></tr></table></figure><p>和docker-compose-env很像，不过我只是用来启动我们的微服务项目，这里面关键就是external_links，我们在项目中使用的很多localhost要替换成这些域名。</p><p>这里的image是我们build好的项目镜像，这里就要提一嘴了。这个是我们build的镜像<br>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，用于构建镜像。每一条指令构建一层镜像，因此每一条指令的内容，就是描述该层镜像应当如何构建<br>具体的可见这篇大佬的博客：  <a href="https://blog.csdn.net/m0_46090675/article/details/121846718?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166489555716782417065884%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166489555716782417065884&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121846718-null-null.142%5Ev51%5Econtrol,201%5Ev3%5Econtrol&utm_term=dockerfile&spm=1018.2226.3001.4187">Dockerfile</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 整合中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整合docker和中间件记录</title>
      <link href="/2022/10/04/%E6%95%B4%E5%90%88docker%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/10/04/%E6%95%B4%E5%90%88docker%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>博主从win换成mac后，想试着自己配一下docker环境，花了足足3到4天的时间。<br>由于中土存在各种中间件的兼容问题，mac版和win版的不一致，中间件版本过新等问题，且大多数博客对于版本的描述不够清晰，很难帮到忙，故博主斗胆记录一下，希望对大家有帮助。</p><p>环境：</p><ul><li>springboot: 2.7.0</li><li>nacos: 2.1.0</li><li>elasticsearch: 8.2.0</li><li>kibana: 8.2.0</li><li>springcloud: 2021.0.3</li><li>springcloudalibaba: 2021.0.1</li><li>mysql: 8.0.26</li><li>redis: 7</li><li>rabbitmq: 3.9.11</li><li>jdk: 8</li><li>kafka: 3.5.11</li></ul><h2 id="1、elasticsearch8-2-0"><a href="#1、elasticsearch8-2-0" class="headerlink" title="1、elasticsearch8.2.0"></a>1、elasticsearch8.2.0</h2><p>当es和kibana到达8版本后，出现了很多变化，而且兼容mac版本的镜像提示不够明确  </p><p>可能出现的问题：</p><p>1、装好es之后你打开9200端口，发现他要求你输入密码，但是你其实根本就没有告诉你初始账号密码和默认的账号密码</p><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csen@CsendeMBA Sen-Blog % docker exec -it (容器名字) /bin/bash</span><br><span class="line">elasticsearch@52142308d267:~$ ls</span><br><span class="line">LICENSE.txt  README.asciidoc  config  jdk  logs     plugins</span><br><span class="line">NOTICE.txt   bin              data    lib  modules</span><br><span class="line">elasticsearch@52142308d267:~$ cd config</span><br><span class="line">elasticsearch@52142308d267:~/config$ ls</span><br><span class="line">certs                              jvm.options             role_mapping.yml</span><br><span class="line">elasticsearch-plugins.example.yml  jvm.options.d           roles.yml</span><br><span class="line">elasticsearch.keystore             log4j2.file.properties  users</span><br><span class="line">elasticsearch.yml                  log4j2.properties       users_roles</span><br><span class="line">elasticsearch@52142308d267:~/config$ </span><br></pre></td></tr></table></figure><p>你会看到有一个文件叫做elasticsearch.yml,我们需要做的就是修改这个文件</p><p>修改文件内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster.name: &quot;docker-cluster&quot;</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"># Enable security features</span><br><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.security.enrollment.enabled: true（可以先不加，上面的必须加）</span><br></pre></td></tr></table></figure><p>当你修改之后，重启容器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart 容器名字</span><br></pre></td></tr></table></figure><p>等重启之后，进入容器的es内部（可以直接docker desk客户端的cli那里，也可以像上面一样命令行）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/share/elasticsearch/bin/x-pack/setup-passwords interactive</span><br></pre></td></tr></table></figure><p>依此设置elastic、apm_system、kibana_system、logstash_system、beats_system、remote_monitoring_user6个用户的密码，每设置一个都要验证一次，所以要按12次，建议直接用一个密码就行，我用的是elastic</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initiating the setup of passwords for reserved users elastic,apm_system,kibana,kibana_system,logstash_system,beats_system,remote_monitoring_user.</span><br><span class="line">You will be prompted to enter passwords as the process progresses.</span><br><span class="line">Please confirm that you would like to continue [y/N]y</span><br><span class="line">Enter password for [elastic]: </span><br><span class="line">Reenter password for [elastic]: </span><br><span class="line">Enter password for [apm_system]: </span><br><span class="line">Reenter password for [apm_system]: </span><br><span class="line">Enter password for [kibana_system]: </span><br><span class="line">Reenter password for [kibana_system]: </span><br><span class="line">Enter password for [logstash_system]: </span><br><span class="line">Reenter password for [logstash_system]: </span><br><span class="line">Enter password for [beats_system]: </span><br><span class="line">Reenter password for [beats_system]: </span><br><span class="line">Enter password for [remote_monitoring_user]: </span><br><span class="line">Reenter password for [remote_monitoring_user]: </span><br><span class="line">Changed password for user [apm_system]</span><br><span class="line">Changed password for user [kibana_system]</span><br><span class="line">Changed password for user [kibana]</span><br><span class="line">Changed password for user [logstash_system]</span><br><span class="line">Changed password for user [beats_system]</span><br><span class="line">Changed password for user [remote_monitoring_user]</span><br><span class="line">Changed password for user [elastic]</span><br></pre></td></tr></table></figure><p>这时候登陆9200端口查看是否成功，如果成功他会返回一个json串，一看就知道成功的json串，有name clustername、version这些属性。</p><h2 id="2、kibana8-2-0"><a href="#2、kibana8-2-0" class="headerlink" title="2、kibana8.2.0"></a>2、kibana8.2.0</h2><p>kibana安装完成后打开5601端口，他会在页面左上角显示一段英文串，意思就是没准备好，但实际是因为权限问题，人家进不去。</p><p>这个问题大多数博主都没讲到。</p><p>解决办法是：你告诉kibana，es的账号密码，我们会发现，在es设置密码的时候有6个用户，那我们到底用哪一个呢？这里有点歧义，我的选择是直接用kibana_system这个用户。因为我们就是kibana所以没什么问题，但是有一个博主用的elastic用户，而我使用这个用户会提示错误，所以大家可以先试试kibana_system然后elastic，具体操作如下：</p><p>首先挂载config，把原本自带的挤掉，因为我们在docker修改起来也不方便，所以直接挂载是最简单的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volumes:</span><br><span class="line">     - /Users/csen/dockerProject/mydata/kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml </span><br><span class="line">     - </span><br></pre></td></tr></table></figure><p>挂载成功后，在我们的kibana.yml文件中修改内容</p><p>1、要对应你们自己修改的密码。如果是elastic那就完全复制，如果不是，就自己改一下密码。<br>2、elasticseatch.hosts那一栏我写的是es：9200，因为我的elasticsearch容器跑通之后，在springboot项目中的别名叫做es，大家根据自己的改哦，别死抄。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># ** THIS IS AN AUTO-GENERATED FILE **</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Default Kibana configuration for docker target</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">server.shutdownTimeout: &quot;5s&quot;</span><br><span class="line">elasticsearch.hosts: [ &quot;http://es:9200&quot; ]</span><br><span class="line">monitoring.ui.container.elasticsearch.enabled: true</span><br><span class="line"># 这里配置中文显示，默认为英文 【English - en (default)、Chinese - zh-CN、Japanese - ja-JP】</span><br><span class="line">i18n.locale: &quot;zh-CN&quot;</span><br><span class="line"># 此处设置elastic的用户名和密码</span><br><span class="line">elasticsearch.username: kibana_system</span><br><span class="line">elasticsearch.password: elastic</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h2><p>这个只说一点就可以了，当然这也是所有中间件的选择方案。版本选对，由于mac有芯片有两代，i5i7和m1m2，这两代的架构是不一样的，所以去hub里面找相应的版本大下载就可以了，举个例子：</p><p>我们要下载2.1.0版本的nacos，我们打开hub.docker.com然后搜索nacos，去tag里面输入2.1.0，你会发现，有好多版本，这时候我们要看【os&#x2F;arch】这一栏，你去看看他到底是哪种架构的，有的是linux&#x2F;amd64，有的是linux&#x2F;arm64，有的是两者皆有。如果是i5i7的就去下带amd64的，如果是m1m2的就去下载带arm64的。</p><p>不过这里提一嘴，m1m2芯片他自带了转译的功能，也就是说即使是amd64的他也有能力转成适合自己的，但是可能存在两代电脑环境配置的问题，大家还是下载各自适合的最好。</p><h2 id="mysql8"><a href="#mysql8" class="headerlink" title="mysql8"></a>mysql8</h2><p>目前网上的博客大多都是mysql5.7版本之类的，8版本的较少，所以会出一些错误。</p><p>特别是连接数据库的时候，大家发现明明我的账号密码都对的，为什么还是说连接错误呢？这其实很可能不是我们自己的问题。</p><p>下面给出我的连接数据库的配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  url: jdbc:mysql://db:3306/mall?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span><br><span class="line">  username: root</span><br><span class="line">  password: XXXXXXXX</span><br><span class="line">  druid:</span><br><span class="line">    initial-size: 5 #连接池初始化大小</span><br><span class="line">    min-idle: 10 #最小空闲连接数</span><br><span class="line">    max-active: 20 #最大连接数</span><br><span class="line">    web-stat-filter:</span><br><span class="line">      exclusions: &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot; #不统计这些请求数据</span><br><span class="line">    stat-view-servlet: #访问监控网页的登录用户名和密码</span><br><span class="line">      login-username: druid</span><br><span class="line">      login-password: druid</span><br></pre></td></tr></table></figure><p>这里需要注意的是一下几点：</p><p>1、如果你把项目放到docker里面，就不要用localhost了，要么你直接用ip地址，要么就和我一样用这种别名。<br>而这种别名的配置则放在docker-compose里面。<br>这个在文章最后会给大家放一个链接将docker-compose怎么写。</p><p>2、由于版本升级和docker的原因，在连接数据库的时候最好加上这些后缀：</p><p>2.1、useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8：一旦设置了之后，不管数据库是什么编码，读取的时候都会转换成UTF-8，存取的时候还是会按数据库编码存</p><p>2.2、serverTimezone&#x3D;Asia&#x2F;Shanghai：问题在 MySQL8.0的驱动包跟之前不一样了，默认时区是全球统一时间 (UTC)，北京时间是 UTC+8，这句话不加就导致了很多人就算不在docker里面都连不上数据库，mysql8就很烦。</p><p>2.3、useSSL&#x3D;false：useSSL&#x3D;true是进行安全验证，一般通过证书或者令牌什么的，useSSL&#x3D;false就是通过账号密码进行连接，通常使用useSSL&#x3D;false，这个也是mysql8的问题，不过这个问题并不是到了8之后才有的，5.7之后就存在这个问题了。ssl会认证用户的服务器，然后加密数据，最后维护数据的完整性。但是我们用docker相当于把它部署到一个linux服务器上，所以用不到这个。</p><p>2.4、allowPublicKeyRetrieval&#x3D;true。</p><p>这个指令比较玄学，是由于报了下面错误才用的，Public Key Retrieval is not allowed（不允许检索公钥）。博主也去网上查了很多资料，大家的话大差不差，就是在第一次连接的时候会出问题，第二次连的时候貌似数据库就缓存的这个配置信息，既然加上能用，大家就加上。有一些朋友也说到，如果我们使用一些可视化工具比如navicat这类的也能解决。</p><p>另一种法是：使用指令mysql -u root -p指令进入mysql，将验证方式修改为“mysql_native_password”</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE mysql; </span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整合中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合elasticsearch8.2.0</title>
      <link href="/2022/10/04/%E6%95%B4%E5%90%88elasticsearch8-2-0/"/>
      <url>/2022/10/04/%E6%95%B4%E5%90%88elasticsearch8-2-0/</url>
      
        <content type="html"><![CDATA[<h1 id="java-整合elasticsearch8-2-0"><a href="#java-整合elasticsearch8-2-0" class="headerlink" title="java 整合elasticsearch8.2.0"></a>java 整合elasticsearch8.2.0</h1><p>[TOC]</p><h3 id="一、application-yml或者其他的配置文件皆可"><a href="#一、application-yml或者其他的配置文件皆可" class="headerlink" title="一、application.yml或者其他的配置文件皆可"></a>一、application.yml或者其他的配置文件皆可</h3><p>两种方式：【1】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elasticsearch:</span><br><span class="line">  hosts: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>     # 如果有多个IP就自己加逗号吧</span><br></pre></td></tr></table></figure><p>【2】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring：</span><br><span class="line">elasticsearch:</span><br><span class="line">    uris: localhost:<span class="number">9200</span>   #这样子自动配置了</span><br></pre></td></tr></table></figure><h3 id="二、config类"><a href="#二、config类" class="headerlink" title="二、config类"></a>二、config类</h3><p>不同的版本会有不同的config类要求，这里只提供es8.2.0的，对应着上面两种application文件，此处也提供两种对应的config类，至于之后和springboot整合就不会出现分类了。</p><h5 id="【1】自定义属性"><a href="#【1】自定义属性" class="headerlink" title="【1】自定义属性"></a>【1】自定义属性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Caosen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/22 10:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EsUtilConfigClint2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;elasticsearch.hosts&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String hosts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpHost[] getHttpHost()&#123;</span><br><span class="line">        <span class="keyword">if</span> (hosts.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(hosts);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] hosts_array = hosts.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">//用string类型创建host的集合</span></span><br><span class="line"></span><br><span class="line">        HttpHost[] httpHosts = <span class="keyword">new</span> <span class="title class_">HttpHost</span>[hosts_array.length];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : hosts_array) &#123;</span><br><span class="line">            <span class="comment">//这里解析端口</span></span><br><span class="line">            String[] hosts_array_in = s.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="comment">//到这里就有了id和端口两个东西</span></span><br><span class="line">            <span class="type">HttpHost</span> <span class="variable">http</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHost</span>(hosts_array_in[<span class="number">0</span>], Integer.parseInt(hosts_array_in[<span class="number">1</span>]), <span class="string">&quot;http&quot;</span>);</span><br><span class="line">            httpHosts[i++] = http;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;目前的配置加入了&quot;</span> + i + <span class="string">&quot;个id及其端口&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> httpHosts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ElasticsearchClient <span class="title function_">configClint</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// Create the low-level client</span></span><br><span class="line">        HttpHost[] httpHosts = getHttpHost();</span><br><span class="line">        <span class="type">RestClient</span> <span class="variable">restClient</span> <span class="operator">=</span> RestClient.builder(httpHosts).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the transport with a Jackson mapper</span></span><br><span class="line">        <span class="type">ElasticsearchTransport</span> <span class="variable">transport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestClientTransport</span>(</span><br><span class="line">                restClient, <span class="keyword">new</span> <span class="title class_">JacksonJsonpMapper</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端</span></span><br><span class="line">        <span class="type">ElasticsearchClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElasticsearchClient</span>(transport);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="【2】使用自带的属性"><a href="#【2】使用自带的属性" class="headerlink" title="【2】使用自带的属性"></a>【2】使用自带的属性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Caosen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/18 15:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EsUtilConfigClint</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ElasticsearchClient <span class="title function_">configClint</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// Create the low-level client</span></span><br><span class="line">        <span class="type">RestClient</span> <span class="variable">restClient</span> <span class="operator">=</span> RestClient.builder(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9200</span>)).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the transport with a Jackson mapper</span></span><br><span class="line">        <span class="type">ElasticsearchTransport</span> <span class="variable">transport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestClientTransport</span>(</span><br><span class="line">                restClient, <span class="keyword">new</span> <span class="title class_">JacksonJsonpMapper</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端</span></span><br><span class="line">        <span class="type">ElasticsearchClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElasticsearchClient</span>(transport);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h3><h5 id="【1】service接口"><a href="#【1】service接口" class="headerlink" title="【1】service接口"></a>【1】service接口</h5><p>由于作者是直接在项目里面加内容的，可能会出现一些不相关的东西，我尽量截取相关代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 从数据库中导入所有商品到ES</span><br><span class="line">     */</span><br><span class="line">    int importAll();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新建指定名称的索引</span><br><span class="line">     * @param name</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    void addIndex(String name) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 检查指定名称的索引是否存在</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    boolean indexExists(String name) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除指定索引</span><br><span class="line">     * @param name</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    void delIndex(String name) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建索引，指定setting和mapping</span><br><span class="line">     * @param name 索引名称</span><br><span class="line">     * @param settingFn 索引参数</span><br><span class="line">     * @param mappingFn 索引结构</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    void create(String name,</span><br><span class="line">                Function&lt;IndexSettings.Builder, ObjectBuilder&lt;IndexSettings&gt;&gt; settingFn,</span><br><span class="line">                Function&lt;TypeMapping.Builder, ObjectBuilder&lt;TypeMapping&gt;&gt; mappingFn) throws IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="【2】serviceImpl，主要看create-，add，exsits-delete"><a href="#【2】serviceImpl，主要看create-，add，exsits-delete" class="headerlink" title="【2】serviceImpl，主要看create ，add，exsits, delete"></a>【2】serviceImpl，主要看create ，add，exsits, delete</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    private EsProductDao esProductDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductRepository esProductRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ElasticsearchClient elasticsearchClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int importAll() &#123;</span><br><span class="line">        List&lt;EsProduct&gt; allEsProductList = esProductDao.getAllEsProductList(null);</span><br><span class="line">        Iterable&lt;EsProduct&gt; esProducts = esProductRepository.saveAll(allEsProductList);</span><br><span class="line">        Iterator&lt;EsProduct&gt; iterator = esProducts.iterator();</span><br><span class="line">        int result = 0;</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addIndex(String name) throws IOException &#123;</span><br><span class="line">        elasticsearchClient.indices().create(b -&gt; b.index(name));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean indexExists(String name) throws IOException &#123;</span><br><span class="line">        return elasticsearchClient.indices().exists(b -&gt; b.index(name)).value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delIndex(String name) throws IOException &#123;</span><br><span class="line">        elasticsearchClient.indices().delete(b -&gt; b.index(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void create(String name, Function&lt;IndexSettings.Builder, ObjectBuilder&lt;IndexSettings&gt;&gt; setting, Function&lt;TypeMapping.Builder, ObjectBuilder&lt;TypeMapping&gt;&gt; mapping) throws IOException &#123;</span><br><span class="line">        elasticsearchClient.indices()</span><br><span class="line">                .create(b -&gt; b</span><br><span class="line">                        .index(name)</span><br><span class="line">                        .settings(setting)</span><br><span class="line">                        .mappings(mapping));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="【3】测试"><a href="#【3】测试" class="headerlink" title="【3】测试"></a>【3】测试</h5><p>测试可以用controller 或者 用test伪装controller，自己测试的时候还是用postman接口比较合适。这里测试两种创建index，一种简单，一种稍微复杂，结果都是通过，见图。其他的删除啊，导入数据库的数据（repository）都是可以查到的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    void addIndexSimple() throws IOException &#123;</span><br><span class="line">        String s = &quot;simple&quot;;</span><br><span class="line"></span><br><span class="line">        esProductService.addIndex(s);</span><br><span class="line">        System.out.println(&quot;创建success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    void addIndexComplicated() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        String s = &quot;complicated&quot;;</span><br><span class="line">        Function&lt;IndexSettings.Builder, ObjectBuilder&lt;IndexSettings&gt;&gt; setting = builder -&gt; builder</span><br><span class="line">                .index(i -&gt; i.numberOfShards(&quot;3&quot;).numberOfReplicas(&quot;1&quot;));</span><br><span class="line">        Property keywordproperty = Property.of(p -&gt; p.keyword(k -&gt; k.ignoreAbove(256)));</span><br><span class="line">        Property testproperty = Property.of(p -&gt; p.text(builder -&gt; builder));</span><br><span class="line">        Property integerproperty = Property.of(builder -&gt; builder.integer(i -&gt; i));</span><br><span class="line"></span><br><span class="line">        Function&lt;TypeMapping.Builder, ObjectBuilder&lt;TypeMapping&gt;&gt; mapping = builder -&gt; builder</span><br><span class="line">                .properties(&quot;name&quot;, keywordproperty)</span><br><span class="line">                .properties(&quot;description&quot;, testproperty)</span><br><span class="line">                .properties(&quot;price&quot;, integerproperty);</span><br><span class="line">        esProductService.create(s, setting, mapping);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220922113434674.png" alt="image-20220922113434674"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整合中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合kafka3.1-基本配置和操作</title>
      <link href="/2022/10/04/%E6%95%B4%E5%90%88kafka3-1-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/10/04/%E6%95%B4%E5%90%88kafka3-1-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>这篇是单机的zookeeper形式，适用于入门。等有时间会更新kraft搭建。</p><p>博主自己装了双系统，虚拟机刚刚删了，所以没去做集群，不过当大家的kafka版本来到3.1，建议大家去学习KRaft集群搭建而不是去整合zookeeper。下面介绍一下怎么整合，正所谓举一反三，这个会了，到时候换个环境就ok，讲的不好的地方还请见谅。</p><p>[toc]</p><h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><h3 id="1、springboot"><a href="#1、springboot" class="headerlink" title="1、springboot"></a>1、springboot</h3><p>博主自己用的是2.7版本的</p><p>一般关于springboot我会引入一下依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2、kafka"><a href="#2、kafka" class="headerlink" title="2、kafka"></a>2、kafka</h3><h4 id="1、kafka下载"><a href="#1、kafka下载" class="headerlink" title="1、kafka下载"></a>1、kafka下载</h4><p><a href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a>  这里下载，这里再提一句，建议直接放到d盘e盘一级子目录里面，否则有可能出现启动的时候名字太长的问题</p><p>下载之后修改配置文件server.properties</p><p>log.dirs&#x3D;E:\kafka_2.13-3.2.3\kafka-logs</p><h4 id="2、项目引入依赖"><a href="#2、项目引入依赖" class="headerlink" title="2、项目引入依赖"></a>2、项目引入依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;根据自己的版本选择&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里提一句：不一样的springboot对应的kafka依赖版本也不一样，所以先去官网查看依赖版本。</p><p><a href="https://spring.io/projects/spring-kafka">https://spring.io/projects/spring-kafka</a>   点这个链接去找对应的，别自己乱下最新的。</p><h5 id="新版本的kafka命令和老版本的不一样。"><a href="#新版本的kafka命令和老版本的不一样。" class="headerlink" title="新版本的kafka命令和老版本的不一样。"></a>新版本的kafka命令和老版本的不一样。</h5><p>试着启动，命令看你在哪个文件夹，如果是kafka，用下面的，如果是linux，把bat换成sh</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-server-start.bat config\server.properties</span><br></pre></td></tr></table></figure><p>简单使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test（自己取）</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure><h3 id="3、zookeeper"><a href="#3、zookeeper" class="headerlink" title="3、zookeeper"></a>3、zookeeper</h3><p>新版本的kafka其实自己集成了zookeeper，博主这里同样介绍两种方式，一种自己重新去下个zookeeper，一种用kafka自带的。</p><h4 id="1、自带的"><a href="#1、自带的" class="headerlink" title="1、自带的"></a>1、自带的</h4><p>修改配置zookeeper.properties</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataDir=/opt/kafka/zookeeper/data/dataDir</span><br><span class="line">dataLogDir=/opt/kafka/zookeeper/data/dataLogDir</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line"># disable the per-ip limit on the number of connections since <span class="built_in">this</span> is a non-production config</span><br><span class="line">maxClientCnxns=<span class="number">100</span></span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line">initLimit=<span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br></pre></td></tr></table></figure><h4 id="2、自己下载zookeeper"><a href="#2、自己下载zookeeper" class="headerlink" title="2、自己下载zookeeper"></a>2、自己下载zookeeper</h4><p>由于是自己下载所以也不用去配置kafka文件中的zookeeper.properties</p><p><a href="https://zookeeper.apache.org/releases.html#download">https://zookeeper.apache.org/releases.html#download</a>  这是下载地址</p><p>进去之后很简单，一样改配置，进入conf目录下，将<code>zoo_example.cfg</code>重命名为<code>zoo.cfg</code></p><p>同样修改dataDir和log， 我的是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">example sakes.</span><br><span class="line"></span><br><span class="line">dataDir=E:\\java-configuration\\apache-zookeeper-<span class="number">3.7</span><span class="number">.1</span>-bin\\data</span><br><span class="line"></span><br><span class="line">存放事务日志目录</span><br><span class="line"></span><br><span class="line">dataLogDir=E:\\java-configuration\\apache-zookeeper-<span class="number">3.7</span><span class="number">.1</span>-bin\\logs</span><br></pre></td></tr></table></figure><p>然后运行zkserver.cmd和zkcli.cmd, 一个是启动我们的zookeeper服务器，一个是客户端。</p><h2 id="springboot整合操作kafka"><a href="#springboot整合操作kafka" class="headerlink" title="springboot整合操作kafka"></a>springboot整合操作kafka</h2><p><img src="C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220924153503966.png" alt="image-20220924153503966"></p><p>这里用一张图作为流程讲解如何整合。</p><h3 id="1、config"><a href="#1、config" class="headerlink" title="1、config"></a>1、config</h3><p>其实可以把下面的conponent exception filter什么的都丢进来，可以配一些生产者消费者的信息，想配什么都可以，这个就不展示了。</p><h3 id="2、回调（conponent）"><a href="#2、回调（conponent）" class="headerlink" title="2、回调（conponent）"></a>2、回调（conponent）</h3><p>回调有多种写法，这里介绍三种</p><h4 id="1、较为泛用的"><a href="#1、较为泛用的" class="headerlink" title="1、较为泛用的"></a>1、较为泛用的</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class KafkaSendResultHandler implements ProducerListener &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSuccess(ProducerRecord producerRecord, RecordMetadata recordMetadata) &#123;</span><br><span class="line">        System.out.println(&quot;Message send success : &quot; + producerRecord.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(ProducerRecord producerRecord, RecordMetadata recordMetadata, Exception exception) &#123;</span><br><span class="line">        System.out.println(&quot;Message send error : &quot; + producerRecord.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在生产者里面使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private KafkaSendResultHandler kafkaSendResultHandler;</span><br><span class="line"></span><br><span class="line">。。。。。省略</span><br><span class="line"></span><br><span class="line">kafkaTemplate.setProducerListener(kafkaSendResultHandler);    </span><br></pre></td></tr></table></figure><h4 id="2、一个方法对应一个特定的回调"><a href="#2、一个方法对应一个特定的回调" class="headerlink" title="2、一个方法对应一个特定的回调"></a>2、一个方法对应一个特定的回调</h4><h5 id="1、第一种写法"><a href="#1、第一种写法" class="headerlink" title="1、第一种写法"></a>1、第一种写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(<span class="string">&quot;topic1&quot;</span>, callbackMessage).addCallback(success -&gt;&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> success.getRecordMetadata().topic();</span><br><span class="line">    <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> success.getRecordMetadata().partition();</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> success.getRecordMetadata().offset();</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息成功:&quot;</span> + topic + <span class="string">&quot;-&quot;</span> + partition + <span class="string">&quot;-&quot;</span> + offset);</span><br><span class="line"></span><br><span class="line">&#125;, failure -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息失败:&quot;</span> + failure.getMessage());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="2、第二种写法"><a href="#2、第二种写法" class="headerlink" title="2、第二种写法"></a>2、第二种写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(<span class="string">&quot;topic1&quot;</span>, callbackMessage).addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;SendResult&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息失败：&quot;</span>+ex.getMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult&lt;String, Object&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：&quot;</span> + result.getRecordMetadata().topic() + <span class="string">&quot;-&quot;</span></span><br><span class="line">                + result.getRecordMetadata().partition() + <span class="string">&quot;-&quot;</span> + result.getRecordMetadata().offset());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3、consumer-消费者"><a href="#3、consumer-消费者" class="headerlink" title="3、consumer(消费者)"></a>3、consumer(消费者)</h3><p>使用KafkaListener，指定消息类型（必选）和groupid，partitions offset（可选）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, groupId = &quot;felix-group0&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage1(ConsumerRecord&lt;?,?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;简单消费：&quot; + record.topic() + &quot;--&quot; + record.partition() + &quot;--&quot; + record.value());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@KafkaListener(id = &quot;comsumer1&quot;, groupId = &quot;felix-group1&quot;, topicPartitions = &#123;</span><br><span class="line">        @TopicPartition(topic = &quot;topic1&quot;, partitions = &#123;&quot;0&quot;&#125;),</span><br><span class="line">        @TopicPartition(topic = &quot;topic2&quot;, partitionOffsets = @PartitionOffset(partition = &quot;0&quot;, initialOffset = &quot;8&quot;))</span><br><span class="line">&#125; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage2(ConsumerRecord&lt;?, ?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;topic:&quot;+record.topic()+&quot;|partition:&quot;+record.partition()+&quot;|offset:&quot;+record.offset()+&quot;|value:&quot;+record.value());</span><br><span class="line">&#125;</span><br><span class="line">@KafkaListener(id = &quot;consumer2&quot;,groupId = &quot;felix-group2&quot;, topics = &quot;topic1&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage3(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records) &#123;</span><br><span class="line">    System.out.println(&quot;&gt;&gt;&gt;批量消费一次，records.size()=&quot;+records.size());</span><br><span class="line">    for (ConsumerRecord&lt;?, ?&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、controller生产者（produces）"><a href="#4、controller生产者（produces）" class="headerlink" title="4、controller生产者（produces）"></a>4、controller生产者（produces）</h3><h4 id="1、同步发送"><a href="#1、同步发送" class="headerlink" title="1、同步发送"></a>1、同步发送</h4><p>如果需要使用同步发送，可以在每次发送之后使用get方法，因为producer.send方法返回一个Future类型的结果，Future的get方法会一直阻塞直到该线程的任务得到返回值，也就是broker返回发送成功。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(&quot;test&quot;, message).get();</span><br></pre></td></tr></table></figure><h4 id="2、异步发送"><a href="#2、异步发送" class="headerlink" title="2、异步发送"></a>2、异步发送</h4><p>可以从返回的future对象中稍后获取发送的结果，ProducerRecord、RecordMetadata包含了返回的结果信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(&quot;test&quot;, message);</span><br></pre></td></tr></table></figure><h4 id="3-使用ack机制实现可靠"><a href="#3-使用ack机制实现可靠" class="headerlink" title="3. 使用ack机制实现可靠"></a>3. 使用ack机制实现可靠</h4><p>producers可以一步的并行向kafka发送消息，但是通常producer在发送完消息之后会得到一个响应，返回的是offset值或者发送过程中遇到的错误。这其中有个非常重要的参数“request.required.acks”，这个参数决定了producer要求leader partition收到确认的副本个数：</p><ul><li>如果acks设置为0，表示producer不会等待broker的相应，所以，producer无法知道消息是否发生成功，这样有可能导致数据丢失，但同时，acks值为0会得到最大的系统吞吐量。</li><li>若acks设置为1，表示producer会在leader partition收到消息时得到broker的一个确认，这样会有更好的可靠性，因为客户端会等待知道broker确认收到消息。</li><li>若设置为-1，producer会在所有备份的partition收到消息时得到broker的确认，这个设置可以得到最高的可靠性保证。</li></ul><h3 id="5、exception"><a href="#5、exception" class="headerlink" title="5、exception"></a>5、exception</h3><p>bean注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ConsumerAwareListenerErrorHandler consumerAwareErrorHandler() &#123;</span><br><span class="line">    return (message, exception, consumer) -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;消费异常：&quot;+message.getPayload());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费异常配置注解实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, groupId = &quot;felix-group0&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage1(ConsumerRecord&lt;?,?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;简单消费：&quot; + record.topic() + &quot;--&quot; + record.partition() + &quot;--&quot; + record.value());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、filter"><a href="#6、filter" class="headerlink" title="6、filter"></a>6、filter</h3><p>bean注入factory的时候配置好消息过滤策略</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置消息过滤策略</span><br><span class="line">    @Bean(value = &quot;filterContainerFactory&quot;)</span><br><span class="line">    public ConcurrentKafkaListenerContainerFactory concurrentKafkaListenerContainerFactory() &#123;</span><br><span class="line">        ConcurrentKafkaListenerContainerFactory factory = new ConcurrentKafkaListenerContainerFactory();</span><br><span class="line">        factory.setConsumerFactory(consumerFactory);</span><br><span class="line">        // 被过滤的消息将被丢弃</span><br><span class="line">        factory.setAckDiscarded(true);</span><br><span class="line">        // 消息过滤策略</span><br><span class="line">        factory.setRecordFilterStrategy(consumerRecord -&gt; &#123;</span><br><span class="line">            if (Integer.parseInt(consumerRecord.value().toString()) % 2 == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return factory;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>消费异常配置注解实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息过滤监听</span><br><span class="line">    @KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, containerFactory = &quot;filterContainerFactory&quot;)</span><br><span class="line">    public void onMessage6(ConsumerRecord&lt;?, ?&gt; record) &#123;</span><br><span class="line">        System.out.println(record.value());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="7、序列化编码解码"><a href="#7、序列化编码解码" class="headerlink" title="7、序列化编码解码"></a>7、序列化编码解码</h3><p>序列化器都实现了接口（<code>org.apache.kafka.common.serialization.Serializer</code>）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Serializer&lt;T&gt; extends Closeable &#123;</span><br><span class="line">default void configure(Map&lt;String, ?&gt; configs, Boolean isKey) &#123;</span><br><span class="line">&#125;</span><br><span class="line">byte[] serialize(String var1, T var2);</span><br><span class="line">default byte[] serialize(String topic, Headers headers, T data) &#123;</span><br><span class="line">return this.serialize(topic, data);</span><br><span class="line">&#125;</span><br><span class="line">default void close() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以我们只用去实现serialize即可</p><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><pre><code>public class MySerializer implements Serializer &#123;    @Override    public byte[] serialize(String s, Object o) &#123;        String json = JSON.toJSONString(o);        return json.getBytes();&#125;&#125;</code></pre><h4 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyDeserializer implements Deserializer &#123;</span><br><span class="line">    private final static Logger logger = LoggerFactory.getLogger(MyDeserializer.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object deserialize(String s, byte[] bytes) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String json = new String(bytes,&quot;utf-8&quot;);</span><br><span class="line">            return JSON.parse(json);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后在application中配置key-serializer 和 value-serializer</p><h3 id="8、分区策略"><a href="#8、分区策略" class="headerlink" title="8、分区策略"></a>8、分区策略</h3><p>分区策略一般分为四种情况：</p><ul><li>有分区号，直接将数据发送到指定的分区里面去</li><li>没有分区号，但是给了数据的key值，根据key取hashCode进行分区</li><li>分区号和key值都没有，直接使用默认的轮循分区</li><li>自定义分区</li></ul><h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试</span><br><span class="line">        kafkaTemplate.send(&quot;test&quot;, 0, key, &quot;key=&quot; + key + &quot;，msg=指定0号分区&quot;);</span><br><span class="line">        kafkaTemplate.send(&quot;test&quot;, key, &quot;key=&quot; + key + &quot;，msg=不指定分区&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line"><span class="comment">//        定义自己的分区策略</span></span><br><span class="line"><span class="comment">//                如果key以0开头，发到0号分区</span></span><br><span class="line"><span class="comment">//                其他都扔到1号分区</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyStr</span> <span class="operator">=</span> key+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (keyStr.startsWith(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitionTemplate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.kafka.bootstrap-servers&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKafkaTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);</span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        <span class="comment">//注意分区器在这里！！！</span></span><br><span class="line">        props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, MyPartitioner.class);</span><br><span class="line">        <span class="built_in">this</span>.kafkaTemplate = <span class="keyword">new</span> <span class="title class_">KafkaTemplate</span>&lt;String, String&gt;(<span class="keyword">new</span> <span class="title class_">DefaultKafkaProducerFactory</span>&lt;&gt;(props));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> KafkaTemplate <span class="title function_">getKafkaTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试自定义分区发送</span><br><span class="line">@RestController</span><br><span class="line">public class MyPartitionProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    MyPartitionTemplate template;</span><br><span class="line"></span><br><span class="line">//    使用0开头和其他任意字母开头的key发送消息</span><br><span class="line">//    看控制台的输出，在哪个分区里？</span><br><span class="line">    @GetMapping(&quot;/kafka/myPartitionSend/&#123;key&#125;&quot;)</span><br><span class="line">    public void setPartition(@PathVariable(&quot;key&quot;) String key) &#123;</span><br><span class="line">        template.getKafkaTemplate().send(&quot;test&quot;, key,&quot;key=&quot;+key+&quot;，msg=自定义分区策略&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整合中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合OAuth2认证服务</title>
      <link href="/2022/10/04/%E6%95%B4%E5%90%88OAuth2%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/10/04/%E6%95%B4%E5%90%88OAuth2%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="1、AuthorizationServerConfig"><a href="#1、AuthorizationServerConfig" class="headerlink" title="1、AuthorizationServerConfig"></a><strong>1、AuthorizationServerConfig</strong></h2><h3 id="【事先准备】："><a href="#【事先准备】：" class="headerlink" title="【事先准备】："></a><strong>【事先准备】：</strong></h3><h4 id="方法、LoadRolePermissionService-调用—-gt-PermissionServiceImpl"><a href="#方法、LoadRolePermissionService-调用—-gt-PermissionServiceImpl" class="headerlink" title="方法、LoadRolePermissionService  调用—&gt; PermissionServiceImpl"></a><strong>方法、LoadRolePermissionService  调用—&gt; PermissionServiceImpl</strong></h4><p><strong>作用：从数据库中将url-&gt;角色对应关系加载到Redis中</strong></p><ul><li>**方法1:listRolePermission **</li><li><ul><li>先从数据库获取permissons</li><li>根据roleid从数据库中找权限数据</li><li>根据permissionid从数据库中找数据</li><li>到此为止，构造了每一个permission对应所需要的权限一共后续使用</li><li>简化一下，放入redis</li></ul></li></ul><h3 id="【1】AuthorizationServerConfig-继承—-gt-AuthorizationServerConfigurerAdapter"><a href="#【1】AuthorizationServerConfig-继承—-gt-AuthorizationServerConfigurerAdapter" class="headerlink" title="【1】AuthorizationServerConfig 继承—&gt; AuthorizationServerConfigurerAdapter"></a><strong>【1】AuthorizationServerConfig 继承—&gt; AuthorizationServerConfigurerAdapter</strong></h3><p><strong>作用：配置认证中心，就是授权服务器配置</strong></p><h4 id="方法1：-configure-ClientDetailsServiceConfigurer-clients"><a href="#方法1：-configure-ClientDetailsServiceConfigurer-clients" class="headerlink" title="方法1： configure(ClientDetailsServiceConfigurer clients)"></a><strong>方法1： configure(ClientDetailsServiceConfigurer clients)</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 配置客户端详情，并不是所有的客户端都能接入授权服务</span><br><span class="line"> * 用来配置客户端详情服务（ClientDetailsService），</span><br><span class="line"> * 客户端详情信息在这里进行初始化，</span><br><span class="line"> * 你能够把客户端详情信息写死在这里或者是通过数据库来存储调取详情信息</span><br><span class="line"> </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h5 id="一、重写configure-ClientDetailsServiceConfigurer-clients-方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的-，"><a href="#一、重写configure-ClientDetailsServiceConfigurer-clients-方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的-，" class="headerlink" title="**一、重写configure(ClientDetailsServiceConfigurer clients)方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的**，"></a>**一、<u>重写configure(ClientDetailsServiceConfigurer clients)方法主要配置客户端，就是告诉auth服务，我有什么客户，每一个客户又是什么样子的</u>**，</h5><ol><li>定义两个client_id，及客户端可以通过不同的client_id来获取不同的令牌；</li><li>client_id为test1的令牌有效时间为3600秒，client_id为test2的令牌有效时间为7200秒；</li><li>client_id为test1的refresh_token（下面会介绍到）有效时间为864000秒，即10天，也就是说在这10天内都可以通过refresh_token来换取新的令牌；</li><li>在获取client_id为test1的令牌的时候，scope只能指定为all，a，b或c中的某个值，否则将获取失败；</li><li>只能通过密码模式(password)来获取client_id为test1的令牌，而test2则无限制。</li></ol><h5 id="二、导入方法有以下几种："><a href="#二、导入方法有以下几种：" class="headerlink" title="二、导入方法有以下几种："></a><strong>二、导入方法有以下几种：</strong></h5><ul><li><strong>内存</strong>，自己测试的时候比较推荐，后续数据库啊什么的</li><li><strong>数据库</strong>，使用JdbcClientDetailsService，JdbcClientDetailsService自己是有一个默认的字段的表的，所以程序是从数据库中的oauth_client_details表中加载客户端信息，</li><li>总而言之，就是配置把客户端信息从数据源拿过来。后面需要授权验证，要用到，所以先配。</li></ul><h4 id="方法2：-configure-AuthorizationServerEndpointsConfigurer-endpoints-——"><a href="#方法2：-configure-AuthorizationServerEndpointsConfigurer-endpoints-——" class="headerlink" title="方法2： configure(AuthorizationServerEndpointsConfigurer endpoints)——"></a><strong>方法2： configure(AuthorizationServerEndpointsConfigurer endpoints)——</strong></h4><p>上面和客户端有关，而这个则直接和令牌有关，比如<u><strong>配置授权（authorization）</strong></u>以及<u><strong>令牌（token）的访问端点</strong></u>和<u><strong>令牌服务(token services)</strong></u>，还有一些其他的，比如异常啊什么的，下面有例子。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 配置令牌访问的端点</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>令牌端点可用于以编程方式请求令牌（非常重要，四种方式）,下面是配置的例子</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">endpoints</span><br><span class="line">        <span class="comment">//设置异常WebResponseExceptionTranslator，用于处理用户名，密码错误、授权类型不正确的异常</span></span><br><span class="line">        .exceptionTranslator(<span class="keyword">new</span> <span class="title class_">OAuthServerWebResponseExceptionTranslator</span>())</span><br><span class="line">        <span class="comment">//授权码模式所需要的authorizationCodeServices</span></span><br><span class="line">        .authorizationCodeServices(authorizationCodeServices())</span><br><span class="line">        <span class="comment">//密码模式所需要的authenticationManager</span></span><br><span class="line">        .authenticationManager(authenticationManager)</span><br><span class="line">        <span class="comment">//令牌管理服务，无论哪种模式都需要</span></span><br><span class="line">        .tokenServices(tokenServices())</span><br><span class="line">        <span class="comment">//添加进入tokenGranter</span></span><br><span class="line">        .tokenGranter(<span class="keyword">new</span> <span class="title class_">CompositeTokenGranter</span>(tokenGranters))</span><br><span class="line">        <span class="comment">//只允许POST提交访问令牌，uri：/oauth/token</span></span><br><span class="line">        .allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br></pre></td></tr></table></figure><h5 id="一、authenticationManager-（建议必须配置）-（密码授权管理器），见文件SecurityConfig这个配置类"><a href="#一、authenticationManager-（建议必须配置）-（密码授权管理器），见文件SecurityConfig这个配置类" class="headerlink" title="一、authenticationManager （建议必须配置）  （密码授权管理器），见文件SecurityConfig这个配置类"></a><strong>一、<u>authenticationManager （建议必须配置）  （密码授权管理器），见文件SecurityConfig这个配置类</u></strong></h5><ul><li>在Spring Security中，AuthenticationManager的默认实现是ProviderManager，而且它不直接自己处理认证请求，而是委托给其所配置的AuthenticationProvider列表，然后会依次使用每一个AuthenticationProvider进行认证，如果有一个AuthenticationProvider认证后的结果不为null，则表示该AuthenticationProvider已经认证成功，之后的AuthenticationProvider将不再继续认证。然后直接以该AuthenticationProvider的认证结果作为ProviderManager的认证结果。如果所有的AuthenticationProvider的认证结果都为null，则表示认证失败，将抛出一个ProviderNotFoundException。<br>校验认证请求最常用的方法是根据请求的用户名加载对应的UserDetails，然后比对UserDetails的密码与认证请求的密码是否一致，一致则表示认证通过。<br>Spring Security内部的DaoAuthenticationProvider就是使用的这种方式。其内部使用UserDetailsService来负责加载UserDetails。在认证成功以后会使用加载的UserDetails来封装要返回的Authentication对象，加载的UserDetails对象是包含用户权限等信息的。认证成功返回的Authentication对象将会保存在当前的SecurityContext中</li></ul><h5 id="二、令牌本身内容的配置（建议必须配置）"><a href="#二、令牌本身内容的配置（建议必须配置）" class="headerlink" title="二、令牌本身内容的配置（建议必须配置）"></a><u><strong>二、令牌本身内容的配置（建议必须配置）</strong></u></h5><h6 id="I、-两种方式，"><a href="#I、-两种方式，" class="headerlink" title="I、 两种方式，"></a><u><strong>I、 两种方式，</strong></u></h6><p>【1】直接在endpoint这里配。</p><p>【2】自己写个bean注入，举个例子：</p><h6 id="II、tokenServices-就在本文件注入-由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里"><a href="#II、tokenServices-就在本文件注入-由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里" class="headerlink" title="II、tokenServices()  就在本文件注入,由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里"></a><strong>II、tokenServices()</strong>  <strong>就在本文件注入,由于是授权服务，所以涉及到颁发令牌，那么有关令牌的管理，比如过期时间，是jwt还是什么格式，客户端存储策略，都在这里</strong></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public AuthorizationServerTokenServices tokenServices() &#123;</span><br><span class="line">    System.out.println(&quot;令牌管理服务的配置&quot;);</span><br><span class="line">    DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">    //客户端端配置策略</span><br><span class="line">    services.setClientDetailsService(clientDetailsService);</span><br><span class="line">    //支持令牌的刷新</span><br><span class="line">    services.setSupportRefreshToken(true);</span><br><span class="line">    //令牌服务</span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    //access_token的过期时间</span><br><span class="line">    services.setAccessTokenValiditySeconds(60 * 60 * 24 * 3);</span><br><span class="line">    //refresh_token的过期时间</span><br><span class="line">    services.setRefreshTokenValiditySeconds(60 * 60 * 24 * 3);</span><br><span class="line"></span><br><span class="line">    //设置令牌增强，使用JwtAccessTokenConverter进行转换</span><br><span class="line">    services.setTokenEnhancer(jwtAccessTokenConverter);</span><br><span class="line">    return services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt-自定义内容。"><a href="#III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt-自定义内容。" class="headerlink" title="III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt+自定义内容。"></a><strong><u>III、根据项目的要求去选择令牌的内容配置，一般来说都是jwt或者jwt+自定义内容。</u></strong></h6><ul><li><p>把令牌变成jwt格式很简单，按下面2两步操作即可，反正就是</p><ul><li><p>~~~<br>@Configuration<br>public class JWTokenConfig {</p><pre><code>@Beanpublic TokenStore jwtTokenStore() &#123;    return new JwtTokenStore(jwtAccessTokenConverter());&#125;@Beanpublic JwtAccessTokenConverter jwtAccessTokenConverter() &#123;    JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();    accessTokenConverter.setSigningKey(&quot;test_key&quot;); // 签名密钥    return accessTokenConverter;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* ~~~java</span><br><span class="line">      services.setTokenStore(tokenStore);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>自定义的话，同样简单，按下面的操作来做，无非就是先写一些配置，然后把配置注入adapter</p><ul><li>&#96;&#96;&#96;java<br>@Component<br>public class JwtTokenEnhancer implements TokenEnhancer {<br>@Override<br>public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {<br>    SecurityUser securityUser &#x3D; (SecurityUser) authentication.getPrincipal();<br>    Map&lt;String, Object&gt; info &#x3D; new HashMap&lt;&gt;();<br>    &#x2F;&#x2F;把用户ID设置到JWT中<br>    info.put(“id”, securityUser.getId());<br>    info.put(“client_id”,securityUser.getClientId());<br>    ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);<br>    return accessToken;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * ~~~</span><br><span class="line">    tokenEnhancer(enhancerChain)</span><br><span class="line">    ~~~</span><br><span class="line"></span><br><span class="line">##### **三、tokenGranter(new CompositeTokenGranter(tokenGranters))    自定义授权  非常重要**</span><br><span class="line"></span><br><span class="line">作用：自定义授权获取token，下面我们来看一看源码是怎么获取token的，在我们发起oauth/token，请求获取token时，实际上是请求Tokenpoint类的postAccessToken或者getacesstoken方法，相当于调用了一个controller方法，根据请求的方法是get还是post，但其实内部还是调用post的方法。</span><br><span class="line"></span><br><span class="line">在TokenEndPoint 获取令牌过程中, 有个这样的步骤:</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">OAuth2AccessToken token = getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">postAccessToken这个方法中，在这个方法的132行调用TokenGranter类的grant方法来获取token，**&lt;u&gt;这个方法也是最重要的&lt;/u&gt;**，通过这个方法我们可以对请求的参数进行校验是否合法，是否给予令牌。</span><br><span class="line"></span><br><span class="line">TokenGranter是一个接口，它有多个实现类，CompositeTokenGranter是其中之一，在grant方法中，会循环遍历所有的授权方式，根据请求参数携带的授权方式码，来匹配对应的授权处理实现类，调用实现类中的grant方法。那么关键点来了，请求参数中携带的是我们**&lt;u&gt;自定义的授权方式码&lt;/u&gt;**，如果要匹配上，那么首先我们要创建自定义的授权处理类，然后把这个授权处理类放入Spring Security默认的授权处理集合中，这样才能循环匹配上，进行下一步。</span><br><span class="line"></span><br><span class="line">和以前的做法一样：创建自定义授权处理类，我们可以继承TokenGranter来实现自定义的身份验证以便获取token，而AbstractTokenGranter是一个继承TokenGranter的实现类，一般我们都会继承这个类进行使用。这一点已经得到验证，可以看下面的流程。</span><br><span class="line"></span><br><span class="line">| 实现类                            | 对应的授权模式  |</span><br><span class="line">| --------------------------------- | --------------- |</span><br><span class="line">| AuthorizationCodeTokenGranter     | 授权码模式      |</span><br><span class="line">| ClientCredentialsTokenGranter     | 客户端模式      |</span><br><span class="line">| ImplicitTokenGranter              | implicit 模式   |</span><br><span class="line">| RefreshTokenGranter               | 刷新 token 模式 |</span><br><span class="line">| ResourceOwnerPasswordTokenGranter | 密码模式        |</span><br><span class="line"></span><br><span class="line">**这些类都继承了AbstractTokenGranter** </span><br><span class="line"></span><br><span class="line">**AbstractTokenGranter   调用-------&gt;getAccessToken --------&gt;getOAuth2Authentication**</span><br><span class="line"></span><br><span class="line">**根据 client、tokenRequest 从 OAuth2RequestFactory 中创建一个 OAuth2Request, 进而可得到 OAuth2Authentication (存放着用户的认证信息)。**</span><br><span class="line"></span><br><span class="line">**通过 tokenService 去创建 OAuth2AccessToken (存放着用户的 token信息、过期时间)。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### **I、————所以，这里加入自定的tokenGrant，也就是要自定义自己的授权方法 去 授权 自定义的令牌——————**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自定义至关重要的一点就是修改**getOAuth2Authentication**方法 （主要文件见sms文件夹和即可）</span><br><span class="line"></span><br><span class="line">具体修改不讲，修改的流程就是1、**组装自定义模式的认证信息** 2、**用authenticationManager去调用内部自定义的Provider认证这个认证信息，认证规则自然是写在Provider里面**。可借鉴 https://blog.csdn.net/m0_38031406/article/details/89316342</span><br><span class="line"></span><br><span class="line">###### **II、&lt;u&gt;所以实现方式：继承AbstractTokenGranter + 重写 getOAuth2Authentication方法。&lt;/u&gt;**</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">@Override</span><br><span class="line">protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) &#123;</span><br><span class="line">    Map&lt;String, String&gt; parameters = new LinkedHashMap&lt;&gt;(tokenRequest.getRequestParameters());</span><br><span class="line">    String mobile = parameters.get(&quot;mobile&quot;);</span><br><span class="line">    String password = parameters.get(&quot;password&quot;);</span><br><span class="line">    //将其中的密码移除</span><br><span class="line">    parameters.remove(&quot;password&quot;);</span><br><span class="line">    //自定义的token类</span><br><span class="line">    Authentication userAuth = new MobilePasswordAuthenticationToken(mobile, password);</span><br><span class="line"></span><br><span class="line">    ((AbstractAuthenticationToken) userAuth).setDetails(parameters);</span><br><span class="line">    //调用AuthenticationManager进行认证，内部会根据MobileAuthenticationToken找到对应的Provider进行认证</span><br><span class="line">    userAuth = authenticationManager.authenticate(userAuth);</span><br><span class="line">    if (userAuth == null || !userAuth.isAuthenticated()) &#123;</span><br><span class="line">        throw new InvalidGrantException(&quot;Could not authenticate mobile: &quot; + mobile);</span><br><span class="line">    &#125;</span><br><span class="line">    OAuth2Request storedOAuth2Request = getRequestFactory().createOAuth2Request(client, tokenRequest);</span><br><span class="line">    return new OAuth2Authentication(storedOAuth2Request, userAuth);</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">这里调用了AuthenticationManager认证，后面回调用自定义的XXXXXAuthenticationProvider</span><br><span class="line"></span><br><span class="line">###### **III、注入**</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">.tokenGranter(new CompositeTokenGranter(tokenGranters))</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **四、new OAuthServerWebResponseExceptionTranslator()**  也是自己配置的见文件夹**Exception**</span><br><span class="line"></span><br><span class="line">自定义异常翻译器，针对用户名、密码异常，授权类型不支持的异常进行处理-----**关键是用户**</span><br><span class="line"></span><br><span class="line">##### **五、authorizationCodeServices()就在本文件注入**</span><br><span class="line"></span><br><span class="line">##### **六、待续**。。。。。。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### **方法3： configure(AuthorizationServerSecurityConfigurer security)**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * 配置令牌访问的安全约束（）</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证"><a href="#一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证" class="headerlink" title="一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证"></a><strong>一、配置OAuthServerClientCredentialsTokenEndpointFilter——主要是客户端的验证</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 客户端异常处理</span></span><br><span class="line"><span class="comment"> * 自定义的客户端认证的过滤器，根据客户端的id、秘钥进行认证</span></span><br><span class="line"><span class="comment"> * 重写这个过滤器用于自定义异常处理</span></span><br><span class="line"><span class="comment"> * 具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;配置令牌访问的安全约束&quot;</span>);</span><br><span class="line">      <span class="comment">//自定义ClientCredentialsTokenEndpointFilter，用于处理客户端id，密码错误的异常</span></span><br><span class="line">        <span class="type">OAuthServerClientCredentialsTokenEndpointFilter</span> <span class="variable">endpointFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OAuthServerClientCredentialsTokenEndpointFilter</span>(security,authenticationEntryPoint);</span><br><span class="line">        endpointFilter.afterPropertiesSet();</span><br><span class="line">        security.addTokenEndpointAuthenticationFilter(endpointFilter);</span><br><span class="line"></span><br><span class="line">        security</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                <span class="comment">//开启/oauth/token_key验证端口权限访问</span></span><br><span class="line">                .tokenKeyAccess(<span class="string">&quot;permitAll()&quot;</span>)</span><br><span class="line">                <span class="comment">//开启/oauth/check_token验证端口认证权限访问</span></span><br><span class="line">                .checkTokenAccess(<span class="string">&quot;permitAll()&quot;</span>);</span><br><span class="line">                <span class="comment">//一定不要添加allowFormAuthenticationForClients，否则自定义的OAuthServerClientCredentialsTokenEndpointFilter不生效</span></span><br><span class="line"><span class="comment">//                .allowFormAuthenticationForClients();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制"><a href="#I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制" class="headerlink" title="I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制"></a><strong>I、具体认证的逻辑依然使用ClientCredentialsTokenEndpointFilter，只是设置一下AuthenticationEntryPoint为定制</strong></h6><p><strong>既然如此，我们就去看自定义的AuthenticationEntryPoint</strong>，这里没改，实际中可以改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OAuthServerAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证失败处理器会调用这个方法返回提示信息</span></span><br><span class="line"><span class="comment">     * TODO 实际开发中可以自己定义，此处直接返回JSON数据：客户端认证失败错误提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ResponseUtils.result(response,<span class="keyword">new</span> <span class="title class_">ResultMsg</span>(ResultCode.CLIENT_AUTHENTICATION_FAILED.getCode(),ResultCode.CLIENT_AUTHENTICATION_FAILED.getMsg(),<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="II、endpointFilter-afterPropertiesSet-认证成功怎么办，认真失败怎么办，这里可以自定义哈哈"><a href="#II、endpointFilter-afterPropertiesSet-认证成功怎么办，认真失败怎么办，这里可以自定义哈哈" class="headerlink" title="II、endpointFilter.afterPropertiesSet(); 认证成功怎么办，认真失败怎么办，这里可以自定义哈哈"></a><strong>II、endpointFilter.afterPropertiesSet();</strong> 认证成功怎么办，认真失败怎么办，这里可以自定义哈哈</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置AuthenticationEntryPoint主要逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;设置AuthenticationEntryPoint主要逻辑&quot;</span>);</span><br><span class="line">    <span class="comment">//TODO 定制认证失败处理器，开发中可以自己修改</span></span><br><span class="line">    setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">            exception = <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(exception.getMessage(), <span class="keyword">new</span> <span class="title class_">BadClientCredentialsException</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//成功处理器，和父类相同，为空即可。</span></span><br><span class="line">    setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="III、security-addTokenEndpointAuthenticationFilter-endpointFilter"><a href="#III、security-addTokenEndpointAuthenticationFilter-endpointFilter" class="headerlink" title="III、security.addTokenEndpointAuthenticationFilter(endpointFilter);"></a><strong>III、security.addTokenEndpointAuthenticationFilter(endpointFilter);</strong></h6><ul><li>注入 自定义相应异常的过滤链</li></ul><h2 id="2、springconfig"><a href="#2、springconfig" class="headerlink" title="2、springconfig"></a><strong>2、springconfig</strong></h2><h3 id="介绍一个比较完整的securityconfig配置"><a href="#介绍一个比较完整的securityconfig配置" class="headerlink" title="介绍一个比较完整的securityconfig配置"></a><strong>介绍一个比较完整的securityconfig配置</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//开启判断用户对某个控制层的方法是否具有访问权限的功能</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//注入自定义的UserDetailService</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsServiceImpl userDetailsServiceImpl;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换默认AuthenticationManager中的UserDetailService，使用数据库用户认证方式登录</span></span><br><span class="line">    <span class="comment">//1. 一旦通过 configure 方法自定义 AuthenticationManager实现 就回将工厂中自动配置AuthenticationManager 进行覆盖</span></span><br><span class="line">    <span class="comment">//2. 一旦通过 configure 方法自定义 AuthenticationManager实现 需要在实现中指定认证数据源对象 UserDetailService 实例</span></span><br><span class="line">    <span class="comment">//3. 一旦通过 configure 方法自定义 AuthenticationManager实现 这种方式创建AuthenticationManager对象工厂内部本地一个 AuthenticationManager 对象 不允许在其他自定义组件中进行注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder builder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        builder.userDetailsService(userDetailsServiceImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BCryptPasswordEncoder相关知识：</span></span><br><span class="line"><span class="comment">     * 用户表的密码通常使用MD5等不可逆算法加密后存储，为防止彩虹表破解更会先使用一个特定的字符串（如域名）加密，然后再使用一个随机的salt（盐值）加密。</span></span><br><span class="line"><span class="comment">     * 特定字符串是程序代码中固定的，salt是每个密码单独随机，一般给用户表加一个字段单独存储，比较麻烦。</span></span><br><span class="line"><span class="comment">     * BCrypt算法将salt随机并混入最终加密后的密码，验证时也无需单独提供之前的salt，从而无需单独处理salt问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将自定义AuthenticationManager在工厂中进行暴露,可以在任何位置注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HttpSecurity配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.cors(withDefaults())</span><br><span class="line">                <span class="comment">// 禁用 CSRF</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 指定的接口直接放行</span></span><br><span class="line">                <span class="comment">// swagger</span></span><br><span class="line">                .antMatchers(SecurityConstants.SWAGGER_WHITELIST).permitAll()</span><br><span class="line">                .antMatchers(SecurityConstants.H2_CONSOLE).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, SecurityConstants.SYSTEM_WHITELIST).permitAll()</span><br><span class="line">                <span class="comment">// 其他的接口都需要认证后才能请求</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//添加自定义Filter</span></span><br><span class="line">                .addFilter(<span class="keyword">new</span> <span class="title class_">JwtAuthorizationFilter</span>(authenticationManager(), stringRedisTemplate))</span><br><span class="line">                <span class="comment">// 不需要session（不创建会话）</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                <span class="comment">// 授权异常处理</span></span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                <span class="comment">// json提示用户没有登录不需要用户跳转到登录页面去</span></span><br><span class="line">                .authenticationEntryPoint(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationEntryPoint</span>())</span><br><span class="line">                <span class="comment">// 权限拦截器，提示用户没有当前权限</span></span><br><span class="line">                .accessDeniedHandler(<span class="keyword">new</span> <span class="title class_">JwtAccessDeniedHandler</span>());</span><br><span class="line">        <span class="comment">// 防止H2 web 页面的Frame 被拦截</span></span><br><span class="line">        http.headers().frameOptions().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cors配置优化</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">        org.springframework.web.cors.<span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        configuration.setAllowedOrigins(singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="comment">// configuration.setAllowedOriginPatterns(singletonList(&quot;*&quot;));</span></span><br><span class="line">        configuration.setAllowedHeaders(singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line">        configuration.setExposedHeaders(singletonList(SecurityConstants.TOKEN_HEADER));</span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">false</span>);</span><br><span class="line">        configuration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="鉴权服务"><a href="#鉴权服务" class="headerlink" title="鉴权服务"></a>鉴权服务</h1><p>和授权服务，许多程序都是围绕着配置类进行的，所以我们直接看配置类</p><h2 id="【1】AccessTokenConfig-令牌的一些配置"><a href="#【1】AccessTokenConfig-令牌的一些配置" class="headerlink" title="【1】AccessTokenConfig  令牌的一些配置"></a><strong>【1】AccessTokenConfig</strong>  令牌的一些配置</h2><ul><li>和授权服务一致，因为令牌要从授权服务到网关，再到客户端，不管是为了现在的还是后续的操作，最好配置，当然，用不到也可以不配，看你用不用得到。</li></ul><h2 id="【2】JwtAuthenticationManager-token认证管理器"><a href="#【2】JwtAuthenticationManager-token认证管理器" class="headerlink" title="【2】JwtAuthenticationManager token认证管理器"></a><strong>【2】JwtAuthenticationManager token认证管理器</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 公众号：码猿技术专栏</span></span><br><span class="line"><span class="comment"> * JWT认证管理器，主要的作用就是对携带过来的token进行校验，比如过期时间，加密方式等</span></span><br><span class="line"><span class="comment"> * 一旦token校验通过，则交给鉴权管理器进行鉴权</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Authentication&gt; <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;第六步***来到JWT认证管理器 检验token&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Mono.justOrEmpty(authentication)</span><br><span class="line">            .filter(a -&gt; a <span class="keyword">instanceof</span> BearerTokenAuthenticationToken)</span><br><span class="line">            .cast(BearerTokenAuthenticationToken.class)</span><br><span class="line">            .map(BearerTokenAuthenticationToken::getToken)</span><br><span class="line">            .flatMap((accessToken -&gt; &#123;</span><br><span class="line">                <span class="type">OAuth2AccessToken</span> <span class="variable">oAuth2AccessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.tokenStore.readAccessToken(accessToken);</span><br><span class="line">                <span class="comment">//根据access_token从数据库获取不到OAuth2AccessToken</span></span><br><span class="line">                <span class="keyword">if</span> (oAuth2AccessToken == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;无效的token！&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oAuth2AccessToken.isExpired()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;token已过期！&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">OAuth2Authentication</span> <span class="variable">oAuth2Authentication</span> <span class="operator">=</span> <span class="built_in">this</span>.tokenStore.readAuthentication(accessToken);</span><br><span class="line">                <span class="keyword">if</span> (oAuth2Authentication == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(<span class="string">&quot;无效的token！&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.just(oAuth2Authentication);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)).cast(Authentication.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【3】JwtAccessManagerV2——-认证管理器自定义"><a href="#【3】JwtAccessManagerV2——-认证管理器自定义" class="headerlink" title="【3】JwtAccessManagerV2——-认证管理器自定义"></a><strong>【3】JwtAccessManagerV2——-认证管理器自定义</strong></h2><ul><li>作用：认证管理的作用就是获取传递过来的令牌，对其进行解析、验签、过期时间判定。就是作为的鉴权</li><li>获取调用方法【get&#x2F;post…】+uri.getPath()  合成完整路径例如：【uri.getPath()】</li><li>从redis里面获取获取所有的uri-&gt;角色对应关系</li><li>去链接里面找到和自己这次申请链接完全一致的那一个键值对，而这个键值对的值恰恰就是【权限集合】</li><li>把自己的权限先从mono中解析出来，然后匹配，如果超级管理员，放行；如果存在交集，则通过；否则失败</li></ul><p>异常</p><ul><li><p>RequestAuthenticationEntryPoint</p><ul><li>用于处理没有登录或token过期时的自定义返回结果</li></ul></li><li><p>RequestAccessDeniedHandler</p><ul><li>自定义返回结果：没有权限访问时</li></ul></li><li><p>RequestAuthenticationEntryPoint</p><ul><li>用于处理没有登录或token过期时的自定义返回结果</li></ul></li></ul><h2 id="【4】-SecurityConfig-在webflux中使用security"><a href="#【4】-SecurityConfig-在webflux中使用security" class="headerlink" title="【4】 SecurityConfig  在webflux中使用security"></a><strong>【4】 SecurityConfig  在webflux中使用security</strong></h2><h3 id="1、webFluxSecurityFilterChain——把之前的配置整合链路"><a href="#1、webFluxSecurityFilterChain——把之前的配置整合链路" class="headerlink" title="1、webFluxSecurityFilterChain——把之前的配置整合链路"></a><strong>1、webFluxSecurityFilterChain——把之前的配置整合链路</strong></h3><ul><li><strong>这里使用的是webFluxSecurityFilterChain</strong></li><li>http下的功能可以借鉴<a href="http://events.jianshu.io/p/8ad366b97e18">http://events.jianshu.io/p/8ad366b97e18</a></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    SecurityWebFilterChain webFluxSecurityFilterChain(ServerHttpSecurity http) throws Exception&#123;</span><br><span class="line">    //认证过滤器，放入认证管理器tokenAuthenticationManager</span><br><span class="line">    AuthenticationWebFilter authenticationWebFilter = new AuthenticationWebFilter(tokenAuthenticationManager);</span><br><span class="line">    System.out.println(&quot;认证过滤器，放入认证管理器tokenAuthenticationManager&quot;);</span><br><span class="line">    authenticationWebFilter.setServerAuthenticationConverter(new ServerBearerTokenAuthenticationConverter());</span><br><span class="line"></span><br><span class="line">    http</span><br><span class="line">            .httpBasic().disable()</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .authorizeExchange()</span><br><span class="line">            //白名单直接放行</span><br><span class="line">            .pathMatchers(ArrayUtil.toArray(sysConfig.getIgnoreUrls(),String.class)).permitAll()</span><br><span class="line">            //其他的请求必须鉴权，使用鉴权管理器</span><br><span class="line">            .anyExchange().access(accessManager)</span><br><span class="line">            //鉴权的异常处理，权限不足，token失效</span><br><span class="line">            .and().exceptionHandling()</span><br><span class="line">            .authenticationEntryPoint(requestAuthenticationEntryPoint)</span><br><span class="line">            .accessDeniedHandler(requestAccessDeniedHandler)</span><br><span class="line">            .and()</span><br><span class="line">            // 跨域过滤器</span><br><span class="line">            .addFilterAt(corsFilter, SecurityWebFiltersOrder.CORS)</span><br><span class="line">            //token的认证过滤器，用于校验token和认证</span><br><span class="line">            .addFilterAt(authenticationWebFilter, SecurityWebFiltersOrder.AUTHENTICATION);</span><br><span class="line">    return http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一、加入了【2】的自定义令牌认证管理器"><a href="#一、加入了【2】的自定义令牌认证管理器" class="headerlink" title="一、加入了【2】的自定义令牌认证管理器"></a><strong>一、加入了【2】的自定义令牌认证管理器</strong></h4><h4 id="二、加入了【3】的鉴权管理器"><a href="#二、加入了【3】的鉴权管理器" class="headerlink" title="二、加入了【3】的鉴权管理器"></a><strong>二、加入了【3】的鉴权管理器</strong></h4><h3 id="2、白名单放行"><a href="#2、白名单放行" class="headerlink" title="**2、白名单放行 **"></a>**2、白名单放行 **</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//白名单直接放行</span><br><span class="line">.pathMatchers(ArrayUtil.toArray(sysConfig.getIgnoreUrls(),String.class)).permitAll()</span><br><span class="line">//其他的请求必须鉴权，使用鉴权管理器</span><br><span class="line">.anyExchange().access(accessManager)</span><br></pre></td></tr></table></figure><h3 id="3、鉴权的异常处理"><a href="#3、鉴权的异常处理" class="headerlink" title="3、鉴权的异常处理"></a><strong>3、鉴权的异常处理</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//鉴权的异常处理，权限不足，token失效</span><br><span class="line">.and().exceptionHandling()</span><br><span class="line">.authenticationEntryPoint(requestAuthenticationEntryPoint)</span><br><span class="line">.accessDeniedHandler(requestAccessDeniedHandler)</span><br></pre></td></tr></table></figure><h1 id="异常配置"><a href="#异常配置" class="headerlink" title="异常配置"></a>异常配置</h1><h2 id="【1】认证服务的异常"><a href="#【1】认证服务的异常" class="headerlink" title="【1】认证服务的异常"></a>【1】认证服务的异常</h2><ul><li>用户名，密码错误异常、授权类型异常</li><li>客户端ID、秘钥异常</li></ul><h3 id="1、用户名，密码错误异常、授权类型异常"><a href="#1、用户名，密码错误异常、授权类型异常" class="headerlink" title="1、用户名，密码错误异常、授权类型异常"></a><strong>1、用户名，密码错误异常、授权类型异常</strong></h3><p>针对用户名、密码、授权类型错误的异常解决方式比较复杂，需要定制的比较多。</p><h4 id="一、定制提示信息、响应码"><a href="#一、定制提示信息、响应码" class="headerlink" title="一、定制提示信息、响应码"></a><strong>一、定制提示信息、响应码</strong></h4><p>这部分根据自己业务需要定制，举个例子，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    CLIENT_AUTHENTICATION_FAILED(<span class="number">1001</span>,<span class="string">&quot;客户端认证失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    USERNAME_OR_PASSWORD_ERROR(<span class="number">1002</span>,<span class="string">&quot;用户名或密码错误&quot;</span>),</span><br><span class="line"></span><br><span class="line">    UNSUPPORTED_GRANT_TYPE(<span class="number">1003</span>, <span class="string">&quot;不支持的认证模式&quot;</span>),</span><br><span class="line"></span><br><span class="line">    NO_PERMISSION(<span class="number">1005</span>,<span class="string">&quot;无权限访问！&quot;</span>),</span><br><span class="line">    UNAUTHORIZED(<span class="number">401</span>, <span class="string">&quot;系统错误&quot;</span>),</span><br><span class="line"></span><br><span class="line">    INVALID_TOKEN(<span class="number">1004</span>,<span class="string">&quot;无效的token&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="二、自定义WebResponseExceptionTranslator"><a href="#二、自定义WebResponseExceptionTranslator" class="headerlink" title="二、自定义WebResponseExceptionTranslator"></a><strong>二、自定义WebResponseExceptionTranslator</strong></h4><ul><li><p>需要自定义一个异常翻译器，默认的是<strong>DefaultWebResponseExceptionTranslator</strong>，此处必须重写，其中有一个需要实现的方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;T&gt; <span class="title function_">translate</span><span class="params">(Exception e)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure><p>这个方法就是根据传递过来的<strong>Exception</strong>判断不同的异常返回特定的信息，这里需要判断的异常的如下：</p><ul><li><strong>UnsupportedGrantTypeException</strong>：不支持的授权类型异常</li><li><strong>InvalidGrantException</strong>：用户名或者密码错误的异常</li></ul></li><li><p>创建一个<strong>OAuthServerWebResponseExceptionTranslator</strong>实现<strong>WebResponseExceptionTranslator</strong>，代码如下：</p></li><li><p>&#96;&#96;&#96;java<br>public class OAuthServerWebResponseExceptionTranslator implements WebResponseExceptionTranslator{<br>&#x2F;**<br> * 业务处理方法，重写这个方法返回客户端信息<br> <em>&#x2F;<br>@Override<br>public ResponseEntity<ResultMsg> translate(Exception e){<br>    ResultMsg resultMsg &#x3D; doTranslateHandler(e);<br>    return new ResponseEntity&lt;&gt;(resultMsg, HttpStatus.UNAUTHORIZED);<br>}<br><br>&#x2F;</em>*<br> * 根据异常定制返回信息<br> * TODO 自己根据业务封装<br> *&#x2F;<br>private ResultMsg doTranslateHandler(Exception e) {<br>    &#x2F;&#x2F;初始值，系统错误，<br>    ResultCode resultCode &#x3D; ResultCode.UNAUTHORIZED;<br>    &#x2F;&#x2F;判断异常，不支持的认证方式<br>    if(e instanceof UnsupportedGrantTypeException){<br>        resultCode &#x3D; ResultCode.UNSUPPORTED_GRANT_TYPE;<br>        &#x2F;&#x2F;用户名或密码异常<br>    }else if(e instanceof InvalidGrantException){<br>        resultCode &#x3D; ResultCode.USERNAME_OR_PASSWORD_ERROR;<br>    }<br>    return new ResultMsg(resultCode.getCode(),resultCode.getMsg(),null);<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### **三、认证服务配置文件中配置**</span><br><span class="line"></span><br><span class="line">需要将自定义的异常翻译器**OAuthServerWebResponseExceptionTranslator**在配置文件中配置，很简单，一行代码的事。</span><br><span class="line"></span><br><span class="line">在**AuthorizationServerConfig**配置文件指定，代码如下：</span><br><span class="line"></span><br><span class="line">![image-20220906203102659](C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203102659.png)</span><br><span class="line"></span><br><span class="line">#### **四、这么配置的原因**</span><br><span class="line"></span><br><span class="line">* 我们知道获取令牌的接口为 **/oauth/token**，这个接口定义在**TokenEndpoint#postAccessToken()**（POST请求）方法中，如下图</span><br><span class="line">* ![image-20220906203752062](C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203752062.png)</span><br><span class="line">* 是不是都继承了**OAuth2Exception**，那么尝试在**TokenEndpoint**这个类中找找有没有处理**OAuth2Exception**这个异常的处理器，果然找到了一个 **handleException()** 方法，如下：</span><br><span class="line">* ![image-20220906203840232](C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220906203840232.png)</span><br><span class="line">* 可以看到，这里的异常翻译器已经使用了我们自定义的**OAuthServerWebResponseExceptionTranslator**。可以看下默认的异常翻译器是啥，代码如下：</span><br><span class="line"></span><br><span class="line">### **2、客户端ID、秘钥异常**</span><br><span class="line"></span><br><span class="line">这部分比较复杂，想要理解还是需要些基础的，解决这个异常的方案很多，陈某只是介绍其中一种，下面详细介绍。</span><br><span class="line"></span><br><span class="line">#### **一、定制提示信息、响应码**</span><br><span class="line"></span><br><span class="line">这部分根据自己业务需要定制，和第一步一样。</span><br><span class="line"></span><br><span class="line">#### **二、自定义AuthenticationEntryPoint**</span><br><span class="line"></span><br><span class="line">这个**AuthenticationEntryPoint**是不是很熟悉，前面的文章已经介绍过了，此处需要自定义来返回定制的提示信息。</span><br><span class="line"></span><br><span class="line">创建**OAuthServerAuthenticationEntryPoint**，实现AuthenticationEntryPoint，重写其中的方法，代码如下：</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  public class OAuthServerAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line">  </span><br><span class="line">      /**</span><br><span class="line">       * 认证失败处理器会调用这个方法返回提示信息</span><br><span class="line">       * TODO 实际开发中可以自己定义，此处直接返回JSON数据：客户端认证失败错误提示</span><br><span class="line">       */</span><br><span class="line">      @Override</span><br><span class="line">      public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException &#123;</span><br><span class="line">          ResponseUtils.result(response,new ResultMsg(ResultCode.CLIENT_AUTHENTICATION_FAILED.getCode(),ResultCode.CLIENT_AUTHENTICATION_FAILED.getMsg(),null));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="三、改造ClientCredentialsTokenEndpointFilter"><a href="#三、改造ClientCredentialsTokenEndpointFilter" class="headerlink" title="三、改造ClientCredentialsTokenEndpointFilter"></a><strong>三、改造ClientCredentialsTokenEndpointFilter</strong></h4><p><strong>ClientCredentialsTokenEndpointFilter</strong>这个过滤器的主要作用就是校验客户端的ID、秘钥，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuthServerClientCredentialsTokenEndpointFilter extends ClientCredentialsTokenEndpointFilter &#123;</span><br><span class="line"></span><br><span class="line">    private final AuthorizationServerSecurityConfigurer configurer;</span><br><span class="line"></span><br><span class="line">    private AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     * @param configurer AuthorizationServerSecurityConfigurer对昂</span><br><span class="line">     * @param authenticationEntryPoint 自定义的AuthenticationEntryPoint</span><br><span class="line">     */</span><br><span class="line">    public OAuthServerClientCredentialsTokenEndpointFilter(AuthorizationServerSecurityConfigurer configurer, AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">        System.out.println(&quot;自定义的客户端认证的过滤器的构造方法&quot;);</span><br><span class="line">        this.configurer = configurer;</span><br><span class="line">        this.authenticationEntryPoint=authenticationEntryPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setAuthenticationEntryPoint(AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">        System.out.println(&quot;setAuthenticationEntryPoint&quot;);</span><br><span class="line">        this.authenticationEntryPoint = authenticationEntryPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 需要重写这个方法，返回AuthenticationManager</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationManager getAuthenticationManager() &#123;</span><br><span class="line">        System.out.println(&quot;getAuthenticationManager&quot;);</span><br><span class="line">        return configurer.and().getSharedObject(AuthenticationManager.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置AuthenticationEntryPoint主要逻辑</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        System.out.println(&quot;设置AuthenticationEntryPoint主要逻辑&quot;);</span><br><span class="line">        //TODO 定制认证失败处理器，开发中可以自己修改</span><br><span class="line">        setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;</span><br><span class="line">            if (exception instanceof BadCredentialsException) &#123;</span><br><span class="line">                exception = new BadCredentialsException(exception.getMessage(), new BadClientCredentialsException());</span><br><span class="line">            &#125;</span><br><span class="line">            authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">        &#125;);</span><br><span class="line">        //成功处理器，和父类相同，为空即可。</span><br><span class="line">        setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个重要的部分需要讲一下，如下：</p><ul><li>构造方法中需要传入第2步自定义的 <strong>OAuthServerAuthenticationEntryPoint</strong></li><li>重写 <strong>getAuthenticationManager()</strong> 方法返回IOC中的AuthenticationManager</li><li>重写<strong>afterPropertiesSet()</strong> 方法，用于自定义认证失败、成功处理器，失败处理器中调用<strong>OAuthServerAuthenticationEntryPoint</strong>进行异常提示信息返回</li></ul><h4 id="四、OAuth配置文件中指定过滤器"><a href="#四、OAuth配置文件中指定过滤器" class="headerlink" title="四、OAuth配置文件中指定过滤器"></a><strong>四、OAuth配置文件中指定过滤器</strong></h4><p>只需要将自定义的过滤器添加到<strong>AuthorizationServerSecurityConfigurer</strong>中，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) &#123;</span><br><span class="line">        System.out.println(&quot;配置令牌访问的安全约束&quot;);</span><br><span class="line">        //自定义ClientCredentialsTokenEndpointFilter，用于处理客户端id，密码错误的异常</span><br><span class="line">        ①OAuthServerClientCredentialsTokenEndpointFilter endpointFilter = new OAuthServerClientCredentialsTokenEndpointFilter(security,authenticationEntryPoint);</span><br><span class="line">       ① endpointFilter.afterPropertiesSet();</span><br><span class="line">        ①security.addTokenEndpointAuthenticationFilter(endpointFilter);</span><br><span class="line"></span><br><span class="line">        security</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                //开启/oauth/token_key验证端口权限访问</span><br><span class="line">                .tokenKeyAccess(&quot;permitAll()&quot;)</span><br><span class="line">                //开启/oauth/check_token验证端口认证权限访问</span><br><span class="line">                .checkTokenAccess(&quot;permitAll()&quot;);</span><br><span class="line">               ② //一定不要添加allowFormAuthenticationForClients，否则自定义的OAuthServerClientCredentialsTokenEndpointFilter不生效</span><br><span class="line">//                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第<strong>①</strong>部分是添加过滤器，其中<strong>authenticationEntryPoint</strong>使用的是第2步自定义的<strong>OAuthServerAuthenticationEntryPoint</strong></p><p>第<strong>②</strong>部分一定要注意：一定要去掉这行代码，具体原因源码解释。</p><h4 id="五、源码追踪"><a href="#五、源码追踪" class="headerlink" title="五、源码追踪"></a><strong>五、源码追踪</strong></h4><h6 id="I、OAuthServerAuthenticationEntryPoint在何时调用？"><a href="#I、OAuthServerAuthenticationEntryPoint在何时调用？" class="headerlink" title="I、OAuthServerAuthenticationEntryPoint在何时调用？"></a><strong>I、OAuthServerAuthenticationEntryPoint在何时调用？</strong></h6><p>OAuthServerAuthenticationEntryPoint这个过滤器继承了 <strong>AbstractAuthenticationProcessingFilter</strong> 这个抽象类，一切的逻辑都在 <strong>doFilter()</strong> 中，陈某简化了其中的关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)</span><br><span class="line">throws IOException, ServletException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //调用子类的attemptAuthentication方法，获取参数并且认证</span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line">&#125;</span><br><span class="line">catch (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">            //一旦认证异常，则调用unsuccessfulAuthentication方法，通过failureHandler处理</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">catch (AuthenticationException failed) &#123;</span><br><span class="line">            //一旦认证异常，则调用unsuccessfulAuthentication方法，通过failureHandler处理</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//认证成功，则调用successHandler处理</span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码在 <strong>unsuccessfulAuthentication()</strong> 这个方法中，代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;</span><br><span class="line">    SecurityContextHolder.clearContext();</span><br><span class="line">    if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">        this.logger.debug(&quot;Authentication request failed: &quot; + failed.toString(), failed);</span><br><span class="line">        this.logger.debug(&quot;Updated SecurityContextHolder to contain null Authentication&quot;);</span><br><span class="line">        this.logger.debug(&quot;Delegating to authentication failure handler &quot; + this.failureHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.rememberMeServices.loginFail(request, response);</span><br><span class="line">    this.failureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="II、自定义的过滤器如何生效的？"><a href="#II、自定义的过滤器如何生效的？" class="headerlink" title="II、自定义的过滤器如何生效的？"></a><strong>II、自定义的过滤器如何生效的？</strong></h6><p>这个就要看 <strong>AuthorizationServerSecurityConfigurer#configure()</strong> 这个方法了，其中有一段代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(var2.hasNext()) &#123;</span><br><span class="line">    Filter filter = (Filter)var2.next();</span><br><span class="line">    http.addFilterBefore(filter, BasicAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，我们自定义的过滤链被加到了BasicAuthenticationFilter里面</p><h6 id="III、为什么不能加-allowFormAuthenticationForClients-？"><a href="#III、为什么不能加-allowFormAuthenticationForClients-？" class="headerlink" title="III、为什么不能加.allowFormAuthenticationForClients()？"></a><strong>III、为什么不能加.allowFormAuthenticationForClients()？</strong></h6><p>还是在 <strong>AuthorizationServerSecurityConfigurer#configure()</strong> 这个方法中，一旦设置了 <strong>allowFormAuthenticationForClients</strong> 为true，则会创建 <strong>ClientCredentialsTokenEndpointFilter</strong>，此时自定义的自然失效了。</p><h2 id="【2】资源服务自定义异常信息"><a href="#【2】资源服务自定义异常信息" class="headerlink" title="【2】资源服务自定义异常信息"></a><strong>【2】资源服务自定义异常信息</strong></h2><p>下面针对上述两种异常分别定制异常提示信息，这个比认证服务定制简单。</p><h3 id="1、自定义返回结果：没有权限访问时"><a href="#1、自定义返回结果：没有权限访问时" class="headerlink" title="1、自定义返回结果：没有权限访问时"></a><strong>1、自定义返回结果：没有权限访问时</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">ServerAccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange, AccessDeniedException denied)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;RequestAccessDeniedHandler&quot;</span>);</span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.OK);</span><br><span class="line">        response.getHeaders().add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        System.out.println(<span class="string">&quot;wuquan2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String body= JSONUtil.toJsonStr(<span class="keyword">new</span> <span class="title class_">ResultMsg</span>(ResultCode.NO_PERMISSION.getCode(),ResultCode.NO_PERMISSION.getMsg(),<span class="literal">null</span>));</span><br><span class="line">        <span class="type">DataBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span>  response.bufferFactory().wrap(body.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、用于处理没有登录或token过期时的自定义返回结果"><a href="#2、用于处理没有登录或token过期时的自定义返回结果" class="headerlink" title="2、用于处理没有登录或token过期时的自定义返回结果"></a><strong>2、用于处理没有登录或token过期时的自定义返回结果</strong></h3><h1 id="令牌配置"><a href="#令牌配置" class="headerlink" title="令牌配置"></a>令牌配置</h1><h2 id="【1】令牌本身的配置"><a href="#【1】令牌本身的配置" class="headerlink" title="【1】令牌本身的配置"></a>【1】令牌本身的配置</h2><ul><li>令牌相关的配置都放在了AccessTokenConfig这个配置类中，代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 令牌的存储策略</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public TokenStore tokenStore() &#123;</span><br><span class="line">        //使用JwtTokenStore生成JWT令牌</span><br><span class="line">        return new JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JwtAccessTokenConverter</span><br><span class="line">     * TokenEnhancer的子类，在JWT编码的令牌值和OAuth身份验证信息之间进行转换。</span><br><span class="line">     * TODO：后期可以使用非对称加密</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAccessTokenConverter jwtAccessTokenConverter()&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = new JwtAccessTokenEnhancer();</span><br><span class="line">        // 设置秘钥</span><br><span class="line">        converter.setSigningKey(TokenConstant.SIGN_KEY);</span><br><span class="line">        /*</span><br><span class="line">         * 设置自定义得的令牌转换器，从map中转换身份信息</span><br><span class="line">         * fix(*)：修复刷新令牌无法获取用户详细信息的问题</span><br><span class="line">         */</span><br><span class="line">        converter.setAccessTokenConverter(new JwtEnhanceAccessTokenConverter());</span><br><span class="line">        return converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JWT令牌增强，继承JwtAccessTokenConverter</span><br><span class="line">     * 将业务所需的额外信息放入令牌中，这样下游微服务就能解析令牌获取</span><br><span class="line">     */</span><br><span class="line">    public static class JwtAccessTokenEnhancer extends JwtAccessTokenConverter &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 重写enhance方法，在其中扩展</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) &#123;</span><br><span class="line">            Object principal = authentication.getUserAuthentication().getPrincipal();</span><br><span class="line">            if (principal instanceof SecurityUser)&#123;</span><br><span class="line">                //获取userDetailService中查询到用户信息</span><br><span class="line">                SecurityUser user=(SecurityUser)principal;</span><br><span class="line">                //将额外的信息放入到LinkedHashMap中</span><br><span class="line">                LinkedHashMap&lt;String,Object&gt; extendInformation=new LinkedHashMap&lt;&gt;();</span><br><span class="line">                //设置用户的userId</span><br><span class="line">                extendInformation.put(TokenConstant.USER_ID,user.getUserId());</span><br><span class="line">                //添加到additionalInformation</span><br><span class="line">                ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(extendInformation);</span><br><span class="line">            &#125;</span><br><span class="line">            return super.enhance(accessToken, authentication);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>1、JwtAccessTokenConverter</strong></li></ul><p>令牌增强类，用于JWT令牌和OAuth身份进行转换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public JwtAccessTokenConverter jwtAccessTokenConverter()&#123;</span><br><span class="line">    JwtAccessTokenConverter converter = new JwtAccessTokenEnhancer();</span><br><span class="line">    // 设置秘钥</span><br><span class="line">    converter.setSigningKey(TokenConstant.SIGN_KEY);</span><br><span class="line">    /*</span><br><span class="line">     * 设置自定义得的令牌转换器，从map中转换身份信息</span><br><span class="line">     * fix(*)：修复刷新令牌无法获取用户详细信息的问题</span><br><span class="line">     */</span><br><span class="line">    converter.setAccessTokenConverter(new JwtEnhanceAccessTokenConverter());</span><br><span class="line">    return converter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>2、TokenStore</strong></li></ul><p>令牌的存储策略，这里使用的是JwtTokenStore，使用JWT的令牌生成方式，其实还有以下两个比较常用的方式</p><ul><li><ul><li>RedisTokenStore：将令牌存储到Redis中，此种方式相对于内存方式来说性能更好</li><li>JdbcTokenStore：将令牌存储到数据库中，需要新建从对应的表，有兴趣的可以尝试</li></ul></li><li><p><strong>3</strong>、<strong>SIGN_KEY</strong></p></li></ul><p>JWT签名的秘钥，这里使用的是对称加密，资源服务中也要使用相同的秘钥进行校验和解析JWT令牌。</p><h2 id="【2】令牌管理服务的配置"><a href="#【2】令牌管理服务的配置" class="headerlink" title="【2】令牌管理服务的配置"></a>【2】令牌管理服务的配置</h2><p><strong>这个放在了AuthorizationServerConfig这个配置类中，代码如下：</strong></p><ul><li><strong>使用的是DefaultTokenServices这个实现类，其中可以配置令牌相关的内容，比如access_token、refresh_token的过期时间，默认时间分别为12小时、30天。</strong></li><li><strong>最重要的一行代码当然是设置令牌增强，使用JWT方式生产令牌，如下：services.setTokenEnhancer(jwtAccessTokenConverter);</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> AuthorizationServerTokenServices <span class="title function_">tokenServices</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;令牌管理服务的配置&quot;</span>);</span><br><span class="line">    <span class="type">DefaultTokenServices</span> <span class="variable">services</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTokenServices</span>();</span><br><span class="line">    <span class="comment">//客户端端配置策略</span></span><br><span class="line">    services.setClientDetailsService(clientDetailsService);</span><br><span class="line">    <span class="comment">//支持令牌的刷新</span></span><br><span class="line">    services.setSupportRefreshToken(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//令牌服务</span></span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    <span class="comment">//access_token的过期时间</span></span><br><span class="line">    services.setAccessTokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//refresh_token的过期时间</span></span><br><span class="line">    services.setRefreshTokenValiditySeconds(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置令牌增强，使用JwtAccessTokenConverter进行转换</span></span><br><span class="line">    services.setTokenEnhancer(jwtAccessTokenConverter);</span><br><span class="line">    <span class="keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【3】、令牌访问端点添加tokenServices"><a href="#【3】、令牌访问端点添加tokenServices" class="headerlink" title="【3】、令牌访问端点添加tokenServices"></a>【3】、令牌访问端点添加tokenServices</h2><h1 id="前置知识：security"><a href="#前置知识：security" class="headerlink" title="前置知识：security"></a>前置知识：security</h1><h2 id="security的核心，Spring-Security使用了springSecurityFilterChain作为了安全过滤的入口"><a href="#security的核心，Spring-Security使用了springSecurityFilterChain作为了安全过滤的入口" class="headerlink" title="security的核心，Spring Security使用了springSecurityFilterChain作为了安全过滤的入口"></a>security的核心，Spring Security使用了springSecurityFilterChain作为了安全过滤的入口</h2><h2 id="【1】Spring-Security过滤器"><a href="#【1】Spring-Security过滤器" class="headerlink" title="【1】Spring Security过滤器"></a>【1】Spring Security过滤器</h2><h3 id="1、核心过滤器概述"><a href="#1、核心过滤器概述" class="headerlink" title="1、核心过滤器概述"></a>1、核心过滤器概述</h3><p>从控制台打印过滤器可见</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.security.web.util.matcher.AnyRequestMatcher@<span class="number">1</span>,</span><br><span class="line">[</span><br><span class="line">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@184de357,</span><br><span class="line">    org.springframework.security.web.context.SecurityContextPersistenceFilter@521ba38f,</span><br><span class="line">    org.springframework.security.web.header.HeaderWriterFilter@77bb916f,</span><br><span class="line">    org.springframework.security.web.csrf.CsrfFilter@76b305e1,</span><br><span class="line">    org.springframework.security.web.authentication.logout.LogoutFilter@17c53dfb,</span><br><span class="line">    org.springframework.security.web.savedrequest.RequestCacheAwareFilter@2086d469,</span><br><span class="line">    org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter<span class="meta">@b1d19ff</span>,</span><br><span class="line">    org.springframework.security.web.authentication.AnonymousAuthenticationFilter<span class="meta">@efe49ab</span>,</span><br><span class="line">    org.springframework.security.web.session.SessionManagementFilter@5a48d186,</span><br><span class="line">    org.springframework.security.web.access.ExceptionTranslationFilter@273aaab7</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>SecurityContextPersistenceFilter 两个主要职责：请求来临时，创建SecurityContext安全上下文信息，请求结束时清空SecurityContextHolder。</li><li>HeaderWriterFilter (文档中并未介绍，非核心过滤器) 用来给http响应添加一些Header,比如X-Frame-Options, X-XSS-Protection*，X-Content-Type-Options.</li><li>CsrfFilter 在spring4这个版本中被默认开启的一个过滤器，用于防止csrf攻击，了解前后端分离的人一定不会对这个攻击方式感到陌生，前后端使用json交互需要注意的一个问题。</li><li>LogoutFilter 顾名思义，处理注销的过滤器</li><li>UsernamePasswordAuthenticationFilter 这个会重点分析，表单提交了username和password，被封装成token进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。</li><li>RequestCacheAwareFilter (文档中并未介绍，非核心过滤器) 内部维护了一个RequestCache，用于缓存request请求</li><li>SecurityContextHolderAwareRequestFilter 此过滤器对ServletRequest进行了一次包装，使得request具有更加丰富的API</li><li>AnonymousAuthenticationFilter 匿名身份过滤器，这个过滤器个人认为很重要，需要将它</li><li>UsernamePasswordAuthenticationFilter 放在一起比较理解，spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。</li><li>SessionManagementFilter 和session相关的过滤器，内部维护了一个SessionAuthenticationStrategy，两者组合使用，常用来防止session-fixation protection attack，以及限制同一用户开启多个会话的数量</li><li>ExceptionTranslationFilter 直译成异常翻译过滤器，还是比较形象的，这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理，具体是那些类下面详细介绍</li><li>FilterSecurityInterceptor 这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的</li></ul><h2 id="【2】Spring-Security核心过滤器解析"><a href="#【2】Spring-Security核心过滤器解析" class="headerlink" title="【2】Spring Security核心过滤器解析"></a>【2】Spring Security核心过滤器解析</h2><h3 id="1、SecurityContextPersistenceFilter"><a href="#1、SecurityContextPersistenceFilter" class="headerlink" title="1、SecurityContextPersistenceFilter"></a>1、SecurityContextPersistenceFilter</h3><p>SecurityContextPersistenceFilter的两个主要作用便是请求来临时，创建SecurityContext安全上下文信息和请求结束时清空SecurityContextHolder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILTER_APPLIED</span> <span class="operator">=</span> <span class="string">&quot;__spring_security_scpf_applied&quot;</span>;</span><br><span class="line">   <span class="comment">//安全上下文存储的仓库</span></span><br><span class="line">   <span class="keyword">private</span> SecurityContextRepository repo;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">SecurityContextPersistenceFilter</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//HttpSessionSecurityContextRepository是SecurityContextRepository接口的一个实现类</span></span><br><span class="line">      <span class="comment">//使用HttpSession来存储SecurityContext</span></span><br><span class="line">      <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">HttpSessionSecurityContextRepository</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">      <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">      <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// ensure that filter is only applied once per request</span></span><br><span class="line">         chain.doFilter(request, response);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">      <span class="comment">//包装request，response</span></span><br><span class="line">      <span class="type">HttpRequestResponseHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpRequestResponseHolder</span>(request,</span><br><span class="line">            response);</span><br><span class="line">      <span class="comment">//从Session中获取安全上下文信息</span></span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> repo.loadContext(holder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//请求开始时，设置安全上下文信息，这样就避免了用户直接从Session中获取安全上下文信息</span></span><br><span class="line">         SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">         chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">//请求结束后，清空安全上下文信息</span></span><br><span class="line">         <span class="type">SecurityContext</span> <span class="variable">contextAfterChainExecution</span> <span class="operator">=</span> SecurityContextHolder</span><br><span class="line">               .getContext();</span><br><span class="line">         SecurityContextHolder.clearContext();</span><br><span class="line">         repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">               holder.getResponse());</span><br><span class="line">         request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">         <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;SecurityContextHolder now cleared, as request processing completed&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、SecurityContextPersistenceFilter"><a href="#2、SecurityContextPersistenceFilter" class="headerlink" title="2、SecurityContextPersistenceFilter"></a>2、SecurityContextPersistenceFilter</h3><p>内部调用了authenticationManager完成认证，根据认证结果执行successfulAuthentication或者unsuccessfulAuthentication，无论成功失败，一般的实现都是转发或者重定向等处理，不再细究AuthenticationSuccessHandler和AuthenticationFailureHandler，有兴趣的朋友，可以去看看两者的实现类。</p><h3 id="2-3-AnonymousAuthenticationFilter"><a href="#2-3-AnonymousAuthenticationFilter" class="headerlink" title="2.3 AnonymousAuthenticationFilter"></a>2.3 AnonymousAuthenticationFilter</h3><p>匿名认证过滤器，可能有人会想：匿名了还有身份？我自己对于Anonymous匿名身份的理解是Spring Security为了整体逻辑的统一性，即使是未通过认证的用户，也给予了一个匿名身份。而AnonymousAuthenticationFilter该过滤器的位置也是非常的科学的，它位于常用的身份认证过滤器（如UsernamePasswordAuthenticationFilter、BasicAuthenticationFilter、RememberMeAuthenticationFilter）之后，意味着只有在上述身份过滤器执行完毕后，SecurityContext依旧没有用户信息，AnonymousAuthenticationFilter该过滤器才会有意义—-基于用户一个匿名身份。</p><h3 id="2-4-ExceptionTranslationFilter"><a href="#2-4-ExceptionTranslationFilter" class="headerlink" title="2.4 ExceptionTranslationFilter"></a>2.4 ExceptionTranslationFilter</h3><p>ExceptionTranslationFilter异常转换过滤器位于整个springSecurityFilterChain的后方，用来转换整个链路中出现的异常，将其转化，顾名思义，转化以意味本身并不处理。一般其只处理两大类异常：AccessDeniedException访问异常和AuthenticationException认证异常。</p><p>这个过滤器非常重要，因为它将Java中的异常和HTTP的响应连接在了一起，这样在处理异常时，我们不用考虑密码错误该跳到什么页面，账号锁定该如何，只需要关注自己的业务逻辑，抛出相应的异常便可。如果该过滤器检测到AuthenticationException，则将会交给内部的AuthenticationEntryPoint去处理，如果检测到AccessDeniedException，需要先判断当前用户是不是匿名用户，如果是匿名访问，则和前面一样运行AuthenticationEntryPoint，否则会委托给AccessDeniedHandler去处理，而AccessDeniedHandler的默认实现，是AccessDeniedHandlerImpl。所以ExceptionTranslationFilter内部的AuthenticationEntryPoint是至关重要的，顾名思义：认证的入口点。</p><h3 id="2-5-FilterSecurityInterceptor"><a href="#2-5-FilterSecurityInterceptor" class="headerlink" title="2.5 FilterSecurityInterceptor"></a>2.5 FilterSecurityInterceptor</h3><p>我们已经有了认证，有了请求的封装，有了Session的关联，还缺一个：由什么控制哪些资源是受限的，这些受限的资源需要什么权限，需要什么角色…这一切和访问控制相关的操作，都是由FilterSecurityInterceptor完成的。</p><p>FilterSecurityInterceptor的工作流程可以理解如下：FilterSecurityInterceptor从SecurityContextHolder中获取Authentication对象，然后比对用户拥有的权限和资源所需的权限。前者可以通过Authentication对象直接获得，而后者则需要引入我们之前一直未提到过的两个类：SecurityMetadataSource，AccessDecisionManager。理解清楚决策管理器的整个创建流程和SecurityMetadataSource的作用需要花很大一笔功夫，这里，暂时只介绍其大概的作用</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
            <tag> 整合中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线性表</title>
      <link href="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"/>
      <url>/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/</url>
      
        <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ul><li><p>线性结构特点：在数据元素的非空有限集合中</p><ul><li>(1)存在唯一的一个被称做“第一个”的数据元素；</li><li>(2)存在唯一的一个被称做“最后一个”的数据元素；</li></ul></li><li><p>(3)除第一个之外，集合中的每个数据元素均只有一个前驱；(4)除最后一个之外，集合中每个数据元素均只有一个后继。</p></li><li><p>线性表定义：有限个性质相同的数据元素组成的序列。</p><span id="more"></span></li><li><p>线性表的存储结构：顺序存储结构和链式存储结构</p></li></ul><blockquote><p>顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。</p><p>通常用一维数组来描述数据结构中的顺序存储结构。</p></blockquote><blockquote><p>链式存储结构: 其结点在存储器中的位置是随意的，即逻辑上相邻的数据元素在物理上不一定相邻。通过指针来实现。</p></blockquote><p><img src="/../img/2-1.png"></p><ul><li><p>顺序表<br>顺序表把线性表的所有元素按照其逻辑顺序，依次存储到从指定的存储位置开始的一块连续的存储结构空间中中。</p></li><li><p>链表<br>在存储链表中，每个节点不仅包含所存元素的信息，还包含元素之间逻辑关系的信息。可以通过前驱结点中的地址信息找到后继结点的位置。</p></li><li><p>两者存储结构比较</p><ul><li>顺序表的特性：(其实就是数组)<br><strong>随机</strong>访问特性。<br>占用<strong>连续</strong>的存储空间。</li><li>链表的特性：<br><strong>不支持随机访问</strong>的特性。<br>结点的存储空间利用率较顺序表稍微低一些。<br>不需要一次性划分所有结点所需空间给链表。</li><li>链表支持存储空间的动态分配。<br>顺序表在做插入操作的时候需要移动多个元素<br>链表进行插入操作无需移动元素</li></ul></li><li><p>4.链表的5种形式</p><ul><li><p>1 单链表</p><ul><li>带<strong>头结点</strong>与<strong>不带头结点</strong>的区别：</li></ul><p>带头结点的单链表有一个结点不存储信息，而不带头结点的单链表所有结点都存储信息。</p><p><img src="/../img/2-2.png"></p></li><li><p>2 双链表</p><p>- </p></li><li><p>3 循环单链表</p><ul><li><p>环单链表可以实现从任一结点出发访问链表的任何结点，而单链表从任一结点出发后只能访问这个结点本身及其后边的所有结点。带头结点的循环单链表，<em><strong>链表空</strong></em>，head&#x3D;head-&gt;next;不带头结点，<strong>链表空</strong>，head&#x3D;NULL</p><p><img src="/../img/2-4.png"></p></li></ul></li><li><p>4 循环双链表</p><ul><li><p>循环双链表即终端结点的next指针指向链表中的第一个结点，将链表中第一个结点的prior指针指向终端结点</p><p><img src="/../img/2-5.png"></p></li></ul></li><li><p>5 静态链表</p><ul><li><p>静态链表借助一维数组来表示。静态链表来自于一个<strong>结构体数组</strong>，数组中每一个结点含有两个分量：一个数据元素分量data;另个一个是指针分量，指示了当前结点的直接后继结点在数组中的位置。</p><p><img src="/../img/2-6.png"></p></li></ul><h3 id="考研中遇到考顺序表和链表的比较："><a href="#考研中遇到考顺序表和链表的比较：" class="headerlink" title="考研中遇到考顺序表和链表的比较："></a>考研中遇到考顺序表和链表的比较：</h3><ul><li>基于空间的比较</li></ul><p>1.存储方式的比较：</p><p>顺序表的存储空间是一次性分配，链表的存储空间是多次分配。</p><p>2.存储密度：(存储密度&#x3D;结点值域所占存储量&#x2F;结点结构所占的存储量)：</p><p>顺序表的存储密度&#x3D;1，链表的存储密度&lt;1(因为结点中有指针域)</p><ul><li>基于时间的比较</li></ul><p>1.存储方式：</p><p>顺序表可以随机存储，也可以顺序存储，链表只能顺序存储</p><p>2.插入、删除时移动元素的个数:</p><p>顺序表平均需要移动一半的元素；链表不需要移动，只需要修改指针。</p><p>对顺序表平均需要移动近一半元素，链表不需要移动元素，只需要修改指针。</p><p>具有n个元素的顺序表，插入一个元素所进行的平均移动个数是多少，</p><p>1）求概率，是随机的，可能性相同，有n个可插入位置，所以任何一个位置被插入元素的概率为p&#x3D;1&#x2F;n；</p><p>2）求对应于每个插入位置需要移动元素个数。</p><p>假设要把新元素插入在表中第i个圆度之后，则需要将第i个元素之后的所有元素往后移动一个为置，因此移动元素个数为n-i。</p><p>由1和2可知，移动元素个数的期望E为：</p><p>E&#x3D;n-1&#x2F;2</p><p>插入和删除算法的平均时间复杂度为O（n).</p></li></ul><h4 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">1.</span>线性表的顺序存储又称顺序表</span><br><span class="line">&gt; <span class="number">2.</span>元素的逻辑顺序与物理顺序相同</span><br><span class="line">&gt; <span class="number">3.</span>顺序存储结构是一种随机存储结构</span><br><span class="line">&gt; <span class="number">4.</span>特点：</span><br><span class="line">&gt; <span class="number">1</span>）顺序表的随机访问：通过首地址和元素符号在<span class="built_in">O</span>(<span class="number">1</span>)时间内找到指定的元素</span><br><span class="line">&gt;<span class="number">2</span>）储存密度高，每个节点只存储数据元素</span><br><span class="line">&gt;<span class="number">3</span>）由于逻辑相邻与物理相邻，所以插入和删除操作需要移动大量的元素</span><br><span class="line">一维数组可以是静态分配的，也可以是动态分配的。</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50  <span class="comment">//定义线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">ElemType data[MaxSize];   <span class="comment">//顺序表的元素</span></span><br><span class="line"><span class="type">int</span> length;  <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;  <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line">动态分配时，存储数组的空间是在程序执行过程中通过动态存储语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为顺序表一次性划分所有空间。</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100  <span class="comment">//表长度的初始定义</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">ElemType *data;   <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line"><span class="type">int</span> MaxSize,length;  <span class="comment">//数组最大容量和当前定义</span></span><br><span class="line">&#125;SeqList;  <span class="comment">//动态分配数组顺序表的类型定义</span></span><br><span class="line">分配存储空间的语句</span><br><span class="line">C：  L.data=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*InitSize);</span><br><span class="line">C++： L.data=<span class="keyword">new</span> <span class="built_in">ElemType</span>(InitSize);</span><br><span class="line">注意：动态分配并不是链式存储，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时动态决定。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>插入操作 【在顺序表L的第i（<span class="number">1</span>&lt;i&lt;L.length+<span class="number">1</span>）个位置插入新元素e】</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>)  <span class="comment">// 判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(L.length&gt;=MaxSize)<span class="comment">//当前存储空间已满不能插入</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)  <span class="comment">//将第i个即以后元素往后移</span></span><br><span class="line">L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">L.data[i<span class="number">-1</span>]=e;   <span class="comment">//在位置i放置e</span></span><br><span class="line">L.lenght++;      <span class="comment">//线性表长度+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">................</span><br><span class="line">&#125;</span><br><span class="line">注意：区别顺序表的位序和数组下标。为何判断插入位置是否合法时 <span class="keyword">if</span>语句中用length+<span class="number">1</span>，而移动元素的<span class="keyword">for</span>语句中只用length？</span><br><span class="line">答：</span><br><span class="line"><span class="number">1.</span>首先明确，位序从 <span class="number">1</span> 开始，数组下标从 <span class="number">0</span> 开始；这里 i 是指 位序；</span><br><span class="line"><span class="number">2.</span><span class="keyword">if</span>语句：分析两种种情况(前提：线性表未满)：</span><br><span class="line"><span class="number">1</span>）length+<span class="number">2</span>的情况：i的范围是[<span class="number">1</span>，length+<span class="number">2</span>],length+<span class="number">2</span>所插入的位置在顺序表上是断档，违背顺序表定义（一组地址连续的存储单元逻辑上相邻的两个元素的物理位置上也相邻）</span><br><span class="line"><span class="number">2</span>）length的情况：i的范围是[<span class="number">1</span>，length],顺序表上length+<span class="number">1</span>位置是空的</span><br><span class="line"></span><br><span class="line"><span class="number">3.f</span><span class="keyword">or</span>语句：到<span class="keyword">for</span>语句时，说明至少有一个可插入的位置；</span><br><span class="line">   j=L.length时，保证最后一个数组元素可以移到数组的后一个位置而不产生数组越界异常</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>在不同位置进行插入操作的时间复杂度（n为length）</span><br><span class="line"><span class="number">1</span>)最好情况：表尾插入（i=n+<span class="number">1</span>），元素后移语句不执行，复杂度<span class="built_in">O</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">2</span>)最坏情况：表头插入(i=<span class="number">1</span>)，元素后移语句执行n次，复杂度<span class="built_in">O</span>(n);</span><br><span class="line"><span class="number">3</span>)平均情况：略，复杂度<span class="built_in">O</span>(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>删除操作 【删除顺序表L中第<span class="built_in">i</span>(<span class="number">1</span>&lt;=i&lt;=L.length)个位置的元素，用引用变量e返回】</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">reutrn <span class="literal">false</span>;</span><br><span class="line">e=L.data[i<span class="number">-1</span>];     <span class="comment">//e保存将要被删的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)    <span class="comment">//第i个位置后的元素前移</span></span><br><span class="line">L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">................</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>在不同位置进行删除操作的时间复杂度（n为length）</span><br><span class="line"><span class="number">1</span>)最好情况：删除表尾元素(i=n)，元素前移语句不执行，复杂度<span class="built_in">O</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">2</span>)最坏情况：删除表头元素（i=<span class="number">1</span>），元素前移语句执行n次，复杂度<span class="built_in">O</span>(n);</span><br><span class="line"><span class="number">3</span>)平均情况：略，复杂度<span class="built_in">O</span>(n);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>按值查找（顺序查找）【在顺序表L中查找第一个元素值等于e的元素，并返回其位序】</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,Elem e)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line"><span class="keyword">if</span>(L.data[i]===e)</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">................</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>时间复杂度（n为length）</span><br><span class="line"><span class="number">1</span>)最好情况：查找的元素就在表头，仅需比较<span class="number">1</span>次，复杂度为<span class="built_in">O</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">2</span>)最坏情况：查找的元素就在表尾，需比较n次，复杂度为<span class="built_in">O</span>(n);</span><br><span class="line"><span class="number">3</span>)平均情况：略，<span class="built_in">O</span>(n);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h3><p>例题将AB，插入C中 归并，尾插</p><p><img src="/../img/2-7.png"></p><p><img src="/../img/2-8.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span><br><span class="line">&#123;</span><br><span class="line"> LNode *P=A-&gt;next;<span class="comment">//p来跟踪A的最小值结点。A-&gt;next表示A链表的开始结点（头结点后边一个结点），A链表是递增，所以最前面的是最小节点。</span></span><br><span class="line">    LNode *q=B-&gt;next;</span><br><span class="line">    LNode *r;<span class="comment">//r始终指向C的终端结点</span></span><br><span class="line">    C=A;<span class="comment">//用A的头结点做C的头结点</span></span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);<span class="comment">//B头结点无用，释放掉</span></span><br><span class="line">    r=C;<span class="comment">//r指向C，因此头结点是终端结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)<span class="comment">//当p与q不空时，选取p与q所指结点中较小的插入c的尾部，</span></span><br><span class="line">       <span class="comment">//以下的if else语句中，r始终指向当前链表终端结点，作为接纳新结点的一个媒介，通过他，新节点被链接入c并且重新指向新的终端接点，以便接受下一个新节点，这里是尾插法的思想</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next=p;p=p-&gt;next;</span><br><span class="line">            r=er-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next=q;q=q-&gt;next</span><br><span class="line">                r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>；</span><br><span class="line">        <span class="comment">//以下两个语句将还有剩余的结点的链表连接在C的尾部</span></span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) r-&gt;next=p;</span><br><span class="line">        <span class="keyword">if</span>(q!=<span class="literal">NULL</span>) r-next=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>假设有n个元素已经存储数组a中，用尾插法建立链表c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createlistR</span><span class="params">(LNode *&amp;C,<span class="type">int</span> a[],<span class="type">int</span> n)</span><span class="comment">//要改变的变量用引用型</span></span><br><span class="line">&#123;</span><br><span class="line">LNode *s,*r;<span class="comment">//s用来指向新申请的结点，r始终指向c的终端</span></span><br><span class="line">    <span class="type">int</span> i;<span class="comment">///</span></span><br><span class="line">    C=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//申请C的头结点空间</span></span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    r=c;<span class="comment">//r指向头结点，因为此时头结点就是终端结点</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++<span class="number">1</span>)<span class="comment">//循环申请n个结点来接受数组a中元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//s指向新申请的结点</span></span><br><span class="line">        s-&gt;data=a[i];<span class="comment">//用新申请的结点来接受a中的一个元素</span></span><br><span class="line">        r-&gt;next=s;<span class="comment">//用r来接纳新结点</span></span><br><span class="line">        r=r-&gt;next;<span class="comment">//r指向终端结点，以便于接纳下一个新到来的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;<span class="comment">//数组a中所有的元素都已经装入链表c中，c的终端结点的指针域置为为null，c建立完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>头插法建表</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createlistF</span><span class="params">(LNode *&amp;C,<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    C=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=a[i];</span><br><span class="line">        <span class="comment">//下面两句是头插法的关键</span></span><br><span class="line">        s-&gt;next=C-&gt;next;<span class="comment">//s所指新节点的指针域next指向C中的开始结点</span></span><br><span class="line">        C-&gt;next=s;<span class="comment">//头指针的指针域next指向s结点，使得s成为新的开始结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>归并成递减的单链表的算法</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span><br><span class="line">&#123;</span><br><span class="line">LNode *p=A-&gt;next;</span><br><span class="line">    LNode *q=B-&gt;next;</span><br><span class="line">    LNode *s;</span><br><span class="line">    C=A;</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="comment">//头插法</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            s=p;p=p-&gt;next;</span><br><span class="line">            s-&gt;next=C-&gt;next;</span><br><span class="line">            C-next=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s=q;q=q-&gt;next;</span><br><span class="line">            s-&gt;next=C-&gt;next;</span><br><span class="line">            C-&gt;next=s;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下边这两个循环是和求增递归并序列不同的地方，必须将剩余元素逐个插入c的头部才能得到最终递减序列</span></span><br><span class="line">    <span class="keyword">while</span>(p!<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=q;</span><br><span class="line">        q=q-&gt;next;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入操作</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-next=s;</span><br></pre></td></tr></table></figure><p><strong>删除操作</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure><h3 id="双链表的操作"><a href="#双链表的操作" class="headerlink" title="双链表的操作"></a>双链表的操作</h3><p><strong>1.采用尾插法建立双链表</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createDlistR</span><span class="params">(DLNode *&amp;L.<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    DLNode *s,*r;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    L=(DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">    L-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    r=L;<span class="comment">//和单链表一样，r始终指向终端结点，开始头结点也是尾结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));<span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data=a[i];</span><br><span class="line">       <span class="comment">//下面3句将s插入到L的尾部，并且r指向s。</span></span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        s-&gt;prior=r;</span><br><span class="line">        r=s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.查找结点的算法</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">在双链表中查找第一个值为x的结点，从第一个结点开始，边扫描边比较，若找到这样的结点，则返回结点指针，否则返回<span class="literal">NULL</span>。</span><br><span class="line"></span><br><span class="line">DLNode* <span class="title function_">findNode</span><span class="params">(DLNode *C.,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    DLNode *p=C-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-data==x)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//如果找到，则p中内容是结点地址（循环因break结束）；如果没找到，则p中内容是Null(循环因p等于NULL而结束)。因此这一句话将要求的两种返回值得情况统一起来。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.插入结点的算法</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">假设在双链表中p所指的结点之后插入一个结点s.</span><br><span class="line"></span><br><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">s-&gt;prior=p;</span><br><span class="line">p-&gt;next=s;</span><br><span class="line">s-&gt;next-&gt;prior=s;<span class="comment">//加入p指向最后一个结点，则本行可去掉</span></span><br></pre></td></tr></table></figure><p><img src="/../img/2-9.png"></p><p><strong>4.删除结点算法</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">设要删除双链表中p结点的后继结点</span><br><span class="line"></span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior=p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure><p><img src="/../img/2-10.png"></p><p>5.循环链表的操作<br>循环单链表和循环双链表是有对应的单链表和双链表改造来得，只需在终端结点和头结点建立联系即可。循环单链表终端结点的next结点指针向表头结点；循环双链表终端接结点的next指针指向表头结点，头结点的prior指针向表尾结点。需要注意的是，如果p指针压着循环链表行走，则判断p走到表尾结点的条件是p-&gt;next&#x3D;&#x3D;head.</p><p>6.逆置问题<br>给定一个线性表，如何将其中的元素逆置？可设置两个整型变量i和j，i指向最后一个元素，边交换i和j所指元素，边让i和j相向而行，直到遇到，实现代码如下：</p><p>假设元素存在于数组a[]中，left和right是数组两端元素的下标。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=left,j=right;i&lt;j;++i,--j)</span><br><span class="line">&#123;</span><br><span class="line">temp=a[i];</span><br><span class="line">a[i]=a[j];</span><br><span class="line">a[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/2-11.png"></p><p>分析：</p><p>（1）只需要逆置整个数组，即可满足前端k个元素逆序后放到数组的后端，如下图：</p><p><img src="/../img/2-12.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=left,j=right;i&lt;left+k;&amp;&amp;i&lt;j;++i,--j)</span><br><span class="line">&#123;</span><br><span class="line">temp=a[i];</span><br><span class="line">a[j]=a[j];</span><br><span class="line">a[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)只需要将前端k个元素逆置，然后将整个数组逆置，即满足前端k个元素保持原序放到数组后端，如下图</p><p><img src="/../img/2-13.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveToEnd</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//调用（1）中的实现的reverse()函数：</span></span><br><span class="line">reverse(a,<span class="number">0</span>,k<span class="number">-1</span>,k);</span><br><span class="line">reverse(a,<span class="number">0</span>,n<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)只需要将0p-1位置逆置，在将pn-1位置元素逆置，然后再将整个数组逆置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">movep</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//调用（1）中实现的reverse（）函数：</span></span><br><span class="line">reverse(a,<span class="number">0</span>,p<span class="number">-1</span>,p);</span><br><span class="line">reverse(a,p,n<span class="number">-1</span>,n-p);</span><br><span class="line">reverse(a,<span class="number">0</span>,n<span class="number">-1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构的基本概念</title>
      <link href="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="信息化时代"><a href="#信息化时代" class="headerlink" title="信息化时代"></a>信息化时代</h2><p><img src="/./../img/1-1.png" alt="xinxihua"></p><hr><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><span id="more"></span><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</p><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul><li><p>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的</p></li><li><p>数据的逻辑结构分为线性结构和非线性结构</p><ul><li>线性结构 （线性表 栈 数字 队列 ）</li><li>非线性结构<ul><li>集合</li><li>树形结构</li><li>图结构（网状结构）</li><li>二维数组、多维数组、广义表</li></ul></li></ul></li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。</p><ul><li>顺序存储：存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。）</li><li>链接存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。</li><li>索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。</li><li>散列存储：通过关键字直接计算出元素的物理地址（hash）。</li></ul><h3 id="算法的五个特征"><a href="#算法的五个特征" class="headerlink" title="算法的五个特征"></a>算法的五个特征</h3><ul><li>1，有穷性：有限步之后结束</li><li>2，确定性：不存在二义性，即没有歧义</li><li>3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。</li><li>4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。</li><li>5，输出：一至多个程序输出结果</li></ul><h3 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h3><ul><li>时间复杂度：<ul><li>• 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢；</li><li>• 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级</li><li>• T(n)&#x3D;O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度</li></ul></li><li>空间复杂度：<ul><li>• 它用来衡量算法随着问题规模增大，算法所需空间的快慢；</li><li>• 是问题规模的函数：S(n)&#x3D;O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
