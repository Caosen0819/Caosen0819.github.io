
<!DOCTYPE html>
<html lang="zh-CH">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="森">
    <title>森</title>
    <meta name="author" content="CSEN">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"http://example.com","author":{"@type":"Person","name":"CSEN","sameAs":["https://github.com/Caosen0819"],"image":"head.jpg"},"name":"森","description":"潮起潮落，云卷云舒","url":"http://example.com"}</script>
    <meta name="description" content="潮起潮落，云卷云舒">
<meta property="og:type" content="blog">
<meta property="og:title" content="森">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="森">
<meta property="og:description" content="潮起潮落，云卷云舒">
<meta property="og:locale" content="zh_CH">
<meta property="article:author" content="CSEN">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="http://example.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-w816scvuzwavitjylabixcb3ofuoklqul47j3rgwu1r0mxrxvbdehvp2jk5s.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            森
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Lesen Sie mehr über den Autor"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
                </a>
                <h4 class="sidebar-profile-name">CSEN</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="档案"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">档案</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/Caosen0819"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title=".github"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">.github</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/"
                            aria-label=": 计算机网络2"
                        >
                            计算机网络2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-08T00:00:00+08:00">
	
		    08 Jul 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="1、TCP和UDP"><a href="#1、TCP和UDP" class="headerlink" title="1、TCP和UDP"></a>1、<strong>TCP和UDP</strong></h3><p><strong>UDP和TCP可以共用一个端口，因为是完全独立的两个软件模块</strong></p>
<h3 id="2、为什么不能两次握手或者四次握手？"><a href="#2、为什么不能两次握手或者四次握手？" class="headerlink" title="2、为什么不能两次握手或者四次握手？"></a>2、为什么不能两次握手或者四次握手？</h3><blockquote>
<p>两次握手：在两次握手的时候，服务端没有中间状态给客户端来阻止历史连接，也就是服务端会多建立一个历史连接浪费资源，因为收到syn就变成established。这里靠序列号同步就知道了</p>
<p>四次握手：四次握手无非就是，你给我发我返回同意，我给你发你返回同意，但是第二和第三部完全可以合并，所以三次就ok了。</p>
</blockquote>
<h3 id="3、为什么，每次建立连接序列号都要求不一样？"><a href="#3、为什么，每次建立连接序列号都要求不一样？" class="headerlink" title="3、为什么，每次建立连接序列号都要求不一样？"></a>3、为什么，每次建立连接序列号都要求不一样？</h3><p>1、防止历史报文被下一个连接接受，如果每次都从特定的值开始，那历史报文就可能被下一个连接接受。</p>
<p>2、防止黑客伪造的相同序列号被接受</p>
<h3 id="4、那这个序列号是怎么随机产生的？"><a href="#4、那这个序列号是怎么随机产生的？" class="headerlink" title="4、那这个序列号是怎么随机产生的？"></a>4、那这个序列号是怎么随机产生的？</h3><p>rfc提高了序列号ISN随机生成算法：ISN &#x3D; M + F</p>
<p>m是计时器，四微秒+1</p>
<p>F是哈希算法根据四元组推出来的</p>
<h3 id="5、为什么ip层会分片，TCP还分片，"><a href="#5、为什么ip层会分片，TCP还分片，" class="headerlink" title="5、为什么ip层会分片，TCP还分片，"></a>5、为什么ip层会分片，TCP还分片，</h3><p>因为ip不能超时重传，所以只能靠tcp，而万一ip层丢了一部分，那么ip层就不能组装成一个完整的tcp报文，也就不可能发给接收方tcp层，所以发送方的tcp层就会重发整个tcp报文，所以我们最好就是自己分片，然后缺什么发什么，直接以MSS为单位就可以了</p>
<h3 id="6、TCP三次握手过程丢失问题"><a href="#6、TCP三次握手过程丢失问题" class="headerlink" title="6、TCP三次握手过程丢失问题"></a>6、TCP三次握手过程丢失问题</h3><blockquote>
<p>第一次握手丢失，会发生什么？</p>
<p>触发超时重传，每次重传次数是上一次两倍，报文最大重传次数由 <code>tcp_syn_retries</code></p>
<p>第二次握手丢失，会发生什么？</p>
<p>客户端和服务端都会重传，重传次数分别有tcp_syn_retries和tcp_synack_retries决定</p>
<p>第三次握手丢失了，会发生什么？</p>
<p>这里有一点很关键，就是ack报文是不会重传的，所以服务端会认为自己的syn+ack没发到，触发重传机制，服务端重传，次数由tcp_synack_retries决定</p>
</blockquote>
<h3 id="7、半连接状态和全连接状态"><a href="#7、半连接状态和全连接状态" class="headerlink" title="7、半连接状态和全连接状态"></a>7、半连接状态和全连接状态</h3><ul>
<li>半连接队列，也称 SYN 队列；</li>
<li>全连接队列，也称 accept 队列；</li>
</ul>
<p>正常流程：</p>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li>
<li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li>
<li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li>
<li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li>
</ul>
<p>所以这样子就出会先一些问题</p>
<p>受到SYN攻击怎么办？就是说半连接状态很多怎么办？</p>
<ul>
<li>调大 netdev_max_backlog；缓冲队列</li>
<li>增大 TCP 半连接队列；</li>
<li>开启 tcp_syncookies；不用建立半连接</li>
<li>减少 SYN+ACK 重传次数</li>
</ul>
<h3 id="8、TCP四次挥手"><a href="#8、TCP四次挥手" class="headerlink" title="8、TCP四次挥手"></a>8、TCP四次挥手</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803130523828.png" alt="image-20230803130523828"></p>
<blockquote>
<p>msl是报文最大生存时间，ip头有一个ttl字段，这个字段代表可以经历的最大路由数</p>
<p>msl大于等于ttl消耗为0的时间，默认60</p>
</blockquote>
<blockquote>
<p><strong>为什么需要这个timewait状态</strong></p>
<p>1<font color='red'><u><em><strong>、也是为了防止接收历史连接中的第三次挥手</strong></em></u></font>。这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失。</strong></p>
<p>2、也就是说，TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
</blockquote>
<blockquote>
<p><font color='red'><u><em><strong>为什么4次？</strong></em></u></font></p>
<p>服务端可能还有数据要发给客户端，所以需要先处理自己的最后流程，然后给客户端发送一个fin报文，也就是说，第二次握手和第三次握手大概率是不同步的。</p>
<p><font color='red'><u><em><strong>特定情况下，可以变成三次，刚刚好没有数据。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>第一次挥手丢失，会发生什么？</strong></em></u></font></p>
<p>客户端收不到来自服务端的ack报文，那么就会触发超时重传，这个次数是由tcp_orphan_retries决定的</p>
<p><font color='red'><u><em><strong>第二次挥手丢失，会发生什么？</strong></em></u></font></p>
<p>ACK 报文是不会重传的,所以首先客户端还是会触发超时重传，这个次数是由tcp_orphan_retries决定的</p>
<p><font color='red'><u><em><strong>第三次丢失，会发生什么？</strong></em></u></font></p>
<p>相当于服务端一直收不到来自客户端的ack，那么服务端会触发超时重传,次数达到后还没收到，断开连接。</p>
<p>而客户端已经进入了fin_wait2状态，一直等，如果超过设定的时间tcp_fin_timeout ，断开连接。</p>
<p><font color='red'><u><em><strong>第四次丢失，会发生什么？</strong></em></u></font></p>
<p>服务端一直收不到，那么触发超时重传，这时候因为客户端已经是timewait状态，所以每一次重传都会重置2msl定时器，超过时间就close，而服务端同样的重传几次之后close</p>
</blockquote>
<blockquote>
<p><strong>如果建立了连接，结果客户端故障了，不发送消息，但是服务端一直establish</strong></p>
<p>tcp搞了个保活机制，隔一段时间发送探测报文，没有得到相应则认为tcp死亡，</p>
<p>但是，这个保活机制时间太长了，我们自己在应用层实现一个心跳机制，一般web服务软件都会提供keepalive-timeout状态</p>
<p><strong>如果服务器的进程崩溃了，那发生什么</strong></p>
<p>其实连接信息是由内核维护的，所以服务端的内核还是会发送fin报文进行四次挥手</p>
</blockquote>
<h3 id="9、可靠性保证方法"><a href="#9、可靠性保证方法" class="headerlink" title="9、可靠性保证方法"></a>9、可靠性保证方法</h3><blockquote>
<h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p><font color='red'><u><em><strong>重传分为超时重传和快速重传两种。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>超时重传：超过时间进行重传，时间RTO</strong></em></u></font></p>
<p><font color='red'><u><em><strong>快速重传：收到三个相同的 ACK 报文时，重传丢失的报文段。这里的问题在于传一个还是传所有，这里引入了SACK和DSACK机制</strong></em></u></font></p>
<p>SACK：服务端把已经收到的数据信息驾到tcp头部的选项里面，告诉发送发我收到了哪些</p>
<p>后面又出现了D-SACK：这是用来告诉发送方哪些被重复接受了了</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>操作系统开辟的一个缓存空间，发送方在收到ACK应答之前，在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除</p>
<p>TCP头部里面既有一个字段叫窗口大小，就是用来告诉发送端自己还有多少缓冲区可以使用，所以窗口大小一般由接收方决定</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>网络发生拥塞，那么tcp就会降低自己的发送量，防止网络负担加重</p>
<p>慢启动 一开始是1，就是可以传1个mss，然后收到应答变成2，4，8，16…..</p>
<p>拥塞避免 触碰到<font color='green'><u><em><strong>慢启动门限</strong></em></u></font>就是用拥塞避免，变成线性的，收到一个ack cwnd增加1&#x2F;cwnd（拥塞窗口）</p>
<p>如果网络发生了拥塞，也就是重传。重传分两种，如果是超时重传，就慢启动门限变成cwnd&#x2F;2，cwnd&#x3D;1重新开始慢启动</p>
<p>如果是快速重传，拥塞窗口和慢启动门限都设置为拥塞窗口的一半，然后拥塞窗口+3，继续发送重复的，如果收到新数据的ACK，快速恢复结束，进入拥塞避免。</p>
<p>握手优化就是调整重传次数、半连接队列，全连接队列</p>
<p>挥手就是调整：重传次数、FINwait2状态时间、</p>
<p>传输速度的话就是调整：接收方缓冲区大小、发送方缓冲区大小、窗口大小，打开缓冲区动态调节。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>避免发送方的数据填满接收方</p>
</blockquote>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803161404210.png" alt="image-20230803161404210"></p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803163142196.png" alt="image-20230803163142196"></p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803163236556.png" alt="image-20230803163236556"></p>
<blockquote>
<h4 id="如何理解字节流"><a href="#如何理解字节流" class="headerlink" title="如何理解字节流"></a>如何理解字节流</h4><p>udp操作系统不会对齐拆分，所以每一个udp就是一个消息的边界.然而tcp是会分片的，这时候，接收方如果不知道消息的长度或者边界，是无法读取消息的，<strong>不能认为一个用户消息对应一个TCP报文，正因为这样，TCP是面向字节流的协议。</strong></p>
<p><strong>没有accept，能建立tcp连接吗</strong></p>
<p>可以</p>
<p><strong>已经建立的tcp，收到syn会发生什么</strong></p>
<p>新的syn首先看看端口是不是一样，如果不一样的话，就建立新的连接，老的那个如果一直不发消息就会触发tcp保活机制</p>
<p>如果相同（可能就是宕机重传），其实会返回一个challenge ack，携带正确的序列号的确认号的ack报文，这时候客户端确认号收到这个，发现不是自己期望收到的，就会返回rst，这样，服务器就释放了连接</p>
<h4 id="如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗"><a href="#如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗" class="headerlink" title="如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗"></a>如果四次挥手过程中，fin包先比数据包到了主动关闭方，那这个数据还会接受吗</h4><p>先到的fin包其实是乱序的，所以会进入乱序队列，等数据真正的到了，才会回头检查这个fin，然后给服务端发这个。</p>
<h4 id="如果timewait状态收到syn？会怎么样？"><a href="#如果timewait状态收到syn？会怎么样？" class="headerlink" title="如果timewait状态收到syn？会怎么样？"></a>如果timewait状态收到syn？会怎么样？</h4><p>还是先看序列号时间戳吧，如果确实合法，那应该会重新进入三次握手阶段，</p>
<p>如果不合法，就会返回一个和第四次挥手一样的ack，这时候服务端收到发现不是自己的，就回复一个rst报文</p>
<h4 id="服务端没有-listen，客户端发起连接建立，会发生什么？"><a href="#服务端没有-listen，客户端发起连接建立，会发生什么？" class="headerlink" title="服务端没有 listen，客户端发起连接建立，会发生什么？"></a>服务端没有 listen，客户端发起连接建立，会发生什么？</h4><p><strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文</strong></p>
<h4 id="Tcp连接，断电和进程崩溃有什么区别？没有保活机制"><a href="#Tcp连接，断电和进程崩溃有什么区别？没有保活机制" class="headerlink" title="Tcp连接，断电和进程崩溃有什么区别？没有保活机制"></a>Tcp连接，断电和进程崩溃有什么区别？没有保活机制</h4><p>客户端主机崩溃，没有保活机制，那就无法感知到，一直处于establish</p>
<p>进程崩溃，内核还是会发送fin完成4次挥手</p>
<h4 id="客户端主机宕机，又迅速重启"><a href="#客户端主机宕机，又迅速重启" class="headerlink" title="客户端主机宕机，又迅速重启"></a>客户端主机宕机，又迅速重启</h4><p><strong>只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</strong></p>
<h4 id="拔掉网线tcp连接还在吗"><a href="#拔掉网线tcp连接还在吗" class="headerlink" title="拔掉网线tcp连接还在吗"></a>拔掉网线tcp连接还在吗</h4><p>在的，tcp连接信息是存储于内核的一个结构体，网线断了，但是结构体不会改变</p>
<ul>
<li>拔掉网线后，有数据传输；</li>
<li>如果在重传前网线插回去了，那我觉得应该什么事情都没发生</li>
<li>如果没插回去，那么就超时重传几次之后，认为此连接死亡，就断开连接，即使后面插回来了，客户端向服务端发送请求，也不是连接的状态，那么服务端就会返回rst</li>
<li>拔掉网线后，没有数据传输</li>
<li>如果开启了保活机制，那就探测几次，如果有工作就重制保活时间，如果客户端没有正常工作，就断开连接</li>
<li>如果没有开启保活机制，就一直连着</li>
</ul>
</blockquote>
<h4 id="HTTPS-中-TLS-和-TCP-能同时握手吗？"><a href="#HTTPS-中-TLS-和-TCP-能同时握手吗？" class="headerlink" title="HTTPS 中 TLS 和 TCP 能同时握手吗？"></a>HTTPS 中 TLS 和 TCP 能同时握手吗？</h4><p>可能，但是有条件</p>
<ul>
<li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li>
<li><strong>客户端和服务端已经完成过一次通信。</strong></li>
</ul>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803205908513.png" alt="image-20230803205908513"></p>
<p>TCP Fast Open定义<br>TCP Fast Open（TFO）是用来加速连续TCP连接的数据交互的TCP协议扩展，原理如下：在TCP三次握手的过程中，当用户首次访问Server时，发送SYN包，Server根据用户IP生成Cookie（已加密），并与SYN-ACK一同发回Client；当Client随后重连时，在SYN包携带TCP Cookie；如果Server校验合法，则在用户回复ACK前就可以直接发送数据；否则按照正常三次握手进行<br><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803210533146.png" alt="image-20230803210533146"></p>
<p>所以就是在第二次以后的通信过程中，tcp open fast在ack发回来之前直接进行tls1.3</p>
<h4 id="quic怎么实现可靠传输"><a href="#quic怎么实现可靠传输" class="headerlink" title="quic怎么实现可靠传输"></a>quic怎么实现可靠传输</h4><p>总的来说，<strong>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</strong>，</p>
<p>Packet Number 是严格递增，即使重传报文的 Packet Number 也是递增的，既然重传数据包的 Packet N+M 与丢失数据包的 Packet N 编号并不一致，我们怎么确定这两个数据包的内容一样呢？</p>
<p>所以引入 Frame Header 这一层，<strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong>，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。</p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803212833705.png"></p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A02/image-20230803213009597.png" alt="image-20230803213009597"></p>
<h3 id="QUIC怎么解决对头阻塞"><a href="#QUIC怎么解决对头阻塞" class="headerlink" title="QUIC怎么解决对头阻塞"></a>QUIC怎么解决对头阻塞</h3><p><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，都是相互独立的，各自控制的滑动窗口</strong>。</p>
<h3 id="QUIC-是如何做流量控制的？"><a href="#QUIC-是如何做流量控制的？" class="headerlink" title="QUIC 是如何做流量控制的？"></a>QUIC 是如何做流量控制的？</h3><p>QUIC 实现流量控制的方式：</p>
<ul>
<li>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。 如果消耗数据的长度大于了最大接收窗口的一半发送</li>
<li>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"
                            aria-label=": 计算机网络1"
                        >
                            计算机网络1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-08T00:00:00+08:00">
	
		    08 Jul 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>计算机网络整体的学习可以按照tcpip网络模型进行学习。我们的总结也是这样的</p>
<p>Tcp&#x2F;ip网络模型分别是应用层、传输层、网络层、数据链路层</p>
<p>这里面前三层比较重要，数据链路层复杂的方面涉及实际的物理知识所以我们只对逻辑思想上做一个学习，</p>
<p>那每一层分别学的是什么呢？</p>
<p>应用层：HTTP  HTTPS TLS</p>
<p>传输层：tcp udp </p>
<p>网络层：ipv4 v6</p>
<p>基本上就是这样子</p>
<p>TCP 连接传输协议，这是传输层的，很多应用层的协议在传输层都是使用这个的，比如HTTP</p>
<h1 id="TCP和UCP的不同"><a href="#TCP和UCP的不同" class="headerlink" title="TCP和UCP的不同"></a>TCP和UCP的不同</h1><blockquote>
<p>那tcp和udp的差距是，tcp相比udp多了很多为了可靠连接所增加的特性，比如三次握手、四次挥手、拥塞控制，超时重传，就是为了数据能可靠的传到对方。udp他不用建立连接，不保证可靠交付，所以效率高。</p>
<p>除此之外，还有一个很大的不同就是tcp是会分片的，但是udp是不会分片。在这里我们还要知道的一点是在网络层，也就是ip协议中还是会分片的，大小是MTU。但是对于tcp来说因为你要是在ip层才分片，我为了保证可靠，我假设12345 丢了一个2，那我就要12345全部重新发，这样不好，所以我们就在tcp层也分片，大小是MSS。而udp不用可靠，所以他不用分片。</p>
</blockquote>
<p>报文头也不一样：udp是源端口目的端口，长度校验和。tcp多了很多东西，源端口目的端口，序列号确认号，状态位，首部长度，校验和等等。</p>
<p>但是过程中究竟是请求-应答模式还是什么模式，那就是后面的不同版本做出的更新。</p>
<p>但是他并不是不能做到可靠传输，因为udp只是传输层，我们还可以在应用层做出一定的限制来保证传输是可靠的，比如quic协议，当然这是困难的。</p>
<h1 id="那我们这里用输入网址到显示，来串联一下整体的流程："><a href="#那我们这里用输入网址到显示，来串联一下整体的流程：" class="headerlink" title="那我们这里用输入网址到显示，来串联一下整体的流程："></a>那我们这里用输入网址到显示，来串联一下整体的流程：</h1><p>首先是解析URL，得到三个信息，一个协议、一个域名、一个路径。</p>
<p>（浏览器缓存 -&gt; 操作系统缓存-&gt;本地DNS服务器-&gt;根域名服务器-&gt;顶级域名服务器-&gt;权威域名服务器）</p>
<p>根据域名，我们可以先去浏览器缓存里面找有没有，如果有，就直接返回，如果没有那就问操作系统的缓存再去看hosts文件，如果都没有，那就看走下面</p>
<p>客户端首先会发出一个 DNS 请求，问 <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> 的 IP 是啥，发给本地 DNS 服务器。</p>
<p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a target="_blank" rel="noopener" href="http://www.xx.com,则它直接返回/">www.xx.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器，根 DNS 收到来自本地 DNS 的请求后，返回一个.com的顶级域名服务器地址。</p>
<p>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？”</p>
<p>顶级域名服务器说：“我给你负责 <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> 区域的权威域名服务器的地址，你去问它应该能问到”。</p>
<p>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.xx.com对应的IP是啥呀？”">www.xx.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</p>
<p>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS，本地域名服务器返回给我们。这时候我们要先建立连接，进行三次握手，然后数据传输。通过调用 Socket 库，来委托协议栈工作。首当其冲肯定是TCP，其实就是加一个tcp报文头部（源端口、目的端口之的），然后由IP模块把数据封装成网络包，就是加一个IP头（源IP、目的IP）这时候你就知道了起点和终点。但是还不知道路径怎么规划，这个就需要ARP协议。具体就是先查ARP缓存，没有的话发一个ARP广播。网卡会把数字信号转为电信号，通过网线发送出去。中间会通过交换机（）、路由器，总之就是做FCS校验后，查询<strong>路由表</strong>找到转发的目标，然后重新加一个mac头（同样是ARP），发出去</p>
<h4 id="1、解析url"><a href="#1、解析url" class="headerlink" title="1、解析url"></a>1、解析url</h4><p><font color='red'><u><em><strong>解析之后得到三个信息，一个协议，一个是web服务器域名，一个是请求文件的路径（可选）。这时候客户端生产自己的HTTP请求报文</strong></em></u></font></p>
<p>格式如下，方法get，url没有默认index什么的，版本HTTP1.1，字段名就很多，然后是数据，这个数据也是后面一直包装的根数据。</p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728193306158.png" alt="image-20230728193306158">	</p>
<h2 id="地址查询-——-DNS"><a href="#地址查询-——-DNS" class="headerlink" title="地址查询 —— DNS"></a>地址查询 —— DNS</h2><p>（浏览器缓存 -&gt; 操作系统缓存-&gt;本地DNS服务器-&gt;根域名服务器-&gt;顶级域名服务器-&gt;权威域名服务器）</p>
<p>基于我们已经拿到的web服务器域名，我们可以先去浏览器缓存里面找有没有，如果有，就直接返回，如果没有那就问操作系统的缓存再去看hosts文件，如果都没有，那就看走下面</p>
<p>客户端首先会发出一个 DNS 请求，问 <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> 的 IP 是啥，发给本地 DNS 服务器。</p>
<p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a target="_blank" rel="noopener" href="http://www.xx.com,则它直接返回/">www.xx.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器，根 DNS 收到来自本地 DNS 的请求后，返回一个.com的顶级域名服务器地址。</p>
<p>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？”</p>
<p>顶级域名服务器说：“我给你负责 <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> 区域的权威域名服务器的地址，你去问它应该能问到”。</p>
<p>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.xx.com对应的IP是啥呀？”">www.xx.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</p>
<p>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</p>
<p>本地 DNS 再将 IP 地址返回客户端，我们要先建立连接，进行三次握手，然后数据传输。</p>
<p>消息传输的过程是我们拿到IP之后，通过调用 Socket 库，来委托协议栈工作。首当其冲肯定是TCP，其实就是加一个tcp报文头部（源端口、目的端口之后的），然后由IP模块把数据封装成网络包，就是加一个IP头（源IP、目的IP）这时候你就知道了起点和终点。但是还不知道路径怎么规划，这个就需要ARP协议。具体就是先查ARP缓存，没有的话发一个ARP广播。网卡会把数字信号转为电信号，通过网线发送出去。中间会通过交换机（）、路由器，总之就是做FCS校验后，查询<strong>路由表</strong>找到转发的目标，然后重新加一个mac头（同样是ARP），发出去</p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728193808617.png" alt="image-20230728193808617"></p>
<p>通过dns或者缓存获取到ip地址之后，我们就要为发送做一些准备，首先浏览器通过调用 Socket 库，来委托协议栈工作。</p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728193955912.png" alt="image-20230728193955912"></p>
<p>说是协议栈，其实就是中间tcp udp ip这些协议。那下面我们就来仔细的看看</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>tcp段的头如下所示：</p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728194108402.png" alt="image-20230728194108402"></p>
<p>TCP 传输数据之前，要先三次握手建立连接</p>
<p>前提：客户端 为closed状态，服务端变成listen状态</p>
<p>连接：</p>
<p>1、客户端向服务端发送连接syn，之后客户端处于syn-sent状态；</p>
<p>2、服务端接收到这个消息之后，会返回一个syn+ack，之后服务端处于syn-rcvd状态</p>
<p>3、客户端收到这个之后，再给服务端发送一个对syn的ack，之后客户端处于establish状态</p>
<p>服务端收到ack也变成了establish状态</p>
<p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p>
<p>假设我们已经建立了连接，我们要发送消息，但是消息要遵循tcp协议，他的消息大小是有限制的，不是每一次都可以发送全部消息。具体要求如下：</p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728195857751.png" alt="image-20230728195857751"></p>
<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li>
</ul>
<p>所以如果HTTP请求消息超过mss，那么就要分段发送。</p>
<p>到这里我们得到了一个tcp的报文段或者说包，下面我们就要把这个包发送给网络层，因为在传输层我们就是服务应用层，然后对好端口，确定好协议，之后的事情就不归传输层管控了。</p>
<p>到这里，我们的数据包的格式如下所示：</p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728200405680.png" alt="image-20230728200405680"></p>
<h2 id="定位IP"><a href="#定位IP" class="headerlink" title="定位IP"></a>定位IP</h2><p>ip协议的最重要的功能就是寻址和路由，他要做到这两点就需要你遵循ip协议，那么遵循的要求就是你加一个ip头<img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728200452235.png" alt="image-20230728200452235"></p>
<p>加上ip头之后我们就知道了我们的源ip和目的ip地址，那么起点站和终点站就已经知道了</p>
<p>可以现在又有一个小问题，那就是路径怎么规划呢？这时候就需要用到Mac地址</p>
<h2 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h2><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728202408619.png" alt="image-20230728202408619"></p>
<ul>
<li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li>
<li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询</li>
</ul>
<p>也就是说到了网络接口层，要发了，结果不知道往哪里发，这时候就按照上面两步得到mac地址</p>
<p>因为上面已经得到了ip地址，所以直接喊话：这个 IP 地址是谁的？请把你的 MAC 地址告诉我，就得到mac地址了。</p>
<p>到这里数据包还差最后一层包装</p>
<h2 id="出口–网卡"><a href="#出口–网卡" class="headerlink" title="出口–网卡"></a>出口–网卡</h2><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230728204942674.png" alt="image-20230728204942674"></p>
<p>最后一层包装就是上面图片提到的报头和起始帧分界符和fcs帧校验序列</p>
<p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p>
<p>到这里数据包就真正的包装结束了，最后网卡会将包转为电信号，通过网线发送出去。！！</p>
<h2 id="送别者—交换机"><a href="#送别者—交换机" class="headerlink" title="送别者—交换机"></a>送别者—交换机</h2><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p>
<p>一般在网线接口啊这些地方，其实路由器也可以作为交换机。</p>
<h3 id="交换机的包接收操作"><a href="#交换机的包接收操作" class="headerlink" title="交换机的包接收操作"></a>交换机的包接收操作</h3><p>交换机里的模块将电信号转换为数字信号。</p>
<p>然后通过包末尾的fcs校验错误，没问题就放到缓存区，这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p>
<h3 id="查询MAC-地址表"><a href="#查询MAC-地址表" class="headerlink" title="查询MAC 地址表"></a>查询<strong>MAC 地址表</strong></h3><p>如果找到，就发送到相应的端口，如果找不到，那说明该mac地址的设备还没有向我们交换机发送过包，那这时候我们主动的向除了源端口的所有端口都发送一遍，因为后面的设备他自己都有检测功能，所以不需要担心</p>
<p>这时候要么就发送到位，要么就可能离开子网了，离开子网需要用到路由器</p>
<h2 id="出境大门–路由器"><a href="#出境大门–路由器" class="headerlink" title="出境大门–路由器"></a>出境大门–路由器</h2><h3 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h3><blockquote>
<p>1、首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p>
<p>2、检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p>
<p>3、路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p>
</blockquote>
<h3 id="路由器的发送操作"><a href="#路由器的发送操作" class="headerlink" title="路由器的发送操作"></a>路由器的发送操作</h3><p><font color='red'><u><em>*<em><strong>匹配路由表确定输出端口并判断转发目标</strong>。</em>*而路由器则会忽略主机号部分，只匹配网络号部分 这里用的是最长匹配，</em><em>如果匹配上了，我们就看下他的网关列，如果网关是一个 IP 地址，那就是我们的转发目标，如果为空，那就是终点了。下面通过通过 ARP协议根据 IP 地址查询 MAC 地址，路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</em>**</u></font></p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20231025123050860.png" alt="image-20231025123050860"></p>
<p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p>
<p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p>
<p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这边举个例子<img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230729000740012.png" alt="image-20230729000740012"></p>
<p>子网1某个设备想要发送数据给子网2的某个设备</p>
<p>首先源ip和目的ip是知道的，如果只是简单的arp群发这个ip问是谁的ip地址，其实是找不到的，所以判断是否为同一子网，如果不是，就把目的mac改成网关的mac，然后数据发送到网关，这时候官网一查mac地址，发现属于子网2的设备，这时候修改源mac为自己的mac，修改目的mac为设备的地址，从子网2的网卡发出。</p>
<p>大多数情况下一个子网的默认网关就是一个，就基本代表着出口。复杂情况就需要某种选择算法了</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>超文本传输协议，就是两点之间超越普通文本范畴的文本（包括文本视频图片等等）的一种协议</p>
<h4 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h4><blockquote>
<table>
<thead>
<tr>
<th>1XX 代表提示信息</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2XX 这个就是成功的状态吗</td>
<td>200 普通的正常的成功</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3XX 代表重定向</td>
<td>301 永久重定向</td>
<td>302 临时重定向</td>
<td>304 缓存重定向</td>
<td></td>
</tr>
<tr>
<td>4XX 代表客户端的报文错误</td>
<td>400 比较笼统的</td>
<td>404 没找到</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5XX 代表服务器端端报文错误</td>
<td>500 同样比较笼统</td>
<td>503 请稍后再访问</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<h4 id="常见的字段"><a href="#常见的字段" class="headerlink" title="常见的字段"></a>常见的字段</h4><blockquote>
<p>host</p>
<p>content-length</p>
<p>content-type</p>
<p>connection </p>
<p>content-encodeing</p>
</blockquote>
<h4 id="HTTP-Get和Post区别"><a href="#HTTP-Get和Post区别" class="headerlink" title="HTTP://Get和Post区别"></a><a target="_blank" rel="noopener" href="http://get和post区别/">HTTP://Get和Post区别</a></h4><blockquote>
<p>额，get和post在请求行会有method的区别，实际中，其实get也可以带数据，post也可以不带数据。所以我觉得最大的区别还是在于语义的，get是读取的语义，post是有一种处理操作的语义。最后get是安全幂等，post不安全也不幂等。</p>
</blockquote>
<h4 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h4><blockquote>
<p>包括强制缓存和协商缓存</p>
<p>强制缓存就是浏览器缓存没有过期，那我就直接使用浏览器的缓存，一般用Cache-Control，相对时间。</p>
<p>协商缓存是有两种，一种时间，一种依赖唯一标识</p>
<p>1、请求头部里面的if modified since 和响应头部last- modified</p>
<p>响应信息的头部会有last modified，然后我们会带这个ifmodifiedsince：时间，去访问服务器，服务器看到之后，就拿自己的Last modified去对比 如果没改，返回304，如果改了，返回200</p>
<p>2、Etag 唯一标识</p>
<p>流程一样，但是etag优先级更高，因为 if modified since还是基于时间，而时间本身可能有一些限制。</p>
<p>1、有可能没有修改文件，但是文件的最后修改时间会变化</p>
<p>2、秒级以内的操作也许不能充分做出响应</p>
</blockquote>
<h4 id="HTTP优缺点"><a href="#HTTP优缺点" class="headerlink" title="HTTP优缺点"></a>HTTP优缺点</h4><p><strong>优点：</strong></p>
<blockquote>
<p>简单，灵活易扩充，应用广泛跨平台</p>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<p>1、HTTP无状态的。</p>
<p>在此基础上出现了cookie技术，他就是通过在请求和响应报文里面增加cookie信息，来控制客户端的状态</p>
<p>2、明文传输。</p>
<p>3、不安全 也是最重要的原因</p>
<blockquote>
<p>账号信息不安全</p>
<p>不验证对方的身份</p>
<p>无法证明报文的完整性</p>
</blockquote>
</blockquote>
<p><strong>HTTP1.1改进</strong></p>
<blockquote>
<p>1、HTTP1.1在HTTP1.0的基础上提出了长连接，之前是《请求-应答》模式就是你发完应答完，关闭连接，想要进行下一次通信，那就得重新建立连接，现在可以建立一次连接之后，就可以 发收发收发收 只要一方没有明确提出断开连接，那么就一直连着</p>
<p>2、管道通信，HTTP1.1支持管道，就是所有请求都处于管道内部，我们可以发发发，而不需要等他先回复再发第二个，你可以发发发，减少了时间</p>
<p>但是这里有一个问题，HTTP是基于tcp的所以服务端会按照顺序接收请求。</p>
<p>所以说，HTTP1.1可以解决发送端的对头阻塞，但是无法解决接受端的对头阻塞</p>
<p>然而！然而！HTTP1.1默认不开启管道，</p>
</blockquote>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="HTTPS和HTTP的区别？"><a href="#HTTPS和HTTP的区别？" class="headerlink" title="HTTPS和HTTP的区别？"></a>HTTPS和HTTP的区别？</h3><p><font color='red'><u><em><strong>Https在Http的基础上加入了TLS协议，在三次握手之后还要进行TLS握手，有RSA、ECDHE。这个TLS握手的过程中就用到了信息加密、数字签名、身份证书。</strong></em></u></font></p>
<h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p><strong>1、信息加密</strong></p>
<p>使用的是混合加密，<font color='red'><u><em><strong>非对称加密是在TLS握手的时候，对称加密是在传输数据的时候。</strong></em></u></font></p>
<p>非对成加密安全，非对称加密速度更快。</p>
<p><strong>2、数字签名（一个哈希值），身份证书（经过CA私钥加密的服务器公钥+内容+数字签名），这两个可以一起讲</strong></p>
<p>整体流程：服务器发送公钥和数字签名发到CA里面，CA用自己的私钥加密服务器的公钥和数字签名，这个就是证书！然后客户端发来请求的时候，服务器就把自己的证书发过去，客户端收到证书，用CA的公钥解密，得到了服务器的公钥和服务器的数字签名，这个签名我们上面讲了一个是原始内容一个是私钥对于哈希值的加密，那我们怎么验证呢？就是用公钥去解密加密项得到一个哈希值，再对原始内容做同样的哈希操作，判断两个哈希值到底一不一样，一样代表认证成功，否则，认证失败。</p>
<h4 id="3、TLS的秘钥交换算法"><a href="#3、TLS的秘钥交换算法" class="headerlink" title="3、TLS的秘钥交换算法"></a>3、TLS的秘钥交换算法</h4><p>TLS的密钥交换算法不同，那么连接步骤也不同，我们会介绍两种</p>
<h5 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h5><p><strong>1、客户端 &gt; 服务端。</strong></p>
<blockquote>
<p>Client Hello：client 随机数 + TLS版本号+密码套件，密码套件可以说是一组配置的整合信息罢了</p>
</blockquote>
<p><strong>2、客户端 &lt; 服务端。</strong></p>
<blockquote>
<p>Server Hello:server随机数+确认版本号+确认密码套件</p>
<p>Certificate: 证书</p>
<p>Server Hello Done：</p>
</blockquote>
<p>当然这里收到之后，先校验，校验流程如下：</p>
<p>首先我们知道了数字签名有原始内容和对于哈希值加密的数字签名，我们对原始内容加密（签名算法），对数字签名解密（CA公钥）</p>
<p>当然，其中有一个问题就是证书的信任问题？为什么？</p>
<p>因为我们得到的证书不一定是CA签发的，假如是中间机构签发的百度证书，那么我们就不能用内置的本地CA证书中的公钥去认证，所以我们先找签发机构，发现是一个中间机构，我们向中间机构请求证书，收到证书后发现这个机构的签发者是CA，那么我们可以用CA去认证中间的这个证书，这个证书被认证了 ，那么百度的也就认证了。</p>
<p><strong>3、客户端 &gt; 服务端 使用服务器的公钥加密pre-master随机数发给服务端</strong></p>
<blockquote>
<p>Client Key Exchange: 用第二步解密得到的公钥加密pre-master</p>
<p>Change Cipher spec：改用会话秘钥加密通信，</p>
<p>Finished：所有握手数据的摘要，再用会话密钥（master secret）加密一下，让服务端做个验证</p>
</blockquote>
<p><strong>4、客户端 &lt; 服务端 服务端发送 加密算法改变通知，和握手结束通知</strong></p>
<blockquote>
<p>Change Cipher spec：改用会话秘钥加密通信</p>
<p>Finished: 所有握手数据的摘要，再用会话密钥（master secret）加密一下，让客户端做个验证</p>
</blockquote>
<p>上面这个就是RSA的基本流程，但是基于RSA的HTTPS依旧存在《前向安全》的问题，客户端发送给服务端的随机数要用服务端的公钥加密，如果服务端私钥泄密，那么所有的TLS通讯就将被破解</p>
<h5 id="ECDHE"><a href="#ECDHE" class="headerlink" title="ECDHE"></a>ECDHE</h5><p>讲过程之前，可以先说一下这个算法。先讲一下前身DH算法。这个算法依赖的就是对数运算的基础上加了「模运算」。我们对数算法知道对数得到真数很简单，但是从真数得到对数是很难的。</p>
<p><strong>1、客户端 &gt; 服务端。</strong></p>
<blockquote>
<p>Client Hello：client 随机数 + TLS版本号+密码套件，密码套件可以说是一组配置的整合信息罢了</p>
</blockquote>
<p><strong>2、客户端 &lt; 服务端。</strong></p>
<blockquote>
<p>Server Hello:server随机数+确认版本号+确认密码套件</p>
<p>Certificate: 证书</p>
<p><strong>Server Key Exchange</strong>：选择椭圆曲线，和根据椭圆曲线的基点公钥，发给客户端</p>
<p>Server Hello Done：</p>
</blockquote>
<p><strong>3、客户端 &gt; 服务端 使用服务器的公钥加密pre-master随机数发给服务端</strong></p>
<blockquote>
<p>Client Key Exchange: 生成一个随机数作为客户端的私钥，根据前面信息生成<strong>客户端的公钥</strong>，发给服务端。<font color='red'><u><em><strong>至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。所以能算出x，两个随机数+x就是最后的秘钥</strong></em></u></font></p>
<p>Change Cipher spec：改用会话秘钥加密通信，</p>
<p><strong>Encrypted Handshake Message</strong>：所有握手数据的摘要，再用会话密钥加密一下，让服务器做个验证</p>
</blockquote>
<p><strong>4、客户端 &lt; 服务端 服务端发送 加密算法改变通知，和握手结束通知</strong></p>
<blockquote>
<p>Change Cipher spec：改用会话秘钥加密通信</p>
<p>Encrypted Handshake Message: 所有握手数据的摘要，再用会话密钥（master secret）加密一下，让服务器做个验证</p>
</blockquote>
<p>RSA和ECDHE的区别</p>
<ul>
<li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；</li>
<li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间（这个是 RFC 文档规定的，具体原因文档没有说明，所以这点我也不太明白）；</li>
<li>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息</li>
</ul>
<h4 id="HTTPS怎么实现数据的完整性？"><a href="#HTTPS怎么实现数据的完整性？" class="headerlink" title="HTTPS怎么实现数据的完整性？"></a>HTTPS怎么实现数据的完整性？</h4><p>刚才我们提到了TLS可以解决三个问题，包括完整性，</p>
<p>其实TLS在实现上包括了握手协议和记录协议</p>
<p>​	握手协议就是四次握手+后续加密来保护应用程序</p>
<p>​	记录协议负责保护数据的完整性和来源</p>
<p>所以我们来看记录协议：，他的实现就是负责对消息（HTTP数据）的压缩，加密和数据认证<img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/image-20230802185945107.png" alt="	"></p>
<p>这里还是应用层，消息被分割后进行压缩，加上消息验证码，加密，加密后加上一个报头，后面就是交给tcp层，传输层</p>
<h4 id="HTTPS一定安全吗"><a href="#HTTPS一定安全吗" class="headerlink" title="HTTPS一定安全吗"></a>HTTPS一定安全吗</h4><p>理论上这个协议是安全的，HTTPS其实就是加了个TLS协议，那就是问这个TLS是不是安全的</p>
<p>而TLS就是按四次握手</p>
<p>1、第一种方法：返回的证书，他大概率是伪造的，但是我们如果接受了，那就不一样了，你接受了服务器的证书，相当于信任了，那后面的通信就会被监听</p>
<p>2、直接植入根证书也会导致这种情况</p>
<p>所以关键就是对于证书的认证</p>
<h3 id="HTTP1-1-gt-HTTP-2-gt-HTTP3"><a href="#HTTP1-1-gt-HTTP-2-gt-HTTP3" class="headerlink" title="HTTP1.1  -&gt; HTTP 2 -&gt; HTTP3"></a>HTTP1.1  -&gt; HTTP 2 -&gt; HTTP3</h3><p><font color='red'><u><em><strong>HTTP1.1在HTTP1.0的基础上增了长连接和管道，解决了发送方的对头阻塞</strong></em></u></font></p>
<p>缺点：header是没有压缩的，只压缩了body部分，接收方会有对头阻塞，服务端智能被动响应</p>
<p><font color='red'><u><em><strong>HTTP2在是基于HTTPS的，所以安全性肯定有保障</strong></em></u></font></p>
<p><strong>1、头部压缩</strong></p>
<p>HTTP2会压缩头部，会帮你压缩消除重复的部分，用的是HPACK算法</p>
<p><font color='red'><u><em><strong>这就是HPACK算法，HPACK包括三个部分（静态字典、动态字典、huffman编码），字段名会被静态表或者动态表的index代替，huffman编码则是去压缩Value的值。</strong></em></u></font></p>
<blockquote>
<p><strong>静态表</strong></p>
<p>表中的参数都是提前定义好的，只有固定的 61个值。如果头部字段在静态表里面，第一个字节是01+静态表的Index，第二个字节代表是否使用Huffman编码+长度。后面就是内容。</p>
<p><strong>动态表</strong></p>
<p>重复的字段会被放到动态表里面，编码什么的和静态表一样</p>
</blockquote>
<p><strong>2、二进制格式</strong></p>
<p>HTTP2不像是HTTP1是纯文本的报文，而是全部改成了二进制，头部和数据题都是二进制，统称帧</p>
<p><strong>3、并发传输，引入了流的机制</strong></p>
<p>一条tcp连接有多个流，每个流可以包含一个或者多个message，这个message就是请求或者响应，message里面有一个或者多个frame帧，不同的HTTP请求有独一无二的帧，所以可以乱序发送，后面会按照streamid组装，<strong>同一 Stream 内部的帧必须是严格有序的</strong></p>
<p><font color='red'><u><em><strong>HTTP3，把tcp换成了udp，但是为了可靠，推出了QUIC</strong></em></u></font></p>
<blockquote>
<p>1、接住了流、没有对头阻塞</p>
<blockquote>
<p>但是各个流之间是相互独立的，一个流阻塞了，另外的流不会阻塞，这样就保证了没有对头阻塞</p>
</blockquote>
<p>2、QUIC包括了TLS，所以连接更快</p>
<blockquote>
<p>因为HTTP2里面tcp和TLS是分层的先三次握手然后四次握手，这样需要3个rtt。然而quic内部携带了TLS，而且TLS1.3只需要一个rtt就可以完成密钥的协商。就是说，第一次发送的时候就已经把签名算法、随机数都发给服务端了，甚至在第二次可以达到0rtt</p>
</blockquote>
<p>3、连接迁移和连接建立都更快了</p>
<blockquote>
<p>tcp是四元组，而quic是基于dcp的，他是靠<font color='red'><u><em><strong>连接id</strong></em></u></font>来标记通信，所以ip换了也没事</p>
</blockquote>
<p>4、头部压缩变成了QPACK</p>
<blockquote>
<p>静态表变成91项，动态编码方式换了</p>
</blockquote>
</blockquote>
<h4 id="HTTP1-1请求怎么优化"><a href="#HTTP1-1请求怎么优化" class="headerlink" title="HTTP1.1请求怎么优化"></a>HTTP1.1请求怎么优化</h4><p>一方面是HTTP发送的问题，一方面是他本身数据的问题</p>
<p>1、首先肯定是避免HTTP请求：缓存技术</p>
<p>2、减少重定向，这个就是把重定向请求交给代理服务器</p>
<p>3、合并请求，就是把多个访问小文件的请求合并成一个大的</p>
<p>4、延迟发送，只访问看得到的资源</p>
<p>5、无损压缩，accept- encoding：gzip br </p>
<p>6、有损压缩，webP png</p>
<h4 id="HTTPS怎么优化"><a href="#HTTPS怎么优化" class="headerlink" title="HTTPS怎么优化"></a>HTTPS怎么优化</h4><p>HTTPs对于HTTP多了一个TLS，关键就是通过非对成加密握手得到对成加密的会话密钥</p>
<ul>
<li>提高cpu</li>
<li>升级linux </li>
<li>对密钥交换过程进行优化</li>
<li>RSA要四次握手，慢，安全性不高，我们可以缓存eche密钥交换算法，曲线选择x25519，对成加密算法，也可以换aes128</li>
<li>TLS升级1.3，升级的地方在于hello和公钥交换两个消息合并成一个消息</li>
<li>证书优化，分为传输优化和验证优化。</li>
</ul>
<p>传输：服务器证书选择椭圆曲线</p>
<p>验证：验证的过程中不仅需要ca还需要是否被ca吊销；crl是吊销列表，ca定期更新，但是实时性不好，ocsp，向ca fan song请求，返回状态，这个增加了请求开销，万一网络不好或者ca繁忙就会出现延迟；oscp stapling，服务器向ca定期查证书状态，然后在握手阶段就直接发给客户端，这样客户端就不用再去请求了。</p>
<ul>
<li>会话复用：session id 和session ticket</li>
</ul>
<p>session id：首次连接后，在内存缓存会话密钥，用session id标识，再次连接的时候，会在hello消息中带上这个，服务器收到这个就从缓存里面找，直接回复会话状态，跳过中间流程</p>
<p>缺点是，内存压力大</p>
<p>session ticket：类似于cookie，把缓存的工作交给客户端，首次连接，会加密这个发给客户端缓存起来，第二次连接，客户端会发送ticket，服务器解密后验证日期是否有效，没问题就恢复会话。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/"
                            aria-label=": mybatis组件的整合理解2"
                        >
                            mybatis组件的整合理解2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-27T00:00:00+08:00">
	
		    27 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>orm我们已经知道具体的做法了，那怎么把这个和我们的spring结合在一起呢？</p>
<p>其实我们要做的就是让他参与到Spring的事务管理之中，然后创建映射器和sqlsession并注入到bean里面，再把异常转化成Spring到dataaccessexception。以上的种种就是要把我们自己的orm交给spring管理。<img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427143800831.png" alt="image-20230427143800831"></p>
<p>orm结合spring的核心内容就是对需要注册对象的扫描，代理类的实现，bean的注册。</p>
<p>这里和orm框架一样，也有三个类非常重要：SqlSessionFactoryBean、MapperScannerConfigurer、MapperFactoryBean</p>
<p>先说SqlSessionFactoryBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 在基本的 MyBatis 中，session 工厂可以使用 SqlSessionFactoryBuilder 来创建。而在 MyBatis-Spring 中,则使用 SqlSessionFactoryBean 来替代。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;SqlSessionFactory&gt;, InitializingBean &#123;</span><br><span class="line">    <span class="keyword">private</span> String resource;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> Resources.getResourceAsReader(resource)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlSessionFactory.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResource</span><span class="params">(String resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SqlSessionFactoryBean实现InitializingBean主要适用于加载mybatis相关内容；解析xml、构造sqlsession、链接数据库等等，这三步就是我们orm框架中的核心部分，这也是为什么你只要引入一些数据库的依赖，你如果没有配置数据库，他在项目启动的时候就会报错，因为这个需要一开始就配置好。</p>
<p>MapperScannerConfigurer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerConfigurer</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String basePackage;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + basePackage.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ResourcePatternResolver</span> <span class="variable">resourcePatternResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line"></span><br><span class="line">            Resource[] resources = resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMetadataReader</span>(resource, ClassUtils.getDefaultClassLoader());</span><br><span class="line"></span><br><span class="line">                <span class="type">ScannedGenericBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> Introspector.decapitalize(ClassUtils.getShortName(beanDefinition.getBeanClassName()));</span><br><span class="line"></span><br><span class="line">                beanDefinition.setResource(resource);</span><br><span class="line">                beanDefinition.setSource(resource);</span><br><span class="line">                beanDefinition.setScope(<span class="string">&quot;singleton&quot;</span>);</span><br><span class="line">                beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(beanDefinition.getBeanClassName());</span><br><span class="line">                beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(sqlSessionFactory);</span><br><span class="line">                beanDefinition.setBeanClass(MapperFactoryBean.class);</span><br><span class="line"></span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName);</span><br><span class="line">                registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBasePackage</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.basePackage = basePackage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个类要做的就是把Dao接口全部扫描出来（也就是所有的XXXdao），完成他们的代理，然后把他们注册到spring Bean容器</p>
<p>打个锻炼看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postProcessBeanDefinitionRegistry</span><br></pre></td></tr></table></figure>

<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427145417700.png" alt="image-20230427145417700"></p>
<p>看这个packagesearchpath就明白了</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427145506491.png" alt="image-20230427145506491"></p>
<p>看resource，因为我们只有一个dao所以就扫描到了一个</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427145729295.png" alt="image-20230427145729295"></p>
<p>这里把他注册到容器中</p>
<p>mapperfactory：</p>
<p>这个类其实就是你所有dao接口类的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日常调用的 dao 层接口就是 MapperFactoryBean 实例化的</span><br></pre></td></tr></table></figure>

<p>我们虽然配置的是<code>MapperFactoryBean</code>的实列，但是根据id拿到的是<code>getObject</code>方法里面返回的的对象。其实在容器中创建的对象仍然是<code>MapperFactoryBean</code>的实列，只是在获取的时候会判断这个结果对象是不是派生于<code>FactoryBean</code>，如果是的话则返回<code>getObject</code>方法创建的对象，并且这个对象并不是容器初始化时创建的，而是使用<code>context.getBean()</code>方法时才创建。当然了，如果你确实想要获取<code>FactoryBean</code>实例，你需要这样写: <em><code>MapperFactoryBean mapper = context.getBean(&quot;&amp;mapper&quot;, MapperFactoryBean.class);</code></em> 只需要在bean的名字ID前加上&amp;符号。</p>
<p>所以究竟getObject获取的是什么呢？那就看他return了什么，后面的详细知识和加载流程，就涉及spring源码，所以可以看我的Spring ioc加载流程，保真有所收获！</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A33/"
                            aria-label=": mybatis组件的整合理解3"
                        >
                            mybatis组件的整合理解3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-27T00:00:00+08:00">
	
		    27 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>现在我们来把我们的成果整合到springboot中，但是我们又不想另起一个模块放我们的整合模块，那怎么做呢？诶，没错，就是依赖组件，我们开发自己的依赖组件，在项目中引入即可。</p>
<p>那么在springboot的starter的开发过程中，主要的核心在于自动加载autoconfiguration的使用，我们需要加载yml或者其他的配置文件，并结合配置信息注册相关的bean，因为spring和springboot的注册方式可以不同。</p>
<p>和myabtis组件的整合理解2中提到的mybatis-spring不同的在于，由于spring和springboot本身存在的区别所以加载配置和启动方式有所不同，所以这里我们需要修改的就是扫描方法，注册代码。</p>
<p>这个工程也主要分成三块：autoconfigure、mybatis、spring</p>
<p>●autoconfigure,读取自定义配置信息以及负责把相关mybatis、spring 中的Bean加载启动<br>●mybatis,这部分与我们之前实现的ORM框架源码几乎是一致的，只是对<br>SqlSessionFactoryBuilder做了符合yml配置方式的加载处理。<br>●spring,这一部分主要的变 动是MapperScannerConfigurer关于扫描定义Bean 信息时<br>addGenericArgumentValue入参信息的变更。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A33/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/26/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/"
                            aria-label=": mybatis组件的整合理解1"
                        >
                            mybatis组件的整合理解1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-26T00:00:00+08:00">
	
		    26 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>其实这里最核心的还是做一个ORM对象关系映射，用于不同类型系统的数据之间的转换，也让我们更方便的使用数据库。</p>
<p>主要做法其实就是通过：参数映射、SQL解析和执行以及结果封装的整体方式对数据库进行操作。这也是ORM框架的核心内容。</p>
<p>这里我们注意三类 类，没错就是三个类的类</p>
<p>分别是，sqlsession、sqlsessionfactory、sqlsessionfactorybuilder</p>
<p>sqlseesion：定义了对数据库的操作，什么查询啊之类的。然后接口必须有一个实现类，这里我们用的是defaultsqlsession，实现了接口的方法，也包装了jdbc，这样就把数据库的jdbc包装起来了，我们敲代码也会方便。</p>
<p>sqlsessionfactory：你每次有数据库操作都需要开启一个sqlsession那么从谁那里获取呢，就是factory。他也有一个实现类defaultsqlsession factory，他的唯一方法就是返回上面我们的defaultsqlsession，通过传进去的参数返回sqlsession，不过这个类的构造函数传递了configuration配置，包括connection connection，Map dataSource， Map mapperElement。</p>
<p>sqlsessionfactorybuilder：这个类主要包括：build构建实例化元素，parseConfiguration解析构造，datasource获取数据库配置，connnection链接数据库，mapperElement解析sql语句。</p>
<p>build，创建解析xml文件的类，然后初始化Defaultsqlsessionfactory工厂类，但是这个工厂类需要configuration，那这个configuration则需要parseconfiguration，所以往下看</p>
<p>parseConfigtation：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        configuration.setDataSource(dataSource(root.selectNodes(<span class="string">&quot;//dataSource&quot;</span>)));</span><br><span class="line">        configuration.setConnection(connection(configuration.dataSource));</span><br><span class="line">        configuration.setMapperElement(mapperElement(root.selectNodes(<span class="string">&quot;mappers&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>首先，我们在build以及把xml文件扫描进来了，然后我们用扫描后的参数去设置数据库、链接、节点这三个关键。</p>
<p>datasource函数打断点看看：就是进去了这四个数据库的参数</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/E7B0BF9D-E780-405F-9FE7-85CECE47328F-2492888.png" alt="E7B0BF9D-E780-405F-9FE7-85CECE47328F"></p>
<p>connectin函数里面用这几个参数得到一个链接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(dataSource.get(<span class="string">&quot;driver&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> DriverManager.getConnection(dataSource.get(<span class="string">&quot;url&quot;</span>), dataSource.get(<span class="string">&quot;username&quot;</span>), dataSource.get(<span class="string">&quot;password&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>mapperElement函数<img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426154547513.png" alt="image-20230426154547513"></p>
<p>拿到build扫描的参数，做循环</p>
<p>每次循环，先拿到resource，举个例子：</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426154908196.png" alt="image-20230426154908196"></p>
<p>先拿到mapper&#x2F;usermapper.xml，然后去读这个文件，拿到namespace</p>
<p>也就是对应的dao类，这里就是iuserdao</p>
<p>然后去读doc文件里面的各个操作，我们这个读取了select等等操作，反正就是把xnode放到map里面</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426155555163.png" alt="image-20230426155555163"></p>
<p>这个map就是我们的mapperelement，里面是一个namespace对应一个xnode。</p>
<p>所以mapperelement函数就是去拿到</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426155850578.png" alt="image-20230426155850578">对应到我们的具体的mapper.xml文件，然后读取这个文件，去解析我们的sql语句，然后得到一个名称和sql的映射关系的map</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/26/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/22/DBRouter%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/"
                            aria-label=": DBRouter组件的整合理解"
                        >
                            DBRouter组件的整合理解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-22T00:00:00+08:00">
	
		    22 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>这个项目我设计的初衷是考虑到业务体量的增加，为了避免原有的设计出现不能承载业务规模的情况发生，所以想设计分库分表， 因为想提高自己的理解，决定自己写一个小组件。</p>
<p><img src="/../images/DBRouter%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/image-20230428132828992.png" alt="image-20230428132828992"></p>
<p>主要考虑以下几个方面：</p>
<p>一是配置，分库分表需要配置连接池，这个依赖于配置文件，配置连接池之后要二是：考虑动态切换，所以需要去实现AbstractRoutingDataSource的deteemingCurrentlookKey方法。</p>
<p>三：数据库连接池和动态切换配置好了，就只剩下一个路由的计算模块了，从路由计算中获得分库分表的字段，通过哈希散列和扰动函数最终选择去哪个表，让数据均匀的散列到各个表。</p>
<p>首先讲一下：DataSourceAutoConfig，借助springboot自动配置机制，读取配置以及数据源的创建，包括yml自定义配置，JoinPoint、路由策略、路由配置、数据源、transactionTemplate.</p>
<p>举个例子：setEnvironment, 读取自定义配置，因为我们要设置的是一个在yml配置多组数据源，这个方法就是为了解析下面的配置信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router :</span><br><span class="line">jdbc:</span><br><span class="line">datasource :</span><br><span class="line">dbCount: 2</span><br><span class="line">tbCount: 4</span><br><span class="line">list: db01 , db02</span><br><span class="line">db01 :</span><br><span class="line">dr iver-class-name: com . mysql. jdbc .Driver</span><br><span class="line">url: jdbc :mysql://127.0.0.1:3306/bugstack_ 01?</span><br><span class="line">useUnicode-true</span><br><span class="line">username: root</span><br><span class="line">password: 123456</span><br><span class="line">db02 :</span><br><span class="line">dr iver-class-name: com. mysql. jdbc . Driver</span><br><span class="line">url: jdbc :mysql:/ /127.0.0.1:3306/bugstack_ 02?</span><br><span class="line">useUnicode-true</span><br><span class="line">username: root</span><br><span class="line">password: 123456</span><br></pre></td></tr></table></figure>



<p>动态数据源的切换如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;db&quot;</span> + DBContextHolder.getDBKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>路由计算：</p>
<p>路由结果会存储在DBConrtextHolder里面</p>
<p>路由计算首先需要一些前提</p>
<p>路由注解@DBRouter 路由的标识，目的是为了给切面提供切点，同时获取方法中入参属性点某个字段，这个字段会作为路由字段存在，比如某个dao接口的xxxdao方法上面就有这个</p>
<p>分表标记@DBRouterStrategy：目的是告诉路由组件要不要分表，默认false</p>
<p>最关键的，DBRouterJoinPoint切面类，进行路由选择	</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/22/DBRouter%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/11/spring%E6%95%B4%E5%90%88mybatis/"
                            aria-label=": Spring整合mybatis"
                        >
                            Spring整合mybatis
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-11T00:00:00+08:00">
	
		    11 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h4 id="Spring整合Mybatis要解决的问题"><a href="#Spring整合Mybatis要解决的问题" class="headerlink" title="Spring整合Mybatis要解决的问题"></a>Spring整合Mybatis要解决的问题</h4><p>重点关注下的Mapper动态代理对象，因为Spring整合Mybatis的核心目标是：把某个Mapper的代理对象作为一个bean放入Spring容器中，使得能够像使用一个普通bean一样去使用这个代理对象，比如能被@Autowire自动注入。常用如下通过Ioc容器把UserMapper注入了UserService</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;    </span><br><span class="line">    @Autowired    </span><br><span class="line">    private UserMapper userMapper;    </span><br><span class="line">    </span><br><span class="line">    public UserEntity queryUser(int id)&#123;        </span><br><span class="line">        UserEntity userEntity = userMapper.getById(id);        </span><br><span class="line">        return userEntity;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    public void printServiceName()&#123;        </span><br><span class="line">        System.out.println(&quot;I&#x27;m UserService&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spring启动过程中，bean的生命周期如下</p>
<ul>
<li>扫描指定的包路径下的class文件或解析xml文件</li>
<li>生成对应的BeanDefinition</li>
<li>BeanFactoryPostProcessor注册或修改BeanDefinition定义</li>
<li>根据BeanDefinition反射实例化Bean</li>
<li>BeanPostProcessor修改Bean定义</li>
<li>Bean的业务调用</li>
<li>Bean的销毁</li>
</ul>
<p>对于两个Service：UserService&#x2F;OrderInfoService定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"> </span><br><span class="line">    public void printServiceName()&#123;</span><br><span class="line">        System.out.println(&quot;I&#x27;m UserService&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">执行如下命令：</span><br><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">System.out.println(ctx.getBean(&quot;userService&quot;));</span><br><span class="line">结果如下：</span><br><span class="line">com.hobbit.service.UserService@4167d97b</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增加一个FactoryBean后置处理器，修改userService的BeanDefinition定义</span><br><span class="line">@Component</span><br><span class="line">public class RenameBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(&quot;userService&quot;);</span><br><span class="line">        beanDefinition.setBeanClassName(OrderInfoService.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">重新运行结果如下，生成了OrderInfoService对象。</span><br><span class="line">com.hobbit.service.OrderInfoService@57ad2aa7</span><br></pre></td></tr></table></figure>

<p><em><strong>所以在Spring中bean对象跟class或xml定义的bean无直接关系，跟最终的BeanDefinition有直接关系。</strong></em></p>
<p><em><strong>要想生成一个bean，首先要有一个BeanDefinition。那Mapper对应的BeanDefinition是？</strong></em></p>
<p>这就引出了下一个类</p>
<h4 id="MapperFactoryBean"><a href="#MapperFactoryBean" class="headerlink" title="MapperFactoryBean"></a>MapperFactoryBean</h4><p>Spring通过BeanDefinition的beanClassName生成对应的bean，那mapper的对应的beanClassName是什么？本可以有两个答案：</p>
<ul>
<li>代理对象对应的代理类</li>
<li>代理对象对应的接口</li>
</ul>
<p>因为代理类是动态生成的，spring启动时无法得知，无法使用。那么代理对象对应的接口？思路如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanDefinition bd = new BeanDefinitoin();</span><br><span class="line">// 注意这里，设置的是UserMapper</span><br><span class="line">bd.setBeanClassName(UserMapper.class.getName());</span><br><span class="line">SpringContainer.addBd(bd);</span><br></pre></td></tr></table></figure>

<p>实际上给BeanDefinition对应的类型设置为一个接口是行不通的，因为Spring没有办法根据这个BeanDefinition去new出对应类型的实例，接口是没法直接new出实例的。</p>
<p>所以想通过设置BeanDefinition的class类型，然后由Spring自动地帮助我们去生成对应的bean，但是这条路是行不通的。可以通过其它方<strong>MapperFactoryBean</strong>来实现。</p>
<p>MapperFactoryBean继承关系</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b00b1795cde71cbf838c42c2d7bd8d42.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  ...</span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public T getObject() throws Exception &#123;</span><br><span class="line">    return getSqlSession().getMapper(this.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public Class&lt;T&gt; getObjectType() &#123;</span><br><span class="line">    return this.mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getObjectType返回的是Mapper接口，通过 AbstractBeanDefinition.AUTOWIRE_BY_TYPE时，可自动注入使用。</p>
<p>getObject返回了动态代理对象，跟之前的使用一致。至此完成了Mapper对应BeanDefinition定义的问题，那这些BeanDefinition是如何注册到Ioc容器呢？</p>
<h4 id="Mapper-BeanDefinition加载"><a href="#Mapper-BeanDefinition加载" class="headerlink" title="Mapper BeanDefinition加载"></a>Mapper BeanDefinition加载</h4><p>Spring可通过多种方式加载BeanDefinition，从XmlBeanDefinitionReader到ClassPathBeanDefinitionScanner在到ConfigurationClassBeanDefinitionReader分别对应xml、@component、@configuration类定义的加载。Mapper BeanDefinition可通过2种形式加载MapperScannerConfigurer和@MapperScan注解，内部都是通过ClassPathMapperScanner实现。ClassPathMapperScanner继承了ClassPathBeanDefinitionScanner，类图如下</p>
<p>两种方式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定要扫描的包，在此包下自动搜索映射器(接口) --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;basePackage&quot; value=&quot;com.hobbit.mapper&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用@MapperScan加载</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用MapperScannerConfigurer加载在配置MapperScannerConfigurer中主要是加载dao包中的所有dao接口，通过sqlsessionFactory获取sqlsession，然后创建所有dao接口对象，存储在spring容器</strong></p>
<p><strong>会在spring容器刷新refresh过程中被调用</strong></p>
<p>到此为止，Spring整合Mybatis的核心原理就结束了，再次总结一下：</p>
<p>定义MapperFactoryBean，用来封装Mapper对应的BeanDefinition<br>通过ClassPathMapperScanner重新定义BeanClass及AutowireMode，实现BeanDefinition加载及MapperInterface与MapperFactory整合<br>通过MapperScannerConfigurer或@MapperScan，分别扩展BeanDefinitionRegistryPostProcessor及ImportBeanDefinitionRegistrar 用来在启动Spring时执行调用ClassPathMapperScanner完成Mapper BeanDefinition的注册</p>
<h2 id="Spring的启动流程："><a href="#Spring的启动流程：" class="headerlink" title="Spring的启动流程："></a>Spring的启动流程：</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39559282/article/details/118255793">https://blog.csdn.net/weixin_39559282/article/details/118255793</a></p>
<h2 id="MyBatis与Spring的集成原理"><a href="#MyBatis与Spring的集成原理" class="headerlink" title="MyBatis与Spring的集成原理"></a>MyBatis与Spring的集成原理</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73311735/article/details/129226313">https://blog.csdn.net/m0_73311735/article/details/129226313</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/11/spring%E6%95%B4%E5%90%88mybatis/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"
                            aria-label=": 参考资料"
                        >
                            参考资料
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-11T00:00:00+08:00">
	
		    11 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/">学习资料</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <hr>
<p>LS0tCnRpdGxlOiDlj4LogIPotYTmlpkKZGF0ZTogMjAyMy0wNC0xMQp0YWdzOiAKICAtIOeUn+eQhumcgOaxggpjYXRlZ29yaWVzOgogIC0g5a2m5Lmg6LWE5paZCgotLS0KIyMjIDIwMjMvMTAvMzHmm7TmlrAK5YaF5a655Li76KaB5p2l6Ieq5pCc5Lmm572R77yM5LiA5LiqSOWwj+ivtOe9keerme+8jOS9huaYr+acieW+iOWkmueRn+eRn+W5v+WRiuOAggpodHRwczovL3d3dy4xMDIwc3NsLjExMTFjaGVhcC5jb20vIOS4u+mhtQpodHRwczovL2YubXVzaWMuc2ZyZWUwODI1LnRvcDo5NDQzLyDmj5DkvpvnmoTlnKjnur&#x2F;op4bpopHnvZHnq5kKaHR0cHM6Ly93d3cuY2FyY2FyLmZsaWdodDJjaGVhcC5jb20vZm9ydW0ucGhwP21vZD1mb3J1bWRpc3BsYXkmZmlkPTIg5o+Q5L6b55qE5LiL6L296KeG6aKR6LWE5rqQCuWwj+ivtOWIhuWMuui&#x2F;mOacieiuuOWkmue9keermeWIhuaekO+8jOiHquihjOWvu+aJvgoKCgojIyMgMjAyMy8wNy8yOeabtOaWsAoK6Ym05LqO5pyA5Yid54mI5pys6YOo5YiG572R56uZ5bey5Lii5aSx77yM5Yaz5a6a5a+55omA5pyJ572R56uZ6L+b6KGM5YWo6Z2i5riF5rSX44CCCgojIyMjIOaXoOmcgOe&#x2F;u+Wime+8mgoKQVblpKnloILnvZHvvJpodHRwOi8vYmIuOTk5OXllcy5jb20vbmV3c2l0ZS5odG1sP2M9NDk5ODg4Mzg0MCAKCua8q+ibme+8iOmfqea8q++8ie+8mmh0dHBzOi8vbWFud2EubWUvCgrmgKflpYvoibLlkIPnk5znvZHvvJpodHRwOi8vd3d3Lnhmc2UxMS5jb20vCgo1R+W9semZou+8mmh0dHBzOi8vNXF3bWJhLnRvcC8KCuadj1RW77yaaHR0cHM6Ly8xOHhpbmd0di5jYy8KCueci+eJh+inhumike+8mmh0dHBzOi8vd3d3LmhrMTJxLnRvcC92b2RwbGF5aHRtbC8yMjQtMS0xLmh0bWwKCuS4u+aSreinhumike+8mmh0dHBzOi8vd3d3LnU3c2IuY29tL2VudGVyL2luZGV4Lmh0bWwKCnlvdXBvcm4gQVNJQSBDSEFOTkVM77yaaHR0cDovL3gzMzY5OS5jb20vCgp2OGs0bi5jb23vvJpodHRwczovL3d3dy52OGs0bi5jb20vaW5kZXgvaG9tZS5odG1sCgojIyMjIOe&#x2F;u+Wime+8mgoKeGhhbXN0ZXLvvJpodHRwczovL3poLnhoYW1zdGVyLmNvbS8KCueLvOWPi+mYge+8mmh0dHBzOi8vMDA1MWF2LmNvbS8KCum7keaWmeato+iDvemHj++8mmh0dHBzOi8vd3d3LmZ1bGkzNC5sdi8KClBvcm5odWLvvJpodHRwczovL2NuLnBvcm5odWIuY29tLwoKYuW9semZou+8mmh0dHBzOi8vYmJieXVuLnRvcC8KCiMjIyMg6L2v5Lu277yaCgrlhbblrp7orrjlpJrnvZHnq5nnmoTlj4vpk77kuK3pg73mnInova&#x2F;ku7bvvIzov5nph4zkuL7kuIDkvosKCum7keaWmeekvu+8mmh0dHBzOi8vdDYycm8uY29tLz9kYz1NSVlVMDQ&#x3D;</p>
<p><a target="_blank" rel="noopener" href="https://www.iamwawa.cn/base64.html">https://www.iamwawa.cn/base64.html</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/11/spring%20ioc%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"
                            aria-label=": Spring ioc加载流程"
                        >
                            Spring ioc加载流程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-11T00:00:00+08:00">
	
		    11 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><strong>在功能上，SpringBoot的容器启动过程基本遵循了Spring的标准启动过程，但是在具体实现上，SpringBoot提供了一些特殊的机制来简化Spring容器的配置和启动。</strong></p>
<p><strong>首先，SpringBoot自动配置了很多常用的第三方库和框架，使得在大多数情况下，开发者不需要手动配置就能够使用这些库和框架。其次，SpringBoot提供了一些基础设施和约定来简化Spring的配置，例如默认的目录结构、默认的配置文件名、默认的属性配置等，这些都能够减少开发者的配置工作。最后，SpringBoot提供了一些自定义扩展机制，例如通过@ConfigurationProperties注解来绑定配置文件属性到Java对象，通过SpringApplication类的addListeners()方法来添加自定义的启动监听器等等，这些扩展机制能够让开发者更加方便地自定义和扩展SpringBoot的功能。</strong></p>
<p><strong>总的来说，SpringBoot并没有改变Spring的核心机制和启动过程，但是它在具体实现上提供了很多便利和简化，让开发者能够更加快速地开发和部署应用程序</strong></p>
<p>总体分成两个阶段；</p>
<ul>
<li>一、refresh之前</li>
<li>二、调用refresh()方法刷新容器</li>
</ul>
<h2 id="一、初始化流程"><a href="#一、初始化流程" class="headerlink" title="一、初始化流程"></a>一、初始化流程</h2><ol>
<li>创建并实例化一个 ApplicationContextInitializer 列表，用于对 Spring 应用上下文进行初始化。ApplicationContextInitializer 是 Spring 4.1 引入的一个新特性，允许用户在容器启动之前，对 Spring 应用上下文进行一些额外的初始化工作。</li>
<li>创建并实例化一个 ResourceLoader 对象，用于加载配置文件。ResourceLoader 是一个接口，它定义了资源加载的基本方法。Spring 容器默认使用 DefaultResourceLoader 作为 ResourceLoader 实现类。</li>
<li>创建并实例化一个 PropertyResolver 对象，用于解析配置文件中的属性。PropertyResolver 也是一个接口，它定义了属性解析的基本方法。Spring 容器默认使用 PropertySourcesPlaceholderConfigurer 作为 PropertyResolver 实现类。</li>
<li>加载和解析配置文件，将解析后的配置信息封装成一个 Environment 对象。Environment 是 Spring 中用于描述应用环境的一个抽象概念，它包含了各种配置属性和属性值。</li>
<li>将解析后的配置信息封装成一个 ConfigurableEnvironment 对象，并将其设置到容器中。ConfigurableEnvironment 是 Environment 的一个子接口，它定义了一些额外的操作，如添加属性、激活配置文件等。</li>
<li>创建并实例化一个 BeanFactoryPostProcessor 列表，用于在 BeanFactory 加载 Bean 定义之后，对 Bean 定义进行进一步的处理。BeanFactoryPostProcessor 是一个接口，它提供了在 BeanFactory 加载 Bean 定义之后，修改 Bean 定义的机会。</li>
<li>创建并实例化一个 BeanPostProcessor 列表，用于在 Bean 实例化之后，对 Bean 进行进一步的处理。BeanPostProcessor 是一个接口，它提供了在 Bean 实例化之后，修改 Bean 实例的机会。</li>
<li>注册并加载 BeanFactory 中的 Bean 定义。在这个阶段，Spring 容器会扫描指定的包，查找标注了 @Component、@Service、@Repository、@Controller 等注解的 Bean，将其封装成 BeanDefinition 对象，注册到 BeanFactory 中。</li>
<li>调用 BeanFactoryPostProcessor 的 postProcessBeanFactory() 方法，对 BeanFactory 中的 Bean 定义进行进一步的处理。</li>
<li>注册并加载 BeanFactoryPostProcessor 中的 Bean 定义。BeanFactoryPostProcessor 可以通过实现 BeanDefinitionRegistryPostProcessor 接口，向 BeanFactory 中注册新的 Bean 定义。</li>
<li>初始化并注册 ConversionService。ConversionService 是 Spring 中用于类型转换的一个组件，它可以将一个对象转换成另一个类型的对象。在这个阶段，Spring 容器会注册一些默认的转换器。</li>
<li>初始化并注册 LoadTimeWeaver。LoadTimeWeaver 是 Spring 中用于支持动态类加载和增强的一个组件。它可以将类的字节码在运行时进行增强，从而实现 AOP 等功能。</li>
<li>初始化并注册 Resource</li>
</ol>
<p><strong>中间第8步解析过程如下：</strong></p>
<p>这个步骤主要是用来解析用户传入的 Spring 配置类，解析成一个 BeanDefinition 然后注册到容器中，主要源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span><br><span class="line">		@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) &#123;</span><br><span class="line">	// 解析传入的配置类，实际上这个方法既可以解析配置类，也可以解析 Spring bean 对象</span><br><span class="line">	AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">	// 判断是否需要跳过，判断依据是此类上有没有 @Conditional 注解</span><br><span class="line">	if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">	ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">	abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">	String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));</span><br><span class="line">	// 处理类上的通用注解</span><br><span class="line">	AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">	if (qualifiers != null) &#123;</span><br><span class="line">		for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">			if (Primary.class == qualifier) &#123;</span><br><span class="line">				abd.setPrimary(true);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (Lazy.class == qualifier) &#123;</span><br><span class="line">				abd.setLazyInit(true);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				abd.addQualifier(new AutowireCandidateQualifier(qualifier));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 封装成一个 BeanDefinitionHolder</span><br><span class="line">	for (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">		customizer.customize(abd);</span><br><span class="line">	&#125;</span><br><span class="line">	BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);</span><br><span class="line">	// 处理 scopedProxyMode</span><br><span class="line">	definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line"> </span><br><span class="line">	// 把 BeanDefinitionHolder 注册到 registry</span><br><span class="line">	BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「扫描」在XML/注解/JavaConfig 中需要被Spring管理的Bean信息</span><br><span class="line"></span><br><span class="line">随后，会将这些信息封装成BeanDefinition，最后会把这些信息放到一个beanDefinitionMap中</span><br><span class="line">那么BeanDefintiions是什么勒？</span><br><span class="line"></span><br><span class="line">BeanDefintiions其实就是对Bean的一些元数据定义</span><br><span class="line">包括parenName 父类名称 baenClassName：类名，scope bean的作用域。Abstract是否是抽象的等信息。</span><br><span class="line">通过 BeanDefinitionReader获取到BeanDefinition之后 。我们在通过BeanDefinitionRegistry将beanDefinition注册到BeanFacory中。存储在BeanFactory的一个conCurrentHashMap中。key为beanName,Value就是BeanDefinition元数据。</span><br><span class="line">Spring通过BeanDefinationReader将配置元信息加载到内存生成相应的BeanDefination之后，就将其注册到BeanDefinationRegistry中，BeanDefinationRegistry就是一个存放BeanDefination的大篮子，它也是一种键值对的形式，通过特定的Bean定义的id，映射到相应的BeanDefination</span><br></pre></td></tr></table></figure>



<p><strong>接着会遍历这个beanDefinitionMap，执行BeanFactoryPostProcessor这个Bean工厂后置处理器的逻辑，比如替换<code>$</code>占位符</strong></p>
<p><img src="https://img-blog.csdnimg.cn/690f5df98811421ab1dc6e1495375d71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ0Nxd2Fz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="三、refresh-容器刷新流程-最重要"><a href="#三、refresh-容器刷新流程-最重要" class="headerlink" title="三、refresh()容器刷新流程(最重要)"></a>三、refresh()容器刷新流程(最重要)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、prepareRefresh()刷新前的预处理：</span><br><span class="line"></span><br><span class="line">（1）initPropertySources()：初始化一些属性设置，子类自定义个性化的属性设置方法；</span><br><span class="line">（2）getEnvironment().validateRequiredProperties()：检验属性的合法性</span><br><span class="line">（3）earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;()：保存容器中的一些早期的事件；</span><br><span class="line">2、obtainFreshBeanFactory()：获取在容器初始化时创建的BeanFactory：</span><br><span class="line"></span><br><span class="line">（1）refreshBeanFactory()：刷新BeanFactory，设置序列化ID；</span><br><span class="line">（2）getBeanFactory()：返回初始化中的GenericApplicationContext创建的BeanFactory对象，即【DefaultListableBeanFactory】类型</span><br><span class="line">3、prepareBeanFactory(beanFactory)：BeanFactory的预处理工作，向容器中添加一些组件：</span><br><span class="line"></span><br><span class="line">（1）设置BeanFactory的类加载器、设置表达式解析器等等</span><br><span class="line">（2）添加BeanPostProcessor【ApplicationContextAwareProcessor】</span><br><span class="line">（3）设置忽略自动装配的接口：EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware；</span><br><span class="line">（4）注册可以解析的自动装配类，即可以在任意组件中通过注解自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext</span><br><span class="line">（5）添加BeanPostProcessor【ApplicationListenerDetector】</span><br><span class="line">（6）添加编译时的AspectJ；</span><br><span class="line">（7）给BeanFactory中注册的3个组件：environment【ConfigurableEnvironment】、systemProperties【Map&lt;String, Object&gt;】、systemEnvironment【Map&lt;String, Object&gt;】</span><br><span class="line">4、postProcessBeanFactory(beanFactory)：子类重写该方法，可以实现在BeanFactory创建并预处理完成以后做进一步的设置</span><br><span class="line"></span><br><span class="line">5、invokeBeanFactoryPostProcessors(beanFactory)：在BeanFactory标准初始化之后执行BeanFactoryPostProcessor的方法，即BeanFactory的后置处理器：</span><br><span class="line"></span><br><span class="line">（1）先执行BeanDefinitionRegistryPostProcessor： postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class="line"></span><br><span class="line">① 获取所有的实现了BeanDefinitionRegistryPostProcessor接口类型的集合</span><br><span class="line">② 先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor</span><br><span class="line">③ 再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor</span><br><span class="line">④ 最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors        </span><br><span class="line">（2）再执行BeanFactoryPostProcessor的方法：postProcessor.postProcessBeanFactory(beanFactory)</span><br><span class="line"></span><br><span class="line">① 获取所有的实现了BeanFactoryPostProcessor接口类型的集合</span><br><span class="line">② 先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor</span><br><span class="line">③ 再执行实现了Ordered顺序接口的BeanFactoryPostProcessor</span><br><span class="line">④ 最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor</span><br><span class="line">6、registerBeanPostProcessors(beanFactory)：向容器中注册Bean的后置处理器BeanPostProcessor，它的主要作用是干预Spring初始化bean的流程，从而完成代理、自动注入、循环依赖等功能</span><br><span class="line"></span><br><span class="line">（1）获取所有实现了BeanPostProcessor接口类型的集合：</span><br><span class="line">（2）先注册实现了PriorityOrdered优先级接口的BeanPostProcessor；</span><br><span class="line">（3）再注册实现了Ordered优先级接口的BeanPostProcessor；</span><br><span class="line">（4）最后注册没有实现任何优先级接口的BeanPostProcessor；</span><br><span class="line">（5）最r终注册MergedBeanDefinitionPostProcessor类型的BeanPostProcessor：beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">（6）给容器注册一个ApplicationListenerDetector：用于在Bean创建完成后检查是否是ApplicationListener，如果是，就把Bean放到容器中保存起来：applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">此时容器中默认有6个默认的BeanProcessor(无任何代理模式下)：【ApplicationContextAwareProcessor】、【ConfigurationClassPostProcessorsAwareBeanPostProcessor】、【PostProcessorRegistrationDelegate】、【CommonAnnotationBeanPostProcessor】、【AutowiredAnnotationBeanPostProcessor】、【ApplicationListenerDetector】</span><br><span class="line"></span><br><span class="line">7、initMessageSource()：初始化MessageSource组件，主要用于做国际化功能，消息绑定与消息解析：</span><br><span class="line"></span><br><span class="line">（1）看BeanFactory容器中是否有id为messageSource 并且类型是MessageSource的组件：如果有，直接赋值给messageSource；如果没有，则创建一个DelegatingMessageSource；</span><br><span class="line">（2）把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource；</span><br><span class="line">8、initApplicationEventMulticaster()：初始化事件派发器，在注册监听器时会用到：</span><br><span class="line"></span><br><span class="line">（1）看BeanFactory容器中是否存在自定义的ApplicationEventMulticaster：如果有，直接从容器中获取；如果没有，则创建一个SimpleApplicationEventMulticaster</span><br><span class="line">（2）将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件就可以直接自动注入</span><br><span class="line">9、onRefresh()：留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑</span><br><span class="line"></span><br><span class="line">10、registerListeners()：注册监听器：将容器中所有的ApplicationListener注册到事件派发器中，并派发之前步骤产生的事件：</span><br><span class="line"></span><br><span class="line"> （1）从容器中拿到所有的ApplicationListener</span><br><span class="line">（2）将每个监听器添加到事件派发器中：getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">（3）派发之前步骤产生的事件applicationEvents：getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">11、finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；</span><br><span class="line"></span><br><span class="line">（1）获取容器中的所有beanDefinitionName，依次进行初始化和创建对象</span><br><span class="line">（2）获取Bean的定义信息RootBeanDefinition，它表示自己的BeanDefinition和可能存在父类的BeanDefinition合并后的对象</span><br><span class="line">（3）如果Bean满足这三个条件：非抽象的，单实例，非懒加载，则执行单例Bean创建流程：    </span><br><span class="line">（4）所有Bean都利用getBean()创建完成以后，检查所有的Bean是否为SmartInitializingSingleton接口的，如果是；就执行afterSingletonsInstantiated()；</span><br><span class="line">12、finishRefresh()：发布BeanFactory容器刷新完成事件：</span><br><span class="line"></span><br><span class="line">（1）initLifecycleProcessor()：初始化和生命周期有关的后置处理器：默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】，如果没有，则创建一个DefaultLifecycleProcessor()加入到容器；</span><br><span class="line">（2）getLifecycleProcessor().onRefresh()：拿到前面定义的生命周期处理器（LifecycleProcessor）回调onRefresh()方法</span><br><span class="line">（3）publishEvent(new ContextRefreshedEvent(this))：发布容器刷新完成事件；</span><br><span class="line">（4）liveBeansView.registerApplicationContext(this);</span><br></pre></td></tr></table></figure>

<p>可以看到这个方法里面调用了很多的方法，我们从开始说起：</p>
<ul>
<li><p>首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；</p>
</li>
<li><p>接着往下看prepareRefresh();这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。</p>
</li>
<li><p>下一步ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();这个就很重要了，这一步是把配置文件解析成一个个BeanDefinition，并且注册到BeanFactory中，注意**<u>这里只是注册进去，并没有实例化</u>**。先继续往下看，等会展开这个方法详细解读</p>
</li>
<li><p>然后是prepareBeanFactory(beanFactory);这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看</p>
</li>
<li><p>postProcessBeanFactory(beanFactory);<strong><u>方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。</u></strong></p>
</li>
<li><p>接下来是invokeBeanFactoryPostProcessors(beanFactory);<u><strong>这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</strong></u></p>
</li>
<li><p>然后是registerBeanPostProcessors(beanFactory);这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。然后回到refresh()方法中继续往下看</p>
</li>
<li><p>initMessageSource();方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下</p>
</li>
<li><p>initApplicationEventMulticaster();方法初始化当前 ApplicationContext 的事件广播器继续往下</p>
</li>
<li><p>onRefresh();<u>方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下</u></p>
</li>
<li><p>registerListeners();方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下</p>
</li>
<li><h5 id="重点到了：finishBeanFactoryInitialization-beanFactory-初始化所有的-singleton-beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说"><a href="#重点到了：finishBeanFactoryInitialization-beanFactory-初始化所有的-singleton-beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说" class="headerlink" title="重点到了：finishBeanFactoryInitialization(beanFactory);初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说"></a>重点到了：finishBeanFactoryInitialization(beanFactory);<u>初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说</u></h5></li>
<li><p>finishRefresh();方法是最后一步，广播事件，ApplicationContext 初始化完成</p>
</li>
</ul>
<h3 id="我们重点来看ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory-和finishBeanFactoryInitialization-beanFactory-这两个方法"><a href="#我们重点来看ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory-和finishBeanFactoryInitialization-beanFactory-这两个方法" class="headerlink" title="我们重点来看ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();和finishBeanFactoryInitialization(beanFactory);这两个方法"></a>我们重点来看<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code>和<code>finishBeanFactoryInitialization(beanFactory);</code>这两个方法</h3><p>先说<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</code>; 这一步上面简单介绍过了，作用是把配置文件解析成一个个BeanBeanDefinition，并且注册到BeanFactory中，点进去源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	return beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法中第一步refreshBeanFactory();方法的作用是关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等，然后getBeanFactory();就是返回刚刚创建的 BeanFactory(其实就是DefaultListableBeanFactory)，我们进入refreshBeanFactory();方法，在AbstractRefreshableApplicationContext类中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">	if (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">			this.beanFactory = beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个refreshBeanFactory()方法首先如果 ApplicationContext 中已经加载过 BeanFactory<br>了，销毁所有 Bean，关闭 BeanFactory；这里指的是当前ApplicationContext 是否有 BeanFactory。<br>然后createBeanFactory();初始化一个DefaultListableBeanFactory，这个DefaultListableBeanFactory是很重的一个类，为什么重要呢？可以看文章开头的BeanFactory继承图，DefaultListableBeanFactory是位于最下面的，他往上能走完BeanFactory继承图所有，所以他可以说是功能最大的BeanFactory。<br>beanFactory.setSerializationId(getId());方法用于 BeanFactory 的序列化<br>customizeBeanFactory(beanFactory);方法设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用，这个等会细说<br>loadBeanDefinitions(beanFactory);这个方法很重要：加载 Bean定义 到 BeanFactory 中，也是等会细说<br>下面看customizeBeanFactory(beanFactory);方法，这个方法作用：是否允许 Bean 覆盖、是否允许循环引用，这是什么意思呢？这就要说到BeanDefinition了，这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中，下面贴出来开头我说的大神的关于BeanDefinition接口的代码注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">AttributeAccessor</span>, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们可以看到，默认只提供 sington 和 prototype 两种，</span></span><br><span class="line">   <span class="comment">// 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span></span><br><span class="line">   <span class="comment">// 不过，它们属于基于 web 的扩展。</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 比较不重要，直接跳过吧</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_APPLICATION</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_SUPPORT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_INFRASTRUCTURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span></span><br><span class="line">   <span class="comment">// 一句话就是：继承父 Bean 的配置信息而已</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setParentName</span><span class="params">(String parentName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取父 Bean</span></span><br><span class="line">   String <span class="title function_">getParentName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setBeanClassName</span><span class="params">(String beanClassName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取 Bean 的类名称</span></span><br><span class="line">   String <span class="title function_">getBeanClassName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 bean 的 scope</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(String scope)</span>;</span><br><span class="line"></span><br><span class="line">   String <span class="title function_">getScope</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setLazyInit</span><span class="params">(<span class="type">boolean</span> lazyInit)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isLazyInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span></span><br><span class="line">   <span class="comment">// 是 depends-on=&quot;&quot; 属性设置的值。</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setDependsOn</span><span class="params">(String... dependsOn)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该 Bean 的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span></span><br><span class="line">   <span class="comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setAutowireCandidate</span><span class="params">(<span class="type">boolean</span> autowireCandidate)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 是否可以注入到其他 Bean 中</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAutowireCandidate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setPrimary</span><span class="params">(<span class="type">boolean</span> primary)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是 primary 的</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrimary</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span></span><br><span class="line">   <span class="comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   String <span class="title function_">getFactoryBeanName</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的 工厂方法名称</span></span><br><span class="line">   String <span class="title function_">getFactoryMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   ConstructorArgumentValues <span class="title function_">getConstructorArgumentValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   MutablePropertyValues <span class="title function_">getPropertyValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span></span><br><span class="line">   <span class="comment">// 常用于作为 父bean 用于继承，其实也很少用......</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAbstract</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getRole</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getResourceDescription</span><span class="params">()</span>;</span><br><span class="line">   BeanDefinition <span class="title function_">getOriginatingBeanDefinition</span><span class="params">()</span>;</span><br><span class="line">&#125;BeanDefinition 的覆盖问题就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 <span class="literal">null</span>，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</span><br><span class="line">循环引用：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</span><br><span class="line">默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</span><br></pre></td></tr></table></figure>

<p>再看loadBeanDefinitions(beanFactory) 方法，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。先贴上源码：AbstractXmlApplicationContext类中</p>
<pre><code>@Override
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;
    // Create a new XmlBeanDefinitionReader for the given BeanFactory.
    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
  // Configure the bean definition reader with this context&#39;s
  // resource loading environment.
  beanDefinitionReader.setEnvironment(this.getEnvironment());
  beanDefinitionReader.setResourceLoader(this);
  beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

  // Allow a subclass to provide custom initialization of the reader,
  // then proceed with actually loading the bean definitions.
  initBeanDefinitionReader(beanDefinitionReader);
  loadBeanDefinitions(beanDefinitionReader);
</code></pre>
<p>}<br>这个源码中我们重点看loadBeanDefinitions(beanDefinitionReader);，再点进去源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">	Resource[] configResources = getConfigResources();</span><br><span class="line">	<span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">		reader.loadBeanDefinitions(configResources);</span><br><span class="line">	&#125;</span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	<span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">		reader.loadBeanDefinitions(configLocations);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在这段源码中我么可以看到2个reader.loadBeanDefinitions()方法，其实两个最终都到了：AbstractBeanDefinitionReader类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">	<span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">		counter += loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法里面，for循环每一个文件是一个resource，最终返回 counter，表示总共加载了多少的 BeanDefinition。<br>进入loadBeanDefinitions(resource);方法，看源码：<br>XmlBeanDefinitionReader类中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line">  Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">  <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">    currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">        <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">      <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">        inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">        <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中可以看到try代码块中一开始是根据外层循环调用的每一个Resource解析成一个InputStream 然后根据这个输入流解析；<br>这段源码的核心在doLoadBeanDefinitions(inputSource, encodedResource.getResource());继续进源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">		<span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="string">&quot; in XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在这个方法里面可以看到doLoadDocument(inputSource, resource);方法是将 xml 文件(输入流和Resource)转换为 Document 对象，然后继续进源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里创建了一个BeanDefinitionDocumentReader，然后spring通过BeanDefinitionDocumentReader 会进行委托bean定义的创建；<br>继续这个方法里面看：documentReader.registerBeanDefinitions(doc, createReaderContext(resource));点进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">	logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line">	<span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">	doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>里面的doRegisterBeanDefinitions(root);方法就是从 xml 根节点开始解析文件，经过很多的步骤，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，可以看到上面有个 for 循环的(loadBeanDefinitions(resource);是在for循环里面的)，进入doRegisterBeanDefinitions(root);方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">	<span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">	<span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">	<span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">	<span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">	<span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">	<span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">	<span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">	<span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">          profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">          logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">              <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">  postProcessXml(root);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码中可以看到BeanDefinitionDocumentReader最终是创建了一个BeanDefinitionParserDelegate ，把bean定义的创建委托给了BeanDefinitionParserDelegate 进行创建，这就是委托模式的提现。<br>同时也可以看到这段代码中先把this.delegate给了一个parent，然后又创建了一个Delegate，然后执行最后又把这个parent给回去了this.delegate，这是为了处理<beans>标签嵌套<beans>的问题，其实是个类似递归的操作。这里大家可以debugger试试嵌套的情况就明白了。</p>
<h5 id="再看preProcessXml-root-，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式-模板方法模式不了解的可以看我的这篇文章-，同理postProcessXml-root-也一样，就是在Bean定义创建前后提供扩展点。"><a href="#再看preProcessXml-root-，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式-模板方法模式不了解的可以看我的这篇文章-，同理postProcessXml-root-也一样，就是在Bean定义创建前后提供扩展点。" class="headerlink" title="再看preProcessXml(root)，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式(模板方法模式不了解的可以看我的这篇文章)，同理postProcessXml(root)也一样，就是在Bean定义创建前后提供扩展点。"></a>再看preProcessXml(root)，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式(模板方法模式不了解的可以看我的这篇文章)，同理postProcessXml(root)也一样，就是在Bean定义创建前后提供扩展点。</h5><p>那继续进入parseBeanDefinitions(root, this.delegate);看重点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">			<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">				<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">				<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">					<span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">					<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">						parseDefaultElement(ele, delegate);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						delegate.parseCustomElement(ele);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			delegate.parseCustomElement(root);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>这段代码是循环解析Element 的每一个节点，一般我们的普通bean都是走parseDefaultElement(ele, delegate);默认的解析流程。<br>但是这里有个else的自定义解析，这个很多人都忽略了，其实如果我们xml的配置文件中定义了<a href="aop:config">aop:config</a> 标签，他就会走这个自定义解析，然后解析aop内容，后续会在分析AOP源码，可以看这篇文章)说<a href="aop:config">aop:config</a>的时候讲这里。<br>这里我们还是走普通的beand解析逻辑parseDefaultElement(ele, delegate)，跟进去看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">			importBeanDefinitionResource(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">			processAliasRegistration(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">			processBeanDefinition(ele, delegate);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">			<span class="comment">// recurse</span></span><br><span class="line">			doRegisterBeanDefinitions(ele);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>这个方法见名知意，解析默认的Element，是4个if分支，第一个是解析import类型的，第二个是alias的，第三个是bean的(也就是我们普通bean默认的)，第四个是beans，也就是嵌套的(这里这个嵌套的就回到上面doRegisterBeanDefinitions方法了，也就是为什么说上面其实类似递归的原因)<br>这里我们只分析普通bean的解析处理，进入processBeanDefinition(ele, delegate);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">					bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send registration event.</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这段代码首先通过delegate创建一个bean定义的持有者BeanDefinitionHolder，<strong>这一步其实BeanDefinition也在里面已经创建出来了</strong>。进入delegate.parseBeanDefinitionElement(ele)看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">		<span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">	List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">		String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">		aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">		beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">		checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">	<span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">					beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">							beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">					<span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">					<span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">					<span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">					<span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">					<span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">							beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">							!<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">						aliases.add(beanClassName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				error(ex.getMessage(), ele);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这段代码中有一个parseBeanDefinitionElement(ele, beanName, containingBean)，<strong>返回了一个AbstractBeanDefinition，这个方法里面实际是创建了一个GenericBeanDefinition</strong>，这里就不跟进去看了，代码篇幅太长了，这个里面很简单没啥绕的逻辑，大家跟着点点就能看到了。创建完GenericBeanDefinition之后设置了Class属性、构造器等等一些创建Bean实例需要的东西之后就返回了。</p>
<p>然后回到processBeanDefinition(ele, delegate);看BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());，由于这个时候<strong>已经创建了BeanDefinition</strong>并且有持有者BeanDefinitionHolder进行注册，所以继续跟进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">      <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">	String[] aliases = definitionHolder.getAliases();</span><br><span class="line">	<span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显继续跟进到registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());，这里是一个接口调用，肯定是到了DefaultListableBeanFactory，但是在这个接口调用时我们需要注意的是第二个参数，从BeanDefinitionHolder中获取到了BeanDefinition对象，这个就是创建Bean定义持有者的时候顺带获取的BeanDefinition，通过上面的解析我们知道这个时候BeanDefinition已经创建好了，然后跟进这个方法进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">	Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">			<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">						existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">			<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">				updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				<span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">				removeManualSingletonName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Still in startup registration phase</span></span><br><span class="line">			<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			<span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">			removeManualSingletonName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法里面就可以看到经过一系列验证等等操作，最后把BeanDefinition放入了beanDefinitionMap，到这里bean定义就完成并注册到org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap里面了</p>
<p>然后我们回到refresh() 方法，就是文章前部分的那个refresh() 方法…TvT<br>再贴一下refresh() 方法的源码吧，方便阅读：<br>我直接贴大神带注释的代码吧，看起来更方便一点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">   <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">  prepareRefresh();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">  <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">  <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">  <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">  <span class="comment">// 这块待会会展开说</span></span><br><span class="line">  prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">     <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">     <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">     postProcessBeanFactory(beanFactory);</span><br><span class="line">     <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span></span><br><span class="line">     invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">     <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">     <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span></span><br><span class="line">     registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">     initMessageSource();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">     initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span></span><br><span class="line">     <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">     onRefresh();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">     registerListeners();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 重点，重点，重点</span></span><br><span class="line">     <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">     <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">     finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span></span><br><span class="line">     finishRefresh();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">     <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">              <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">     <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">     destroyBeans();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">     cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 把异常往外抛</span></span><br><span class="line">     <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">     <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">     resetCommonCaches();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="到此为止，ConfigurableListableBeanFactory-beanFactory-x3D-obtainFreshBeanFactory-结束"><a href="#到此为止，ConfigurableListableBeanFactory-beanFactory-x3D-obtainFreshBeanFactory-结束" class="headerlink" title="到此为止，ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();结束"></a>到此为止，ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();结束</h4><hr>
<h3 id="下面我们来看finishBeanFactoryInitialization-beanFactory"><a href="#下面我们来看finishBeanFactoryInitialization-beanFactory" class="headerlink" title="下面我们来看finishBeanFactoryInitialization(beanFactory)"></a>下面我们来看finishBeanFactoryInitialization(beanFactory)</h3><p>到这一步为止BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些<strong>特殊的 Bean，如 ‘environment’、‘systemProperties’ 等</strong>。剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。点进去看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">	<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">  <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">  <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>在这段代码中：首先初始化名字为 “conversionService” 的 Bean，为什么是conversionService 呢？原因是注册这个bean之后，类似于前端传给后端的非基础类型和基础类型的包装类之外，其他的就可以考虑采用ConversionService来进行类型等的转换，初始化这个 “conversionService” 实在上面源码中的beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));进行的。然后直接跳过来到beanFactory.preInstantiateSingletons();这个方法，这里开始初始化。点进去：<br>DefaultListableBeanFactory这个类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">  <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="type">boolean</span> isEagerInit;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<ol>
<li><p>迭代所有的BeanDefinitionNames集合，挨个初始化所有非懒加载的单例类。</p>
</li>
<li><p>BeanDefinitionNames是在注册BeanDefinitionMap时同时注册的集合。该集合，主要用在<strong>这里</strong>进行迭代初始化Spring Bean，并且也方便一些类似获取BeanDefinitionName的方法使用。</p>
</li>
<li><p>初始化的时候还对FactoryBean进行判断，因为默认FactoryBean默认是惰性初始化，如果实现SmartFactoryBean设置isEagerInit为true，则代表该类需要急切的进行初始化，会即刻开始初始化FactoryBean里getObject返回的类。</p>
</li>
<li><p>关于getMergedLocalBeanDefinition和getBean：Spring通过getBean来完成类的初始化并添加到Spring容器内（即Spring的一级缓存：单例池里面），而在初始化时需要当前类的相关信息：即BeanDefinition，而BeanDefinition是可以存在父子关系（并非真的继承，而是BeanDefinition可以设置父BeanDefinition），所以Spring通过getMergedLocalBeanDefinition来获取当前类的完整信息。</p>
</li>
</ol>
<p>getBean-》doGetBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="comment">// 1.转换beanName，主要处理别名、以&amp;开头的name</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.尝试从单例缓存中获取bean实例</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">	<span class="comment">// 3. 获取bean实例</span></span><br><span class="line">	<span class="comment">// 3.1 缓存中已存在bean实例</span></span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 省略日志输出代码...</span></span><br><span class="line">		<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 省略父工厂处理相关代码...</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 省略dependsOn相关代码...</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3.2 创建单例bean</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3.3 创建原型bean实例</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">				<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3.4 根据scope创建bean实例</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">				<span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">				<span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="comment">// 省略异常处理代码...</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略其他代码.</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>}</p>
<p><strong>在可以看到上面有四种情况：缓存中存在bean实例、创建单例bean、创建原型bean、根据scope创建bean，都调用了getObjectForBeanInstance()方法，接下来我们就点进去看看。</strong></p>
<p><em><strong>getObjectForBeanInstance是从bean实例中获取对象（本章重点，获取实例中的对象）</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">		Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 如果是工厂引用(即name以&amp;开头)，但该实例又不是FactoryBean类型，则抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 如果该实例不是FactoryBean类型，或者是工厂引用都直接返回该实例</span></span><br><span class="line">	<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 尝试从缓存中加载bean</span></span><br><span class="line">		object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 把初始bean实例强转为FactoryBean</span></span><br><span class="line">		FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">		<span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 是否是用户自定义的beanDefinition(默认是false)</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">		<span class="comment">// 重点方法，跟进去</span></span><br><span class="line">		object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>从FactoryBean中获取对象：getObjectFromFactoryBean()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 单例模式</span></span><br><span class="line">	<span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 真正获取对象的方法(重点方法)</span></span><br><span class="line">				object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">				<span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">				<span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;</span><br><span class="line">					object = alreadyThere;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">						<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">							<span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">							<span class="keyword">return</span> object;</span><br><span class="line">						&#125;</span><br><span class="line">						beforeSingletonCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="comment">// 调用bean的后置处理器(有兴趣的可以点进去看下，后面的章节会单独讲述)</span></span><br><span class="line">							object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">									<span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterSingletonCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">						<span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> object;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 2. 原型模式</span></span><br><span class="line">		<span class="comment">// 真正获取对象的方法(重点方法)</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">		<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>真正从FactoryBean中获取对象的逻辑：doGetObjectFromFactoryBean()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">	Object object;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 权限验证</span></span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> getAccessControlContext();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">				<span class="keyword">throw</span> pae.getException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 终于看到你了！</span></span><br><span class="line">			object = factory.getObject();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName, ex.toString());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do not accept a null value for a FactoryBean that&#x27;s not fully</span></span><br><span class="line">	<span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line">	<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(</span><br><span class="line">					beanName, <span class="string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		object = <span class="keyword">new</span> <span class="title class_">NullBean</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终发现其实获取对象的方法，就是一行调用FactoryBean的getObject()方法。</p>
<h4 id="在上面的方法中有个bean的实例化过程我们必须知道"><a href="#在上面的方法中有个bean的实例化过程我们必须知道" class="headerlink" title="在上面的方法中有个bean的实例化过程我们必须知道"></a>在上面的方法中有个bean的实例化过程我们必须知道</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//推断当前Beandefinition的beanClass</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 准备方法重写 包括lookup-method和replaced-method的处理，本文暂不展开</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 第一次调用后置处理器：初始化Bean之前，InstantiationAwareBeanPostProcessor,</span></span><br><span class="line">      <span class="comment">// 根据BeanDefinition获取到了对应的class类</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//创建Bean</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">      <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">      <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>}</p>
<p>docreatebean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">//从未完成的 FactoryBean 实例中移除</span></span><br><span class="line">			instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">//实例化对象(仅仅是生成对象，并非添加到spring单例池中，即目前并没有成为Spring Bean)，</span></span><br><span class="line">			<span class="comment">//并且第二次调用 后置处理器 determineConstructorsFromBeanPostProcessors</span></span><br><span class="line"> 			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">		<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">			mbd.resolvedTargetType = beanType;</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line"> 		... </span><br><span class="line">     	...  </span><br><span class="line">     	...   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先通过createBeanInstance方法调用后置处理器推断其构造函数，并反射创建BeanDefinition对应的实例。<strong>实例化 Bean</strong></p>
<p><strong>注意此时只是创建了类对象，但还没有添加到Spring的单例池中，即还没有加入到Spring容器内部。</strong><br><strong>可以理解为此时只是完成了类对象的声明：即类似于A a&#x3D;null</strong></p>
<p>添加到Spring的单例池是在getSingleton（）的addSingleton中。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38289451/article/details/121965628">https://blog.csdn.net/qq_38289451/article/details/121965628</a></p>
<p>createBeanInstance() 方法是 spring 实例化 bean 的核心代码，它根据不同的情况会调用四种实例化方法</p>
<ul>
<li>obtainFromSupplier() ：通过 Supplier 实例化</li>
<li>instantiateUsingFactoryMethod()：通过工厂方法实例化</li>
<li>autowireConstructor()：用合适的构造函数实例化</li>
<li>instantiateBean()：用无参构造函数实例化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;</span><br><span class="line">    </span><br><span class="line">	// 确认需要创建的bean实例的类可以实例化</span><br><span class="line">	Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">	// 确保class不为空，并且访问权限是public</span><br><span class="line">	if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">		throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">				&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot; + beanClass.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * ----------1，通过Supplier实例化------------</span><br><span class="line">	 */</span><br><span class="line">	Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">	if (instanceSupplier != null) &#123;</span><br><span class="line">		return obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	/**</span><br><span class="line">	 * ----------2，通过工厂方法实例化------------</span><br><span class="line">	 */</span><br><span class="line">	if (mbd.getFactoryMethodName() != null) &#123;</span><br><span class="line">		return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">	 * ----------3，用合适的构造函数实例化------------</span><br><span class="line">	 *</span><br><span class="line">	 *  一个类可能有多个构造器，所以Spring得根据参数个数、类型确定需要调用的构造器。</span><br><span class="line">	 *  在使用构造器创建实例后，Spring会将解析过后确定下来的构造器或工厂方法保存在缓存中，</span><br><span class="line">	 *  避免再次创建相同bean时再次解析</span><br><span class="line">	 */</span><br><span class="line">	// 标记下，防止重复创建同一个bean</span><br><span class="line">	boolean resolved = false;</span><br><span class="line">	// 是否需要自动装配，构造有参数的需要</span><br><span class="line">	boolean autowireNecessary = false;</span><br><span class="line">	// 如果没有参数</span><br><span class="line">	if (args == null) &#123;</span><br><span class="line">		synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">			// 一个类中有多个构造函数，每个构造函数都有不同的参数，所以调用前需要先根据参数锁定构造函数或对应的工厂方法</span><br><span class="line">			if (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class="line">				resolved = true;</span><br><span class="line">				autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 有构造参数的或者工厂方法</span><br><span class="line">	if (resolved) &#123;</span><br><span class="line">		// 构造器有参数</span><br><span class="line">		if (autowireNecessary) &#123;</span><br><span class="line">			// 构造函数自动注入</span><br><span class="line">			return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// 使用默认构造函数构造</span><br><span class="line">			return instantiateBean(beanName, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 从bean后置处理器中为自动装配寻找构造方法</span><br><span class="line">	Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">	if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">			mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">		return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 找出最合适的默认构造方法</span><br><span class="line">	ctors = mbd.getPreferredConstructors();</span><br><span class="line">	if (ctors != null) &#123;</span><br><span class="line">		// 构造函数自动注入</span><br><span class="line">		return autowireConstructor(beanName, mbd, ctors, null);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">	 * ----------4，使用默认构造函数构造------------</span><br><span class="line">	 */</span><br><span class="line">	return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="新增ObjectFactory到第三级缓存"><a href="#新增ObjectFactory到第三级缓存" class="headerlink" title="新增ObjectFactory到第三级缓存"></a>新增ObjectFactory到第三级缓存</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">    	throws BeanCreationException &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        //允许后置处理器重新定义beanDefinition</span><br><span class="line">		synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">			if (!mbd.postProcessed) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					//第三次调用后置处理器 MergedBeanDefinitionPostProcessors</span><br><span class="line">					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				catch (Throwable ex) &#123;</span><br><span class="line">					throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">							&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				mbd.postProcessed = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//判断是否允许循环依赖，默认是允许的，可以通过代码修改的一般只有allowCircularReferences的值</span><br><span class="line">		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">						&quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			// getEarlyBeanReference里面包含了又一次后置处理器的调用，SmartInstantiationAwareBeanPostProcessor </span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="属性填充：populateBean"><a href="#属性填充：populateBean" class="headerlink" title="属性填充：populateBean"></a>属性填充：populateBean</h4><p>然后做一些处理比如循环依赖等，直到看到populateBean(beanName, mbd, instanceWrapper);这个代码，这一步负责属性装配，很重要，因为前面的实例只是实例化了，并没有设值，这里就是设值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//填充属性（即自动注入） 完成第五次和第六次后置处理器的调用</span></span><br><span class="line">        <span class="comment">// InstantiationAwareBeanPostProcessor.after</span></span><br><span class="line">        <span class="comment">// hasInstantiationAwareBeanPostProcessors</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">//完成第七次和第八次后置处理器的调用，</span></span><br><span class="line">        <span class="comment">//判断当前Bean，是否是BeanNameAware、BeanClassLoaderAware、BeanFactoryAware并分别设置相关内容</span></span><br><span class="line">        <span class="comment">//applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line">        <span class="comment">//applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">populateBean方法完成属性填充，跟进</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在设置属性之前，让任何 InstantiationAwareBeanPostProcessors 有机会修改 bean 的状态。例如，这可用于支持字段注入样式。</span></span><br><span class="line">  <span class="comment">//扩展点，又一次调用后置处理器，</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果后置处理器修改了Beandefinition，则判断是否已经修改过了属性值的相关配置</span></span><br><span class="line">   <span class="comment">//如果修改了，则按照器byName或byType的方式直接完成装载</span></span><br><span class="line">   <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">      <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   [] filteredPds = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">         pvs = mbd.getPropertyValues();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">//利用后置处理器，处理属性的获取</span></span><br><span class="line">            <span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">                  filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">               &#125;</span><br><span class="line">               pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">      <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">         filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      &#125;</span><br><span class="line">      checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//根据PropertyValues完成属性填充</span></span><br><span class="line">      applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>populateBean里面再次调用后置处理器，spring在这里提供了一个扩展点，允许开发者在属性填充这个阶段修改Bean的状态（使用后置处理器的方式）。并且可能直接依据byName和byType装载属性值。</p>
<p>我们知道，使用自动装载这一功能时，我们可以使用@Autowired和@Resource。这两个注解的功能也不一样。那么解析的方式也应当不一样。</p>
<h3 id="factorybean和beanfactory"><a href="#factorybean和beanfactory" class="headerlink" title="factorybean和beanfactory"></a>factorybean和beanfactory</h3><p>在我们的开发工作中应该都见过或使用过FactoryBean这个类，也许你会看成了BeanFactory这个类。FactoryBean和BeanFactory虽然长的很像，但是他们的作用确实完全不像。这里你可以想象一下，你会在什么样的场景下使用FactoryBean这个接口？FactoryBean是一个工厂Bean，可以生成某一个类型Bean实例，它最大的一个作用是：可以让我们自定义Bean的创建过程。BeanFactory是Spring容器中的一个基本类也是很重要的一个类，在BeanFactory中可以创建和管理Spring容器中的Bean，它对于Bean的创建有一个统一的流程。下面我们先看一下FactoryBean中有什么东西：</p>
<p>背景<br>假设我们有这种需求，像Mybaits需要将这些接口注入到Spring容器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface OneTestDao &#123;</span><br><span class="line">    @Select(&quot;SELECT name FROM user WHERE id = 1&quot;)</span><br><span class="line">    String query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface TwoTestDao &#123;</span><br><span class="line">    @Select(&quot;SELECT name FROM user WHERE id = 2&quot;)</span><br><span class="line">    String query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先我们想将我们的自己的Bean(比如代理对象)注入到Spring容器中，有什么方式呢？</p>
<p>一般都是通过Spring扫描Resouce资源然后解析为BeanDefinition，才能从getBean时解析BeanDefinition实例化对象放入此单例缓存中.但是我们这里的是接口，没法直接注入到Spring容器中。</p>
<p>不过Spring提供了一些扩展接口来供我们在Bean加载、初始化、加载完提供了一些接口，供我们扩展。<br>比如BeanFactoryPostProcessor</p>
<p>从测试结果中得知，我们虽然配置的是<code>MapperFactoryBean</code>的实列，但是根据id拿到的是<code>getObject</code>方法创建的对象。其实在容器中创建的对象仍然是<code>MapperFactoryBean</code>的实列，只是在获取的时候会判断这个结果对象是不是派生于<code>FactoryBean</code>，如果是的话则返回<code>getObject</code>方法创建的对象，并且这个对象并不是容器初始化时创建的，而是使用<code>context.getBean()</code>方法时才创建。当然了，如果你确实想要获取<code>FactoryBean</code>实例，你需要这样写: <em><code>MapperFactoryBean mapper = context.getBean(&quot;&amp;mapper&quot;, MapperFactoryBean.class);</code></em> 只需要在bean的名字ID前加上&amp;符号。</p>
<p>非常重要：想知道factory流程，请结合</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30881367/article/details/98567729?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mapperfactorybean%E7%9A%84%E4%BD%9C%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-98567729.nonecase&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_30881367/article/details/98567729?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mapperfactorybean%E7%9A%84%E4%BD%9C%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-98567729.nonecase&amp;spm=1018.2226.3001.4187</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Roger_CX/article/details/120739214?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168111515116800192294702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168111515116800192294702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-120739214-null-null.142%5Ev82%5Ekoosearch_v1,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=FactoryBean%E4%BD%9C%E7%94%A8&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/Roger_CX/article/details/120739214?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168111515116800192294702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168111515116800192294702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-120739214-null-null.142^v82^koosearch_v1,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=FactoryBean%E4%BD%9C%E7%94%A8&amp;spm=1018.2226.3001.4187</a></p>
<p><strong>FactoryBean是一个能生产或修饰对象生成的工厂Bean</strong>。一个Bean如果实现了FactoryBean接口，那么<strong>根据该Bean的名称获取到的实际上是getObject返回的对象</strong>，而不是这个Bean自身实例，如果<strong>要获取这个Bean自身实例，那么需要在名称前面加上’&amp;’符号</strong>。</p>
<p>创建bean的两种方式：</p>
<p>第一种，单例在Spring容器初始化之前， 就已经创建了bean，且整个应用只有一个。</p>
<p>第二种，多例在用到对象的时候，才创建对象，当我们在A类中需要用到B类时，通过@Autowired注解注入用到时。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/11/spring%20ioc%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A10/"
                            aria-label=": 章节：10"
                        >
                            章节：10
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-04T00:00:00+08:00">
	
		    04 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>第十节我们可以从注解出发看项目。<br>DBRouter注解写好后，肯定要配备切面类DBRouterJoinPoint（这里面包括了路由策略和路由配置几库几表），里面有一个@Around注解，表示包围一个函数，也就是可以在函数执行前做一些事情，也可以在函数执行后做一些事情。</p>
<p>项目中是先拿到Key字段（uId），判断是不是空，是的话Runtime异常，不是的话就去拿uId这个字段对应的值，按照例子就是Uhdgkw766120d。</p>
<p>拿到值之后，那么下面就是拿着这个值去做路由了（该怎么走），这部分内容被写在DBRouterStrategyHashCode的doRouter里面。其实就是hash的扰动函数，通过设定的算法得到去拿个库哪个表，把这两个信息交给DBContextHolder（一个标识类，用来存储当前数据源的key及状态判断），下面就要向数据集里面写东西了，jp.process(),接下去就是mybatis拦截器的任务了。</p>
<p>自定义拦截器需要实现org.apache.ibatis.plugin.Interceptor接口, 并在接口上添加@Intercepts注解。<br>@Intercepts注解是通过一个@Signature注解(拦截点),来指定拦截那个对象里面的某个方法。<br>@Signature注解需要定义三个东西：</p>
<p>定义拦截的类 Executor、ParameterHandler、StatementHandler、ResultSetHandler当中的一个<br>Class&lt;?&gt; type();</p>
<p>在定义拦截类的基础之上，在定义拦截的方法<br>String method();</p>
<p>在定义拦截方法的基础之上在定义拦截的方法对应的参数，<br>因方法里面可能重载，不指定参数列表，不能确定是对应拦截的方法<br>Class&lt;?&gt;[] args();</p>
<p>我们查看代码，发现拦截的类选择的是StatementHandler，目前不太了解mybatis的源码，但是查询资料之后发现毫无疑问是四大对象最重要的一个，它的任务就是和数据库对话。在它这里会使用parameterHandler和ResultSetHandler对象为我们绑定SQL参数和组装最后的结果返回。</p>
<p>拦截的方法是prepare，预编译阶段</p>
<p>参数是{Connection.class, Integer.class}</p>
<p>回到那个自定义拦截器类 继承了Interceptor。intercept里面就放着怎么把sql变成我们想要的那种动态分库分表的逻辑。<br>首先几行代码拿到dbRouterStrategy注解，看他是不是true<br>如果是，我们去拿sql语句，如下所示：</p>
<p>INSERT INTO user_strategy_export<br>        (u_id, activity_id, order_id, strategy_id, strategy_mode,<br>         grant_type, grant_date, grant_state, award_id, award_type,<br>         award_name, award_content, uuid, create_time, update_time)<br>        VALUES<br>        (?,?,?,?,?,<br>         ?,?,?,?,?,<br>         ?,?,?,now(),now())</p>
<p>他利用一个matcher找到 INTO user_strategy_export这段语句。为什么？因为INTO后面跟着的就是表，至于是哪个表，在上面已经提到了，就是DBContextHolder。这里就实现了分表。</p>
<p>至于分库，我们重写了determineCurrentLookupKey方法，这个方法被determineTargetDataSource调用，determineTargetDataSource被getConnection调用，getConection可以追溯到DataSource接口的getConnection抽象方法。但是我还不知道determineCurrentLookupKey什么时候被调用？？</p>
<p>所以就去查了查多数据源的处理机制的一些文章，发现和自己想的有区别，我一直以为调用DAO层的方法，应该先切面再切换数据源最后才是DAO的逻辑（毕竟我看不到什么时候切换数据源，但是DBRouter注解就是直勾勾的放在DAO方法上面的），结果文章中提到其实是先切换数据源，然后切面方法，最后DAO逻辑。文章给出的原因是事务中不支持数据源切换。<br>但是我打断点还是没找到调用determineCurrentLookupKey的那段代码，可惜。</p>
<p>最后就是把这些配置到DataSourceAutoConfig，打包给我们的项目。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A10/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/"
                aria-label="NEUERE BEITRÄGE"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEUERE BEITRÄGE</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/page/3/"
                aria-label="ÄLTERE BEITRÄGE"
            >
              <span>ÄLTERE BEITRÄGE</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">Seite 2 von 5</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 CSEN. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
            <h4 id="about-card-name">CSEN</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                浙江温州
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-39paoi2hupf5wmw7ojejrxpco6edftjriz5ezbtp4grymrdceksftgan2adp.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
