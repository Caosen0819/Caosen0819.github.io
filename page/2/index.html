
<!DOCTYPE html>
<html lang="zh-CH">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="森">
    <title>森</title>
    <meta name="author" content="CSEN">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"http://example.com","author":{"@type":"Person","name":"CSEN","sameAs":["https://github.com/Caosen0819"],"image":"head.jpg"},"name":"森","description":"潮起潮落，云卷云舒","url":"http://example.com"}</script>
    <meta name="description" content="潮起潮落，云卷云舒">
<meta property="og:type" content="blog">
<meta property="og:title" content="森">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="森">
<meta property="og:description" content="潮起潮落，云卷云舒">
<meta property="og:locale" content="zh_CH">
<meta property="article:author" content="CSEN">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="http://example.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-w816scvuzwavitjylabixcb3ofuoklqul47j3rgwu1r0mxrxvbdehvp2jk5s.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            森
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Lesen Sie mehr über den Autor"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
                </a>
                <h4 class="sidebar-profile-name">CSEN</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="档案"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">档案</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/Caosen0819"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title=".github"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">.github</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/07/08/Mysql%E5%A4%8D%E4%B9%A0%EF%BC%88mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%20innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%89/"
                            aria-label=": Mysql复习（mysql技术内幕 innodb存储引擎）"
                        >
                            Mysql复习（mysql技术内幕 innodb存储引擎）
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-08T00:00:00+08:00">
	
		    08 Jul 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>InnoDB最重要的点：行锁设计、MVCC、外键</p>
<p>首先来了解一下InnoDB的体系架构：</p>
<h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><p>![image-20231004235405057](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231004235405057.png)</p>
<p>InnoDB有很多内存块，组成内存池，负责的工作：</p>
<p>维护所有线程</p>
<p>缓存磁盘的数据</p>
<p>重做日志缓冲</p>
<p>后台线程的主要作用就是：刷新内存池中的数据，保证缓冲池里的是最新的数据。把已修改的数据文件刷新到磁盘文件，</p>
<p>我们看体系架构，可以从以下几点：</p>
<h2 id="1、后台线程"><a href="#1、后台线程" class="headerlink" title="1、后台线程"></a>1、后台线程</h2><p>主要有：</p>
<p>master thread：最重要的，脏页刷新、合并insert buffer，undo 页的回收。不过后来脏页回收放到了单独的线程，也就是page thread</p>
<p>本质是一个</p>
<p>IO thread</p>
<p>purge thread</p>
<p>page thread</p>
<h3 id="1、master-thread"><a href="#1、master-thread" class="headerlink" title="1、master thread"></a>1、master thread</h3><p>本质是一个循环</p>
<p>每秒都会进行一次操作：重做日志缓冲刷新、合并insertbuffer ，脏页刷新被放到了page clean 线程</p>
<p>每十秒会进行的操作：重做日志缓冲刷新、合并insertbuffer、脏页刷新被放到了page clean 线程、删除无用的undo 页</p>
<h2 id="2、内存"><a href="#2、内存" class="headerlink" title="2、内存"></a>2、内存</h2><p>内存方面就是缓冲池、lrulist freelist flushlist、redo log buffer 三块，还有一些额外内存池</p>
<h3 id="1、缓冲池"><a href="#1、缓冲池" class="headerlink" title="1、缓冲池"></a>1、缓冲池</h3><p>本质就是一块内存，就是为了缓解cpu和磁盘的差距，缓冲池里面有数据页、索引页、undo 页、insert buffer、自适应哈希索引、锁信息、数据字典。</p>
<p>所以修改操作，基本都是现修改缓冲池里面的数据，然后按照一定频率通过checkpoint刷回磁盘。</p>
<h3 id="2、List"><a href="#2、List" class="headerlink" title="2、List"></a>2、List</h3><p>缓冲池是通过改进的LRU算法（在原本的基础上加了midpoint，新加入的页放到这里，默认5&#x2F;8）进行管理的，方法就是LRUlist、freelist flushlist。如果缓冲池不能放新的，就把lru里面末尾的释放掉。</p>
<p>改进lru的原因：有可能新页仅仅是这次查询需要用到，并不是真正的热点数据，这样反而有可能将真正的热点数据淘汰。</p>
<p>flushlist就是脏页列表，就像上面说的，用checkpoiint机制刷新</p>
<p>一页16k</p>
<p>说了这么多checkpoint，什么是checkpoint？</p>
<h4 id="1、checkpoint"><a href="#1、checkpoint" class="headerlink" title="1、checkpoint"></a>1、checkpoint</h4><p>解决问题：</p>
<ul>
<li>缩短数据库恢复时间？</li>
</ul>
<p>即使发生宕机， 因为checkpoint之前多页已经刷新回磁盘，所以只需要对checkpoint之后对进行恢复</p>
<ul>
<li>缓冲池不够时，可以将脏页刷回磁盘？</li>
</ul>
<p>缓冲池不够用的时候，根据lru找lru末尾的页，如果是脏页，就强制执行checkpoint，讲脏页刷新回磁盘</p>
<ul>
<li>重做日志不可用，刷新脏页。</li>
</ul>
<p>重做日志两个文件是循环使用，为了不让他一直无限变大，不可用是指重做日志已经不被需要了可以被覆盖。如果宕机，数据库恢复操作不需要这部分的重做日志就可以覆盖重用。如果此时重做日志还需要用，就必须强制产生checkpoint将讲缓冲池的页至少刷新到当前重做日志的位置</p>
<p>所以总归checkpoint做的事情就是把脏页刷回磁盘。那怎么刷新？什么时候刷新？</p>
<p>这里有两种checkpoint，分别是：</p>
<p>sharp checkpoint</p>
<p>fuzzy checkpoint</p>
<p>sharp checkpoint就是在关闭的时候全部刷新到磁盘</p>
<p>fuzzy checkpoint是刷新部分脏页？刷新到时机如下：</p>
<p>master thread checkpoint</p>
<p>flushlrulist checkpoint：这饿是lru列表需要有100个空闲的页，否则一处lru末尾的页，如果有脏页就checkpoint</p>
<p>async sycn flush checkpoint：这个是重做日志i文件不可用的情况，需要强制将一些刷新回磁盘  </p>
<p>dirty page too much：这个是脏页数量太多了，强制checkpoint 75%</p>
<h3 id="3、Redo-log-buffer"><a href="#3、Redo-log-buffer" class="headerlink" title="3、Redo log buffer"></a>3、Redo log buffer</h3><p>这个是innodb独有的，重做日志信息 -&gt;Redo log buffer -〉 重做日志文件，为重做日志文件服务，重做日志文件本身是为了数据库的恢复功能，但是同样的，为了环节和磁盘的差距，我们给他加一个buffer。</p>
<p>刷回时机：</p>
<p>master thread 每秒</p>
<p>每个事务提交的时候</p>
<p>重做日志缓冲 剩余空间小雨1&#x2F;2</p>
<h1 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h1><p>1、插入缓冲</p>
<p>2、两次写</p>
<p>3、自适应哈希</p>
<p>4、异步io</p>
<p>5、刷新邻接页</p>
<h2 id="1、插入缓冲"><a href="#1、插入缓冲" class="headerlink" title="1、插入缓冲"></a>1、插入缓冲</h2><h3 id="1、insert-buffer"><a href="#1、insert-buffer" class="headerlink" title="1、insert buffer"></a>1、insert buffer</h3><p>插入缓冲是针对辅助索引的，数据在真正存放的时候还是按照主键顺序插入的，但是这个表如果有辅助索引，那么这条记录也会插入辅助索引，但是这时候他就不是顺序插入了，而是离散的插入访问。</p>
<p>为此，InnoDB开创性的提出了Insert buffer，insertbuffer不是缓存，而是实实在在的物理页。我们在对非聚集索引的插入的时候不会实时的插入，而是先判断有没有在缓冲池里面，有的话直接插入，没有的话，先放到一个insert buffer里面。后面再以一定的频率进行insertbuffer和非聚集索页子节点的merge操作。</p>
<h3 id="2、change-buffer"><a href="#2、change-buffer" class="headerlink" title="2、change buffer"></a>2、change buffer</h3><p>insert buffer 升级为了 change buffer，对插入更新删除操作都准备了缓冲</p>
<h3 id="3、insert-buffer的内部实现"><a href="#3、insert-buffer的内部实现" class="headerlink" title="3、insert buffer的内部实现"></a>3、insert buffer的内部实现</h3><p>全局唯一的b+树的形式，负责对所有表的辅助索引进行insert buffer，存放在共享表空间，就是ibdata1。但是我们知道，我们可以有独立表ibdata，但是恢复的时候最好用共享表里面的。</p>
<p>因为是树，所以有非叶子结点和叶子结点。</p>
<p>非叶子结点放的是searchkey，所以插入非聚集索引的时候，如果不在缓冲池，那么要加入这颗唯一的insertbuffer，实现构造一个searchkey，我想通过这个searchkey找到我要插入的位置，然后再构造一个叶子结点，放进去。</p>
<h3 id="4、Merge-insert-buffer"><a href="#4、Merge-insert-buffer" class="headerlink" title="4、Merge insert buffer"></a>4、Merge insert buffer</h3><p>所以后面就是合并操作，合并的时机：</p>
<p>1、master thread</p>
<p>2、辅助索引页被读到缓冲池里去，然后这个是要执行正常的查询语句了，就去检查这个insert buffer bitmap，确认这个该辅助索引是不是在insert buffer b+书里面，如果有，就把树里面的记录查到辅助索引里面。</p>
<h2 id="2、两次写"><a href="#2、两次写" class="headerlink" title="2、两次写"></a>2、两次写</h2><p>doublewrite的目的是为了数据的可靠性。</p>
<p>具体实现的话，是依赖于两个部分，一个是内存中的doublewrite buffer，2m。另一部分是磁盘里的共享表空间里面有一个连续的128页，也是2m。然后我们对脏页进行刷新到磁盘里面，我先不直接写磁盘，我先复制到这个内存的doublewrite buffer里面，然后分两次写入，每次1m写入共享表空间的物理磁盘，然后马上调用fsync函数，同步磁盘。所以，如果写的时候崩溃了，那就把这个共享表空间里面的副本拿出来配合redo log进行恢复。</p>
<h2 id="3、自适应哈希"><a href="#3、自适应哈希" class="headerlink" title="3、自适应哈希"></a>3、自适应哈希</h2><p>InnoDB会自动为某些访问频率非常高的页建立哈希索引，而哈希索引比起b+树更快，所以也是一种提高性能手段。</p>
<p>但是有一个比较大的痛点就是他只能用于做 等值查询，如果遇到范围查到，就无能为力。</p>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>文件包括mysql文件和innodb文件</p>
<p>1、参数文件</p>
<p>2、日志文件、</p>
<p>3、socket文件</p>
<p>4、pid文件</p>
<p>5、mysql表结构文件</p>
<p>6、存储引擎文件</p>
<p>我们这里只讲几个</p>
<h2 id="2、日志文件"><a href="#2、日志文件" class="headerlink" title="2、日志文件"></a>2、日志文件</h2><p>日志文件有错误日志、慢查询日志、查询日志、二进制日志，我们着重可以讲一下二进制日志</p>
<h3 id="1、二进制日志"><a href="#1、二进制日志" class="headerlink" title="1、二进制日志"></a>1、二进制日志</h3><p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），MySQL 给每个线程分配了一片内存用于缓冲 binlog，事务提交的时候，再把 binlog cache 写到 binlog 文件中</p>
<p>他是mysql 的日志，记录了对mysql数据库更改的所有操作。不包括selectshow这类操作</p>
<p>主要用于：</p>
<p>恢复：某些数据需要二进制日志。比如数据库全备文件恢复之后，通过二进制进行point-in-time的恢复</p>
<p>复制；主从同步，那canal也是通过这种方式去监听binlog</p>
<p>审计：用户通过二进制的信息判断是否有对数据库进行注入的攻击</p>
<p>然后二进制日志它肯定要落盘，但是他不是每一次写都要落盘，他有个参数sync—binlog，如果等于n，代表每次缓冲多少次就同步到磁盘里面。如果等于1，那就代表同步写磁盘。</p>
<p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<ul>
<li>sync_binlog &#x3D; 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog &#x3D; 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog &#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>还有个需要关注的点就是它落盘的形式，就是怎么记录的？</p>
<p>这个是依赖于binlog——format这个参数，他就是记录二进制的格式，有三种、statement、row、mixed。</p>
<p>statement就是最简单的sql语句，但是他有个很大的问题就是如果用到了uuid rand udf这些函数或触发器，那么回导致主从不一致，那我们可以用row的格式，row的话就是记录表的行修改情况。同样的他也有一个很大问题就是要求的容量比较大。那还有一种mixed格式就是混用，正常情况下我按照statement记录sql语句，但是在uuid rand udf这些特殊情况我用row的格式进行纪记录。</p>
<h3 id="2、表结构定义文件"><a href="#2、表结构定义文件" class="headerlink" title="2、表结构定义文件"></a>2、表结构定义文件</h3><p>这个文件的后缀是.frm，每个文件都会有这个一个frm文件，记录了该表的表结构定义</p>
<h3 id="3、Innodb存储引擎文件"><a href="#3、Innodb存储引擎文件" class="headerlink" title="3、Innodb存储引擎文件"></a>3、Innodb存储引擎文件</h3><h4 id="1、表空间文件"><a href="#1、表空间文件" class="headerlink" title="1、表空间文件"></a>1、表空间文件</h4><p>首当其冲的就是表空间文件，次情况下我们会放到ibdata那个文件里面，但是我们可以通过设置一个参数去产生一个自己表的独立表空间，然后这些独立的表空间记录该表的数据，索引，insertbuffer等信息，其余的还是放在共享表空间里面。</p>
<h4 id="2、重做日志文件"><a href="#2、重做日志文件" class="headerlink" title="2、重做日志文件"></a>2、重做日志文件</h4><p>这个ib_logfile0 ib_logile1，先写logfile0，写完之后我们再去写logfile1.然后他有一个capacity容量参数，如果超过这个值，就必须从缓冲池里面的脏页列表去刷回一部分脏页。</p>
<p>binlog他是mysql的，所以很多其他引擎的操作都会记录，而redolog就是属于innodb的，然后她的记录格式也是大不相同的，binlog是逻辑日志，而redolog则是记录每个页的更改的物理情况</p>
<p>其次刷新的时间也不同，binlog是很明显，我事务提交之前进行一次提交，而redolog在事务执行过程中就会不多的写入redolog。</p>
<h1 id="索引前的准备知识"><a href="#索引前的准备知识" class="headerlink" title="索引前的准备知识"></a>索引前的准备知识</h1><p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1709211669369376612&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1709211669369376612&amp;wfr=spider&amp;for=pc</a></p>
<p><strong>这里我们首先要问三个重要的问题去扒一扒MySQL的InnoDB存储引擎</strong></p>
<ol>
<li><strong>MySQL的记录是怎么存储的？</strong></li>
<li><strong>页内记录到底是怎么维护的？</strong></li>
<li><strong>页内查询过程是怎样的</strong></li>
</ol>
<h3 id="穿上第一件：Page页面"><a href="#穿上第一件：Page页面" class="headerlink" title="穿上第一件：Page页面"></a>穿上第一件：Page页面</h3><p>MySQL管理数据的一个单位叫Page页面，数据都是存在页面里的<strong>。</strong>那咱们想要知道数据是怎么存，就<strong>需要了解页面长什么样子</strong>。</p>
<p>直接爆照：</p>
<p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;42a98226cffc1e171d3b202cf4e9e50a728de9ae.jpeg)</p>
<p>页头（Page Header）：存一些统计信息，记录页面的控制信息，共占56字节，包括页面空间使用情况、页的左右兄弟页面指针（<strong>这个就是双向链表，把左右兄弟页面的指针给拿到了</strong>）等。</p>
<p>虚记录：分为最大虚记录与最小虚记录，<strong>它俩把这页里面存储的数据的范围框住了。</strong>那怎么比较谁大谁小？用的是主键去比较：最大虚记录比页内最大主键还大，最小虚记录比页内最小主键还小<strong>。</strong>那主键到底是怎么存的呢？InnoDB用的是聚簇索引——<strong>数据和主键存到一起、数据和索引存到一起，数据按主键顺序存储。</strong></p>
<p>记录堆：<strong>这部分就是存储记录的区域</strong>，分为有效记录和已删除记录。已被删除的记录构成一个链表，叫做自由空间链表<strong>，</strong>如图蓝色已经被删除的数据，<strong>用一个链表把它们连起来</strong>。</p>
<p>未分配空间：页面未使用的存储空间，除了用了一部分的橙色的区域和已删除的蓝色的数据，剩下的就是未分配空间了，<strong>后面有新的数据插入，往里放就行了</strong>。</p>
<p>Slog区：<strong>这一块对数据检索非常有用</strong>，卖个关子，后面详细说。</p>
<p>页尾（Page Tailer）：页面的最后部分，占8个字节，主要存储页面的校验信息。<strong>这一页如果写坏了，数据不对了，通过校验位可以检查出来。</strong></p>
<p>好了，到这里一个页面咱们了解了，了解数据大概是怎么分布的，<strong>那接下来需要考虑哪些点呢？</strong>我们接下来研究一下——页面记录是怎么维护的</p>
<h3 id="穿上第二件：聚簇索引"><a href="#穿上第二件：聚簇索引" class="headerlink" title="穿上第二件：聚簇索引"></a>穿上第二件：聚簇索引</h3><p>刚刚提到了主键顺序这个词，那这个顺序是怎么保证的？这里说的按什么顺序存储，不是说升序、降序这些，这些没有意义，实际上说的是<strong>在页里面数据是怎么组织起来的</strong>，还有就是插入数据的策略，<strong>我怎么插入数据</strong>，还有就是<strong>页内的查询是怎样的</strong>。</p>
<p>我们先来看看聚簇索引：</p>
<p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;c9fcc3cec3fdfc032a5c874b6446949da5c2269b.jpeg)</p>
<p>首先，聚簇索引是一棵B+树，那什么是聚簇呢？</p>
<p>图中下面绿色的部分是咱们的数据区域，数据是基于紫色部分的主键顺序去存储的，<strong>数据和主键存到一起没毛病，主键是按照树的顺序去组织的，这个结构就叫聚簇</strong>。</p>
<p>我们再看每一个Page，刚刚说到，Page里面有最大虚记录、最小虚记录，最大、最小这数据肯定是有个范围，<strong>那这个数据在里边到底是怎么存的</strong>？换个说法——数据的顺序是怎么保证的？<strong>到底是物理有序，还是逻辑有序？</strong></p>
<p>我们再回顾一下大学的知识——<strong>物理有序写入不友好，查询友好；逻辑有序查询不友好，插入友好</strong>，两者优缺点互补。</p>
<p>再回到正题，了解了这两种不同存储方式的特性，反观页面是怎么做的。</p>
<p>先看下面这幅图，思考一下插入主键为10，9，8的数据，是按物理有序存储还是逻辑有序存储：</p>
<p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;e850352ac65c103892bb2f180b68801ab27e89a2.jpeg)</p>
<p>数据插入是写入IO，数据查询是读IO，不管是写还是读，在分析存储的时候，无非是这四种：顺序写、随机写、顺序读、随机读。<strong>如果是顺序写，数据会有各种移动，写入性能肯定非常糟糕</strong>。但是没办法，<strong>优化写入的手段十分有限，不过呢我们却有很多办法优化读</strong>。</p>
<p><strong>所以想都不用想，页内数据存储的顺序就是逻辑有序</strong>。</p>
<p>重新梳理一下，Page与Page之间由双向链表连接，页内是用小的链表连起来的：</p>
<p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;9825bc315c6034a8191108a4766a5a5d082376a2.jpeg)</p>
<p>我们再来重新画一下这棵树：</p>
<p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;80cb39dbb6fd5266c5d8021702618422d5073647.jpeg)</p>
<p>这里要注意，每个Page的索引的每个节点，也就是树的每个节点，它也是一个Page。<strong>既然是个Page，也会有页头，也会有双向链表</strong>，如图蓝色与紫色相间那部分节点数据。</p>
<p><strong>接下来咱分析一下它的插入策略。</strong></p>
<p>蓝色部分已删除的空间（记录堆）怎么办呢？<strong>我们得想办法尽量把它们利用上</strong>，这个换谁做数据库设计都要这么设计<strong>。</strong></p>
<p>其实，插入策略就是先使用自由空间链表，再使用未使用空间，<strong>把数据库“空洞”给补上。</strong>不过呢，自由空间链表的空间也不能完全利用上，比如旧的数据占25个字节，新的数据假设都只有20个字节，<strong>那剩下这5个字节基本也利用不上，这样一来就会产生越来越多的“碎片”</strong>。经过长时间的插入删除插入删除以后，我们就得考虑给数据库做一次收缩，比如通过两次主从表的双向同步，<strong>把所有表数据重新插一遍</strong>。</p>
<p><strong>我们接下来研究一下——页内查询是怎么做的？</strong></p>
<h3 id="穿上第三件：Slot槽"><a href="#穿上第三件：Slot槽" class="headerlink" title="穿上第三件：Slot槽"></a>穿上第三件：Slot槽</h3><p><strong>页内的数据是遍历还是二分查找？</strong></p>
<p>无论数据是物理连续还是逻辑有序，都不能二分查找，都得用遍历的办法。如果我们设计一款数据库，通过索引找到数据在哪个Page里面，要是Page这一层通过遍历的方式，那效率实在是太低了，所以数据库肯定不能这样设计。</p>
<p>遍历不行，那就使用二分查找吧，提高一下效率。那MySQL是怎么做的呢？看看这张图：</p>
<p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;3b87e950352ac65c1fead4dc4c8ba11892138a30.jpeg)</p>
<p>如图，最小虚记录和最大虚记录之间形成一个链表，这时候Slot区就派上用场了，每个Slot槽指向链表中的某一个位置，每个槽的大小一样，可以理解为一个指针，<strong>这样我们只需要用一个算法把每个子链表的长度拆成差不多大小就行了</strong>。</p>
<p>在查找的时候，先基于Sn、S0找到指向的最大最小虚记录，在Slot区进行二分：<strong>先找到Sn和S0的中间位置，中间找到某个Slot，然后再一步步进行比较，通过几次二分后找到具体的子链表，最后，在子链表内进行遍历找到最终的记录</strong>。这样我们借助Slot区实现了一个近似二分查找的方法。这特别像Java里面的跳表结构，一次查找跳一次，再一次查找再跳一次，效率就特别高了</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>innodb最常见的索引就是：</p>
<p>b+树索引 （b+树只能找到数据行所在的页，然后把页读到内存里面，进行查找）</p>
<p>哈希索引（自动生成）</p>
<p>全文索引</p>
<h2 id="1、B-树索引"><a href="#1、B-树索引" class="headerlink" title="1、B+树索引"></a>1、B+树索引</h2><p>二叉查找树（左小于中小于右）-》平衡二叉树，任何结点的两个子树高度差小于等于1（性能比较高，但不是最高）（需要左旋右旋等等）</p>
<p>b+树是为了磁盘或其他直接存取辅助设备设计的一种平衡查找树</p>
<p>b+树的所有记录结点都是按照键值的大小顺序存放到同一层的叶子结点，他们之间通过叶子结点指针进行连接，中间的都是searchkey</p>
<h3 id="1、操作"><a href="#1、操作" class="headerlink" title="1、操作"></a>1、操作</h3><h4 id="1、插入"><a href="#1、插入" class="headerlink" title="1、插入"></a>1、插入</h4><p>![image-20231005201534270](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231005201534270.png)</p>
<h4 id="2、旋转"><a href="#2、旋转" class="headerlink" title="2、旋转"></a>2、旋转</h4><p>旋转发生在leaf page已经满了，但是左右兄弟还没有满，这时候会把记录平移到兄弟结点上面，左兄弟优先</p>
<h4 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h4><p>![image-20231005202324173](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231005202324173.png)</p>
<h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><p>b+树可以分成聚集索引、辅助索引，这两个到区别就是叶子结点放的到底是不是一行信息</p>
<h4 id="1、聚集索引"><a href="#1、聚集索引" class="headerlink" title="1、聚集索引"></a>1、聚集索引</h4><p>innodb引擎是索引组织表，按照主键顺序存放，而聚集索引就是按照主键构造的索引b+树，所以叶子结点存放的就是整张表的数据，叶子结点也叫做数据页。非叶子结点的索引页存放的仅仅是键值和指向数据页的偏移量。</p>
<h4 id="2、辅助索引"><a href="#2、辅助索引" class="headerlink" title="2、辅助索引"></a>2、辅助索引</h4><p>辅助索引的叶子结点不包含行记录的全部数据。叶子结点包含键值和书签，书签用来告诉引擎哪里能找到真正的行数据。由于innodb是索引组织表，所以辅助索引的书签就是行记录的聚集索引键。比如（文件名：页号：槽号），所以辅助索引就是包含了索引那列的值和主键的值</p>
<h3 id="3、B-树索引的管理"><a href="#3、B-树索引的管理" class="headerlink" title="3、B+树索引的管理"></a>3、B+树索引的管理</h3><h4 id="1、索引管理"><a href="#1、索引管理" class="headerlink" title="1、索引管理"></a>1、索引管理</h4><p>创建和删除可以通过两种方法。一种是alter table。另一种是create&#x2F;drop index。</p>
<p>查看：show index from XX</p>
<h4 id="2、fast-index-create"><a href="#2、fast-index-create" class="headerlink" title="2、fast index create"></a>2、fast index create</h4><p>对于一张大表进行索引的添加和删除操作，这会需要很长时间。所以就提出了这个快速创建索引的方式。只限制于辅助索引。</p>
<p>在创建索引的表加上一个S锁不需要重建表，删除索引只需要更新内部视图。</p>
<h4 id="3、Online-Schema-Change在线架构改变OSC"><a href="#3、Online-Schema-Change在线架构改变OSC" class="headerlink" title="3、Online Schema Change在线架构改变OSC"></a>3、Online Schema Change在线架构改变OSC</h4><p>在线的意思其实就是在DDL的过程中，可以有读写事务对表进行操作</p>
<h4 id="4、Online-DDL"><a href="#4、Online-DDL" class="headerlink" title="4、Online DDL"></a>4、Online DDL</h4><p>允许在辅助索引创建的同时，还允许insert update等DML操作</p>
<p>原理是：执行insert update delete这些操作的时候，先把操作日志写入一个缓存里面，然后，索引建立后重做表上面</p>
<p>新的alter table语法中，通过algorithm如果是 copy还是通过建立临时表的方式，如果是replace就是不需要临时表，如果是default，那就是根据old_alter_table判断，如果是off，那就是replace。</p>
<h4 id="5、cardinality值"><a href="#5、cardinality值" class="headerlink" title="5、cardinality值"></a>5、cardinality值</h4><p>优化器会根据这个值来判断我们用不用索引。表示索引中唯一值的数据的估计值，如果是性别这种，重复的非常多，我们叫低选择性，不适合做索引。反之高选择性就比较适合，尤其是在高选择性属性字段里面取出一小部分数据，那就更有必要了。</p>
<ul>
<li><strong>统计的方式</strong>？</li>
</ul>
<p>一张大表，每次统计的时间很长，这是不能接受的，所以我们用的是采样的方法。cardinality值的更新发生在insert和update操作，但是肯定不是每一次insertupdate都去更新，具体策略如下：</p>
<p>1、表中1&#x2F;16数据发生了变化</p>
<p>2、计数器超过20亿</p>
<ul>
<li><strong>采样的方法：</strong></li>
</ul>
<p>对八个叶子结点进行采样预估，取出平均值</p>
<h3 id="4、B-树索引的使用"><a href="#4、B-树索引的使用" class="headerlink" title="4、B+树索引的使用"></a>4、B+树索引的使用</h3><h4 id="1、联合索引"><a href="#1、联合索引" class="headerlink" title="1、联合索引"></a>1、联合索引</h4><p>本质也是一颗二叉树，之前是a,b,c,d现在是（a,b）(c,d)</p>
<p>第一个好处：对于联合查询和单列的第一列的查询都可以用联合查询</p>
<p>第二个好处：一句对第二个键值进行了排序处理，可以缩短某些情况的查询时间</p>
<h4 id="2、覆盖索引"><a href="#2、覆盖索引" class="headerlink" title="2、覆盖索引"></a>2、覆盖索引</h4><p>覆盖索引的意思是，从辅助索引中就直接可以得到想要查询的记录，不需要回表。</p>
<p>第一个好处是：辅助索引本身不包括整行记录，所以大小远小于聚集索引，减少io操作</p>
<p>第二个好处是：对于某些统计问题，存储引擎并不会通过积极索引，辅助索引远远小于聚集索引，</p>
<h4 id="3、优化器不选择索引的方式"><a href="#3、优化器不选择索引的方式" class="headerlink" title="3、优化器不选择索引的方式"></a>3、优化器不选择索引的方式</h4><p>多发生在范围查找、join链接操作</p>
<h4 id="4、MRR优化（只支持非聚集索引）（离散读变成顺序读）"><a href="#4、MRR优化（只支持非聚集索引）（离散读变成顺序读）" class="headerlink" title="4、MRR优化（只支持非聚集索引）（离散读变成顺序读）"></a>4、MRR优化（只支持非聚集索引）（离散读变成顺序读）</h4><p>工作方式：</p>
<ul>
<li>把辅助索引读出来放到一个缓存里面</li>
<li>把缓存中的键值更具rowid进行排序</li>
<li>然后根据rowid去找数据</li>
</ul>
<p>他还可以进行某些范围查找，就是把范围查找拆分成键值对的等值查找。直接就过滤了一些不符合条件的数据。</p>
<p>好处：</p>
<ul>
<li>数据访问更加顺序，</li>
<li>减少缓冲池页的替换</li>
</ul>
<h4 id="5、ICP优化（只支持非聚集索引）"><a href="#5、ICP优化（只支持非聚集索引）" class="headerlink" title="5、ICP优化（只支持非聚集索引）"></a>5、ICP优化（只支持非聚集索引）</h4><p>原本我们通过索引进行查询的时候，首先根据索引查找记录，然后根据where条件过滤记录。ICP是在取出索引的同时，判断是否可以进行where条件的过滤，也就是讲where的部分过滤操作放到了存储引擎层</p>
<p>场景：</p>
<p>假设表TB1上有索引IDX_C1_C2_C3(C1,C2,C3)，对于查询SELECT * FROM TB1 WHERE C1&#x3D;’XXX’ AND C3&#x3D;’XXX’</p>
<p>在MySQL 5.6版本以前，由于缺少C2的过滤条件，Innodb存储引擎层只能使用索引IDX_C1_C2_C3按照C1&#x3D;’XXX’条件找出所有满足条件的索引记录，再根据这些索引记录去聚集索引中查找，将找到的表数据返回给MySQL Server层，然后由MySQL Server层使用C3&#x3D;’XXX’条件进行过滤得到最终结果。</p>
<p>再MySQL 5.6版本中引入ICP特性，Innodb存储引擎层只能使用索引IDX_C1_C2_C3按照C1&#x3D;’XXX’条件去扫描所有满足条件的索引记录，再将这些索引记录按照C3&#x3D;’XXX’条件进行过滤，并按照过滤后的索引记录去去聚集索引中查找，将找到的表数据返回给MySQL Server层，得到最终结果。</p>
<p>假设满足C1&#x3D;’XXX’条件的数据行为100000条，而满足C1&#x3D;’XXX’ AND C3&#x3D;’XXX’的数据行为100条，则：</p>
<p>1、在MySQL 5.5版本中，需要对TB1的聚集索引进行100000次Index Seek操作，Innodb存储引擎层向MySQL Server层传递100000行数据。</p>
<p>2、在MySQL 5.6版本中，使用ICP仅需要对TB1的聚集索引进行100次的Index Seek操作，Innodb存储引擎层向MySQL Server层传递100行数据。</p>
<h4 id="6、自适应哈希索引"><a href="#6、自适应哈希索引" class="headerlink" title="6、自适应哈希索引"></a>6、自适应哈希索引</h4><p>InnoDB中的哈希用的字典进行查找，冲突用链表解决，哈希函数用除法散列</p>
<p>自适应哈希索引就是用的这种方法。</p>
<h4 id="7、全文检索"><a href="#7、全文检索" class="headerlink" title="7、全文检索"></a>7、全文检索</h4><p>全文检索一般使用倒排索引。</p>
<h5 id="1、倒排索引"><a href="#1、倒排索引" class="headerlink" title="1、倒排索引"></a>1、倒排索引</h5><p>它在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关键数组实现，其拥有两种表现形式：<br>inverted file index：其表现形式为{单词，单词所在文档的ID}<br>full inverted index：其表现形式为{单词，(单词所在文档的ID，在文档中的具体位置)}</p>
<h5 id="2、InnoDB全文检索的实现"><a href="#2、InnoDB全文检索的实现" class="headerlink" title="2、InnoDB全文检索的实现"></a>2、InnoDB全文检索的实现</h5><p><strong>InnoDB全文索引有3个非常重要的东西，一个是辅助表，一个是FTS Index Cache、一个是FTS DOUCUMENT id</strong></p>
<h6 id="1、Auxiliary-Table（辅助表）"><a href="#1、Auxiliary-Table（辅助表）" class="headerlink" title="1、Auxiliary Table（辅助表）"></a><strong>1、Auxiliary Table（辅助表）</strong></h6><p>辅助表是把文档，分词然后规范化后的白哦，</p>
<p>辅助表的话采用“full inverted index”的方式有两个列：<br>一个是word字段。在word字段上有设有索引，另一个是ilist字段，（DocumentId,Position）</p>
<h6 id="2、FTS-INDEX-Cache（全文检索缓存）"><a href="#2、FTS-INDEX-Cache（全文检索缓存）" class="headerlink" title="2、FTS INDEX Cache（全文检索缓存）"></a><strong>2、FTS INDEX Cache（全文检索缓存）</strong></h6><p>他是一个红黑树的结构：我执行插入操作，插入的数据已经更新了对应的表，但是我们的辅助表可能还没更新，这个更新还停留在FTS cache里面。如果没插一次就更新这是不合理的，那具体同步到辅助表的时机：</p>
<p>1、在我进行全文检索查询的时候，我把FTS INDEX cache里的word字段合并到辅助表，然后查询。有点类似于insert buffer</p>
<p>2、数据库关闭的时候会同步</p>
<p>3、cache满了	</p>
<p>数据库宕机时：一些FTS InDEX Cache中的数据库可能未被同步到磁盘上。那么下次重启时，当用户对表进行全文检索（查询或者插入操作）时，InnoDB会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入到FTS Index Cache中</p>
<p>对于InnoDB来说，其总是在事务提交时将分词写入到FTS Index Cache。</p>
<h6 id="3、FTS-DOUCUMENT-ID"><a href="#3、FTS-DOUCUMENT-ID" class="headerlink" title="3、FTS DOUCUMENT ID"></a>3、FTS DOUCUMENT ID</h6><p>为了支持全文检索，<strong>必须有一个列与word进行映射：</strong></p>
<ul>
<li>在InnoDB中这个列<strong>被命名为FTS_DOC_ID</strong></li>
<li>其<strong>类型必须是</strong>bigint unsigned not null</li>
<li>并且InnoDB自动会在该列上加入一个<strong>名为FTS_DOC_ID_INDEX的unique index索引</strong></li>
<li><strong>用户也可以在建表时自动添加FTS_DOC_ID，以及相应的Unique Index</strong></li>
</ul>
<p>Deleted auxiliary table<br>文档中分词的插入操作是在事务提交时完成的，然而对于删除操作，其在事务提交时不删除磁盘Auxiliary Table中的记录，而只是删除FTS Index Cache中的记录。对于Auxiliary Table中被删除的记录，InnoDB会记录其FTS Document ID，并将其保存在Deleted auxiliary table中</p>
<p>由于文档的DML操作实际并不删除索引中的数据，相反还会在对应的DELETED表中插入记录，因此随着应用程序的允许，索引会变得非常大，即使索引列中的有些数据已经被删除，查询也不会使用到。为了，InnoDB存储引擎提供了一种方式，允许用户手动地将已删除的记录从索引中彻底删除，该命令就是OPTIMIZE TABLE</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁机制是用于管理对共享资源的并发访问，保证数据的完整性和一致性。</p>
<h2 id="1、锁的类型"><a href="#1、锁的类型" class="headerlink" title="1、锁的类型"></a>1、锁的类型</h2><h3 id="1、全局锁"><a href="#1、全局锁" class="headerlink" title="1、全局锁"></a>1、全局锁</h3><p>典型的使用场景就是做全库的逻辑备份</p>
<ul>
<li><p>一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态</p>
</li>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;<span class="number">1</span>、加全局锁</span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pxxx db_name <span class="operator">-</span><span class="operator">&gt;</span> xxx.sql;<span class="number">2</span>、数据备份</span><br><span class="line">unlock tables;<span class="number">3</span>、释放锁</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2、表级锁"><a href="#2、表级锁" class="headerlink" title="2、表级锁"></a>2、表级锁</h3><p>表级锁，主要分为3类：</p>
<ul>
<li>表锁</li>
<li>元数据锁（meta data lock，MDL）</li>
<li>意向锁</li>
</ul>
<h4 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h4><p>对于表锁，又可以分为2类：</p>
<ul>
<li>表共享读锁（read lock）</li>
<li>表独占写锁（write lock）</li>
</ul>
<p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞 其他客户端的写。</p>
<h4 id="2、、元数据锁"><a href="#2、、元数据锁" class="headerlink" title="2、、元数据锁"></a>2、、元数据锁</h4><p>再来说说<strong>元数据锁</strong>（MDL）。</p>
<p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p>
<blockquote>
<p>MDL 不需要显示调用，那它是在什么时候释放的?</p>
</blockquote>
<p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
<p>MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL 锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与 DDL冲突，保证读写的正确性。</p>
<h4 id="3、意向锁"><a href="#3、意向锁" class="headerlink" title="3、意向锁"></a>3、意向锁</h4><p>我觉得意向锁主要还是解决行锁和表锁之间的冲突问题。</p>
<ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li>
</ul>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加行级独占锁。</p>
<p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;20e0f35589584352bd15e817668a0886.png)</p>
<p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;6e6b275c2d6d4dfcbbb338be4f61bee9.png)</p>
<p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p>
<h4 id="4、自增锁"><a href="#4、自增锁" class="headerlink" title="4、自增锁"></a>4、自增锁</h4><p>主键设置成自增之后，在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p>
<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增</p>
<p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p>
<ul>
<li>当 innodb_autoinc_lock_mode &#x3D; 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 1：<ul>
<li>普通 insert 语句，自增锁在申请之后就马上释放；</li>
<li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
</ul>
</li>
</ul>
<p>![img](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;innodb_autoinc_lock_mode&#x3D;2.png)</p>
<p>session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后<strong>两个 session 同时执行向表 t2 中插入数据</strong>。</p>
<p>如果 innodb_autoinc_lock_mode &#x3D; 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：</p>
<ul>
<li>session B 先插入了两个记录，(1,1,1)、(2,2,2)；</li>
<li>然后，session A 来申请自增 id 得到 id&#x3D;3，插入了（3,5,5)；</li>
<li>之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</li>
</ul>
<p>可以看到，<strong>session B 的 insert 语句，生成的 id 不连续</strong>。</p>
<p>当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format&#x3D;statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。</p>
<p>但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在<strong>从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致</strong>。</p>
<p>要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。</p>
<p>所以，<strong>当 innodb_autoinc_lock_mode &#x3D; 2 时，并且 binlog_format &#x3D; row，既能提升并发性，又不会出现数据一致性问题</strong>。</p>
<h3 id="3、行锁"><a href="#3、行锁" class="headerlink" title="3、行锁"></a>3、行锁</h3><p>InnoDB实现了以下两种类型的行锁：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他 锁</li>
</ul>
<p>![image-20230805221422216](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20230805221422216.png)</p>
<h2 id="2、一致性非锁定读（快照读）"><a href="#2、一致性非锁定读（快照读）" class="headerlink" title="2、一致性非锁定读（快照读）"></a>2、一致性非锁定读（快照读）</h2><p>一致性非锁定读是指InnoDb通过多版本控制（MVCC）的方式读取当前执行时间里面数据库的数据。如果读取的那一行正在做一些dml操作，但是我不会去等，我会直接去读一个快照数据。不需要等待X锁的释放，那这个数据是哪里来的呢？这个快照数据是指该行之前版本的数据，他的实现是通过undo页完成的，而一个行记录它对应的可能不只有一个快照数据，所以我们把对于这些快照数据的管理，叫做多版本控制MVCC。当然这里提一嘴就是,读已提交和可重复读这两种级别是可以用一致性非锁定读，但是对于快照数据的定义不一样，读已提交总是读区被锁定行的最新的一份快照，可重复读总是读事务开始时候的数据版本，</p>
<h2 id="3、一致性锁定读（当前读）"><a href="#3、一致性锁定读（当前读）" class="headerlink" title="3、一致性锁定读（当前读）"></a>3、一致性锁定读（当前读）</h2><p>有时候用户需要些显式的对读操作进行加锁保证一致性。</p>
<h2 id="4、锁的算法"><a href="#4、锁的算法" class="headerlink" title="4、锁的算法"></a>4、锁的算法</h2><p>InnoDB有三种行锁的算法：</p>
<p>Record Lock：单个行记录的锁</p>
<p>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身</p>
<p>Next-Key Lock：Record Lock + Gap Lock</p>
<p>InnoDB就是用Next-Key去解决幻想问题（同一事务下，连续执行两次相同的sql语句可能导致不同的结果，第二次sql可能会返回之前不存在的行）</p>
<p>查询的索引如果是唯一性质，那么降级为Record Lock</p>
<h2 id="5、锁问题"><a href="#5、锁问题" class="headerlink" title="5、锁问题"></a>5、锁问题</h2><h3 id="1、脏读"><a href="#1、脏读" class="headerlink" title="1、脏读"></a>1、脏读</h3><p>读到了其他事务没有提交的数据，违反了隔离性。但是脏读发生的隔离级别最少也得是read uncommitted，而我们的数据库默认是可重复读，所以一般在生产环境中，发生的并不多。</p>
<h3 id="2、不可重复读"><a href="#2、不可重复读" class="headerlink" title="2、不可重复读"></a>2、不可重复读</h3><p>就是一个事务读两次，另一个事务在两次读之间作出修改，因为读是mvcc，不加锁，所以会出现不可重复读。innoDB的解决方法：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<h3 id="3、丢失更新"><a href="#3、丢失更新" class="headerlink" title="3、丢失更新"></a>3、丢失更新</h3><p>是指一个事务的操作被另一个事务的操作覆盖了，但是当前数据库的任何隔离级别都对行或者粗粒度的对象加锁，所以还是比较难发生。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>事务级别</p>
<p><strong>类型一：RU（READ-UNCOMMITTED 表示读未提交）</strong></p>
<p>可以读取到事务未提交的数据，隔离性差，会出现脏读（当前内存读），不可重复读，幻读问题;</p>
<p><strong>类型二：RC（READ-COMMITTED 表示读已提交）</strong>可用</p>
<p>可以读取到事务已提交的数据，隔离性一般，不会出现脏读问题，但是会出现不可重复读，幻读问题；</p>
<p><strong>类型三：RR（REPEATABLE-READ 表示可重复读）</strong><code>默认</code></p>
<p>可以防止脏读（当前内存读），防止不可重复读问题，防止会出现的幻读问题，但是并发能力较差；</p>
<p>会使用next lock锁进制，来防止幻读问题，但是引入锁进制后，锁的代价会比较高，比较耗费CPU资源，占用系统性能；</p>
<p><strong>类型四：SR（SERIALIZABLE 可串行化）</strong></p>
<p>隔离性比较高，可以实现串行化读取数据，但是事务的并发度就没有了；</p>
<p>这是事务的最高级别，在每条读的数据上，加上锁，使之不可能相互冲突</p>
<h2 id="6、死锁"><a href="#6、死锁" class="headerlink" title="6、死锁"></a>6、死锁</h2><p>死锁是指两个或以上的事务争夺资源造成的一种互相等待的现象</p>
<p>解决方法：</p>
<p>1、设置超时的阈值，回滚一个事务</p>
<p>2、wait-for-graph 等待图。检测是否有回路。通常用深度优先。1.2版本开始就变成非递归</p>
<p>如果有死锁，那就回归undo量最少的</p>
<h2 id="7、锁升级"><a href="#7、锁升级" class="headerlink" title="7、锁升级"></a>7、锁升级</h2><p>InnoDB中不存在锁升级的问题，因为InnoDB不是更具每个记录来产生锁的，相反，其根据每个事务访问的每个页对锁进行管理，采用的是位图的方式。所以不管你锁住的是页中的一个记录或者多个记录，开销一样</p>
<p>![image-20231006204601132](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231006204601132.png)</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="1、认识事务"><a href="#1、认识事务" class="headerlink" title="1、认识事务"></a>1、认识事务</h2><h3 id="1、四个特性：acid。"><a href="#1、四个特性：acid。" class="headerlink" title="1、四个特性：acid。"></a>1、四个特性：acid。</h3><p>原子性：要么成功要么失败</p>
<p>一致性：讲数据库从一种状态转变为下一种一致的专题。</p>
<p>isolation：一个事务提交之前对其他事物不可见</p>
<p>durability：一旦提交，那么结果是永久性的</p>
<h3 id="2、分类-1"><a href="#2、分类-1" class="headerlink" title="2、分类"></a>2、分类</h3><p>扁平事务</p>
<p>带有保存点的扁平事务</p>
<p>链事务</p>
<p>嵌套事务</p>
<p>分布式事务</p>
<h2 id="2、事务的实现"><a href="#2、事务的实现" class="headerlink" title="2、事务的实现"></a>2、事务的实现</h2><p>事务的隔离性由锁机制来实现。</p>
<p>原子性、一致性、持久性通过redo log和undo log完成</p>
<p>redo log保证持久性</p>
<p>undo log保证事务的原子性，一致性</p>
<p>redolog恢复提交事务修改的页操作</p>
<p>undo回滚行记录道某个特定版本，事务</p>
<h3 id="1、redo"><a href="#1、redo" class="headerlink" title="1、redo"></a>1、redo</h3><p>有两部分组成：redo log buffer缓冲，redo log file</p>
<p>事务提交的时候必须把事务的所有日志写入重做日志文件进行持久化。这个的所有日志包括redo log 和undo log</p>
<p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p>
<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p>
<p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p>
<p>![image-20231007131604938](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231007131604938.png)</p>
<p>![image-20231007131752781](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231007131752781.png)</p>
<p>![image-20231007131726290](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231007131726290.png)</p>
<blockquote>
<p>产生的 redo log 是直接写入磁盘的吗？</p>
</blockquote>
<p>不是的。</p>
<p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作，而且磁盘的运行速度远慢于内存。</p>
<p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图：</p>
<p>![image-20231007131921540](..&#x2F;images&#x2F;Mysql复习（mysql技术内幕 innodb存储引擎）&#x2F;image-20231007131921540.png)</p>
<h3 id="redo-log-什么时候刷盘？"><a href="#redo-log-什么时候刷盘？" class="headerlink" title="redo log 什么时候刷盘？"></a>redo log 什么时候刷盘？</h3><p>缓存在 redo log buffer 里的 redo log 还是在内存中，它什么时候刷新到磁盘？</p>
<p>主要有下面几个时机：</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。</li>
</ul>
<p>由参数 <code>innodb_flush_log_at_trx_commit</code> 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：</p>
<ul>
<li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li>
<li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li>
<li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/6_file_system/pagecache.html">这篇 (opens new window)</a>），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li>
</ul>
<h3 id="2、undo-log"><a href="#2、undo-log" class="headerlink" title="2、undo log"></a>2、undo log</h3><p>undo log最主要的作用有两点：一个是事务回滚，保证原子性；还有一个是支持mvcc</p>
<p>那我们先讲第一个，就是事务提交之前，如果发生意外，这时候你用redolog是没有办法恢复的，所以我们可以使用undolog，他的做法是，假如我们去修改一个数据，上锁之后，我们把该行数据拷贝到 <code>undo log</code>作为旧版本。copy之后，那进行真正的修改操作，同时修改trxid 和roll_pointer。</p>
<p>另外一个大的作用是mvcc，mvcc他是基于undo log版本链和ReadView实现</p>
<p>然后每一行数据其实都有两个隐藏列，一个是trxid一个是rollpointer，trxid 表示修最新修改事务的id，rollpointer表示指向旧版本log</p>
<p>ReadView，里面有四个比较关键的东西：</p>
<p>一个是m_ids，这个就是说事务开启那一刻有哪些事务在Mysql里面执行还没有提交的；</p>
<p>一个是min_trx_id，就是m_ids里最小的事务id的值；</p>
<p>一个是max_trx_id，就是此刻mysql下一个要生成的事务id，就是最大事务id；</p>
<p>一个是creator_trx_id，就是你这个事务的id。</p>
<p>那我们只要对比mintexid，如果说比他小，说明已经事务已经提交了，我们可以看得见。</p>
<p>比如一条记录旧版本里面有三条记录：10，20，30。然后我们的事务id是15，m_ids里面有20，30。这里的min_trx_id就是20，我们的15比她小，说明还没有提交。因为隔离性所以肯定是看不到的，然后再去找更前面版本，我们就找到了10，发现10可以，所以我们这次读到的数据就是事务id为10的那一个版本。</p>
<p>rr：事务启动的时候创建readview</p>
<p>rc：每次查询都会创建一个readview</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/07/08/Mysql%E5%A4%8D%E4%B9%A0%EF%BC%88mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%20innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%89/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/"
                            aria-label=": mybatis组件的整合理解2"
                        >
                            mybatis组件的整合理解2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-27T00:00:00+08:00">
	
		    27 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>orm我们已经知道具体的做法了，那怎么把这个和我们的spring结合在一起呢？</p>
<p>其实我们要做的就是让他参与到Spring的事务管理之中，然后创建映射器和sqlsession并注入到bean里面，再把异常转化成Spring到dataaccessexception。以上的种种就是要把我们自己的orm交给spring管理。<img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427143800831.png" alt="image-20230427143800831"></p>
<p>orm结合spring的核心内容就是对需要注册对象的扫描，代理类的实现，bean的注册。</p>
<p>这里和orm框架一样，也有三个类非常重要：SqlSessionFactoryBean、MapperScannerConfigurer、MapperFactoryBean</p>
<p>先说SqlSessionFactoryBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 在基本的 MyBatis 中，session 工厂可以使用 SqlSessionFactoryBuilder 来创建。而在 MyBatis-Spring 中,则使用 SqlSessionFactoryBean 来替代。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;SqlSessionFactory&gt;, InitializingBean &#123;</span><br><span class="line">    <span class="keyword">private</span> String resource;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> Resources.getResourceAsReader(resource)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlSessionFactory.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResource</span><span class="params">(String resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SqlSessionFactoryBean实现InitializingBean主要适用于加载mybatis相关内容；解析xml、构造sqlsession、链接数据库等等，这三步就是我们orm框架中的核心部分，这也是为什么你只要引入一些数据库的依赖，你如果没有配置数据库，他在项目启动的时候就会报错，因为这个需要一开始就配置好。</p>
<p>MapperScannerConfigurer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerConfigurer</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String basePackage;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + basePackage.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ResourcePatternResolver</span> <span class="variable">resourcePatternResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line"></span><br><span class="line">            Resource[] resources = resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMetadataReader</span>(resource, ClassUtils.getDefaultClassLoader());</span><br><span class="line"></span><br><span class="line">                <span class="type">ScannedGenericBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> Introspector.decapitalize(ClassUtils.getShortName(beanDefinition.getBeanClassName()));</span><br><span class="line"></span><br><span class="line">                beanDefinition.setResource(resource);</span><br><span class="line">                beanDefinition.setSource(resource);</span><br><span class="line">                beanDefinition.setScope(<span class="string">&quot;singleton&quot;</span>);</span><br><span class="line">                beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(beanDefinition.getBeanClassName());</span><br><span class="line">                beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(sqlSessionFactory);</span><br><span class="line">                beanDefinition.setBeanClass(MapperFactoryBean.class);</span><br><span class="line"></span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName);</span><br><span class="line">                registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBasePackage</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.basePackage = basePackage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个类要做的就是把Dao接口全部扫描出来（也就是所有的XXXdao），完成他们的代理，然后把他们注册到spring Bean容器</p>
<p>打个锻炼看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postProcessBeanDefinitionRegistry</span><br></pre></td></tr></table></figure>

<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427145417700.png" alt="image-20230427145417700"></p>
<p>看这个packagesearchpath就明白了</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427145506491.png" alt="image-20230427145506491"></p>
<p>看resource，因为我们只有一个dao所以就扫描到了一个</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/image-20230427145729295.png" alt="image-20230427145729295"></p>
<p>这里把他注册到容器中</p>
<p>mapperfactory：</p>
<p>这个类其实就是你所有dao接口类的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日常调用的 dao 层接口就是 MapperFactoryBean 实例化的</span><br></pre></td></tr></table></figure>

<p>我们虽然配置的是<code>MapperFactoryBean</code>的实列，但是根据id拿到的是<code>getObject</code>方法里面返回的的对象。其实在容器中创建的对象仍然是<code>MapperFactoryBean</code>的实列，只是在获取的时候会判断这个结果对象是不是派生于<code>FactoryBean</code>，如果是的话则返回<code>getObject</code>方法创建的对象，并且这个对象并不是容器初始化时创建的，而是使用<code>context.getBean()</code>方法时才创建。当然了，如果你确实想要获取<code>FactoryBean</code>实例，你需要这样写: <em><code>MapperFactoryBean mapper = context.getBean(&quot;&amp;mapper&quot;, MapperFactoryBean.class);</code></em> 只需要在bean的名字ID前加上&amp;符号。</p>
<p>所以究竟getObject获取的是什么呢？那就看他return了什么，后面的详细知识和加载流程，就涉及spring源码，所以可以看我的Spring ioc加载流程，保真有所收获！</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A33/"
                            aria-label=": mybatis组件的整合理解3"
                        >
                            mybatis组件的整合理解3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-27T00:00:00+08:00">
	
		    27 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>现在我们来把我们的成果整合到springboot中，但是我们又不想另起一个模块放我们的整合模块，那怎么做呢？诶，没错，就是依赖组件，我们开发自己的依赖组件，在项目中引入即可。</p>
<p>那么在springboot的starter的开发过程中，主要的核心在于自动加载autoconfiguration的使用，我们需要加载yml或者其他的配置文件，并结合配置信息注册相关的bean，因为spring和springboot的注册方式可以不同。</p>
<p>和myabtis组件的整合理解2中提到的mybatis-spring不同的在于，由于spring和springboot本身存在的区别所以加载配置和启动方式有所不同，所以这里我们需要修改的就是扫描方法，注册代码。</p>
<p>这个工程也主要分成三块：autoconfigure、mybatis、spring</p>
<p>●autoconfigure,读取自定义配置信息以及负责把相关mybatis、spring 中的Bean加载启动<br>●mybatis,这部分与我们之前实现的ORM框架源码几乎是一致的，只是对<br>SqlSessionFactoryBuilder做了符合yml配置方式的加载处理。<br>●spring,这一部分主要的变 动是MapperScannerConfigurer关于扫描定义Bean 信息时<br>addGenericArgumentValue入参信息的变更。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A33/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/26/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/"
                            aria-label=": mybatis组件的整合理解1"
                        >
                            mybatis组件的整合理解1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-26T00:00:00+08:00">
	
		    26 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>其实这里最核心的还是做一个ORM对象关系映射，用于不同类型系统的数据之间的转换，也让我们更方便的使用数据库。</p>
<p>主要做法其实就是通过：参数映射、SQL解析和执行以及结果封装的整体方式对数据库进行操作。这也是ORM框架的核心内容。</p>
<p>这里我们注意三类 类，没错就是三个类的类</p>
<p>分别是，sqlsession、sqlsessionfactory、sqlsessionfactorybuilder</p>
<p>sqlseesion：定义了对数据库的操作，什么查询啊之类的。然后接口必须有一个实现类，这里我们用的是defaultsqlsession，实现了接口的方法，也包装了jdbc，这样就把数据库的jdbc包装起来了，我们敲代码也会方便。</p>
<p>sqlsessionfactory：你每次有数据库操作都需要开启一个sqlsession那么从谁那里获取呢，就是factory。他也有一个实现类defaultsqlsession factory，他的唯一方法就是返回上面我们的defaultsqlsession，通过传进去的参数返回sqlsession，不过这个类的构造函数传递了configuration配置，包括connection connection，Map dataSource， Map mapperElement。</p>
<p>sqlsessionfactorybuilder：这个类主要包括：build构建实例化元素，parseConfiguration解析构造，datasource获取数据库配置，connnection链接数据库，mapperElement解析sql语句。</p>
<p>build，创建解析xml文件的类，然后初始化Defaultsqlsessionfactory工厂类，但是这个工厂类需要configuration，那这个configuration则需要parseconfiguration，所以往下看</p>
<p>parseConfigtation：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        configuration.setDataSource(dataSource(root.selectNodes(<span class="string">&quot;//dataSource&quot;</span>)));</span><br><span class="line">        configuration.setConnection(connection(configuration.dataSource));</span><br><span class="line">        configuration.setMapperElement(mapperElement(root.selectNodes(<span class="string">&quot;mappers&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>首先，我们在build以及把xml文件扫描进来了，然后我们用扫描后的参数去设置数据库、链接、节点这三个关键。</p>
<p>datasource函数打断点看看：就是进去了这四个数据库的参数</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/E7B0BF9D-E780-405F-9FE7-85CECE47328F-2492888.png" alt="E7B0BF9D-E780-405F-9FE7-85CECE47328F"></p>
<p>connectin函数里面用这几个参数得到一个链接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(dataSource.get(<span class="string">&quot;driver&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> DriverManager.getConnection(dataSource.get(<span class="string">&quot;url&quot;</span>), dataSource.get(<span class="string">&quot;username&quot;</span>), dataSource.get(<span class="string">&quot;password&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>mapperElement函数<img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426154547513.png" alt="image-20230426154547513"></p>
<p>拿到build扫描的参数，做循环</p>
<p>每次循环，先拿到resource，举个例子：</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426154908196.png" alt="image-20230426154908196"></p>
<p>先拿到mapper&#x2F;usermapper.xml，然后去读这个文件，拿到namespace</p>
<p>也就是对应的dao类，这里就是iuserdao</p>
<p>然后去读doc文件里面的各个操作，我们这个读取了select等等操作，反正就是把xnode放到map里面</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426155555163.png" alt="image-20230426155555163"></p>
<p>这个map就是我们的mapperelement，里面是一个namespace对应一个xnode。</p>
<p>所以mapperelement函数就是去拿到</p>
<p><img src="/../images/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A3/image-20230426155850578.png" alt="image-20230426155850578">对应到我们的具体的mapper.xml文件，然后读取这个文件，去解析我们的sql语句，然后得到一个名称和sql的映射关系的map</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/26/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/22/DBRouter%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/"
                            aria-label=": DBRouter组件的整合理解"
                        >
                            DBRouter组件的整合理解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-22T00:00:00+08:00">
	
		    22 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>这个项目我设计的初衷是考虑到业务体量的增加，为了避免原有的设计出现不能承载业务规模的情况发生，所以想设计分库分表， 因为想提高自己的理解，决定自己写一个小组件。</p>
<p><img src="/../images/DBRouter%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/image-20230428132828992.png" alt="image-20230428132828992"></p>
<p>主要考虑以下几个方面：</p>
<p>一是配置，分库分表需要配置连接池，这个依赖于配置文件，配置连接池之后要二是：考虑动态切换，所以需要去实现AbstractRoutingDataSource的deteemingCurrentlookKey方法。</p>
<p>三：数据库连接池和动态切换配置好了，就只剩下一个路由的计算模块了，从路由计算中获得分库分表的字段，通过哈希散列和扰动函数最终选择去哪个表，让数据均匀的散列到各个表。</p>
<p>首先讲一下：DataSourceAutoConfig，借助springboot自动配置机制，读取配置以及数据源的创建，包括yml自定义配置，JoinPoint、路由策略、路由配置、数据源、transactionTemplate.</p>
<p>举个例子：setEnvironment, 读取自定义配置，因为我们要设置的是一个在yml配置多组数据源，这个方法就是为了解析下面的配置信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router :</span><br><span class="line">jdbc:</span><br><span class="line">datasource :</span><br><span class="line">dbCount: 2</span><br><span class="line">tbCount: 4</span><br><span class="line">list: db01 , db02</span><br><span class="line">db01 :</span><br><span class="line">dr iver-class-name: com . mysql. jdbc .Driver</span><br><span class="line">url: jdbc :mysql://127.0.0.1:3306/bugstack_ 01?</span><br><span class="line">useUnicode-true</span><br><span class="line">username: root</span><br><span class="line">password: 123456</span><br><span class="line">db02 :</span><br><span class="line">dr iver-class-name: com. mysql. jdbc . Driver</span><br><span class="line">url: jdbc :mysql:/ /127.0.0.1:3306/bugstack_ 02?</span><br><span class="line">useUnicode-true</span><br><span class="line">username: root</span><br><span class="line">password: 123456</span><br></pre></td></tr></table></figure>



<p>动态数据源的切换如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;db&quot;</span> + DBContextHolder.getDBKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>路由计算：</p>
<p>路由结果会存储在DBConrtextHolder里面</p>
<p>路由计算首先需要一些前提</p>
<p>路由注解@DBRouter 路由的标识，目的是为了给切面提供切点，同时获取方法中入参属性点某个字段，这个字段会作为路由字段存在，比如某个dao接口的xxxdao方法上面就有这个</p>
<p>分表标记@DBRouterStrategy：目的是告诉路由组件要不要分表，默认false</p>
<p>最关键的，DBRouterJoinPoint切面类，进行路由选择	</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/22/DBRouter%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/11/spring%E6%95%B4%E5%90%88mybatis/"
                            aria-label=": Spring整合mybatis"
                        >
                            Spring整合mybatis
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-11T00:00:00+08:00">
	
		    11 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h4 id="Spring整合Mybatis要解决的问题"><a href="#Spring整合Mybatis要解决的问题" class="headerlink" title="Spring整合Mybatis要解决的问题"></a>Spring整合Mybatis要解决的问题</h4><p>重点关注下的Mapper动态代理对象，因为Spring整合Mybatis的核心目标是：把某个Mapper的代理对象作为一个bean放入Spring容器中，使得能够像使用一个普通bean一样去使用这个代理对象，比如能被@Autowire自动注入。常用如下通过Ioc容器把UserMapper注入了UserService</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;    </span><br><span class="line">    @Autowired    </span><br><span class="line">    private UserMapper userMapper;    </span><br><span class="line">    </span><br><span class="line">    public UserEntity queryUser(int id)&#123;        </span><br><span class="line">        UserEntity userEntity = userMapper.getById(id);        </span><br><span class="line">        return userEntity;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    public void printServiceName()&#123;        </span><br><span class="line">        System.out.println(&quot;I&#x27;m UserService&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spring启动过程中，bean的生命周期如下</p>
<ul>
<li>扫描指定的包路径下的class文件或解析xml文件</li>
<li>生成对应的BeanDefinition</li>
<li>BeanFactoryPostProcessor注册或修改BeanDefinition定义</li>
<li>根据BeanDefinition反射实例化Bean</li>
<li>BeanPostProcessor修改Bean定义</li>
<li>Bean的业务调用</li>
<li>Bean的销毁</li>
</ul>
<p>对于两个Service：UserService&#x2F;OrderInfoService定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"> </span><br><span class="line">    public void printServiceName()&#123;</span><br><span class="line">        System.out.println(&quot;I&#x27;m UserService&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">执行如下命令：</span><br><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">System.out.println(ctx.getBean(&quot;userService&quot;));</span><br><span class="line">结果如下：</span><br><span class="line">com.hobbit.service.UserService@4167d97b</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增加一个FactoryBean后置处理器，修改userService的BeanDefinition定义</span><br><span class="line">@Component</span><br><span class="line">public class RenameBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(&quot;userService&quot;);</span><br><span class="line">        beanDefinition.setBeanClassName(OrderInfoService.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">重新运行结果如下，生成了OrderInfoService对象。</span><br><span class="line">com.hobbit.service.OrderInfoService@57ad2aa7</span><br></pre></td></tr></table></figure>

<p><em><strong>所以在Spring中bean对象跟class或xml定义的bean无直接关系，跟最终的BeanDefinition有直接关系。</strong></em></p>
<p><em><strong>要想生成一个bean，首先要有一个BeanDefinition。那Mapper对应的BeanDefinition是？</strong></em></p>
<p>这就引出了下一个类</p>
<h4 id="MapperFactoryBean"><a href="#MapperFactoryBean" class="headerlink" title="MapperFactoryBean"></a>MapperFactoryBean</h4><p>Spring通过BeanDefinition的beanClassName生成对应的bean，那mapper的对应的beanClassName是什么？本可以有两个答案：</p>
<ul>
<li>代理对象对应的代理类</li>
<li>代理对象对应的接口</li>
</ul>
<p>因为代理类是动态生成的，spring启动时无法得知，无法使用。那么代理对象对应的接口？思路如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanDefinition bd = new BeanDefinitoin();</span><br><span class="line">// 注意这里，设置的是UserMapper</span><br><span class="line">bd.setBeanClassName(UserMapper.class.getName());</span><br><span class="line">SpringContainer.addBd(bd);</span><br></pre></td></tr></table></figure>

<p>实际上给BeanDefinition对应的类型设置为一个接口是行不通的，因为Spring没有办法根据这个BeanDefinition去new出对应类型的实例，接口是没法直接new出实例的。</p>
<p>所以想通过设置BeanDefinition的class类型，然后由Spring自动地帮助我们去生成对应的bean，但是这条路是行不通的。可以通过其它方<strong>MapperFactoryBean</strong>来实现。</p>
<p>MapperFactoryBean继承关系</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b00b1795cde71cbf838c42c2d7bd8d42.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  ...</span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public T getObject() throws Exception &#123;</span><br><span class="line">    return getSqlSession().getMapper(this.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public Class&lt;T&gt; getObjectType() &#123;</span><br><span class="line">    return this.mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getObjectType返回的是Mapper接口，通过 AbstractBeanDefinition.AUTOWIRE_BY_TYPE时，可自动注入使用。</p>
<p>getObject返回了动态代理对象，跟之前的使用一致。至此完成了Mapper对应BeanDefinition定义的问题，那这些BeanDefinition是如何注册到Ioc容器呢？</p>
<h4 id="Mapper-BeanDefinition加载"><a href="#Mapper-BeanDefinition加载" class="headerlink" title="Mapper BeanDefinition加载"></a>Mapper BeanDefinition加载</h4><p>Spring可通过多种方式加载BeanDefinition，从XmlBeanDefinitionReader到ClassPathBeanDefinitionScanner在到ConfigurationClassBeanDefinitionReader分别对应xml、@component、@configuration类定义的加载。Mapper BeanDefinition可通过2种形式加载MapperScannerConfigurer和@MapperScan注解，内部都是通过ClassPathMapperScanner实现。ClassPathMapperScanner继承了ClassPathBeanDefinitionScanner，类图如下</p>
<p>两种方式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定要扫描的包，在此包下自动搜索映射器(接口) --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;basePackage&quot; value=&quot;com.hobbit.mapper&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用@MapperScan加载</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用MapperScannerConfigurer加载在配置MapperScannerConfigurer中主要是加载dao包中的所有dao接口，通过sqlsessionFactory获取sqlsession，然后创建所有dao接口对象，存储在spring容器</strong></p>
<p><strong>会在spring容器刷新refresh过程中被调用</strong></p>
<p>到此为止，Spring整合Mybatis的核心原理就结束了，再次总结一下：</p>
<p>定义MapperFactoryBean，用来封装Mapper对应的BeanDefinition<br>通过ClassPathMapperScanner重新定义BeanClass及AutowireMode，实现BeanDefinition加载及MapperInterface与MapperFactory整合<br>通过MapperScannerConfigurer或@MapperScan，分别扩展BeanDefinitionRegistryPostProcessor及ImportBeanDefinitionRegistrar 用来在启动Spring时执行调用ClassPathMapperScanner完成Mapper BeanDefinition的注册</p>
<h2 id="Spring的启动流程："><a href="#Spring的启动流程：" class="headerlink" title="Spring的启动流程："></a>Spring的启动流程：</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39559282/article/details/118255793">https://blog.csdn.net/weixin_39559282/article/details/118255793</a></p>
<h2 id="MyBatis与Spring的集成原理"><a href="#MyBatis与Spring的集成原理" class="headerlink" title="MyBatis与Spring的集成原理"></a>MyBatis与Spring的集成原理</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73311735/article/details/129226313">https://blog.csdn.net/m0_73311735/article/details/129226313</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/11/spring%E6%95%B4%E5%90%88mybatis/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"
                            aria-label=": 参考资料"
                        >
                            参考资料
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-11T00:00:00+08:00">
	
		    11 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/">学习资料</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="2023-x2F-07-x2F-29更新"><a href="#2023-x2F-07-x2F-29更新" class="headerlink" title="2023&#x2F;07&#x2F;29更新"></a>2023&#x2F;07&#x2F;29更新</h3><p>鉴于最初版本部分网站已丢失，决定对所有网站进行全面清洗。</p>
<hr>
<h3 id="为防止意外情况，使用最简单的Base64编码："><a href="#为防止意外情况，使用最简单的Base64编码：" class="headerlink" title="为防止意外情况，使用最简单的Base64编码："></a>为防止意外情况，使用最简单的Base64编码：</h3><p>LS0tCnRpdGxlOiDlj4LogIPotYTmlpkKZGF0ZTogMjAyMy0wNC0xMQp0YWdzOiAKICAtIOeUn+eQhumcgOaxggpjYXRlZ29yaWVzOgogIC0g5a2m5Lmg6LWE5paZCgotLS0KCgoKIyMjIDIwMjMvMDcvMjnmm7TmlrAKCumJtOS6juacgOWIneeJiOacrOmDqOWIhue9keermeW3suS4ouWkse+8jOWGs+WumuWvueaJgOaciee9keermei&#x2F;m+ihjOWFqOmdoua4hea0l+OAggoKIyMjIyDml6DpnIDnv7vlopnvvJoKCkFW5aSp5aCC572R77yaaHR0cDovL2JiLjk5OTl5ZXMuY29tL25ld3NpdGUuaHRtbD9jPTQ5OTg4ODM4NDAgCgrmvKvom5nvvIjpn6nmvKvvvInvvJpodHRwczovL21hbndhLm1lLwoK5oCn5aWL6Imy5ZCD55Oc572R77yaaHR0cDovL3d3dy54ZnNlMTEuY29tLwoKNUflvbHpmaLvvJpodHRwczovLzVxd21iYS50b3AvCgrmnY9UVu+8mmh0dHBzOi8vMTh4aW5ndHYuY2MvCgrnnIvniYfop4bpopHvvJpodHRwczovL3d3dy5oazEycS50b3Avdm9kcGxheWh0bWwvMjI0LTEtMS5odG1sCgrkuLvmkq3op4bpopHvvJpodHRwczovL3d3dy51N3NiLmNvbS9lbnRlci9pbmRleC5odG1sCgp5b3Vwb3JuIEFTSUEgQ0hBTk5FTO+8mmh0dHA6Ly94MzM2OTkuY29tLwoKdjhrNG4uY29t77yaaHR0cHM6Ly93d3cudjhrNG4uY29tL2luZGV4L2hvbWUuaHRtbAoKIyMjIyDnv7vlopnvvJoKCnhoYW1zdGVy77yaaHR0cHM6Ly96aC54aGFtc3Rlci5jb20vCgrni7zlj4vpmIHvvJpodHRwczovLzAwNTFhdi5jb20vCgrpu5HmlpnmraPog73ph4&#x2F;vvJpodHRwczovL3d3dy5mdWxpMzQubHYvCgpQb3JuaHVi77yaaHR0cHM6Ly9jbi5wb3JuaHViLmNvbS8KCmLlvbHpmaLvvJpodHRwczovL2JiYnl1bi50b3AvCgojIyMjIOi9r+S7tu+8mgoK5YW25a6e6K645aSa572R56uZ55qE5Y+L6ZO+5Lit6YO95pyJ6L2v5Lu277yM6L+Z6YeM5Li+5LiA5L6LCgrpu5HmlpnnpL7vvJpodHRwczovL3Q2MnJvLmNvbS8&#x2F;ZGM9TUlZVTA0</p>
<h4 id="将上述内容复制（快速三击）到以下网站，点击BASE64解码，即可获得最新内容，将其保存就避免了频繁访问。"><a href="#将上述内容复制（快速三击）到以下网站，点击BASE64解码，即可获得最新内容，将其保存就避免了频繁访问。" class="headerlink" title="将上述内容复制（快速三击）到以下网站，点击BASE64解码，即可获得最新内容，将其保存就避免了频繁访问。"></a>将上述内容复制（快速三击）到以下网站，点击BASE64解码，即可获得最新内容，将其保存就避免了频繁访问。</h4><p><a target="_blank" rel="noopener" href="https://www.iamwawa.cn/base64.html">https://www.iamwawa.cn/base64.html</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/11/spring%20ioc%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"
                            aria-label=": Spring ioc加载流程"
                        >
                            Spring ioc加载流程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-11T00:00:00+08:00">
	
		    11 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><strong>在功能上，SpringBoot的容器启动过程基本遵循了Spring的标准启动过程，但是在具体实现上，SpringBoot提供了一些特殊的机制来简化Spring容器的配置和启动。</strong></p>
<p><strong>首先，SpringBoot自动配置了很多常用的第三方库和框架，使得在大多数情况下，开发者不需要手动配置就能够使用这些库和框架。其次，SpringBoot提供了一些基础设施和约定来简化Spring的配置，例如默认的目录结构、默认的配置文件名、默认的属性配置等，这些都能够减少开发者的配置工作。最后，SpringBoot提供了一些自定义扩展机制，例如通过@ConfigurationProperties注解来绑定配置文件属性到Java对象，通过SpringApplication类的addListeners()方法来添加自定义的启动监听器等等，这些扩展机制能够让开发者更加方便地自定义和扩展SpringBoot的功能。</strong></p>
<p><strong>总的来说，SpringBoot并没有改变Spring的核心机制和启动过程，但是它在具体实现上提供了很多便利和简化，让开发者能够更加快速地开发和部署应用程序</strong></p>
<p>总体分成两个阶段；</p>
<ul>
<li>一、refresh之前</li>
<li>二、调用refresh()方法刷新容器</li>
</ul>
<h2 id="一、初始化流程"><a href="#一、初始化流程" class="headerlink" title="一、初始化流程"></a>一、初始化流程</h2><ol>
<li>创建并实例化一个 ApplicationContextInitializer 列表，用于对 Spring 应用上下文进行初始化。ApplicationContextInitializer 是 Spring 4.1 引入的一个新特性，允许用户在容器启动之前，对 Spring 应用上下文进行一些额外的初始化工作。</li>
<li>创建并实例化一个 ResourceLoader 对象，用于加载配置文件。ResourceLoader 是一个接口，它定义了资源加载的基本方法。Spring 容器默认使用 DefaultResourceLoader 作为 ResourceLoader 实现类。</li>
<li>创建并实例化一个 PropertyResolver 对象，用于解析配置文件中的属性。PropertyResolver 也是一个接口，它定义了属性解析的基本方法。Spring 容器默认使用 PropertySourcesPlaceholderConfigurer 作为 PropertyResolver 实现类。</li>
<li>加载和解析配置文件，将解析后的配置信息封装成一个 Environment 对象。Environment 是 Spring 中用于描述应用环境的一个抽象概念，它包含了各种配置属性和属性值。</li>
<li>将解析后的配置信息封装成一个 ConfigurableEnvironment 对象，并将其设置到容器中。ConfigurableEnvironment 是 Environment 的一个子接口，它定义了一些额外的操作，如添加属性、激活配置文件等。</li>
<li>创建并实例化一个 BeanFactoryPostProcessor 列表，用于在 BeanFactory 加载 Bean 定义之后，对 Bean 定义进行进一步的处理。BeanFactoryPostProcessor 是一个接口，它提供了在 BeanFactory 加载 Bean 定义之后，修改 Bean 定义的机会。</li>
<li>创建并实例化一个 BeanPostProcessor 列表，用于在 Bean 实例化之后，对 Bean 进行进一步的处理。BeanPostProcessor 是一个接口，它提供了在 Bean 实例化之后，修改 Bean 实例的机会。</li>
<li>注册并加载 BeanFactory 中的 Bean 定义。在这个阶段，Spring 容器会扫描指定的包，查找标注了 @Component、@Service、@Repository、@Controller 等注解的 Bean，将其封装成 BeanDefinition 对象，注册到 BeanFactory 中。</li>
<li>调用 BeanFactoryPostProcessor 的 postProcessBeanFactory() 方法，对 BeanFactory 中的 Bean 定义进行进一步的处理。</li>
<li>注册并加载 BeanFactoryPostProcessor 中的 Bean 定义。BeanFactoryPostProcessor 可以通过实现 BeanDefinitionRegistryPostProcessor 接口，向 BeanFactory 中注册新的 Bean 定义。</li>
<li>初始化并注册 ConversionService。ConversionService 是 Spring 中用于类型转换的一个组件，它可以将一个对象转换成另一个类型的对象。在这个阶段，Spring 容器会注册一些默认的转换器。</li>
<li>初始化并注册 LoadTimeWeaver。LoadTimeWeaver 是 Spring 中用于支持动态类加载和增强的一个组件。它可以将类的字节码在运行时进行增强，从而实现 AOP 等功能。</li>
<li>初始化并注册 Resource</li>
</ol>
<p><strong>中间第8步解析过程如下：</strong></p>
<p>这个步骤主要是用来解析用户传入的 Spring 配置类，解析成一个 BeanDefinition 然后注册到容器中，主要源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span><br><span class="line">		@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) &#123;</span><br><span class="line">	// 解析传入的配置类，实际上这个方法既可以解析配置类，也可以解析 Spring bean 对象</span><br><span class="line">	AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">	// 判断是否需要跳过，判断依据是此类上有没有 @Conditional 注解</span><br><span class="line">	if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">	ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">	abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">	String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));</span><br><span class="line">	// 处理类上的通用注解</span><br><span class="line">	AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">	if (qualifiers != null) &#123;</span><br><span class="line">		for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">			if (Primary.class == qualifier) &#123;</span><br><span class="line">				abd.setPrimary(true);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (Lazy.class == qualifier) &#123;</span><br><span class="line">				abd.setLazyInit(true);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				abd.addQualifier(new AutowireCandidateQualifier(qualifier));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 封装成一个 BeanDefinitionHolder</span><br><span class="line">	for (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">		customizer.customize(abd);</span><br><span class="line">	&#125;</span><br><span class="line">	BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);</span><br><span class="line">	// 处理 scopedProxyMode</span><br><span class="line">	definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line"> </span><br><span class="line">	// 把 BeanDefinitionHolder 注册到 registry</span><br><span class="line">	BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「扫描」在XML/注解/JavaConfig 中需要被Spring管理的Bean信息</span><br><span class="line"></span><br><span class="line">随后，会将这些信息封装成BeanDefinition，最后会把这些信息放到一个beanDefinitionMap中</span><br><span class="line">那么BeanDefintiions是什么勒？</span><br><span class="line"></span><br><span class="line">BeanDefintiions其实就是对Bean的一些元数据定义</span><br><span class="line">包括parenName 父类名称 baenClassName：类名，scope bean的作用域。Abstract是否是抽象的等信息。</span><br><span class="line">通过 BeanDefinitionReader获取到BeanDefinition之后 。我们在通过BeanDefinitionRegistry将beanDefinition注册到BeanFacory中。存储在BeanFactory的一个conCurrentHashMap中。key为beanName,Value就是BeanDefinition元数据。</span><br><span class="line">Spring通过BeanDefinationReader将配置元信息加载到内存生成相应的BeanDefination之后，就将其注册到BeanDefinationRegistry中，BeanDefinationRegistry就是一个存放BeanDefination的大篮子，它也是一种键值对的形式，通过特定的Bean定义的id，映射到相应的BeanDefination</span><br></pre></td></tr></table></figure>



<p><strong>接着会遍历这个beanDefinitionMap，执行BeanFactoryPostProcessor这个Bean工厂后置处理器的逻辑，比如替换<code>$</code>占位符</strong></p>
<p><img src="https://img-blog.csdnimg.cn/690f5df98811421ab1dc6e1495375d71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ0Nxd2Fz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="三、refresh-容器刷新流程-最重要"><a href="#三、refresh-容器刷新流程-最重要" class="headerlink" title="三、refresh()容器刷新流程(最重要)"></a>三、refresh()容器刷新流程(最重要)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、prepareRefresh()刷新前的预处理：</span><br><span class="line"></span><br><span class="line">（1）initPropertySources()：初始化一些属性设置，子类自定义个性化的属性设置方法；</span><br><span class="line">（2）getEnvironment().validateRequiredProperties()：检验属性的合法性</span><br><span class="line">（3）earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;()：保存容器中的一些早期的事件；</span><br><span class="line">2、obtainFreshBeanFactory()：获取在容器初始化时创建的BeanFactory：</span><br><span class="line"></span><br><span class="line">（1）refreshBeanFactory()：刷新BeanFactory，设置序列化ID；</span><br><span class="line">（2）getBeanFactory()：返回初始化中的GenericApplicationContext创建的BeanFactory对象，即【DefaultListableBeanFactory】类型</span><br><span class="line">3、prepareBeanFactory(beanFactory)：BeanFactory的预处理工作，向容器中添加一些组件：</span><br><span class="line"></span><br><span class="line">（1）设置BeanFactory的类加载器、设置表达式解析器等等</span><br><span class="line">（2）添加BeanPostProcessor【ApplicationContextAwareProcessor】</span><br><span class="line">（3）设置忽略自动装配的接口：EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware；</span><br><span class="line">（4）注册可以解析的自动装配类，即可以在任意组件中通过注解自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext</span><br><span class="line">（5）添加BeanPostProcessor【ApplicationListenerDetector】</span><br><span class="line">（6）添加编译时的AspectJ；</span><br><span class="line">（7）给BeanFactory中注册的3个组件：environment【ConfigurableEnvironment】、systemProperties【Map&lt;String, Object&gt;】、systemEnvironment【Map&lt;String, Object&gt;】</span><br><span class="line">4、postProcessBeanFactory(beanFactory)：子类重写该方法，可以实现在BeanFactory创建并预处理完成以后做进一步的设置</span><br><span class="line"></span><br><span class="line">5、invokeBeanFactoryPostProcessors(beanFactory)：在BeanFactory标准初始化之后执行BeanFactoryPostProcessor的方法，即BeanFactory的后置处理器：</span><br><span class="line"></span><br><span class="line">（1）先执行BeanDefinitionRegistryPostProcessor： postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class="line"></span><br><span class="line">① 获取所有的实现了BeanDefinitionRegistryPostProcessor接口类型的集合</span><br><span class="line">② 先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor</span><br><span class="line">③ 再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor</span><br><span class="line">④ 最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors        </span><br><span class="line">（2）再执行BeanFactoryPostProcessor的方法：postProcessor.postProcessBeanFactory(beanFactory)</span><br><span class="line"></span><br><span class="line">① 获取所有的实现了BeanFactoryPostProcessor接口类型的集合</span><br><span class="line">② 先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor</span><br><span class="line">③ 再执行实现了Ordered顺序接口的BeanFactoryPostProcessor</span><br><span class="line">④ 最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor</span><br><span class="line">6、registerBeanPostProcessors(beanFactory)：向容器中注册Bean的后置处理器BeanPostProcessor，它的主要作用是干预Spring初始化bean的流程，从而完成代理、自动注入、循环依赖等功能</span><br><span class="line"></span><br><span class="line">（1）获取所有实现了BeanPostProcessor接口类型的集合：</span><br><span class="line">（2）先注册实现了PriorityOrdered优先级接口的BeanPostProcessor；</span><br><span class="line">（3）再注册实现了Ordered优先级接口的BeanPostProcessor；</span><br><span class="line">（4）最后注册没有实现任何优先级接口的BeanPostProcessor；</span><br><span class="line">（5）最r终注册MergedBeanDefinitionPostProcessor类型的BeanPostProcessor：beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">（6）给容器注册一个ApplicationListenerDetector：用于在Bean创建完成后检查是否是ApplicationListener，如果是，就把Bean放到容器中保存起来：applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">此时容器中默认有6个默认的BeanProcessor(无任何代理模式下)：【ApplicationContextAwareProcessor】、【ConfigurationClassPostProcessorsAwareBeanPostProcessor】、【PostProcessorRegistrationDelegate】、【CommonAnnotationBeanPostProcessor】、【AutowiredAnnotationBeanPostProcessor】、【ApplicationListenerDetector】</span><br><span class="line"></span><br><span class="line">7、initMessageSource()：初始化MessageSource组件，主要用于做国际化功能，消息绑定与消息解析：</span><br><span class="line"></span><br><span class="line">（1）看BeanFactory容器中是否有id为messageSource 并且类型是MessageSource的组件：如果有，直接赋值给messageSource；如果没有，则创建一个DelegatingMessageSource；</span><br><span class="line">（2）把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource；</span><br><span class="line">8、initApplicationEventMulticaster()：初始化事件派发器，在注册监听器时会用到：</span><br><span class="line"></span><br><span class="line">（1）看BeanFactory容器中是否存在自定义的ApplicationEventMulticaster：如果有，直接从容器中获取；如果没有，则创建一个SimpleApplicationEventMulticaster</span><br><span class="line">（2）将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件就可以直接自动注入</span><br><span class="line">9、onRefresh()：留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑</span><br><span class="line"></span><br><span class="line">10、registerListeners()：注册监听器：将容器中所有的ApplicationListener注册到事件派发器中，并派发之前步骤产生的事件：</span><br><span class="line"></span><br><span class="line"> （1）从容器中拿到所有的ApplicationListener</span><br><span class="line">（2）将每个监听器添加到事件派发器中：getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">（3）派发之前步骤产生的事件applicationEvents：getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">11、finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；</span><br><span class="line"></span><br><span class="line">（1）获取容器中的所有beanDefinitionName，依次进行初始化和创建对象</span><br><span class="line">（2）获取Bean的定义信息RootBeanDefinition，它表示自己的BeanDefinition和可能存在父类的BeanDefinition合并后的对象</span><br><span class="line">（3）如果Bean满足这三个条件：非抽象的，单实例，非懒加载，则执行单例Bean创建流程：    </span><br><span class="line">（4）所有Bean都利用getBean()创建完成以后，检查所有的Bean是否为SmartInitializingSingleton接口的，如果是；就执行afterSingletonsInstantiated()；</span><br><span class="line">12、finishRefresh()：发布BeanFactory容器刷新完成事件：</span><br><span class="line"></span><br><span class="line">（1）initLifecycleProcessor()：初始化和生命周期有关的后置处理器：默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】，如果没有，则创建一个DefaultLifecycleProcessor()加入到容器；</span><br><span class="line">（2）getLifecycleProcessor().onRefresh()：拿到前面定义的生命周期处理器（LifecycleProcessor）回调onRefresh()方法</span><br><span class="line">（3）publishEvent(new ContextRefreshedEvent(this))：发布容器刷新完成事件；</span><br><span class="line">（4）liveBeansView.registerApplicationContext(this);</span><br></pre></td></tr></table></figure>

<p>可以看到这个方法里面调用了很多的方法，我们从开始说起：</p>
<ul>
<li><p>首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；</p>
</li>
<li><p>接着往下看prepareRefresh();这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。</p>
</li>
<li><p>下一步ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();这个就很重要了，这一步是把配置文件解析成一个个BeanDefinition，并且注册到BeanFactory中，注意**<u>这里只是注册进去，并没有实例化</u>**。先继续往下看，等会展开这个方法详细解读</p>
</li>
<li><p>然后是prepareBeanFactory(beanFactory);这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看</p>
</li>
<li><p>postProcessBeanFactory(beanFactory);<strong><u>方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。</u></strong></p>
</li>
<li><p>接下来是invokeBeanFactoryPostProcessors(beanFactory);<u><strong>这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</strong></u></p>
</li>
<li><p>然后是registerBeanPostProcessors(beanFactory);这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。然后回到refresh()方法中继续往下看</p>
</li>
<li><p>initMessageSource();方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下</p>
</li>
<li><p>initApplicationEventMulticaster();方法初始化当前 ApplicationContext 的事件广播器继续往下</p>
</li>
<li><p>onRefresh();<u>方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下</u></p>
</li>
<li><p>registerListeners();方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下</p>
</li>
<li><h5 id="重点到了：finishBeanFactoryInitialization-beanFactory-初始化所有的-singleton-beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说"><a href="#重点到了：finishBeanFactoryInitialization-beanFactory-初始化所有的-singleton-beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说" class="headerlink" title="重点到了：finishBeanFactoryInitialization(beanFactory);初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说"></a>重点到了：finishBeanFactoryInitialization(beanFactory);<u>初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说</u></h5></li>
<li><p>finishRefresh();方法是最后一步，广播事件，ApplicationContext 初始化完成</p>
</li>
</ul>
<h3 id="我们重点来看ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory-和finishBeanFactoryInitialization-beanFactory-这两个方法"><a href="#我们重点来看ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory-和finishBeanFactoryInitialization-beanFactory-这两个方法" class="headerlink" title="我们重点来看ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();和finishBeanFactoryInitialization(beanFactory);这两个方法"></a>我们重点来看<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code>和<code>finishBeanFactoryInitialization(beanFactory);</code>这两个方法</h3><p>先说<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</code>; 这一步上面简单介绍过了，作用是把配置文件解析成一个个BeanBeanDefinition，并且注册到BeanFactory中，点进去源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	return beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法中第一步refreshBeanFactory();方法的作用是关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等，然后getBeanFactory();就是返回刚刚创建的 BeanFactory(其实就是DefaultListableBeanFactory)，我们进入refreshBeanFactory();方法，在AbstractRefreshableApplicationContext类中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">	if (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">			this.beanFactory = beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个refreshBeanFactory()方法首先如果 ApplicationContext 中已经加载过 BeanFactory<br>了，销毁所有 Bean，关闭 BeanFactory；这里指的是当前ApplicationContext 是否有 BeanFactory。<br>然后createBeanFactory();初始化一个DefaultListableBeanFactory，这个DefaultListableBeanFactory是很重的一个类，为什么重要呢？可以看文章开头的BeanFactory继承图，DefaultListableBeanFactory是位于最下面的，他往上能走完BeanFactory继承图所有，所以他可以说是功能最大的BeanFactory。<br>beanFactory.setSerializationId(getId());方法用于 BeanFactory 的序列化<br>customizeBeanFactory(beanFactory);方法设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用，这个等会细说<br>loadBeanDefinitions(beanFactory);这个方法很重要：加载 Bean定义 到 BeanFactory 中，也是等会细说<br>下面看customizeBeanFactory(beanFactory);方法，这个方法作用：是否允许 Bean 覆盖、是否允许循环引用，这是什么意思呢？这就要说到BeanDefinition了，这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中，下面贴出来开头我说的大神的关于BeanDefinition接口的代码注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">AttributeAccessor</span>, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们可以看到，默认只提供 sington 和 prototype 两种，</span></span><br><span class="line">   <span class="comment">// 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span></span><br><span class="line">   <span class="comment">// 不过，它们属于基于 web 的扩展。</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 比较不重要，直接跳过吧</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_APPLICATION</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_SUPPORT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_INFRASTRUCTURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span></span><br><span class="line">   <span class="comment">// 一句话就是：继承父 Bean 的配置信息而已</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setParentName</span><span class="params">(String parentName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取父 Bean</span></span><br><span class="line">   String <span class="title function_">getParentName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setBeanClassName</span><span class="params">(String beanClassName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取 Bean 的类名称</span></span><br><span class="line">   String <span class="title function_">getBeanClassName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 bean 的 scope</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(String scope)</span>;</span><br><span class="line"></span><br><span class="line">   String <span class="title function_">getScope</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setLazyInit</span><span class="params">(<span class="type">boolean</span> lazyInit)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isLazyInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span></span><br><span class="line">   <span class="comment">// 是 depends-on=&quot;&quot; 属性设置的值。</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setDependsOn</span><span class="params">(String... dependsOn)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该 Bean 的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span></span><br><span class="line">   <span class="comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setAutowireCandidate</span><span class="params">(<span class="type">boolean</span> autowireCandidate)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 是否可以注入到其他 Bean 中</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAutowireCandidate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setPrimary</span><span class="params">(<span class="type">boolean</span> primary)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是 primary 的</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrimary</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span></span><br><span class="line">   <span class="comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   String <span class="title function_">getFactoryBeanName</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的 工厂方法名称</span></span><br><span class="line">   String <span class="title function_">getFactoryMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   ConstructorArgumentValues <span class="title function_">getConstructorArgumentValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   MutablePropertyValues <span class="title function_">getPropertyValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span></span><br><span class="line">   <span class="comment">// 常用于作为 父bean 用于继承，其实也很少用......</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAbstract</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getRole</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getResourceDescription</span><span class="params">()</span>;</span><br><span class="line">   BeanDefinition <span class="title function_">getOriginatingBeanDefinition</span><span class="params">()</span>;</span><br><span class="line">&#125;BeanDefinition 的覆盖问题就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 <span class="literal">null</span>，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</span><br><span class="line">循环引用：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</span><br><span class="line">默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</span><br></pre></td></tr></table></figure>

<p>再看loadBeanDefinitions(beanFactory) 方法，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。先贴上源码：AbstractXmlApplicationContext类中</p>
<pre><code>@Override
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;
    // Create a new XmlBeanDefinitionReader for the given BeanFactory.
    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
  // Configure the bean definition reader with this context&#39;s
  // resource loading environment.
  beanDefinitionReader.setEnvironment(this.getEnvironment());
  beanDefinitionReader.setResourceLoader(this);
  beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

  // Allow a subclass to provide custom initialization of the reader,
  // then proceed with actually loading the bean definitions.
  initBeanDefinitionReader(beanDefinitionReader);
  loadBeanDefinitions(beanDefinitionReader);
</code></pre>
<p>}<br>这个源码中我们重点看loadBeanDefinitions(beanDefinitionReader);，再点进去源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">	Resource[] configResources = getConfigResources();</span><br><span class="line">	<span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">		reader.loadBeanDefinitions(configResources);</span><br><span class="line">	&#125;</span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	<span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">		reader.loadBeanDefinitions(configLocations);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在这段源码中我么可以看到2个reader.loadBeanDefinitions()方法，其实两个最终都到了：AbstractBeanDefinitionReader类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">	<span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">		counter += loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法里面，for循环每一个文件是一个resource，最终返回 counter，表示总共加载了多少的 BeanDefinition。<br>进入loadBeanDefinitions(resource);方法，看源码：<br>XmlBeanDefinitionReader类中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line">  Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">  <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">    currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">        <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">      <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">        inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">        <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中可以看到try代码块中一开始是根据外层循环调用的每一个Resource解析成一个InputStream 然后根据这个输入流解析；<br>这段源码的核心在doLoadBeanDefinitions(inputSource, encodedResource.getResource());继续进源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">		<span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="string">&quot; in XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在这个方法里面可以看到doLoadDocument(inputSource, resource);方法是将 xml 文件(输入流和Resource)转换为 Document 对象，然后继续进源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里创建了一个BeanDefinitionDocumentReader，然后spring通过BeanDefinitionDocumentReader 会进行委托bean定义的创建；<br>继续这个方法里面看：documentReader.registerBeanDefinitions(doc, createReaderContext(resource));点进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">	logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line">	<span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">	doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>里面的doRegisterBeanDefinitions(root);方法就是从 xml 根节点开始解析文件，经过很多的步骤，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，可以看到上面有个 for 循环的(loadBeanDefinitions(resource);是在for循环里面的)，进入doRegisterBeanDefinitions(root);方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">	<span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">	<span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">	<span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">	<span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">	<span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">	<span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">	<span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">	<span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">          profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">          logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">              <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">  postProcessXml(root);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码中可以看到BeanDefinitionDocumentReader最终是创建了一个BeanDefinitionParserDelegate ，把bean定义的创建委托给了BeanDefinitionParserDelegate 进行创建，这就是委托模式的提现。<br>同时也可以看到这段代码中先把this.delegate给了一个parent，然后又创建了一个Delegate，然后执行最后又把这个parent给回去了this.delegate，这是为了处理<beans>标签嵌套<beans>的问题，其实是个类似递归的操作。这里大家可以debugger试试嵌套的情况就明白了。</p>
<h5 id="再看preProcessXml-root-，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式-模板方法模式不了解的可以看我的这篇文章-，同理postProcessXml-root-也一样，就是在Bean定义创建前后提供扩展点。"><a href="#再看preProcessXml-root-，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式-模板方法模式不了解的可以看我的这篇文章-，同理postProcessXml-root-也一样，就是在Bean定义创建前后提供扩展点。" class="headerlink" title="再看preProcessXml(root)，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式(模板方法模式不了解的可以看我的这篇文章)，同理postProcessXml(root)也一样，就是在Bean定义创建前后提供扩展点。"></a>再看preProcessXml(root)，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式(模板方法模式不了解的可以看我的这篇文章)，同理postProcessXml(root)也一样，就是在Bean定义创建前后提供扩展点。</h5><p>那继续进入parseBeanDefinitions(root, this.delegate);看重点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">			<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">				<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">				<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">					<span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">					<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">						parseDefaultElement(ele, delegate);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						delegate.parseCustomElement(ele);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			delegate.parseCustomElement(root);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>这段代码是循环解析Element 的每一个节点，一般我们的普通bean都是走parseDefaultElement(ele, delegate);默认的解析流程。<br>但是这里有个else的自定义解析，这个很多人都忽略了，其实如果我们xml的配置文件中定义了<a href="aop:config">aop:config</a> 标签，他就会走这个自定义解析，然后解析aop内容，后续会在分析AOP源码，可以看这篇文章)说<a href="aop:config">aop:config</a>的时候讲这里。<br>这里我们还是走普通的beand解析逻辑parseDefaultElement(ele, delegate)，跟进去看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">			importBeanDefinitionResource(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">			processAliasRegistration(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">			processBeanDefinition(ele, delegate);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">			<span class="comment">// recurse</span></span><br><span class="line">			doRegisterBeanDefinitions(ele);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>这个方法见名知意，解析默认的Element，是4个if分支，第一个是解析import类型的，第二个是alias的，第三个是bean的(也就是我们普通bean默认的)，第四个是beans，也就是嵌套的(这里这个嵌套的就回到上面doRegisterBeanDefinitions方法了，也就是为什么说上面其实类似递归的原因)<br>这里我们只分析普通bean的解析处理，进入processBeanDefinition(ele, delegate);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">					bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send registration event.</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这段代码首先通过delegate创建一个bean定义的持有者BeanDefinitionHolder，<strong>这一步其实BeanDefinition也在里面已经创建出来了</strong>。进入delegate.parseBeanDefinitionElement(ele)看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">		<span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">	List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">		String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">		aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">		beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">		checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">	<span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">					beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">							beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">					<span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">					<span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">					<span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">					<span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">					<span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">							beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">							!<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">						aliases.add(beanClassName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				error(ex.getMessage(), ele);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这段代码中有一个parseBeanDefinitionElement(ele, beanName, containingBean)，<strong>返回了一个AbstractBeanDefinition，这个方法里面实际是创建了一个GenericBeanDefinition</strong>，这里就不跟进去看了，代码篇幅太长了，这个里面很简单没啥绕的逻辑，大家跟着点点就能看到了。创建完GenericBeanDefinition之后设置了Class属性、构造器等等一些创建Bean实例需要的东西之后就返回了。</p>
<p>然后回到processBeanDefinition(ele, delegate);看BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());，由于这个时候<strong>已经创建了BeanDefinition</strong>并且有持有者BeanDefinitionHolder进行注册，所以继续跟进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">      <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">	String[] aliases = definitionHolder.getAliases();</span><br><span class="line">	<span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显继续跟进到registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());，这里是一个接口调用，肯定是到了DefaultListableBeanFactory，但是在这个接口调用时我们需要注意的是第二个参数，从BeanDefinitionHolder中获取到了BeanDefinition对象，这个就是创建Bean定义持有者的时候顺带获取的BeanDefinition，通过上面的解析我们知道这个时候BeanDefinition已经创建好了，然后跟进这个方法进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">	Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">			<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">						existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">			<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">				updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				<span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">				removeManualSingletonName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Still in startup registration phase</span></span><br><span class="line">			<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			<span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">			removeManualSingletonName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法里面就可以看到经过一系列验证等等操作，最后把BeanDefinition放入了beanDefinitionMap，到这里bean定义就完成并注册到org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap里面了</p>
<p>然后我们回到refresh() 方法，就是文章前部分的那个refresh() 方法…TvT<br>再贴一下refresh() 方法的源码吧，方便阅读：<br>我直接贴大神带注释的代码吧，看起来更方便一点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">   <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">  prepareRefresh();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">  <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">  <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">  <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">  <span class="comment">// 这块待会会展开说</span></span><br><span class="line">  prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">     <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">     <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">     postProcessBeanFactory(beanFactory);</span><br><span class="line">     <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span></span><br><span class="line">     invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">     <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">     <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span></span><br><span class="line">     registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">     initMessageSource();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">     initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span></span><br><span class="line">     <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">     onRefresh();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">     registerListeners();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 重点，重点，重点</span></span><br><span class="line">     <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">     <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">     finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span></span><br><span class="line">     finishRefresh();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">     <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">              <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">     <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">     destroyBeans();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">     cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 把异常往外抛</span></span><br><span class="line">     <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">     <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">     resetCommonCaches();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="到此为止，ConfigurableListableBeanFactory-beanFactory-x3D-obtainFreshBeanFactory-结束"><a href="#到此为止，ConfigurableListableBeanFactory-beanFactory-x3D-obtainFreshBeanFactory-结束" class="headerlink" title="到此为止，ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();结束"></a>到此为止，ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();结束</h4><hr>
<h3 id="下面我们来看finishBeanFactoryInitialization-beanFactory"><a href="#下面我们来看finishBeanFactoryInitialization-beanFactory" class="headerlink" title="下面我们来看finishBeanFactoryInitialization(beanFactory)"></a>下面我们来看finishBeanFactoryInitialization(beanFactory)</h3><p>到这一步为止BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些<strong>特殊的 Bean，如 ‘environment’、‘systemProperties’ 等</strong>。剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。点进去看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">	<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">  <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">  <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>在这段代码中：首先初始化名字为 “conversionService” 的 Bean，为什么是conversionService 呢？原因是注册这个bean之后，类似于前端传给后端的非基础类型和基础类型的包装类之外，其他的就可以考虑采用ConversionService来进行类型等的转换，初始化这个 “conversionService” 实在上面源码中的beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));进行的。然后直接跳过来到beanFactory.preInstantiateSingletons();这个方法，这里开始初始化。点进去：<br>DefaultListableBeanFactory这个类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">  <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="type">boolean</span> isEagerInit;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<ol>
<li><p>迭代所有的BeanDefinitionNames集合，挨个初始化所有非懒加载的单例类。</p>
</li>
<li><p>BeanDefinitionNames是在注册BeanDefinitionMap时同时注册的集合。该集合，主要用在<strong>这里</strong>进行迭代初始化Spring Bean，并且也方便一些类似获取BeanDefinitionName的方法使用。</p>
</li>
<li><p>初始化的时候还对FactoryBean进行判断，因为默认FactoryBean默认是惰性初始化，如果实现SmartFactoryBean设置isEagerInit为true，则代表该类需要急切的进行初始化，会即刻开始初始化FactoryBean里getObject返回的类。</p>
</li>
<li><p>关于getMergedLocalBeanDefinition和getBean：Spring通过getBean来完成类的初始化并添加到Spring容器内（即Spring的一级缓存：单例池里面），而在初始化时需要当前类的相关信息：即BeanDefinition，而BeanDefinition是可以存在父子关系（并非真的继承，而是BeanDefinition可以设置父BeanDefinition），所以Spring通过getMergedLocalBeanDefinition来获取当前类的完整信息。</p>
</li>
</ol>
<p>getBean-》doGetBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="comment">// 1.转换beanName，主要处理别名、以&amp;开头的name</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.尝试从单例缓存中获取bean实例</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">	<span class="comment">// 3. 获取bean实例</span></span><br><span class="line">	<span class="comment">// 3.1 缓存中已存在bean实例</span></span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 省略日志输出代码...</span></span><br><span class="line">		<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 省略父工厂处理相关代码...</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 省略dependsOn相关代码...</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3.2 创建单例bean</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3.3 创建原型bean实例</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">				<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3.4 根据scope创建bean实例</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">				<span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">				<span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="comment">// 省略异常处理代码...</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略其他代码.</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>}</p>
<p><strong>在可以看到上面有四种情况：缓存中存在bean实例、创建单例bean、创建原型bean、根据scope创建bean，都调用了getObjectForBeanInstance()方法，接下来我们就点进去看看。</strong></p>
<p><em><strong>getObjectForBeanInstance是从bean实例中获取对象（本章重点，获取实例中的对象）</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">		Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 如果是工厂引用(即name以&amp;开头)，但该实例又不是FactoryBean类型，则抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 如果该实例不是FactoryBean类型，或者是工厂引用都直接返回该实例</span></span><br><span class="line">	<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 尝试从缓存中加载bean</span></span><br><span class="line">		object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 把初始bean实例强转为FactoryBean</span></span><br><span class="line">		FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">		<span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 是否是用户自定义的beanDefinition(默认是false)</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">		<span class="comment">// 重点方法，跟进去</span></span><br><span class="line">		object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>从FactoryBean中获取对象：getObjectFromFactoryBean()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 单例模式</span></span><br><span class="line">	<span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 真正获取对象的方法(重点方法)</span></span><br><span class="line">				object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">				<span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">				<span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;</span><br><span class="line">					object = alreadyThere;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">						<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">							<span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">							<span class="keyword">return</span> object;</span><br><span class="line">						&#125;</span><br><span class="line">						beforeSingletonCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="comment">// 调用bean的后置处理器(有兴趣的可以点进去看下，后面的章节会单独讲述)</span></span><br><span class="line">							object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">									<span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterSingletonCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">						<span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> object;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 2. 原型模式</span></span><br><span class="line">		<span class="comment">// 真正获取对象的方法(重点方法)</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">		<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>真正从FactoryBean中获取对象的逻辑：doGetObjectFromFactoryBean()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">	Object object;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 权限验证</span></span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> getAccessControlContext();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">				<span class="keyword">throw</span> pae.getException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 终于看到你了！</span></span><br><span class="line">			object = factory.getObject();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName, ex.toString());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do not accept a null value for a FactoryBean that&#x27;s not fully</span></span><br><span class="line">	<span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line">	<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(</span><br><span class="line">					beanName, <span class="string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		object = <span class="keyword">new</span> <span class="title class_">NullBean</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终发现其实获取对象的方法，就是一行调用FactoryBean的getObject()方法。</p>
<h4 id="在上面的方法中有个bean的实例化过程我们必须知道"><a href="#在上面的方法中有个bean的实例化过程我们必须知道" class="headerlink" title="在上面的方法中有个bean的实例化过程我们必须知道"></a>在上面的方法中有个bean的实例化过程我们必须知道</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//推断当前Beandefinition的beanClass</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 准备方法重写 包括lookup-method和replaced-method的处理，本文暂不展开</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 第一次调用后置处理器：初始化Bean之前，InstantiationAwareBeanPostProcessor,</span></span><br><span class="line">      <span class="comment">// 根据BeanDefinition获取到了对应的class类</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//创建Bean</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">      <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">      <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>}</p>
<p>docreatebean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">//从未完成的 FactoryBean 实例中移除</span></span><br><span class="line">			instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">//实例化对象(仅仅是生成对象，并非添加到spring单例池中，即目前并没有成为Spring Bean)，</span></span><br><span class="line">			<span class="comment">//并且第二次调用 后置处理器 determineConstructorsFromBeanPostProcessors</span></span><br><span class="line"> 			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">		<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">			mbd.resolvedTargetType = beanType;</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line"> 		... </span><br><span class="line">     	...  </span><br><span class="line">     	...   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先通过createBeanInstance方法调用后置处理器推断其构造函数，并反射创建BeanDefinition对应的实例。<strong>实例化 Bean</strong></p>
<p><strong>注意此时只是创建了类对象，但还没有添加到Spring的单例池中，即还没有加入到Spring容器内部。</strong><br><strong>可以理解为此时只是完成了类对象的声明：即类似于A a&#x3D;null</strong></p>
<p>添加到Spring的单例池是在getSingleton（）的addSingleton中。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38289451/article/details/121965628">https://blog.csdn.net/qq_38289451/article/details/121965628</a></p>
<p>createBeanInstance() 方法是 spring 实例化 bean 的核心代码，它根据不同的情况会调用四种实例化方法</p>
<ul>
<li>obtainFromSupplier() ：通过 Supplier 实例化</li>
<li>instantiateUsingFactoryMethod()：通过工厂方法实例化</li>
<li>autowireConstructor()：用合适的构造函数实例化</li>
<li>instantiateBean()：用无参构造函数实例化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;</span><br><span class="line">    </span><br><span class="line">	// 确认需要创建的bean实例的类可以实例化</span><br><span class="line">	Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">	// 确保class不为空，并且访问权限是public</span><br><span class="line">	if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">		throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">				&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot; + beanClass.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * ----------1，通过Supplier实例化------------</span><br><span class="line">	 */</span><br><span class="line">	Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">	if (instanceSupplier != null) &#123;</span><br><span class="line">		return obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	/**</span><br><span class="line">	 * ----------2，通过工厂方法实例化------------</span><br><span class="line">	 */</span><br><span class="line">	if (mbd.getFactoryMethodName() != null) &#123;</span><br><span class="line">		return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">	 * ----------3，用合适的构造函数实例化------------</span><br><span class="line">	 *</span><br><span class="line">	 *  一个类可能有多个构造器，所以Spring得根据参数个数、类型确定需要调用的构造器。</span><br><span class="line">	 *  在使用构造器创建实例后，Spring会将解析过后确定下来的构造器或工厂方法保存在缓存中，</span><br><span class="line">	 *  避免再次创建相同bean时再次解析</span><br><span class="line">	 */</span><br><span class="line">	// 标记下，防止重复创建同一个bean</span><br><span class="line">	boolean resolved = false;</span><br><span class="line">	// 是否需要自动装配，构造有参数的需要</span><br><span class="line">	boolean autowireNecessary = false;</span><br><span class="line">	// 如果没有参数</span><br><span class="line">	if (args == null) &#123;</span><br><span class="line">		synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">			// 一个类中有多个构造函数，每个构造函数都有不同的参数，所以调用前需要先根据参数锁定构造函数或对应的工厂方法</span><br><span class="line">			if (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class="line">				resolved = true;</span><br><span class="line">				autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 有构造参数的或者工厂方法</span><br><span class="line">	if (resolved) &#123;</span><br><span class="line">		// 构造器有参数</span><br><span class="line">		if (autowireNecessary) &#123;</span><br><span class="line">			// 构造函数自动注入</span><br><span class="line">			return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// 使用默认构造函数构造</span><br><span class="line">			return instantiateBean(beanName, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 从bean后置处理器中为自动装配寻找构造方法</span><br><span class="line">	Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">	if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">			mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">		return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 找出最合适的默认构造方法</span><br><span class="line">	ctors = mbd.getPreferredConstructors();</span><br><span class="line">	if (ctors != null) &#123;</span><br><span class="line">		// 构造函数自动注入</span><br><span class="line">		return autowireConstructor(beanName, mbd, ctors, null);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">	 * ----------4，使用默认构造函数构造------------</span><br><span class="line">	 */</span><br><span class="line">	return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="新增ObjectFactory到第三级缓存"><a href="#新增ObjectFactory到第三级缓存" class="headerlink" title="新增ObjectFactory到第三级缓存"></a>新增ObjectFactory到第三级缓存</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">    	throws BeanCreationException &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        //允许后置处理器重新定义beanDefinition</span><br><span class="line">		synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">			if (!mbd.postProcessed) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					//第三次调用后置处理器 MergedBeanDefinitionPostProcessors</span><br><span class="line">					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				catch (Throwable ex) &#123;</span><br><span class="line">					throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">							&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				mbd.postProcessed = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//判断是否允许循环依赖，默认是允许的，可以通过代码修改的一般只有allowCircularReferences的值</span><br><span class="line">		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">						&quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			// getEarlyBeanReference里面包含了又一次后置处理器的调用，SmartInstantiationAwareBeanPostProcessor </span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="属性填充：populateBean"><a href="#属性填充：populateBean" class="headerlink" title="属性填充：populateBean"></a>属性填充：populateBean</h4><p>然后做一些处理比如循环依赖等，直到看到populateBean(beanName, mbd, instanceWrapper);这个代码，这一步负责属性装配，很重要，因为前面的实例只是实例化了，并没有设值，这里就是设值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//填充属性（即自动注入） 完成第五次和第六次后置处理器的调用</span></span><br><span class="line">        <span class="comment">// InstantiationAwareBeanPostProcessor.after</span></span><br><span class="line">        <span class="comment">// hasInstantiationAwareBeanPostProcessors</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">//完成第七次和第八次后置处理器的调用，</span></span><br><span class="line">        <span class="comment">//判断当前Bean，是否是BeanNameAware、BeanClassLoaderAware、BeanFactoryAware并分别设置相关内容</span></span><br><span class="line">        <span class="comment">//applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line">        <span class="comment">//applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">populateBean方法完成属性填充，跟进</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在设置属性之前，让任何 InstantiationAwareBeanPostProcessors 有机会修改 bean 的状态。例如，这可用于支持字段注入样式。</span></span><br><span class="line">  <span class="comment">//扩展点，又一次调用后置处理器，</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果后置处理器修改了Beandefinition，则判断是否已经修改过了属性值的相关配置</span></span><br><span class="line">   <span class="comment">//如果修改了，则按照器byName或byType的方式直接完成装载</span></span><br><span class="line">   <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">      <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   [] filteredPds = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">         pvs = mbd.getPropertyValues();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">//利用后置处理器，处理属性的获取</span></span><br><span class="line">            <span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">                  filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">               &#125;</span><br><span class="line">               pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">      <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">         filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      &#125;</span><br><span class="line">      checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//根据PropertyValues完成属性填充</span></span><br><span class="line">      applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>populateBean里面再次调用后置处理器，spring在这里提供了一个扩展点，允许开发者在属性填充这个阶段修改Bean的状态（使用后置处理器的方式）。并且可能直接依据byName和byType装载属性值。</p>
<p>我们知道，使用自动装载这一功能时，我们可以使用@Autowired和@Resource。这两个注解的功能也不一样。那么解析的方式也应当不一样。</p>
<h3 id="factorybean和beanfactory"><a href="#factorybean和beanfactory" class="headerlink" title="factorybean和beanfactory"></a>factorybean和beanfactory</h3><p>在我们的开发工作中应该都见过或使用过FactoryBean这个类，也许你会看成了BeanFactory这个类。FactoryBean和BeanFactory虽然长的很像，但是他们的作用确实完全不像。这里你可以想象一下，你会在什么样的场景下使用FactoryBean这个接口？FactoryBean是一个工厂Bean，可以生成某一个类型Bean实例，它最大的一个作用是：可以让我们自定义Bean的创建过程。BeanFactory是Spring容器中的一个基本类也是很重要的一个类，在BeanFactory中可以创建和管理Spring容器中的Bean，它对于Bean的创建有一个统一的流程。下面我们先看一下FactoryBean中有什么东西：</p>
<p>背景<br>假设我们有这种需求，像Mybaits需要将这些接口注入到Spring容器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface OneTestDao &#123;</span><br><span class="line">    @Select(&quot;SELECT name FROM user WHERE id = 1&quot;)</span><br><span class="line">    String query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface TwoTestDao &#123;</span><br><span class="line">    @Select(&quot;SELECT name FROM user WHERE id = 2&quot;)</span><br><span class="line">    String query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先我们想将我们的自己的Bean(比如代理对象)注入到Spring容器中，有什么方式呢？</p>
<p>一般都是通过Spring扫描Resouce资源然后解析为BeanDefinition，才能从getBean时解析BeanDefinition实例化对象放入此单例缓存中.但是我们这里的是接口，没法直接注入到Spring容器中。</p>
<p>不过Spring提供了一些扩展接口来供我们在Bean加载、初始化、加载完提供了一些接口，供我们扩展。<br>比如BeanFactoryPostProcessor</p>
<p>从测试结果中得知，我们虽然配置的是<code>MapperFactoryBean</code>的实列，但是根据id拿到的是<code>getObject</code>方法创建的对象。其实在容器中创建的对象仍然是<code>MapperFactoryBean</code>的实列，只是在获取的时候会判断这个结果对象是不是派生于<code>FactoryBean</code>，如果是的话则返回<code>getObject</code>方法创建的对象，并且这个对象并不是容器初始化时创建的，而是使用<code>context.getBean()</code>方法时才创建。当然了，如果你确实想要获取<code>FactoryBean</code>实例，你需要这样写: <em><code>MapperFactoryBean mapper = context.getBean(&quot;&amp;mapper&quot;, MapperFactoryBean.class);</code></em> 只需要在bean的名字ID前加上&amp;符号。</p>
<p>非常重要：想知道factory流程，请结合</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30881367/article/details/98567729?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mapperfactorybean%E7%9A%84%E4%BD%9C%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-98567729.nonecase&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_30881367/article/details/98567729?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mapperfactorybean%E7%9A%84%E4%BD%9C%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-98567729.nonecase&amp;spm=1018.2226.3001.4187</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Roger_CX/article/details/120739214?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168111515116800192294702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168111515116800192294702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-120739214-null-null.142%5Ev82%5Ekoosearch_v1,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=FactoryBean%E4%BD%9C%E7%94%A8&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/Roger_CX/article/details/120739214?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168111515116800192294702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168111515116800192294702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-120739214-null-null.142^v82^koosearch_v1,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=FactoryBean%E4%BD%9C%E7%94%A8&amp;spm=1018.2226.3001.4187</a></p>
<p><strong>FactoryBean是一个能生产或修饰对象生成的工厂Bean</strong>。一个Bean如果实现了FactoryBean接口，那么<strong>根据该Bean的名称获取到的实际上是getObject返回的对象</strong>，而不是这个Bean自身实例，如果<strong>要获取这个Bean自身实例，那么需要在名称前面加上’&amp;’符号</strong>。</p>
<p>创建bean的两种方式：</p>
<p>第一种，单例在Spring容器初始化之前， 就已经创建了bean，且整个应用只有一个。</p>
<p>第二种，多例在用到对象的时候，才创建对象，当我们在A类中需要用到B类时，通过@Autowired注解注入用到时。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/11/spring%20ioc%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/04/new%20page/"
                            aria-label=": 待定"
                        >
                            待定
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-04T00:00:00+08:00">
	
		    04 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/new/">new</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/04/new%20page/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A10/"
                            aria-label=": 章节：10"
                        >
                            章节：10
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-04T00:00:00+08:00">
	
		    04 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>第十节我们可以从注解出发看项目。<br>DBRouter注解写好后，肯定要配备切面类DBRouterJoinPoint（这里面包括了路由策略和路由配置几库几表），里面有一个@Around注解，表示包围一个函数，也就是可以在函数执行前做一些事情，也可以在函数执行后做一些事情。</p>
<p>项目中是先拿到Key字段（uId），判断是不是空，是的话Runtime异常，不是的话就去拿uId这个字段对应的值，按照例子就是Uhdgkw766120d。</p>
<p>拿到值之后，那么下面就是拿着这个值去做路由了（该怎么走），这部分内容被写在DBRouterStrategyHashCode的doRouter里面。其实就是hash的扰动函数，通过设定的算法得到去拿个库哪个表，把这两个信息交给DBContextHolder（一个标识类，用来存储当前数据源的key及状态判断），下面就要向数据集里面写东西了，jp.process(),接下去就是mybatis拦截器的任务了。</p>
<p>自定义拦截器需要实现org.apache.ibatis.plugin.Interceptor接口, 并在接口上添加@Intercepts注解。<br>@Intercepts注解是通过一个@Signature注解(拦截点),来指定拦截那个对象里面的某个方法。<br>@Signature注解需要定义三个东西：</p>
<p>定义拦截的类 Executor、ParameterHandler、StatementHandler、ResultSetHandler当中的一个<br>Class&lt;?&gt; type();</p>
<p>在定义拦截类的基础之上，在定义拦截的方法<br>String method();</p>
<p>在定义拦截方法的基础之上在定义拦截的方法对应的参数，<br>因方法里面可能重载，不指定参数列表，不能确定是对应拦截的方法<br>Class&lt;?&gt;[] args();</p>
<p>我们查看代码，发现拦截的类选择的是StatementHandler，目前不太了解mybatis的源码，但是查询资料之后发现毫无疑问是四大对象最重要的一个，它的任务就是和数据库对话。在它这里会使用parameterHandler和ResultSetHandler对象为我们绑定SQL参数和组装最后的结果返回。</p>
<p>拦截的方法是prepare，预编译阶段</p>
<p>参数是{Connection.class, Integer.class}</p>
<p>回到那个自定义拦截器类 继承了Interceptor。intercept里面就放着怎么把sql变成我们想要的那种动态分库分表的逻辑。<br>首先几行代码拿到dbRouterStrategy注解，看他是不是true<br>如果是，我们去拿sql语句，如下所示：</p>
<p>INSERT INTO user_strategy_export<br>        (u_id, activity_id, order_id, strategy_id, strategy_mode,<br>         grant_type, grant_date, grant_state, award_id, award_type,<br>         award_name, award_content, uuid, create_time, update_time)<br>        VALUES<br>        (?,?,?,?,?,<br>         ?,?,?,?,?,<br>         ?,?,?,now(),now())</p>
<p>他利用一个matcher找到 INTO user_strategy_export这段语句。为什么？因为INTO后面跟着的就是表，至于是哪个表，在上面已经提到了，就是DBContextHolder。这里就实现了分表。</p>
<p>至于分库，我们重写了determineCurrentLookupKey方法，这个方法被determineTargetDataSource调用，determineTargetDataSource被getConnection调用，getConection可以追溯到DataSource接口的getConnection抽象方法。但是我还不知道determineCurrentLookupKey什么时候被调用？？</p>
<p>所以就去查了查多数据源的处理机制的一些文章，发现和自己想的有区别，我一直以为调用DAO层的方法，应该先切面再切换数据源最后才是DAO的逻辑（毕竟我看不到什么时候切换数据源，但是DBRouter注解就是直勾勾的放在DAO方法上面的），结果文章中提到其实是先切换数据源，然后切面方法，最后DAO逻辑。文章给出的原因是事务中不支持数据源切换。<br>但是我打断点还是没找到调用determineCurrentLookupKey的那段代码，可惜。</p>
<p>最后就是把这些配置到DataSourceAutoConfig，打包给我们的项目。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A10/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/"
                aria-label="NEUERE BEITRÄGE"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEUERE BEITRÄGE</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/page/3/"
                aria-label="ÄLTERE BEITRÄGE"
            >
              <span>ÄLTERE BEITRÄGE</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">Seite 2 von 4</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 CSEN. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
            <h4 id="about-card-name">CSEN</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                浙江温州
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-39paoi2hupf5wmw7ojejrxpco6edftjriz5ezbtp4grymrdceksftgan2adp.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
