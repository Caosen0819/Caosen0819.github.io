
<!DOCTYPE html>
<html lang="zh-CH">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="森">
    <title>森</title>
    <meta name="author" content="CSEN">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"http://example.com","author":{"@type":"Person","name":"CSEN","sameAs":["https://github.com/"],"image":"head.jpg"},"name":"森","description":"潮起潮落，云卷云舒","url":"http://example.com"}</script>
    <meta name="description" content="潮起潮落，云卷云舒">
<meta property="og:type" content="blog">
<meta property="og:title" content="森">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="森">
<meta property="og:description" content="潮起潮落，云卷云舒">
<meta property="og:locale" content="zh_CH">
<meta property="article:author" content="CSEN">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="http://example.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-w816scvuzwavitjylabixcb3ofuoklqul47j3rgwu1r0mxrxvbdehvp2jk5s.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            森
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Lesen Sie mehr über den Autor"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
                </a>
                <h4 class="sidebar-profile-name">CSEN</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archiv"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archiv</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Suche"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Suche</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="Über"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Über</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A7-10%EF%BC%8C%E5%90%8C%E6%97%B6%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8B4-6%E7%9A%84%E5%86%85%E5%AE%B9/"
                            aria-label=": 章节：7-10，同时回顾一下4-6的内容"
                        >
                            章节：7-10，同时回顾一下4-6的内容
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-04T00:00:00+08:00">
	
		    04 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>7-10，同时回顾一下4-6的内容</p>
<p>第六节的重点是模版模式。</p>
<p>模版模式是定义一个算法的骨架，并允许子类为一个或多个步骤提供实现。在第六节中这个算法骨架（抽象模版类）是AbstractDrawBase，这个类中有通用的比如对于抽奖结果的包装，也有抽象方法比如执行抽奖算法（这个在子类中实现）。小傅哥在这个基础上又把一些一些通用的数据服务抽象出新的一层DrawStrategySupport，这个算是一种优化，但是他本质也属于抽象模版类的一部分。</p>
<p>而我们抽奖则需要抽奖策略（怎么个抽法），这就是第五节的东西—策略模式：</p>
<p>对象的某个行为，在不同场景中有不同的实现方式，这样就可以将这些实现方式定义成一组策略，每个实现类对应一个策略，在不同的场景就使用不同的实现类，并且可以自由切换策略。</p>
<p>其实看完第六节会发现第五节和第六节很像，也是抽象出了一个接口和一个抽象模版类，其他的子类继承抽象模版类实现randomDraw（）方法，不同的实现对应不同的算法，具体算法我们自己可以修改逻辑、补充内容等操作。</p>
<p>在这时候我们发现策略模式和模版模式很像，但是是有一些区别的：</p>
<p>模板模式：问题处理的流程已经被定义好，父类实现通用的逻辑（当然你也可以再抽象出一层），子类实现个性化逻辑。</p>
<p>策略模式：父类定义一组抽象算法，子类自己实现自己的。每个策略完成的功能是重复的，同一时间，只能选择其中的一种，即互斥的</p>
<p>策略模式核心在使用者的策略，按照自己的策略去替换。模板方法模式核心在子类的怎么实现。</p>
<p>举个例子：</p>
<p>模版模式： 父类：早上6点吃饭，晚上6点吃面。子类1：早上6点吃稀饭，晚上6点吃泡面。子类2：早上6点吃干饭，晚上6点吃挂面。</p>
<p>策略模式：父类：早晚进食。子类1:早上5点吃面，晚上5点吃面。子类2:早上7点吃饭，晚上7点吃饭。子类3:早上不吃，晚上不吃…</p>
<p>第八节：状态模式</p>
<p>当一个对象的内在状态改变时，允许改变其行为，把不同状态当做一个类，解决对象在多种状态转换时，需要对外输出不同的行为的问题。</p>
<p>同样的有抽象模版类（AbstractState，当然你要自己提炼一个接口大概也没什么问题），多个具体实现的子类。要有一个Context类，这个类持有State，负责保持并切换当前的状态，当状态变化时，修改这个State。在项目中应该是活动创建的时候初始化状态，后续收到一些通知（比如：快递公司揽件，发送目的地，菜鸟驿站收到快递）修改活动中的状态变量就可以，非常方面。</p>
<p>第九节：ID生成策略</p>
<p>也是策略模型，因为目前就一个id生成的要求，也无需什么流程啊，也不涉及什么状态改变，不同情境下使用不同类型的id，所以策略模式最佳。</p>
<p>第十节：分库分表</p>
<p>内容多，也是这几天最花时间的，bug奇多，自己不小心把application.yml文件里面的配置写错了，然后报空指针，找不到bean，我还以为自己打包有问题呢；因为自己的版本和傅哥的不太一样，总报一些依赖错误，还有什么commons-lang、commons-beanutils依赖缺失。自己的的项目工程包名是自定义的，和傅哥的cn.itedus.lottery和那个cn.bugstack不一样，中途修改的时候感觉对理解还是有益处的。</p>
<p>之后再对第十节做一次总结，加深感悟。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A7-10%EF%BC%8C%E5%90%8C%E6%97%B6%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8B4-6%E7%9A%84%E5%86%85%E5%AE%B9/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/03/%E7%AB%A0%E8%8A%82%EF%BC%9A11-13/"
                            aria-label=": 章节：11-13"
                        >
                            章节：11-13
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-03T00:00:00+08:00">
	
		    03 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="11"><a href="#11" class="headerlink" title="11"></a>11</h1><p>如果一个请求，需要对多个表进行修改，那么大概率需要事务，因为也许第一个对表的操作成功了，但是第二个对表的操作失败，那就出问题了。</p>
<p>Spring支持两种事务管理方式：编程式事务管理以及声明式事务管理。</p>
<p>编程式事务方式需要是开发者在代码中手动的管理事务的开启、提交、回滚等操作<br>声明式事务管理方法允许开发者配置的帮助下来管理事务，而不需要依赖底层API进行硬编码。声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚</p>
<p>声明式事务的优点：对代码没有侵入性，方法内只需要写业务逻辑就可以了。<br>声明式事务的缺点：<br>如果在一个事务下，连续操作不同的DAO操作，那么就会涉及到在 DAO 上使用注解 @DBRouter(key &#x3D; “uId”) 反复切换路由的操作。比如你第一个DAO对某个库表操作，第二个DAO对另一个库表操作，这就不行，原因是网上查的不知道对不对：<br>1、Spring@Transactional不支持跨数据源事物，Spring 事务控制是基于数据库链接进行的，当数据源切换后，数据库链接切换，事物回滚只能回退，当前持有的链接<br>2、Spring开启事物后，会将当前数据库及数据库链接资源进行线程绑定，导致数据源切换失效（数据源切换执行后，并未获取到新的数据库链接）</p>
<p>我们把领取活动提炼成一个模版，这个模版里的流程是有的操作需要同时处理多个数据源加上我们还是分库分表，所以不适用声明式，应该用编程式。<br>spring事务配置总是由DataSource、TransactionManager和代理机制这三部分，new一个TransactionManager然后放入我们自己的DataSource。然后在transactionTemplate里放入新的TransactionManager。到这里基本就配置好了，至于什么路由策略啊这些其实和第十章的没什么区别。</p>
<p>回顾一下第十章，我们是在DAO上加上注解，配合路由组件中的一系列（数据路由切面），拦截被切面的方法。<br>但是在第十一章中，通用模版类中第四步我们使用了编程式事务，他需要同时对多个表进行操作。但是第一步第二步这种查询工作、校验工作这种对数据库没有修改的操作，小傅哥要么DBRouter要么直接就没加（分库分表）。所以声明式和编程式配合使用也许会更好。</p>
<h1 id="12"><a href="#12" class="headerlink" title="12"></a>12</h1><p>这章有一个问题就是，傅哥给的sql语句是2021年的，然后你执行test方法会报错，因为里面有一个活动信息校验处理模块，他会去判断你当前的时间是不是在活动期限里面，要么你直接把时间写死在2021年，要么你对数据库里面的数据进行一定修改，要么直接就把校验模块注释。</p>
<h1 id="13"><a href="#13" class="headerlink" title="13"></a>13</h1><p>运用组合模式搭建规则引擎领域服务，包括：logic 逻辑过滤器、engine 引擎执行器。<br>其实我们现在脑海中想到一棵规则树，那么这个数有根节点，子节点，连线，我们把这三部分分别弄成三张表放到数据库中，也就是数据库中的三张表就代表着我们的规则树。<br>理论知识有了那么接下来就是实践了——引擎执行。<br>我们参考ruleTest测试方法，他是直接给出请求，这个请求包括了规则树id，但是之后项目复杂之后，关于这个规则数id的选取可能也要做些文章，现在我们假设就是这个规则树id。<br>从请求req到获取活动id，分成三步。<br>1、从id到数据库里取到规则树详细的信息<br>2、根据这颗规则树拿到果实节点<br>3、提炼果实节点的信息，包装成结果返回，这个结果里面就包括了活动id<br>第一步无需事务，直接查询，返回结果，这个看似没什么好讲的，其实非常重要，我们要查果实节点，那就需要完整的树，刚才我们提到了，树被分成了三个表，那这一步中就对这三张表分别进行了一次查询，将结果聚合成我们的聚合对象。第二步就是在第一步的基础上拿出东西做循环。第三步就是包装一下。因为第一步三个表也没做分库分表，所以也用不上DBRouter，也不是特别适合用编程式路由，就是对特定表的简单查询。但是问题在于是否要给这三个表的查询加上事务呢？<br>感觉加上是不是更好呢？</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/03/%E7%AB%A0%E8%8A%82%EF%BC%9A11-13/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/03/%E7%AB%A0%E8%8A%82%EF%BC%9A%E5%B0%8F%E7%9F%A5%E8%AF%86/"
                            aria-label=": 章节：小知识"
                        >
                            章节：小知识
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-03T00:00:00+08:00">
	
		    03 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="Maven的三种packaging方式-pom、jar、war"><a href="#Maven的三种packaging方式-pom、jar、war" class="headerlink" title="Maven的三种packaging方式(pom、jar、war)"></a>Maven的三种packaging方式(pom、jar、war)</h1><p>pom是maven依赖文件<br>jar是java普通项目打包<br>war是java web项目打包 </p>
<p>pom：打出来可以作为其他项目的maven依赖，在工程A中添加工程B的pom，A就可以使用B中的类。用在父级工程或聚合工程中。用来做jar包的版本控制。</p>
<p>jar包：通常是开发时要引用通用类，打成jar包便于存放管理。当你使用某些功能时就需要这些jar包的支持，需要导入jar包。</p>
<p>war包：是做好一个web网站后，打成war包部署到服务器。目的是节省资源，提供效率</p>
<h1 id="relativePath"><a href="#relativePath" class="headerlink" title="relativePath"></a>relativePath</h1><p>搭建<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=maven&spm=1001.2101.3001.7020">maven</a>项目，子模块指定父模块试，经常会在parent下面出现relativePath类似下面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">	&lt;groupId&gt;net.itxw&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;test&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">	&lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>

<p>这个<parent>下面的<relativePath>属性是什么意思？</p>
<p>其实很明显，就是parent的路径，具体来说就是你引用这个parent项目，那parent项目的pom在哪里</p>
<h1 id="dependencyManagement"><a href="#dependencyManagement" class="headerlink" title="dependencyManagement"></a>dependencyManagement</h1><p>如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号。当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要逐个修改子项目；另外如果某个子项目需要另外的一个版本，只需要声明version即可。</p>
<p>dependencyManagement中定义的只是依赖的声明，并不实现引入，因此子项目需要显式的声明需要用的依赖。</p>
<p>在父项目的POM.xml中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.2.3.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>在子项目中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="build"><a href="#build" class="headerlink" title="build"></a>build</h1><h3 id="1-约定的目录结构"><a href="#1-约定的目录结构" class="headerlink" title="1 约定的目录结构"></a>1 约定的目录结构</h3><p><code>build </code>标签的子标签大致包含三个主体部分：</p>
<p>2.2.1 约定的目录结构<br>参考附录中的如下部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;sourceDirectory&gt;D:\idea\maven-test\src\main\java&lt;/sourceDirectory&gt;</span><br><span class="line">&lt;scriptSourceDirectory&gt;D:\idea\maven-test\src\main\scripts&lt;/scriptSourceDirectory&gt;</span><br><span class="line">&lt;testSourceDirectory&gt;D:\idea\maven-test\src\test\java&lt;/testSourceDirectory&gt;</span><br><span class="line">&lt;outputDirectory&gt;D:\idea\maven-test\target\classes&lt;/outputDirectory&gt;</span><br><span class="line">&lt;testOutputDirectory&gt;D:\idea\maven-test\target\test-classes&lt;/testOutputDirectory&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;D:\idea\maven-test\src\main\resources&lt;/directory&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;testResources&gt;</span><br><span class="line">    &lt;testResource&gt;</span><br><span class="line">        &lt;directory&gt;D:\idea\maven-test\src\test\resources&lt;/directory&gt;</span><br><span class="line">    &lt;/testResource&gt;</span><br><span class="line">&lt;/testResources&gt;</span><br><span class="line">&lt;directory&gt;D:\idea\maven-test\target&lt;/directory&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>能看到各个目录的作用如下：</p>
<p>目录名	作用<br>sourceDirectory	主体源程序存放目录<br>scriptSourceDirectory	脚本源程序存放目录<br>testSourceDirectory	测试源程序存放目录<br>outputDirectory	主体源程序编译结果输出目录<br>testOutputDirectory	测试源程序编译结果输出目录<br>resources	主体资源文件存放目录<br>testResources	测试资源文件存放目录<br>directory	构建结果输出目录</p>
<h3 id="2备用插件管理"><a href="#2备用插件管理" class="headerlink" title="2备用插件管理"></a>2备用插件管理</h3><p>pluginManagement 标签存放着几个极少用到的插件：</p>
<p>maven-antrun-plugin<br>maven-assembly-plugin<br>maven-dependency-plugin<br>maven-release-plugin<br>通过 pluginManagement 标签管理起来的插件就像 dependencyManagement 一样，子工程使用时可以省略版本号，起到在父工程中统一管理版本的效果，看下面例子：</p>
<p>被 spring-boot-dependencies 管理的插件信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;pluginManagement&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/pluginManagement&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line">子工程使用的插件信息：</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-生命周期插件"><a href="#3-生命周期插件" class="headerlink" title="3 生命周期插件"></a>3 生命周期插件</h3><h1 id="把cn-XXXX-改成自己的包名，发现也有蛮多地方需要修改，也能加深理解"><a href="#把cn-XXXX-改成自己的包名，发现也有蛮多地方需要修改，也能加深理解" class="headerlink" title="把cn.XXXX 改成自己的包名，发现也有蛮多地方需要修改，也能加深理解"></a>把cn.XXXX 改成自己的包名，发现也有蛮多地方需要修改，也能加深理解</h1><p> 比如application.xml，mybatis全局配置xml里的typeAliases，不过这个文件在第三章还没用到，configuration里面的注释里也能正常跑。</p>
<h1 id="第4节-策略"><a href="#第4节-策略" class="headerlink" title="第4节 策略"></a>第4节 策略</h1><p> 通常分库分表的几个常见方面；</p>
<ol>
<li>访问频率：对于高频访问的数据，可以将其存储在单独的数据库或表中，以提高读写性能。</li>
<li>数据大小：对于大量的数据，可以将其拆分到多个表中，以减少单表的数据量，降低存储开销。</li>
<li>数据类型：对于不同类型的数据，可以将其拆分到不同的数据库或表中，便于管理和查询。</li>
<li>数据范围：对于不同范围的数据，可以将其拆分到不同的数据库或表中，便于数据的管理和查询。</li>
</ol>
<p>分库分表的主要目的在于；数据分摊、提高QPS&#x2F;TPS、分摊压力、提高可扩展性。比如；比如数据库的读写性能下降，或者单表数据量过大，这时候您就需要考虑进行分库分表操作了。通过拆分数据库，可以将单个数据库的压力分摊到多个数据库上，从而避免单个数据库的性能瓶颈，提高系统的性能和可扩展性。此外，分库分表还可以解决数据库存储容量的限制，提高数据库的存储能力。</p>
<p>另外在分库分表之后，数据的一致性会受到影响，数据库的管理和维护成本也会增加。因此，在考虑分库分表时，需要仔细权衡利弊，确定是否真的需要进行分库分表操作。也就是你的开发成本问题。因为有分库分表就会相应的引入 canal binlog同步、es、mq、xxl-job等分布式技术栈。</p>
<h2 id="库表梳理"><a href="#库表梳理" class="headerlink" title="库表梳理"></a>库表梳理</h2><p>1、感觉从抽奖流程出发比较好理解，用户-&gt;抽奖-&gt;有无得奖-&gt;结果<br>抽奖单独提炼策略表，有无得奖提炼奖品表，策略表和奖品表可以联系成策略明细表（一个策略多个奖品1:n）。抽完后的结果肯定要弄出个结果表，包括奖品发放后续、抽奖明细，但是考虑到用户可以多抽几次，全放一张表肯定不行，那一个用户三个记录肯定不行，所以可以单独分出一个纯粹的参与活动记录表和用户活动抽奖次数表，至于发放奖品后续就可以一个用户一条记录，做成用户抽奖结果表，这样理解可以吗？<br>2、从什么角度出发对需求进行初步的库表梳理比较好的，就像傅哥说的怎么打好地基。</p>
<h1 id="第5节"><a href="#第5节" class="headerlink" title="第5节"></a>第5节</h1><p>原始mvc架构的一个服务可能对应多个实体类，多个服务可能对应一个实体类，那后面修改一个服务的时候可能造成牵一发而动全身的结果。<br>ddd架构中model（聚合对象）里的对象类只服务于这个领域的repository（数据仓储） service（领域服务），从包的结构区分问题。dao则是仓储的具体实现，repository是接口。</p>
<p>自增id</p>
<p>疑惑：不是说model放聚合对象吗，为什么award strategy这些在基础设施层呢，不是应该在strategy领域里面吗？<br>draw req res 这代表什么意思呢</p>
<p>思考：default抽奖算法，能不能直接在single每次抽奖完的基础上加一个判断，如果有一个奖品抽完了，那就重新更新rateTuple，这样是不是也可以呢，反正原本的default抽奖算法每次抽奖也是要循环奖品？</p>
<p>service层结构很清晰,DrawExecImpl为什么不自己申明一个变量作为抽奖类型，初始化的时候给他赋值。这样就不用每次抽奖都去数据库请求了。还是说为了防止抽奖方式的改变而这么做呢？</p>
<h1 id="第06节"><a href="#第06节" class="headerlink" title="第06节"></a>第06节</h1>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/03/%E7%AB%A0%E8%8A%82%EF%BC%9A%E5%B0%8F%E7%9F%A5%E8%AF%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/30/%E5%AF%BC%E5%90%91%E6%BB%A4%E6%B3%A2/"
                            aria-label=": 导向滤波"
                        >
                            导向滤波
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-30T09:23:00+08:00">
	
		    30 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95/">去雾算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/30/%E5%AF%BC%E5%90%91%E6%BB%A4%E6%B3%A2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/23/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"
                            aria-label=": 暗通道去雾算法总结"
                        >
                            暗通道去雾算法总结
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-23T13:03:43+08:00">
	
		    23 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95/">去雾算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>何凯明的去雾算法重点都是围绕暗通道展开的。</p>
<h2 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h2><p>何凯明发现，凡是无雾的算法都有一个规律，就是每一幅图像的非天空的区域里的每一个像素的rbg三个通道，一定有一个通道是很低的值。这个也很容易理解，比如大红的玫瑰翠绿的草等等。</p>
<h2 id="去雾模型"><a href="#去雾模型" class="headerlink" title="去雾模型"></a>去雾模型</h2><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/QQ20221023-132042@2x.png" alt="df"></p>
<p>i(x) 是现在有的图像，等待去雾，而j(x)是要恢复的无雾图像，A是全球大气光成分，t(x)则是透射率，所以现在有的就是ix，求jx，所以我们还需要去得到tx和A。</p>
<h2 id="暗通道怎么求"><a href="#暗通道怎么求" class="headerlink" title="暗通道怎么求"></a>暗通道怎么求</h2><p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023134357882.png" alt="image-20221023134357882"></p>
<p>其中c表示rgb三通道中的某一通道。上式表示在一幅输入图像中，先取图像中每一个像素的三通道中的灰度值的最小值，得到一幅灰度图像，再在这幅灰度图像中，以每一个像素为中心取一定大小的矩形窗口，取矩形窗口中灰度值最小值代替中心像素灰度值（最小值滤波），从而得到该雾天图像的暗通道图像。</p>
<h2 id="如何去估计全局大气光值A？"><a href="#如何去估计全局大气光值A？" class="headerlink" title="如何去估计全局大气光值A？"></a>如何去估计全局大气光值A？</h2><p>估计全局大气光的方法有很多，有的是直接找全局最亮的点，比如天空这种雾气感最强的。</p>
<p>但是何凯明认为，有可能这样子找的只是白色的物体，而不是雾气最密集的区域。所以何凯明提出一种找大气光的方法：<strong>从观测图像的暗通道</strong>中选取最亮的前 0.1%的点，这些点对应到原图中再去找最亮的点作为 A 的估计。</p>
<h2 id="如何估计t-x"><a href="#如何估计t-x" class="headerlink" title="如何估计t(x)?"></a>如何估计t(x)?</h2><p>其实还是依赖于暗通道，在有雾气的暗通道里面，非天空区域的亮度值主要就是大气光贡献的，场景本身的暗通道的亮度应该趋于0，所以用暗通道估计雾气的传输率。</p>
<p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023135440803.png" alt="image-20221023135440803"></p>
<p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023135544543.png" alt="image-20221023135544543"></p>
<p>但是现实生活中，空气中总是有颗粒，所以看远方的物体还是能感受到雾气，所以保留一部分雾气</p>
<p><img src="/../images/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221023135641640.png" alt="image-20221023135641640"></p>
<h2 id="Soft-Matting"><a href="#Soft-Matting" class="headerlink" title="Soft Matting"></a>Soft Matting</h2><p>利用Soft Matting，优化原有的透射图。</p>
<p>可见<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/pUcuPMaT2bFuT5d0PD4xxQ">走出寂静岭！何恺明经典去雾论文分析</a></p>
<p>参考文献为2006年CVPR《A closed form solution to natural image matting.》后期何恺明在2010年ECCV上《Guided image filtering》提出了导向滤波的方法。</p>
<h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><p>上面我们获得了大气光值以及透射率，那么根据雾天退化模型我们就可以获得去雾后的结果图了。一般来说，去雾后的结果图可能会偏暗，因此可以适当进行一些后处理如采用<strong>自动对比度增强，亮度增强，伽马校正</strong> 等图像处理方法进行处理，以便得效果更佳的无雾图像。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/23/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/20/%E5%AF%B9%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%96%B0%E7%90%86%E8%A7%A3/"
                            aria-label=": 对权限校验和token的新理解"
                        >
                            对权限校验和token的新理解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-20T14:43:00+08:00">
	
		    20 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/java%E5%AD%A6%E4%B9%A0/">java学习</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="对权限校验和token的新理解"><a href="#对权限校验和token的新理解" class="headerlink" title="对权限校验和token的新理解"></a>对权限校验和token的新理解</h1><p>在我们前端页面发出请求的时候，会先发出一个预检请求，看看这个接口是否好用，但不会去检验这个接口是否正确。比如说：发出get请求，对info这个接口进行校验，所以他会先发一个get的预检验去看看你这个接口能不能收到我这个get。如果可以，get请求返回之后会告诉我们前端可以发送，这时候前端发出真正的请求（带着参数的那种）。</p>
<p>下面简单讲一下权限校验的流程，以防止自己忘记和供大家参考（勿喷）。</p>
<p>首先我们前端服务启动之后，假设端口是8090，我们输入账号密码点击登陆，这时候前端服务会<br>将其发送到另一个端口，这里涉及跨域了，一般前端会有个简单的处理，然后后端也会有一个允许跨域什么的配置（有可能是在security里面设置或者是自己configuration一个配置文件）。</p>
<p>假设我们转发到了8201接口，那么请问这个接口是什么服务的接口呢？答案揭晓，一般是网关服务这边借鉴我自己的项目，用的是gateway的。</p>
<p>然而我们知道gateway服务一般会进行拦截访问校验权限这类工作。那么这个gateway服务，对于这种登陆的接口访问，又会做出什么样子的判断呢？其实对于这类我们会把他列入白名单，所以举个login例子，我在8090端口发出&#x2F;admin&#x2F;login命令，然后遇到gateway网关，网关直接放行，那么我们假设admin端口是8080端口，那这时候request是不是通过转发变成了：8080&#x2F;admin&#x2F;login，然后带一些账号密码这类参数什么的。</p>
<p>下面很关键。</p>
<p>一般我们的login命令是不是首先要取得授权啊，你不授权你登陆各寂寞呢。那么这时候就要请出我们的授权服务了，Auth服务。我们可以直接在login的controller里面写调用获取授权的服务。</p>
<p>那用什么授权呢，举个例子token或者是token的变体。下面用spring security oauth2讲一下这个token怎么获取，又怎么调教。</p>
<p>其实大家不用吧授权服务想的很难，无非就是自己写了一些接口，你去调用，然后判断，如果对就通过，如果错误就失败。</p>
<p>那么这边我们举个例子<br>在login函数里面调用这个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CommonResult restResult = authService.getAccessToken(params);</span><br></pre></td></tr></table></figure>
<p>然后authService如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(&quot;auth-server&quot;)</span><br><span class="line">public interface AuthService &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(value = &quot;/oauth/token&quot;)</span><br><span class="line">    CommonResult getAccessToken(@RequestParam Map&lt;String, String&gt; parameters);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候通过注解直接跑掉另一个端口服务了。</p>
<h1 id="Auth服务"><a href="#Auth服务" class="headerlink" title="Auth服务"></a>Auth服务</h1><h2 id="token的生成"><a href="#token的生成" class="headerlink" title="token的生成"></a>token的生成</h2><p>我们需要配置令牌访问的端点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void configure(AuthorizationServerEndpointsConfigurer endpoints)</span><br></pre></td></tr></table></figure>
<p>在这里我们可以自定义授权方式，比如说微信授权、手机号授权等等。当时我们先讲token的生成</p>
<p>1、用户发起获取token的请求，请求&#x2F;oauth&#x2F;token接口</p>
<p>2、首先要过一道关卡是ClientCredentialsTokenEndpointFilter</p>
<ol>
<li>通过clientId查询生成一个Authentication对象</li>
<li>将clientId和clientSecret构造成UsernamePasswordAuthenticationToken,交给ProviderManager，然后ProviderManager代理AuthenticationProvider去认证，最后真正执行的是DaoAuthenticationProvider，通过UserDetailsService.loadUserByUsername向表oauth_client_details查询clientDetails信息</li>
</ol>
<p>3、 以上认证客户端信息的逻辑全部通过后，会进入地址&#x2F;oauth&#x2F;token，即TokenEndpoint的postAccessToken方法(当然这个方法我们可以自定义)中。</p>
<p>4、 postAccessToken方法中会验证Scope，然后验证是否是refreshToken请求等</p>
<p>5、 AbstractTokenGranter(此时的实现类是ResourceOwnerPasswordTokenGranter)中的grant方法</p>
<p>6、 之后调用AbstractTokenGranter(此时的实现类ResourceOwnerPasswordTokenGranter)中的grant方法</p>
<p>7、 grant方法中调用getAccessToken方法，在这个方法中又逐步调用到WebSecurityConfigurerAdapter的AbstractUserDetailsAuthenticationProvider的authenticate方法（<br>非常关键的一点</p>
<ul>
<li>先看缓存有没有</li>
<li>看数据库UserDetails loadedUser &#x3D; this.getUserDetailsService().loadUserByUsername(username);</li>
</ul>
<p>），对username与password进行认证</p>
<p>8、 验证通过后，把得到Authentication认证结果对象包装成OAuth2Authentication认证对象。然后传给DefaultTokenServices类的tokenStore的getAccessToken方法，利用OAuth2Authentication对象中的信息查找tokenStore中是否已经存在token，存在则返回OAuth2AccessToken对象。如果不存在DefaultTokenServices则调用createAccessToken（增强方法就在这里实现，这个方法主要做了五件事情，</p>
<ul>
<li>使用UUID生成Token</li>
<li>判断Token是否过期，如果没过期，就把过期时间设为当前时间加1000s</li>
<li>设置刷新令牌</li>
<li>设置权限</li>
<li>判断是否有增强器，如果有就调用它的enhance方法）</li>
</ul>
<p>方法创建OAuth2AccessToken对象。</p>
<p>9、 然后将OAuth2AccessToken对象包装进响应流返回。</p>
<h2 id="token刷新"><a href="#token刷新" class="headerlink" title="token刷新"></a>token刷新</h2><p>刷新token（refresh token）的流程与获取token的流程只有8有所区别：</p>
<p>1.获取token调用的是AbstractTokenGranter中的getAccessToken方法，然后调用tokenStore中的getAccessToken方法获取token。</p>
<p>2.刷新token调用的是RefreshTokenGranter中的getAccessToken方法，然后使用tokenStore中的refreshAccessToken方法获取token。</p>
<h2 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h2><p>当我们拿到token之后我们会拿着这个token去访问其他的接口，比如说我们login接口成功返回之后，你马上紧接着就访问info接口，你直接8080&#x2F;admin&#x2F;info这么发过去，首先找到gateway，gateway首先要鉴定一下你这个是不是有权限是不是啊？那么这里就涉及了鉴权服务。<br>这个鉴权服务分为两个部分：</p>
<p>1、token 检验<br>首先调用下面这个代码，不过readaccesstoken具体的实现我们可以自定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OAuth2AccessToken oAuth2AccessToken = this.tokenStore.readAccessToken(accessToken);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总之就去去查你这个token有没有，没有的话，就返回没有token的信息错误。<br>如果有，继续判断是不是过期了，如果过期了，就返回过期的错误信息<br>然后通过这个token去缓存或者数据库里面找到OAuth2Authentication对象，如果没有再次返回无效异常，如果有，那我们就通过token的校验，进入到权限的校验。</p>
<p>OAuth2AccessToken和OAuth2Authentication是好基友，TokenStore同时存储OAuth2AccessToken和OAuth2Authentication</p>
<p>2、权限检验</p>
<p>进来之后如果是白名单，我们就放行，毕竟有些东西确实不需要什么权限。</p>
<p>跨域的预检也放行，这一点在上面也提到过，预检验，你要是把他拦下来，那就没必要了。</p>
<p>下面进入真正的检验从request获取token，提取信息组装成一个对象（dto）</p>
<p>非管理端直接放行，这个意思是，我们的后台服务不是所有人都能进来的，要是你一个用户能进我们的后台那就完蛋了。</p>
<p>去缓存里面拿到资源规则，然后对比两者的访问路径，要是匹配得上就把相应的权限加到一个集合里面。</p>
<p>这时候我们就得到访问这个路径需要的权限，那我们就用自己的权限去对比，要是比他高，那就通过，要是不如，那就拒绝。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/20/%E5%AF%B9%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%96%B0%E7%90%86%E8%A7%A3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/04/springboot-cloud%E6%95%B4%E5%90%88docker-compose/"
                            aria-label=": springboot/cloud整合docker-compose"
                        >
                            springboot/cloud整合docker-compose
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-04T21:25:08+08:00">
	
		    04 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/java%E5%AD%A6%E4%B9%A0/">java学习</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>docker-compose是一个定义复杂应用的工具，我们平时使用docker，一般是docker run ….</p>
<p>然而这样每次只能运行一个镜像，而且不能保证各个容器之间是能够正常通信的，如果想要用docker做到这种容器之间相互通信，要么你每次的命令加上一大串的参数，比如说同一个网络名字啊，link啊，dependon啊，如此之类的，然而单单跑一个容器的命令的够长了，这个容器要是和4、5个其他的容器通信，那怎么写？</p>
<p>这就引出了我们的第二种方法：docker-compose，<br>关于这个工具我们需要下载，如果我们使用的是docker-desktop这种可视化客户端，那么他已经安装好了：怎么判断自己是不是已经完成了docker-compose的下载？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose -v   即可</span><br></pre></td></tr></table></figure>
<p>博主跑一个微服务的项目一般喜欢先把环境搭好，然后在测试我么的项目正确性。<br>所以这里就分成了两个docker-compose文件，一个是env，一个是我们的项目app。</p>
<p>这里先介绍一下docker-compse的用法。<br>我们写好一个yml文件，然后docker-compose命令去执行，而这个文件就相当于pom配置文件。<br>具体举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose -f XXXX.yml up 要是路径上面只有一个docker-compose.yml文件那么</span><br><span class="line">-f也可以不加上去，反正就是寻找的意思。</span><br></pre></td></tr></table></figure>
<p>先介绍docker-compose-env.yml, 这里截取一部分，来讲一讲都是什么含义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:8.0.26</span><br><span class="line">    container_name: mysql</span><br><span class="line">    command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 185450844 #设置root帐号密码</span><br><span class="line">    ports:</span><br><span class="line">      - 3307:3306</span><br><span class="line">    volumes:</span><br><span class="line">      - /Users/csen/dockerProject/mydata/mysql/data/db:/var/lib/mysql #数据文件挂载</span><br><span class="line">      - /Users/csen/dockerProject/mydata/mysql/data/conf:/etc/mysql/conf.d #配置文件挂载</span><br><span class="line">      - /Users/csen/dockerProject/mydata/mysql/log:/var/log/mysql #日志文件挂载</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>command：声明启动参数</li>
<li>image：你docker里面的镜像名字</li>
<li>container_name：启动后的容器名字</li>
<li>environment：设置容器中的环境变量</li>
<li>privileged：用来给容器root权限，不安全的</li>
<li>network_mode： 设置容器的网络模式</li>
<li>ports：端口</li>
<li>volumes：挂载，这个大家都没说清楚，就是用冒号前面的路径代替后面，这样一些数据啊配置啊就可以跟着你的要求走。前面的是自己的，后面的是容器的。</li>
</ul>
<p>下面介绍docker-compose-app.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  XXXX:</span><br><span class="line">    image: XXXX:latest</span><br><span class="line">    container_name: XXXX</span><br><span class="line">    ports:</span><br><span class="line">      - 8081:8081</span><br><span class="line">    volumes:</span><br><span class="line">      - /Users/csen/dockerProject/XXXX/logs:/var/logs</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br><span class="line">    environment:</span><br><span class="line">      - &#x27;TZ=&quot;Asia/Shanghai&quot;&#x27;</span><br><span class="line">    external_links:</span><br><span class="line">      - elasticsearch:es #可以用es这个域名访问elasticsearch服务</span><br><span class="line">      - mysql:db #可以用db这个域名访问mysql服务</span><br><span class="line">      - nacos-registry:nacos</span><br></pre></td></tr></table></figure>
<p>和docker-compose-env很像，不过我只是用来启动我们的微服务项目，这里面关键就是external_links，我们在项目中使用的很多localhost要替换成这些域名。</p>
<p>这里的image是我们build好的项目镜像，这里就要提一嘴了。这个是我们build的镜像<br>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，用于构建镜像。每一条指令构建一层镜像，因此每一条指令的内容，就是描述该层镜像应当如何构建<br>具体的可见这篇大佬的博客：  <a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46090675/article/details/121846718?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166489555716782417065884%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166489555716782417065884&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121846718-null-null.142%5Ev51%5Econtrol,201%5Ev3%5Econtrol&utm_term=dockerfile&spm=1018.2226.3001.4187">Dockerfile</a>。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/04/springboot-cloud%E6%95%B4%E5%90%88docker-compose/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/04/springboot-cloud%E6%95%B4%E5%90%88docker%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%B0%E5%BD%95/"
                            aria-label=": springboot/cloud整合docker和中间件记录"
                        >
                            springboot/cloud整合docker和中间件记录
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-04T21:23:41+08:00">
	
		    04 Oct 2022
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>前言：<br>博主从win换成mac后，想试着自己配一下docker环境，花了足足3到4天的时间。<br>由于中土存在各种中间件的兼容问题，mac版和win版的不一致，中间件版本过新等问题，且大多数博客对于版本的描述不够清晰，很难帮到忙，故博主斗胆记录一下，希望对大家有帮助。</p>
<p>环境：</p>
<ul>
<li>springboot: 2.7.0</li>
<li>nacos: 2.1.0</li>
<li>elasticsearch: 8.2.0</li>
<li>kibana: 8.2.0</li>
<li>springcloud: 2021.0.3</li>
<li>springcloudalibaba: 2021.0.1</li>
<li>mysql: 8.0.26</li>
<li>redis: 7</li>
<li>rabbitmq: 3.9.11</li>
<li>jdk: 8</li>
<li>kafka: 3.5.11</li>
</ul>
<h2 id="1、elasticsearch8-2-0"><a href="#1、elasticsearch8-2-0" class="headerlink" title="1、elasticsearch8.2.0"></a>1、elasticsearch8.2.0</h2><p>当es和kibana到达8版本后，出现了很多变化，而且兼容mac版本的镜像提示不够明确  </p>
<p>可能出现的问题：</p>
<p>1、装好es之后你打开9200端口，发现他要求你输入密码，但是你其实根本就没有告诉你初始账号密码和默认的账号密码</p>
<p>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csen@CsendeMBA Sen-Blog % docker exec -it (容器名字) /bin/bash</span><br><span class="line">elasticsearch@52142308d267:~$ ls</span><br><span class="line">LICENSE.txt  README.asciidoc  config  jdk  logs     plugins</span><br><span class="line">NOTICE.txt   bin              data    lib  modules</span><br><span class="line">elasticsearch@52142308d267:~$ cd config</span><br><span class="line">elasticsearch@52142308d267:~/config$ ls</span><br><span class="line">certs                              jvm.options             role_mapping.yml</span><br><span class="line">elasticsearch-plugins.example.yml  jvm.options.d           roles.yml</span><br><span class="line">elasticsearch.keystore             log4j2.file.properties  users</span><br><span class="line">elasticsearch.yml                  log4j2.properties       users_roles</span><br><span class="line">elasticsearch@52142308d267:~/config$ </span><br></pre></td></tr></table></figure>
<p>你会看到有一个文件叫做elasticsearch.yml,我们需要做的就是修改这个文件</p>
<p>修改文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster.name: &quot;docker-cluster&quot;</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"># Enable security features</span><br><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.security.enrollment.enabled: true（可以先不加，上面的必须加）</span><br></pre></td></tr></table></figure>

<p>当你修改之后，重启容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart 容器名字</span><br></pre></td></tr></table></figure>
<p>等重启之后，进入容器的es内部（可以直接docker desk客户端的cli那里，也可以像上面一样命令行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/share/elasticsearch/bin/x-pack/setup-passwords interactive</span><br></pre></td></tr></table></figure>

<p>依此设置elastic、apm_system、kibana_system、logstash_system、beats_system、remote_monitoring_user6个用户的密码，每设置一个都要验证一次，所以要按12次，建议直接用一个密码就行，我用的是elastic</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initiating the setup of passwords for reserved users elastic,apm_system,kibana,kibana_system,logstash_system,beats_system,remote_monitoring_user.</span><br><span class="line">You will be prompted to enter passwords as the process progresses.</span><br><span class="line">Please confirm that you would like to continue [y/N]y</span><br><span class="line">Enter password for [elastic]: </span><br><span class="line">Reenter password for [elastic]: </span><br><span class="line">Enter password for [apm_system]: </span><br><span class="line">Reenter password for [apm_system]: </span><br><span class="line">Enter password for [kibana_system]: </span><br><span class="line">Reenter password for [kibana_system]: </span><br><span class="line">Enter password for [logstash_system]: </span><br><span class="line">Reenter password for [logstash_system]: </span><br><span class="line">Enter password for [beats_system]: </span><br><span class="line">Reenter password for [beats_system]: </span><br><span class="line">Enter password for [remote_monitoring_user]: </span><br><span class="line">Reenter password for [remote_monitoring_user]: </span><br><span class="line">Changed password for user [apm_system]</span><br><span class="line">Changed password for user [kibana_system]</span><br><span class="line">Changed password for user [kibana]</span><br><span class="line">Changed password for user [logstash_system]</span><br><span class="line">Changed password for user [beats_system]</span><br><span class="line">Changed password for user [remote_monitoring_user]</span><br><span class="line">Changed password for user [elastic]</span><br></pre></td></tr></table></figure>
<p>这时候登陆9200端口查看是否成功，如果成功他会返回一个json串，一看就知道成功的json串，有name clustername、version这些属性。</p>
<h2 id="2、kibana8-2-0"><a href="#2、kibana8-2-0" class="headerlink" title="2、kibana8.2.0"></a>2、kibana8.2.0</h2><p>kibana安装完成后打开5601端口，他会在页面左上角显示一段英文串，意思就是没准备好，但实际是因为权限问题，人家进不去。</p>
<p>这个问题大多数博主都没讲到。</p>
<p>解决办法是：你告诉kibana，es的账号密码，我们会发现，在es设置密码的时候有6个用户，那我们到底用哪一个呢？这里有点歧义，我的选择是直接用kibana_system这个用户。因为我们就是kibana所以没什么问题，但是有一个博主用的elastic用户，而我使用这个用户会提示错误，所以大家可以先试试kibana_system然后elastic，具体操作如下：</p>
<p>首先挂载config，把原本自带的挤掉，因为我们在docker修改起来也不方便，所以直接挂载是最简单的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volumes:</span><br><span class="line">     - /Users/csen/dockerProject/mydata/kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml </span><br><span class="line">     - </span><br></pre></td></tr></table></figure>
<p>挂载成功后，在我们的kibana.yml文件中修改内容</p>
<p>1、要对应你们自己修改的密码。如果是elastic那就完全复制，如果不是，就自己改一下密码。<br>2、elasticseatch.hosts那一栏我写的是es：9200，因为我的elasticsearch容器跑通之后，在springboot项目中的别名叫做es，大家根据自己的改哦，别死抄。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># ** THIS IS AN AUTO-GENERATED FILE **</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Default Kibana configuration for docker target</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">server.shutdownTimeout: &quot;5s&quot;</span><br><span class="line">elasticsearch.hosts: [ &quot;http://es:9200&quot; ]</span><br><span class="line">monitoring.ui.container.elasticsearch.enabled: true</span><br><span class="line"># 这里配置中文显示，默认为英文 【English - en (default)、Chinese - zh-CN、Japanese - ja-JP】</span><br><span class="line">i18n.locale: &quot;zh-CN&quot;</span><br><span class="line"># 此处设置elastic的用户名和密码</span><br><span class="line">elasticsearch.username: kibana_system</span><br><span class="line">elasticsearch.password: elastic</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h2><p>这个只说一点就可以了，当然这也是所有中间件的选择方案。版本选对，由于mac有芯片有两代，i5i7和m1m2，这两代的架构是不一样的，所以去hub里面找相应的版本大下载就可以了，举个例子：</p>
<p>我们要下载2.1.0版本的nacos，我们打开hub.docker.com然后搜索nacos，去tag里面输入2.1.0，你会发现，有好多版本，这时候我们要看【os&#x2F;arch】这一栏，你去看看他到底是哪种架构的，有的是linux&#x2F;amd64，有的是linux&#x2F;arm64，有的是两者皆有。如果是i5i7的就去下带amd64的，如果是m1m2的就去下载带arm64的。</p>
<p>不过这里提一嘴，m1m2芯片他自带了转译的功能，也就是说即使是amd64的他也有能力转成适合自己的，但是可能存在两代电脑环境配置的问题，大家还是下载各自适合的最好。</p>
<h2 id="mysql8"><a href="#mysql8" class="headerlink" title="mysql8"></a>mysql8</h2><p>目前网上的博客大多都是mysql5.7版本之类的，8版本的较少，所以会出一些错误。</p>
<p>特别是连接数据库的时候，大家发现明明我的账号密码都对的，为什么还是说连接错误呢？这其实很可能不是我们自己的问题。</p>
<p>下面给出我的连接数据库的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  url: jdbc:mysql://db:3306/mall?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span><br><span class="line">  username: root</span><br><span class="line">  password: XXXXXXXX</span><br><span class="line">  druid:</span><br><span class="line">    initial-size: 5 #连接池初始化大小</span><br><span class="line">    min-idle: 10 #最小空闲连接数</span><br><span class="line">    max-active: 20 #最大连接数</span><br><span class="line">    web-stat-filter:</span><br><span class="line">      exclusions: &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot; #不统计这些请求数据</span><br><span class="line">    stat-view-servlet: #访问监控网页的登录用户名和密码</span><br><span class="line">      login-username: druid</span><br><span class="line">      login-password: druid</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是一下几点：</p>
<p>1、如果你把项目放到docker里面，就不要用localhost了，要么你直接用ip地址，要么就和我一样用这种别名。<br>而这种别名的配置则放在docker-compose里面。<br>这个在文章最后会给大家放一个链接将docker-compose怎么写。</p>
<p>2、由于版本升级和docker的原因，在连接数据库的时候最好加上这些后缀：</p>
<p>2.1、useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8：一旦设置了之后，不管数据库是什么编码，读取的时候都会转换成UTF-8，存取的时候还是会按数据库编码存</p>
<p>2.2、serverTimezone&#x3D;Asia&#x2F;Shanghai：问题在 MySQL8.0的驱动包跟之前不一样了，默认时区是全球统一时间 (UTC)，北京时间是 UTC+8，这句话不加就导致了很多人就算不在docker里面都连不上数据库，mysql8就很烦。</p>
<p>2.3、useSSL&#x3D;false：useSSL&#x3D;true是进行安全验证，一般通过证书或者令牌什么的，useSSL&#x3D;false就是通过账号密码进行连接，通常使用useSSL&#x3D;false，这个也是mysql8的问题，不过这个问题并不是到了8之后才有的，5.7之后就存在这个问题了。ssl会认证用户的服务器，然后加密数据，最后维护数据的完整性。但是我们用docker相当于把它部署到一个linux服务器上，所以用不到这个。</p>
<p>2.4、allowPublicKeyRetrieval&#x3D;true。</p>
<p>这个指令比较玄学，是由于报了下面错误才用的，Public Key Retrieval is not allowed（不允许检索公钥）。博主也去网上查了很多资料，大家的话大差不差，就是在第一次连接的时候会出问题，第二次连的时候貌似数据库就缓存的这个配置信息，既然加上能用，大家就加上。有一些朋友也说到，如果我们使用一些可视化工具比如navicat这类的也能解决。</p>
<p>另一种法是：使用指令mysql -u root -p指令进入mysql，将验证方式修改为“mysql_native_password”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE mysql; </span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/04/springboot-cloud%E6%95%B4%E5%90%88docker%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%B0%E5%BD%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/04/springboot%E6%95%B4%E5%90%88elasticsearch8-2-0/"
                            aria-label=": springboot整合elasticsearch8.2.0"
                        >
                            springboot整合elasticsearch8.2.0
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-04T13:40:04+08:00">
	
		    04 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/java%E5%AD%A6%E4%B9%A0/">java学习</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="java-整合elasticsearch8-2-0"><a href="#java-整合elasticsearch8-2-0" class="headerlink" title="java 整合elasticsearch8.2.0"></a>java 整合elasticsearch8.2.0</h1><p>[TOC]</p>
<h3 id="一、application-yml或者其他的配置文件皆可"><a href="#一、application-yml或者其他的配置文件皆可" class="headerlink" title="一、application.yml或者其他的配置文件皆可"></a>一、application.yml或者其他的配置文件皆可</h3><p>两种方式：【1】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elasticsearch:</span><br><span class="line">  hosts: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>     # 如果有多个IP就自己加逗号吧</span><br></pre></td></tr></table></figure>

<p>【2】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring：</span><br><span class="line">	elasticsearch:</span><br><span class="line">    	uris: localhost:<span class="number">9200</span>   #这样子自动配置了</span><br></pre></td></tr></table></figure>

<h3 id="二、config类"><a href="#二、config类" class="headerlink" title="二、config类"></a>二、config类</h3><p>不同的版本会有不同的config类要求，这里只提供es8.2.0的，对应着上面两种application文件，此处也提供两种对应的config类，至于之后和springboot整合就不会出现分类了。</p>
<h5 id="【1】自定义属性"><a href="#【1】自定义属性" class="headerlink" title="【1】自定义属性"></a>【1】自定义属性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Caosen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/22 10:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EsUtilConfigClint2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;elasticsearch.hosts&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String hosts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpHost[] getHttpHost()&#123;</span><br><span class="line">        <span class="keyword">if</span> (hosts.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(hosts);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] hosts_array = hosts.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">//用string类型创建host的集合</span></span><br><span class="line"></span><br><span class="line">        HttpHost[] httpHosts = <span class="keyword">new</span> <span class="title class_">HttpHost</span>[hosts_array.length];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : hosts_array) &#123;</span><br><span class="line">            <span class="comment">//这里解析端口</span></span><br><span class="line">            String[] hosts_array_in = s.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="comment">//到这里就有了id和端口两个东西</span></span><br><span class="line">            <span class="type">HttpHost</span> <span class="variable">http</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHost</span>(hosts_array_in[<span class="number">0</span>], Integer.parseInt(hosts_array_in[<span class="number">1</span>]), <span class="string">&quot;http&quot;</span>);</span><br><span class="line">            httpHosts[i++] = http;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;目前的配置加入了&quot;</span> + i + <span class="string">&quot;个id及其端口&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> httpHosts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ElasticsearchClient <span class="title function_">configClint</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// Create the low-level client</span></span><br><span class="line">        HttpHost[] httpHosts = getHttpHost();</span><br><span class="line">        <span class="type">RestClient</span> <span class="variable">restClient</span> <span class="operator">=</span> RestClient.builder(httpHosts).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the transport with a Jackson mapper</span></span><br><span class="line">        <span class="type">ElasticsearchTransport</span> <span class="variable">transport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestClientTransport</span>(</span><br><span class="line">                restClient, <span class="keyword">new</span> <span class="title class_">JacksonJsonpMapper</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端</span></span><br><span class="line">        <span class="type">ElasticsearchClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElasticsearchClient</span>(transport);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="【2】使用自带的属性"><a href="#【2】使用自带的属性" class="headerlink" title="【2】使用自带的属性"></a>【2】使用自带的属性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Caosen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/18 15:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EsUtilConfigClint</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ElasticsearchClient <span class="title function_">configClint</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// Create the low-level client</span></span><br><span class="line">        <span class="type">RestClient</span> <span class="variable">restClient</span> <span class="operator">=</span> RestClient.builder(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9200</span>)).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the transport with a Jackson mapper</span></span><br><span class="line">        <span class="type">ElasticsearchTransport</span> <span class="variable">transport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestClientTransport</span>(</span><br><span class="line">                restClient, <span class="keyword">new</span> <span class="title class_">JacksonJsonpMapper</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端</span></span><br><span class="line">        <span class="type">ElasticsearchClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElasticsearchClient</span>(transport);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h3><h5 id="【1】service接口"><a href="#【1】service接口" class="headerlink" title="【1】service接口"></a>【1】service接口</h5><p>由于作者是直接在项目里面加内容的，可能会出现一些不相关的东西，我尽量截取相关代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 从数据库中导入所有商品到ES</span><br><span class="line">     */</span><br><span class="line">    int importAll();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新建指定名称的索引</span><br><span class="line">     * @param name</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    void addIndex(String name) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 检查指定名称的索引是否存在</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    boolean indexExists(String name) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除指定索引</span><br><span class="line">     * @param name</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    void delIndex(String name) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建索引，指定setting和mapping</span><br><span class="line">     * @param name 索引名称</span><br><span class="line">     * @param settingFn 索引参数</span><br><span class="line">     * @param mappingFn 索引结构</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    void create(String name,</span><br><span class="line">                Function&lt;IndexSettings.Builder, ObjectBuilder&lt;IndexSettings&gt;&gt; settingFn,</span><br><span class="line">                Function&lt;TypeMapping.Builder, ObjectBuilder&lt;TypeMapping&gt;&gt; mappingFn) throws IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="【2】serviceImpl，主要看create-，add，exsits-delete"><a href="#【2】serviceImpl，主要看create-，add，exsits-delete" class="headerlink" title="【2】serviceImpl，主要看create ，add，exsits, delete"></a>【2】serviceImpl，主要看create ，add，exsits, delete</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    private EsProductDao esProductDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductRepository esProductRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ElasticsearchClient elasticsearchClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int importAll() &#123;</span><br><span class="line">        List&lt;EsProduct&gt; allEsProductList = esProductDao.getAllEsProductList(null);</span><br><span class="line">        Iterable&lt;EsProduct&gt; esProducts = esProductRepository.saveAll(allEsProductList);</span><br><span class="line">        Iterator&lt;EsProduct&gt; iterator = esProducts.iterator();</span><br><span class="line">        int result = 0;</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addIndex(String name) throws IOException &#123;</span><br><span class="line">        elasticsearchClient.indices().create(b -&gt; b.index(name));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean indexExists(String name) throws IOException &#123;</span><br><span class="line">        return elasticsearchClient.indices().exists(b -&gt; b.index(name)).value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delIndex(String name) throws IOException &#123;</span><br><span class="line">        elasticsearchClient.indices().delete(b -&gt; b.index(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void create(String name, Function&lt;IndexSettings.Builder, ObjectBuilder&lt;IndexSettings&gt;&gt; setting, Function&lt;TypeMapping.Builder, ObjectBuilder&lt;TypeMapping&gt;&gt; mapping) throws IOException &#123;</span><br><span class="line">        elasticsearchClient.indices()</span><br><span class="line">                .create(b -&gt; b</span><br><span class="line">                        .index(name)</span><br><span class="line">                        .settings(setting)</span><br><span class="line">                        .mappings(mapping));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="【3】测试"><a href="#【3】测试" class="headerlink" title="【3】测试"></a>【3】测试</h5><p>测试可以用controller 或者 用test伪装controller，自己测试的时候还是用postman接口比较合适。这里测试两种创建index，一种简单，一种稍微复杂，结果都是通过，见图。其他的删除啊，导入数据库的数据（repository）都是可以查到的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    void addIndexSimple() throws IOException &#123;</span><br><span class="line">        String s = &quot;simple&quot;;</span><br><span class="line"></span><br><span class="line">        esProductService.addIndex(s);</span><br><span class="line">        System.out.println(&quot;创建success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    void addIndexComplicated() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        String s = &quot;complicated&quot;;</span><br><span class="line">        Function&lt;IndexSettings.Builder, ObjectBuilder&lt;IndexSettings&gt;&gt; setting = builder -&gt; builder</span><br><span class="line">                .index(i -&gt; i.numberOfShards(&quot;3&quot;).numberOfReplicas(&quot;1&quot;));</span><br><span class="line">        Property keywordproperty = Property.of(p -&gt; p.keyword(k -&gt; k.ignoreAbove(256)));</span><br><span class="line">        Property testproperty = Property.of(p -&gt; p.text(builder -&gt; builder));</span><br><span class="line">        Property integerproperty = Property.of(builder -&gt; builder.integer(i -&gt; i));</span><br><span class="line"></span><br><span class="line">        Function&lt;TypeMapping.Builder, ObjectBuilder&lt;TypeMapping&gt;&gt; mapping = builder -&gt; builder</span><br><span class="line">                .properties(&quot;name&quot;, keywordproperty)</span><br><span class="line">                .properties(&quot;description&quot;, testproperty)</span><br><span class="line">                .properties(&quot;price&quot;, integerproperty);</span><br><span class="line">        esProductService.create(s, setting, mapping);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220922113434674.png" alt="image-20220922113434674"></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/04/springboot%E6%95%B4%E5%90%88elasticsearch8-2-0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/04/springboot%E6%95%B4%E5%90%88kafka3-1-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/"
                            aria-label=": springboot整合kafka3.1-基本配置和操作"
                        >
                            springboot整合kafka3.1-基本配置和操作
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-04T13:38:01+08:00">
	
		    04 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/java%E5%AD%A6%E4%B9%A0/">java学习</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>这篇是单机的zookeeper形式，适用于入门。等有时间会更新kraft搭建。</p>
<p>博主自己装了双系统，虚拟机刚刚删了，所以没去做集群，不过当大家的kafka版本来到3.1，建议大家去学习KRaft集群搭建而不是去整合zookeeper。下面介绍一下怎么整合，正所谓举一反三，这个会了，到时候换个环境就ok，讲的不好的地方还请见谅。</p>
<p>[toc]</p>
<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><h3 id="1、springboot"><a href="#1、springboot" class="headerlink" title="1、springboot"></a>1、springboot</h3><p>博主自己用的是2.7版本的</p>
<p>一般关于springboot我会引入一下依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2、kafka"><a href="#2、kafka" class="headerlink" title="2、kafka"></a>2、kafka</h3><h4 id="1、kafka下载"><a href="#1、kafka下载" class="headerlink" title="1、kafka下载"></a>1、kafka下载</h4><p><a target="_blank" rel="noopener" href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a>  这里下载，这里再提一句，建议直接放到d盘e盘一级子目录里面，否则有可能出现启动的时候名字太长的问题</p>
<p>下载之后修改配置文件server.properties</p>
<p>log.dirs&#x3D;E:\kafka_2.13-3.2.3\kafka-logs</p>
<h4 id="2、项目引入依赖"><a href="#2、项目引入依赖" class="headerlink" title="2、项目引入依赖"></a>2、项目引入依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;根据自己的版本选择&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>这里提一句：不一样的springboot对应的kafka依赖版本也不一样，所以先去官网查看依赖版本。</p>
<p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-kafka">https://spring.io/projects/spring-kafka</a>   点这个链接去找对应的，别自己乱下最新的。</p>
<h5 id="新版本的kafka命令和老版本的不一样。"><a href="#新版本的kafka命令和老版本的不一样。" class="headerlink" title="新版本的kafka命令和老版本的不一样。"></a>新版本的kafka命令和老版本的不一样。</h5><p>试着启动，命令看你在哪个文件夹，如果是kafka，用下面的，如果是linux，把bat换成sh</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-server-start.bat config\server.properties</span><br></pre></td></tr></table></figure>

<p>简单使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test（自己取）</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>



<h3 id="3、zookeeper"><a href="#3、zookeeper" class="headerlink" title="3、zookeeper"></a>3、zookeeper</h3><p>新版本的kafka其实自己集成了zookeeper，博主这里同样介绍两种方式，一种自己重新去下个zookeeper，一种用kafka自带的。</p>
<h4 id="1、自带的"><a href="#1、自带的" class="headerlink" title="1、自带的"></a>1、自带的</h4><p>修改配置zookeeper.properties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataDir=/opt/kafka/zookeeper/data/dataDir</span><br><span class="line">dataLogDir=/opt/kafka/zookeeper/data/dataLogDir</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line"># disable the per-ip limit on the number of connections since <span class="built_in">this</span> is a non-production config</span><br><span class="line">maxClientCnxns=<span class="number">100</span></span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line">initLimit=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br></pre></td></tr></table></figure>

<h4 id="2、自己下载zookeeper"><a href="#2、自己下载zookeeper" class="headerlink" title="2、自己下载zookeeper"></a>2、自己下载zookeeper</h4><p>由于是自己下载所以也不用去配置kafka文件中的zookeeper.properties</p>
<p><a target="_blank" rel="noopener" href="https://zookeeper.apache.org/releases.html#download">https://zookeeper.apache.org/releases.html#download</a>  这是下载地址</p>
<p>进去之后很简单，一样改配置，进入conf目录下，将<code>zoo_example.cfg</code>重命名为<code>zoo.cfg</code></p>
<p>同样修改dataDir和log， 我的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">example sakes.</span><br><span class="line"></span><br><span class="line">dataDir=E:\\java-configuration\\apache-zookeeper-<span class="number">3.7</span><span class="number">.1</span>-bin\\data</span><br><span class="line"></span><br><span class="line">存放事务日志目录</span><br><span class="line"></span><br><span class="line">dataLogDir=E:\\java-configuration\\apache-zookeeper-<span class="number">3.7</span><span class="number">.1</span>-bin\\logs</span><br></pre></td></tr></table></figure>

<p>然后运行zkserver.cmd和zkcli.cmd, 一个是启动我们的zookeeper服务器，一个是客户端。</p>
<h2 id="springboot整合操作kafka"><a href="#springboot整合操作kafka" class="headerlink" title="springboot整合操作kafka"></a>springboot整合操作kafka</h2><p><img src="C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220924153503966.png" alt="image-20220924153503966"></p>
<p>这里用一张图作为流程讲解如何整合。</p>
<h3 id="1、config"><a href="#1、config" class="headerlink" title="1、config"></a>1、config</h3><p>其实可以把下面的conponent exception filter什么的都丢进来，可以配一些生产者消费者的信息，想配什么都可以，这个就不展示了。</p>
<h3 id="2、回调（conponent）"><a href="#2、回调（conponent）" class="headerlink" title="2、回调（conponent）"></a>2、回调（conponent）</h3><p>回调有多种写法，这里介绍三种</p>
<h4 id="1、较为泛用的"><a href="#1、较为泛用的" class="headerlink" title="1、较为泛用的"></a>1、较为泛用的</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class KafkaSendResultHandler implements ProducerListener &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSuccess(ProducerRecord producerRecord, RecordMetadata recordMetadata) &#123;</span><br><span class="line">        System.out.println(&quot;Message send success : &quot; + producerRecord.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(ProducerRecord producerRecord, RecordMetadata recordMetadata, Exception exception) &#123;</span><br><span class="line">        System.out.println(&quot;Message send error : &quot; + producerRecord.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在生产者里面使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private KafkaSendResultHandler kafkaSendResultHandler;</span><br><span class="line"></span><br><span class="line">。。。。。省略</span><br><span class="line"></span><br><span class="line">kafkaTemplate.setProducerListener(kafkaSendResultHandler);    </span><br></pre></td></tr></table></figure>

<h4 id="2、一个方法对应一个特定的回调"><a href="#2、一个方法对应一个特定的回调" class="headerlink" title="2、一个方法对应一个特定的回调"></a>2、一个方法对应一个特定的回调</h4><h5 id="1、第一种写法"><a href="#1、第一种写法" class="headerlink" title="1、第一种写法"></a>1、第一种写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(<span class="string">&quot;topic1&quot;</span>, callbackMessage).addCallback(success -&gt;&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> success.getRecordMetadata().topic();</span><br><span class="line">    <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> success.getRecordMetadata().partition();</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> success.getRecordMetadata().offset();</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息成功:&quot;</span> + topic + <span class="string">&quot;-&quot;</span> + partition + <span class="string">&quot;-&quot;</span> + offset);</span><br><span class="line"></span><br><span class="line">&#125;, failure -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息失败:&quot;</span> + failure.getMessage());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="2、第二种写法"><a href="#2、第二种写法" class="headerlink" title="2、第二种写法"></a>2、第二种写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(<span class="string">&quot;topic1&quot;</span>, callbackMessage).addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;SendResult&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息失败：&quot;</span>+ex.getMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult&lt;String, Object&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：&quot;</span> + result.getRecordMetadata().topic() + <span class="string">&quot;-&quot;</span></span><br><span class="line">                + result.getRecordMetadata().partition() + <span class="string">&quot;-&quot;</span> + result.getRecordMetadata().offset());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3、consumer-消费者"><a href="#3、consumer-消费者" class="headerlink" title="3、consumer(消费者)"></a>3、consumer(消费者)</h3><p>使用KafkaListener，指定消息类型（必选）和groupid，partitions offset（可选）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, groupId = &quot;felix-group0&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage1(ConsumerRecord&lt;?,?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;简单消费：&quot; + record.topic() + &quot;--&quot; + record.partition() + &quot;--&quot; + record.value());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@KafkaListener(id = &quot;comsumer1&quot;, groupId = &quot;felix-group1&quot;, topicPartitions = &#123;</span><br><span class="line">        @TopicPartition(topic = &quot;topic1&quot;, partitions = &#123;&quot;0&quot;&#125;),</span><br><span class="line">        @TopicPartition(topic = &quot;topic2&quot;, partitionOffsets = @PartitionOffset(partition = &quot;0&quot;, initialOffset = &quot;8&quot;))</span><br><span class="line">&#125; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage2(ConsumerRecord&lt;?, ?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;topic:&quot;+record.topic()+&quot;|partition:&quot;+record.partition()+&quot;|offset:&quot;+record.offset()+&quot;|value:&quot;+record.value());</span><br><span class="line">&#125;</span><br><span class="line">@KafkaListener(id = &quot;consumer2&quot;,groupId = &quot;felix-group2&quot;, topics = &quot;topic1&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage3(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records) &#123;</span><br><span class="line">    System.out.println(&quot;&gt;&gt;&gt;批量消费一次，records.size()=&quot;+records.size());</span><br><span class="line">    for (ConsumerRecord&lt;?, ?&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、controller生产者（produces）"><a href="#4、controller生产者（produces）" class="headerlink" title="4、controller生产者（produces）"></a>4、controller生产者（produces）</h3><h4 id="1、同步发送"><a href="#1、同步发送" class="headerlink" title="1、同步发送"></a>1、同步发送</h4><p>如果需要使用同步发送，可以在每次发送之后使用get方法，因为producer.send方法返回一个Future类型的结果，Future的get方法会一直阻塞直到该线程的任务得到返回值，也就是broker返回发送成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(&quot;test&quot;, message).get();</span><br></pre></td></tr></table></figure>

<h4 id="2、异步发送"><a href="#2、异步发送" class="headerlink" title="2、异步发送"></a>2、异步发送</h4><p>可以从返回的future对象中稍后获取发送的结果，ProducerRecord、RecordMetadata包含了返回的结果信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(&quot;test&quot;, message);</span><br></pre></td></tr></table></figure>

<h4 id="3-使用ack机制实现可靠"><a href="#3-使用ack机制实现可靠" class="headerlink" title="3. 使用ack机制实现可靠"></a>3. 使用ack机制实现可靠</h4><p>producers可以一步的并行向kafka发送消息，但是通常producer在发送完消息之后会得到一个响应，返回的是offset值或者发送过程中遇到的错误。这其中有个非常重要的参数“request.required.acks”，这个参数决定了producer要求leader partition收到确认的副本个数：</p>
<ul>
<li>如果acks设置为0，表示producer不会等待broker的相应，所以，producer无法知道消息是否发生成功，这样有可能导致数据丢失，但同时，acks值为0会得到最大的系统吞吐量。</li>
<li>若acks设置为1，表示producer会在leader partition收到消息时得到broker的一个确认，这样会有更好的可靠性，因为客户端会等待知道broker确认收到消息。</li>
<li>若设置为-1，producer会在所有备份的partition收到消息时得到broker的确认，这个设置可以得到最高的可靠性保证。</li>
</ul>
<h3 id="5、exception"><a href="#5、exception" class="headerlink" title="5、exception"></a>5、exception</h3><p>bean注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ConsumerAwareListenerErrorHandler consumerAwareErrorHandler() &#123;</span><br><span class="line">    return (message, exception, consumer) -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;消费异常：&quot;+message.getPayload());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费异常配置注解实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, groupId = &quot;felix-group0&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage1(ConsumerRecord&lt;?,?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;简单消费：&quot; + record.topic() + &quot;--&quot; + record.partition() + &quot;--&quot; + record.value());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6、filter"><a href="#6、filter" class="headerlink" title="6、filter"></a>6、filter</h3><p>bean注入factory的时候配置好消息过滤策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置消息过滤策略</span><br><span class="line">    @Bean(value = &quot;filterContainerFactory&quot;)</span><br><span class="line">    public ConcurrentKafkaListenerContainerFactory concurrentKafkaListenerContainerFactory() &#123;</span><br><span class="line">        ConcurrentKafkaListenerContainerFactory factory = new ConcurrentKafkaListenerContainerFactory();</span><br><span class="line">        factory.setConsumerFactory(consumerFactory);</span><br><span class="line">        // 被过滤的消息将被丢弃</span><br><span class="line">        factory.setAckDiscarded(true);</span><br><span class="line">        // 消息过滤策略</span><br><span class="line">        factory.setRecordFilterStrategy(consumerRecord -&gt; &#123;</span><br><span class="line">            if (Integer.parseInt(consumerRecord.value().toString()) % 2 == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return factory;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>消费异常配置注解实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息过滤监听</span><br><span class="line">    @KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, containerFactory = &quot;filterContainerFactory&quot;)</span><br><span class="line">    public void onMessage6(ConsumerRecord&lt;?, ?&gt; record) &#123;</span><br><span class="line">        System.out.println(record.value());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、序列化编码解码"><a href="#7、序列化编码解码" class="headerlink" title="7、序列化编码解码"></a>7、序列化编码解码</h3><p>序列化器都实现了接口（<code>org.apache.kafka.common.serialization.Serializer</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Serializer&lt;T&gt; extends Closeable &#123;</span><br><span class="line">	default void configure(Map&lt;String, ?&gt; configs, Boolean isKey) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	byte[] serialize(String var1, T var2);</span><br><span class="line">	default byte[] serialize(String topic, Headers headers, T data) &#123;</span><br><span class="line">		return this.serialize(topic, data);</span><br><span class="line">	&#125;</span><br><span class="line">	default void close() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们只用去实现serialize即可</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><pre><code>public class MySerializer implements Serializer &#123;
    @Override
    public byte[] serialize(String s, Object o) &#123;
        String json = JSON.toJSONString(o);
        return json.getBytes();
&#125;
&#125;
</code></pre>
<h4 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyDeserializer implements Deserializer &#123;</span><br><span class="line">    private final static Logger logger = LoggerFactory.getLogger(MyDeserializer.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object deserialize(String s, byte[] bytes) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String json = new String(bytes,&quot;utf-8&quot;);</span><br><span class="line">            return JSON.parse(json);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后在application中配置key-serializer 和 value-serializer</p>
<h3 id="8、分区策略"><a href="#8、分区策略" class="headerlink" title="8、分区策略"></a>8、分区策略</h3><p>分区策略一般分为四种情况：</p>
<ul>
<li>有分区号，直接将数据发送到指定的分区里面去</li>
<li>没有分区号，但是给了数据的key值，根据key取hashCode进行分区</li>
<li>分区号和key值都没有，直接使用默认的轮循分区</li>
<li>自定义分区</li>
</ul>
<h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试</span><br><span class="line">        kafkaTemplate.send(&quot;test&quot;, 0, key, &quot;key=&quot; + key + &quot;，msg=指定0号分区&quot;);</span><br><span class="line">        kafkaTemplate.send(&quot;test&quot;, key, &quot;key=&quot; + key + &quot;，msg=不指定分区&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line"><span class="comment">//        定义自己的分区策略</span></span><br><span class="line"><span class="comment">//                如果key以0开头，发到0号分区</span></span><br><span class="line"><span class="comment">//                其他都扔到1号分区</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyStr</span> <span class="operator">=</span> key+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (keyStr.startsWith(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitionTemplate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.kafka.bootstrap-servers&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKafkaTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);</span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        <span class="comment">//注意分区器在这里！！！</span></span><br><span class="line">        props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, MyPartitioner.class);</span><br><span class="line">        <span class="built_in">this</span>.kafkaTemplate = <span class="keyword">new</span> <span class="title class_">KafkaTemplate</span>&lt;String, String&gt;(<span class="keyword">new</span> <span class="title class_">DefaultKafkaProducerFactory</span>&lt;&gt;(props));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> KafkaTemplate <span class="title function_">getKafkaTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试自定义分区发送</span><br><span class="line">@RestController</span><br><span class="line">public class MyPartitionProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    MyPartitionTemplate template;</span><br><span class="line"></span><br><span class="line">//    使用0开头和其他任意字母开头的key发送消息</span><br><span class="line">//    看控制台的输出，在哪个分区里？</span><br><span class="line">    @GetMapping(&quot;/kafka/myPartitionSend/&#123;key&#125;&quot;)</span><br><span class="line">    public void setPartition(@PathVariable(&quot;key&quot;) String key) &#123;</span><br><span class="line">        template.getKafkaTemplate().send(&quot;test&quot;, key,&quot;key=&quot;+key+&quot;，msg=自定义分区策略&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/04/springboot%E6%95%B4%E5%90%88kafka3-1-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/"
                aria-label="NEUERE BEITRÄGE"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEUERE BEITRÄGE</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/page/3/"
                aria-label="ÄLTERE BEITRÄGE"
            >
              <span>ÄLTERE BEITRÄGE</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">Seite 2 von 3</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 CSEN. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
            <h4 id="about-card-name">CSEN</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                浙江温州
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-39paoi2hupf5wmw7ojejrxpco6edftjriz5ezbtp4grymrdceksftgan2adp.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
