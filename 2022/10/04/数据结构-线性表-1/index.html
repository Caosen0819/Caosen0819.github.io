
<!DOCTYPE html>
<html lang="zh-CH">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="森">
    <title>数据结构-线性表 - 森</title>
    <meta name="author" content="CSEN">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CSEN","sameAs":["https://github.com/Caosen0819"],"image":"head.jpg"},"articleBody":"线性表\n线性结构特点：在数据元素的非空有限集合中\n\n(1)存在唯一的一个被称做“第一个”的数据元素；\n(2)存在唯一的一个被称做“最后一个”的数据元素；\n\n\n(3)除第一个之外，集合中的每个数据元素均只有一个前驱；(4)除最后一个之外，集合中每个数据元素均只有一个后继。\n\n线性表定义：有限个性质相同的数据元素组成的序列。\n\n\n线性表的存储结构：顺序存储结构和链式存储结构\n\n\n\n顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。\n通常用一维数组来描述数据结构中的顺序存储结构。\n\n\n链式存储结构: 其结点在存储器中的位置是随意的，即逻辑上相邻的数据元素在物理上不一定相邻。通过指针来实现。\n\n\n\n顺序表顺序表把线性表的所有元素按照其逻辑顺序，依次存储到从指定的存储位置开始的一块连续的存储结构空间中中。\n\n链表在存储链表中，每个节点不仅包含所存元素的信息，还包含元素之间逻辑关系的信息。可以通过前驱结点中的地址信息找到后继结点的位置。\n\n两者存储结构比较\n\n顺序表的特性：(其实就是数组)随机访问特性。占用连续的存储空间。\n链表的特性：不支持随机访问的特性。结点的存储空间利用率较顺序表稍微低一些。不需要一次性划分所有结点所需空间给链表。\n链表支持存储空间的动态分配。顺序表在做插入操作的时候需要移动多个元素链表进行插入操作无需移动元素\n\n\n4.链表的5种形式\n\n1 单链表\n\n带头结点与不带头结点的区别：\n\n带头结点的单链表有一个结点不存储信息，而不带头结点的单链表所有结点都存储信息。\n\n\n2 双链表\n- \n\n3 循环单链表\n\n环单链表可以实现从任一结点出发访问链表的任何结点，而单链表从任一结点出发后只能访问这个结点本身及其后边的所有结点。带头结点的循环单链表，链表空，head&#x3D;head-&gt;next;不带头结点，链表空，head&#x3D;NULL\n\n\n\n\n4 循环双链表\n\n循环双链表即终端结点的next指针指向链表中的第一个结点，将链表中第一个结点的prior指针指向终端结点\n\n\n\n\n5 静态链表\n\n静态链表借助一维数组来表示。静态链表来自于一个结构体数组，数组中每一个结点含有两个分量：一个数据元素分量data;另个一个是指针分量，指示了当前结点的直接后继结点在数组中的位置。\n\n\n\n考研中遇到考顺序表和链表的比较：\n基于空间的比较\n\n1.存储方式的比较：\n顺序表的存储空间是一次性分配，链表的存储空间是多次分配。\n2.存储密度：(存储密度&#x3D;结点值域所占存储量&#x2F;结点结构所占的存储量)：\n顺序表的存储密度&#x3D;1，链表的存储密度&lt;1(因为结点中有指针域)\n\n基于时间的比较\n\n1.存储方式：\n顺序表可以随机存储，也可以顺序存储，链表只能顺序存储\n2.插入、删除时移动元素的个数:\n顺序表平均需要移动一半的元素；链表不需要移动，只需要修改指针。\n对顺序表平均需要移动近一半元素，链表不需要移动元素，只需要修改指针。\n具有n个元素的顺序表，插入一个元素所进行的平均移动个数是多少，\n1）求概率，是随机的，可能性相同，有n个可插入位置，所以任何一个位置被插入元素的概率为p&#x3D;1&#x2F;n；\n2）求对应于每个插入位置需要移动元素个数。\n假设要把新元素插入在表中第i个圆度之后，则需要将第i个元素之后的所有元素往后移动一个为置，因此移动元素个数为n-i。\n由1和2可知，移动元素个数的期望E为：\nE&#x3D;n-1&#x2F;2\n插入和删除算法的平均时间复杂度为O（n).\n\n\n顺序表的定义&gt; 1.线性表的顺序存储又称顺序表&gt; 2.元素的逻辑顺序与物理顺序相同&gt; 3.顺序存储结构是一种随机存储结构&gt; 4.特点：&gt; \t1）顺序表的随机访问：通过首地址和元素符号在O(1)时间内找到指定的元素&gt;\t2）储存密度高，每个节点只存储数据元素&gt;\t3）由于逻辑相邻与物理相邻，所以插入和删除操作需要移动大量的元素一维数组可以是静态分配的，也可以是动态分配的。#define MaxSize 50  //定义线性表的最大长度typedef struct&#123;\tElemType data[MaxSize];   //顺序表的元素\tint length;\t\t\t\t  //顺序表的当前长度&#125;SqList;\t\t\t\t\t  //顺序表的类型定义动态分配时，存储数组的空间是在程序执行过程中通过动态存储语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为顺序表一次性划分所有空间。#define InitSize 100  //表长度的初始定义typedef struct&#123;\tElemType *data;   //指示动态分配数组的指针\tint MaxSize,length;\t\t\t\t  //数组最大容量和当前定义&#125;SeqList;\t\t\t\t\t  //动态分配数组顺序表的类型定义分配存储空间的语句C：\t  L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);C++： L.data=new ElemType(InitSize);注意：动态分配并不是链式存储，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时动态决定。\n\n顺序表的插入1.插入操作 【在顺序表L的第i（1&lt;i&lt;L.length+1）个位置插入新元素e】#define MaxSize 10typedef struct&#123;\tint data[MaxSize];\tint length;&#125;SqList;bool ListInsert(SqList &amp;L,int i,ElemType e)&#123;\tif(i&lt;1 || i&gt;L.length+1)  // 判断i的范围是否有效\t\treturn false;\tif(L.length&gt;=MaxSize)\t//当前存储空间已满不能插入\t\treturn false;       \tfor(int j=L.length;j&gt;=i;j--)  //将第i个即以后元素往后移\t\tL.data[j]=L.data[j-1];\tL.data[i-1]=e;   //在位置i放置e\tL.lenght++;      //线性表长度+1\treturn true;&#125;int main()&#123;................&#125;注意：区别顺序表的位序和数组下标。为何判断插入位置是否合法时 if语句中用length+1，而移动元素的for语句中只用length？答：\t1.首先明确，位序从 1 开始，数组下标从 0 开始；这里 i 是指 位序；\t2.if语句：分析两种种情况(前提：线性表未满)：\t\t\t\t1）length+2的情况：i的范围是[1，length+2],length+2所插入的位置在顺序表上是断档，违背顺序表定义（一组地址连续的存储单元逻辑上相邻的两个元素的物理位置上也相邻）\t\t\t\t2）length的情况：i的范围是[1，length],顺序表上length+1位置是空的\t3.for语句：到for语句时，说明至少有一个可插入的位置；\t\t\t   j=L.length时，保证最后一个数组元素可以移到数组的后一个位置而不产生数组越界异常\t\t2.在不同位置进行插入操作的时间复杂度（n为length）\t1)最好情况：表尾插入（i=n+1），元素后移语句不执行，复杂度O(1);\t2)最坏情况：表头插入(i=1)，元素后移语句执行n次，复杂度O(n);\t3)平均情况：略，复杂度O(n);\n\n顺序表的删除1.删除操作 【删除顺序表L中第i(1&lt;=i&lt;=L.length)个位置的元素，用引用变量e返回】#define MaxSize 10typedef struct&#123;\tint data[MaxSize];\tint length;&#125;SqList;bool ListDelete(SqList &amp;L,int i,ElemType &amp;e)&#123;\tif(i&lt;1||i&gt;L.length)    //判断i的范围是否有效\t\treutrn false;\te=L.data[i-1];     //e保存将要被删的值\tfor(int j=i;j&lt;L.length;j++)    //第i个位置后的元素前移\t\tL.data[j-1]=L.data[j];\tL.length--;\treturn true;&#125;int main()&#123;................&#125;2.在不同位置进行删除操作的时间复杂度（n为length）\t1)最好情况：删除表尾元素(i=n)，元素前移语句不执行，复杂度O(1);\t2)最坏情况：删除表头元素（i=1），元素前移语句执行n次，复杂度O(n);\t3)平均情况：略，复杂度O(n);\n\n按值查找1.按值查找（顺序查找）【在顺序表L中查找第一个元素值等于e的元素，并返回其位序】#define MaxSize 10typedef struct&#123;\tint data[MaxSize];\tint length;&#125;SqList;int LocateElem(SqList L,Elem e)&#123;\tint i;\tfor(i=0;i&lt;L.length;i++)\t\tif(L.data[i]===e)\t\t\treturn i+1;\treturn 0;&#125;int main()&#123;................&#125;2.时间复杂度（n为length）\t1)最好情况：查找的元素就在表头，仅需比较1次，复杂度为O(1);\t2)最坏情况：查找的元素就在表尾，需比较n次，复杂度为O(n);\t3)平均情况：略，O(n);\n\n单链表的操作例题将AB，插入C中 归并，尾插\n\n\nvoid merge(LNode *A,LNode *B,LNode *&amp;C)&#123; \tLNode *P=A-&gt;next;//p来跟踪A的最小值结点。A-&gt;next表示A链表的开始结点（头结点后边一个结点），A链表是递增，所以最前面的是最小节点。    LNode *q=B-&gt;next;    LNode *r;//r始终指向C的终端结点    C=A;//用A的头结点做C的头结点    C-&gt;next=NULL;    free(B);//B头结点无用，释放掉    r=C;//r指向C，因此头结点是终端结点    while(p!=NULL&amp;&amp;q!=NULL)//当p与q不空时，选取p与q所指结点中较小的插入c的尾部，       //以下的if else语句中，r始终指向当前链表终端结点，作为接纳新结点的一个媒介，通过他，新节点被链接入c并且重新指向新的终端接点，以便接受下一个新节点，这里是尾插法的思想    &#123;\t\tif(p-&gt;data&lt;=q-&gt;data)        &#123;            r-&gt;next=p;p=p-&gt;next;            r=er-&gt;next;        &#125;        else        &#123;            r-&gt;next=q;q=q-&gt;next                r=r-&gt;next;        &#125;    &#125;    r-&gt;next=NULL；        //以下两个语句将还有剩余的结点的链表连接在C的尾部        if(p!=NULL) r-&gt;next=p;        if(q!=NULL) r-next=q;&#125;\n\n假设有n个元素已经存储数组a中，用尾插法建立链表c\nvoid createlistR(LNode *&amp;C,int a[],int n)//要改变的变量用引用型&#123;\tLNode *s,*r;//s用来指向新申请的结点，r始终指向c的终端    int i;///    C=(LNode*)malloc(sizeof(LNode));//申请C的头结点空间    C-&gt;next=NULL;    r=c;//r指向头结点，因为此时头结点就是终端结点 \tfor(i=0;i&lt;n;++1)//循环申请n个结点来接受数组a中元素    &#123;        s=(LNode*)malloc(sizeof(LNode));//s指向新申请的结点        s-&gt;data=a[i];//用新申请的结点来接受a中的一个元素        r-&gt;next=s;//用r来接纳新结点        r=r-&gt;next;//r指向终端结点，以便于接纳下一个新到来的结点    &#125;    r-&gt;next=NULL;//数组a中所有的元素都已经装入链表c中，c的终端结点的指针域置为为null，c建立完成&#125;\n\n\n\n头插法建表\nvoid createlistF(LNode *&amp;C,int a[],int n)&#123;    LNode *s;    int i;    C=(LNode*)malloc(sizeof(LNode));    C-&gt;next=NULL;    for(i=0;i&lt;n;++i)    &#123;        s=(LNode*)malloc(sizeof(LNode));        s-&gt;data=a[i];        //下面两句是头插法的关键        s-&gt;next=C-&gt;next;//s所指新节点的指针域next指向C中的开始结点        C-&gt;next=s;//头指针的指针域next指向s结点，使得s成为新的开始结点    &#125;&#125;\n\n\n归并成递减的单链表的算法\nvoid merge(LNode *A,LNode *B,LNode *&amp;C)&#123;\tLNode *p=A-&gt;next;    LNode *q=B-&gt;next;    LNode *s;    C=A;    C-&gt;next=NULL;    free(B);    while(p!=NULL&amp;&amp;q!=NULL)    &#123;//头插法        if(p-&gt;data&lt;=q-&gt;data)        &#123;            s=p;p=p-&gt;next;            s-&gt;next=C-&gt;next;            C-next=s;        &#125;        else        &#123;            s=q;q=q-&gt;next;            s-&gt;next=C-&gt;next;            C-&gt;next=s;\t\t&#125;    &#125;    //下边这两个循环是和求增递归并序列不同的地方，必须将剩余元素逐个插入c的头部才能得到最终递减序列    while(p!NULL)    &#123;        s=p;        p=p-&gt;next;        s-&gt;next=C-&gt;next;        C-&gt;next=s;    &#125;    while(q!=NULL)    &#123;        s=q;        q=q-&gt;next;        s-&gt;next=C-&gt;next;        C-&gt;next=s;    &#125;&#125;\n\n\n\n插入操作\ns-&gt;next=p-&gt;next;p-next=s;\n\n删除操作\nq=p-&gt;next;p-&gt;next=p-&gt;next-&gt;next;free(q);\n\n\n双链表的操作1.采用尾插法建立双链表\nvoid createDlistR(DLNode *&amp;L.int a[],int n)&#123;    DLNode *s,*r;    int i;    L=(DLNode*)malloc(sizeof(DLNode));    L-&gt;prior=NULL;    L-&gt;next=NULL;    r=L;//和单链表一样，r始终指向终端结点，开始头结点也是尾结点    for(i=0;i&lt;n;++i)    &#123;        s=(DLNode*)malloc(sizeof(DLNode));//创建新结点        s-&gt;data=a[i];       //下面3句将s插入到L的尾部，并且r指向s。        r-&gt;next=s;        s-&gt;prior=r;        r=s;    &#125;    r-&gt;next=NULL;    &#125;\n\n\n\n\n2.查找结点的算法\n在双链表中查找第一个值为x的结点，从第一个结点开始，边扫描边比较，若找到这样的结点，则返回结点指针，否则返回NULL。DLNode* findNode(DLNode *C.,int x)&#123;    DLNode *p=C-&gt;next;    while(p!=NULL)    &#123;        if(p-data==x)        break;        p=p-&gt;next;    &#125;    return p;//如果找到，则p中内容是结点地址（循环因break结束）；如果没找到，则p中内容是Null(循环因p等于NULL而结束)。因此这一句话将要求的两种返回值得情况统一起来。&#125;\n\n3.插入结点的算法\n假设在双链表中p所指的结点之后插入一个结点s.s-&gt;next=p-&gt;next;s-&gt;prior=p;p-&gt;next=s;s-&gt;next-&gt;prior=s;//加入p指向最后一个结点，则本行可去掉\n\n\n4.删除结点算法\n设要删除双链表中p结点的后继结点q=p-&gt;next;p-&gt;next=q-&gt;next;q-&gt;next-&gt;prior=p;free(q);\n\n\n5.循环链表的操作循环单链表和循环双链表是有对应的单链表和双链表改造来得，只需在终端结点和头结点建立联系即可。循环单链表终端结点的next结点指针向表头结点；循环双链表终端接结点的next指针指向表头结点，头结点的prior指针向表尾结点。需要注意的是，如果p指针压着循环链表行走，则判断p走到表尾结点的条件是p-&gt;next&#x3D;&#x3D;head.\n6.逆置问题给定一个线性表，如何将其中的元素逆置？可设置两个整型变量i和j，i指向最后一个元素，边交换i和j所指元素，边让i和j相向而行，直到遇到，实现代码如下：\n假设元素存在于数组a[]中，left和right是数组两端元素的下标。\nfor(int i=left,j=right;i&lt;j;++i,--j)&#123;\ttemp=a[i];\ta[i]=a[j];\ta[j]=temp;&#125;\n\n\n分析：\n（1）只需要逆置整个数组，即可满足前端k个元素逆序后放到数组的后端，如下图：\n\nvoid reverse(int a[],int left,int right,int k)&#123;\tint temp;\tfor(int i=left,j=right;i&lt;left+k;&amp;&amp;i&lt;j;++i,--j)\t&#123;\t\ttemp=a[i];\t\ta[j]=a[j];\t\ta[j]=temp;\t&#125;&#125;\n\n\n(2)只需要将前端k个元素逆置，然后将整个数组逆置，即满足前端k个元素保持原序放到数组后端，如下图\n\nvoid moveToEnd(int a[],int n,int k)&#123;\t//调用（1）中的实现的reverse()函数：\treverse(a,0,k-1,k);\treverse(a,0,n-1,k);&#125;\n\n\n(3)只需要将0p-1位置逆置，在将pn-1位置元素逆置，然后再将整个数组逆置\nvoid movep(int a[],int n,int p)&#123;\t//调用（1）中实现的reverse（）函数：\treverse(a,0,p-1,p);\treverse(a,p,n-1,n-p);\treverse(a,0,n-1,n);&#125;\n\n​\t\n​\t\n","dateCreated":"2022-10-04T13:33:19+08:00","dateModified":"2022-10-04T13:33:49+08:00","datePublished":"2022-10-04T13:33:19+08:00","description":"线性表\n线性结构特点：在数据元素的非空有限集合中\n\n(1)存在唯一的一个被称做“第一个”的数据元素；\n(2)存在唯一的一个被称做“最后一个”的数据元素；\n\n\n(3)除第一个之外，集合中的每个数据元素均只有一个前驱；(4)除最后一个之外，集合中每个数据元素均只有一个后继。\n\n线性表定义：有限个性质相同的数据元素组成的序列。","headline":"数据结构-线性表","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"},"publisher":{"@type":"Organization","name":"CSEN","sameAs":["https://github.com/Caosen0819"],"image":"head.jpg","logo":{"@type":"ImageObject","url":"head.jpg"}},"url":"http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/","keywords":"数据结构"}</script>
    <meta name="description" content="线性表 线性结构特点：在数据元素的非空有限集合中  (1)存在唯一的一个被称做“第一个”的数据元素； (2)存在唯一的一个被称做“最后一个”的数据元素；   (3)除第一个之外，集合中的每个数据元素均只有一个前驱；(4)除最后一个之外，集合中每个数据元素均只有一个后继。  线性表定义：有限个性质相同的数据元素组成的序列。">
<meta property="og:type" content="blog">
<meta property="og:title" content="数据结构-线性表">
<meta property="og:url" content="http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/index.html">
<meta property="og:site_name" content="森">
<meta property="og:description" content="线性表 线性结构特点：在数据元素的非空有限集合中  (1)存在唯一的一个被称做“第一个”的数据元素； (2)存在唯一的一个被称做“最后一个”的数据元素；   (3)除第一个之外，集合中的每个数据元素均只有一个前驱；(4)除最后一个之外，集合中每个数据元素均只有一个后继。  线性表定义：有限个性质相同的数据元素组成的序列。">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="http://example.com/img/2-1.png">
<meta property="og:image" content="http://example.com/img/2-2.png">
<meta property="og:image" content="http://example.com/img/2-4.png">
<meta property="og:image" content="http://example.com/img/2-5.png">
<meta property="og:image" content="http://example.com/img/2-6.png">
<meta property="og:image" content="http://example.com/img/2-7.png">
<meta property="og:image" content="http://example.com/img/2-8.png">
<meta property="og:image" content="http://example.com/img/2-9.png">
<meta property="og:image" content="http://example.com/img/2-10.png">
<meta property="og:image" content="http://example.com/img/2-11.png">
<meta property="og:image" content="http://example.com/img/2-12.png">
<meta property="og:image" content="http://example.com/img/2-13.png">
<meta property="article:published_time" content="2022-10-04T05:33:19.000Z">
<meta property="article:modified_time" content="2022-10-04T05:33:49.459Z">
<meta property="article:author" content="CSEN">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/2-1.png">
    
    
        
    
    
        <meta property="og:image" content="http://example.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-w816scvuzwavitjylabixcb3ofuoklqul47j3rgwu1r0mxrxvbdehvp2jk5s.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            森
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Lesen Sie mehr über den Autor"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
                </a>
                <h4 class="sidebar-profile-name">CSEN</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="档案"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">档案</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/Caosen0819"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title=".github"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">.github</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            数据结构-线性表
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2022-10-04T13:33:19+08:00">
	
		    04 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ul>
<li><p>线性结构特点：在数据元素的非空有限集合中</p>
<ul>
<li>(1)存在唯一的一个被称做“第一个”的数据元素；</li>
<li>(2)存在唯一的一个被称做“最后一个”的数据元素；</li>
</ul>
</li>
<li><p>(3)除第一个之外，集合中的每个数据元素均只有一个前驱；(4)除最后一个之外，集合中每个数据元素均只有一个后继。</p>
</li>
<li><p>线性表定义：有限个性质相同的数据元素组成的序列。</p>
<span id="more"></span>
</li>
<li><p>线性表的存储结构：顺序存储结构和链式存储结构</p>
</li>
</ul>
<blockquote>
<p>顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。</p>
<p>通常用一维数组来描述数据结构中的顺序存储结构。</p>
</blockquote>
<blockquote>
<p>链式存储结构: 其结点在存储器中的位置是随意的，即逻辑上相邻的数据元素在物理上不一定相邻。通过指针来实现。</p>
</blockquote>
<p><img src="/../img/2-1.png"></p>
<ul>
<li><p>顺序表<br>顺序表把线性表的所有元素按照其逻辑顺序，依次存储到从指定的存储位置开始的一块连续的存储结构空间中中。</p>
</li>
<li><p>链表<br>在存储链表中，每个节点不仅包含所存元素的信息，还包含元素之间逻辑关系的信息。可以通过前驱结点中的地址信息找到后继结点的位置。</p>
</li>
<li><p>两者存储结构比较</p>
<ul>
<li>顺序表的特性：(其实就是数组)<br><strong>随机</strong>访问特性。<br>占用<strong>连续</strong>的存储空间。</li>
<li>链表的特性：<br><strong>不支持随机访问</strong>的特性。<br>结点的存储空间利用率较顺序表稍微低一些。<br>不需要一次性划分所有结点所需空间给链表。</li>
<li>链表支持存储空间的动态分配。<br>顺序表在做插入操作的时候需要移动多个元素<br>链表进行插入操作无需移动元素</li>
</ul>
</li>
<li><p>4.链表的5种形式</p>
<ul>
<li><p>1 单链表</p>
<ul>
<li>带<strong>头结点</strong>与<strong>不带头结点</strong>的区别：</li>
</ul>
<p>带头结点的单链表有一个结点不存储信息，而不带头结点的单链表所有结点都存储信息。</p>
<p><img src="/../img/2-2.png"></p>
</li>
<li><p>2 双链表</p>
<p>- </p>
</li>
<li><p>3 循环单链表</p>
<ul>
<li><p>环单链表可以实现从任一结点出发访问链表的任何结点，而单链表从任一结点出发后只能访问这个结点本身及其后边的所有结点。带头结点的循环单链表，<em><strong>链表空</strong></em>，head&#x3D;head-&gt;next;不带头结点，<strong>链表空</strong>，head&#x3D;NULL</p>
<p><img src="/../img/2-4.png"></p>
</li>
</ul>
</li>
<li><p>4 循环双链表</p>
<ul>
<li><p>循环双链表即终端结点的next指针指向链表中的第一个结点，将链表中第一个结点的prior指针指向终端结点</p>
<p><img src="/../img/2-5.png"></p>
</li>
</ul>
</li>
<li><p>5 静态链表</p>
<ul>
<li><p>静态链表借助一维数组来表示。静态链表来自于一个<strong>结构体数组</strong>，数组中每一个结点含有两个分量：一个数据元素分量data;另个一个是指针分量，指示了当前结点的直接后继结点在数组中的位置。</p>
<p><img src="/../img/2-6.png"></p>
</li>
</ul>
<h3 id="考研中遇到考顺序表和链表的比较："><a href="#考研中遇到考顺序表和链表的比较：" class="headerlink" title="考研中遇到考顺序表和链表的比较："></a>考研中遇到考顺序表和链表的比较：</h3><ul>
<li>基于空间的比较</li>
</ul>
<p>1.存储方式的比较：</p>
<p>顺序表的存储空间是一次性分配，链表的存储空间是多次分配。</p>
<p>2.存储密度：(存储密度&#x3D;结点值域所占存储量&#x2F;结点结构所占的存储量)：</p>
<p>顺序表的存储密度&#x3D;1，链表的存储密度&lt;1(因为结点中有指针域)</p>
<ul>
<li>基于时间的比较</li>
</ul>
<p>1.存储方式：</p>
<p>顺序表可以随机存储，也可以顺序存储，链表只能顺序存储</p>
<p>2.插入、删除时移动元素的个数:</p>
<p>顺序表平均需要移动一半的元素；链表不需要移动，只需要修改指针。</p>
<p>对顺序表平均需要移动近一半元素，链表不需要移动元素，只需要修改指针。</p>
<p>具有n个元素的顺序表，插入一个元素所进行的平均移动个数是多少，</p>
<p>1）求概率，是随机的，可能性相同，有n个可插入位置，所以任何一个位置被插入元素的概率为p&#x3D;1&#x2F;n；</p>
<p>2）求对应于每个插入位置需要移动元素个数。</p>
<p>假设要把新元素插入在表中第i个圆度之后，则需要将第i个元素之后的所有元素往后移动一个为置，因此移动元素个数为n-i。</p>
<p>由1和2可知，移动元素个数的期望E为：</p>
<p>E&#x3D;n-1&#x2F;2</p>
<p>插入和删除算法的平均时间复杂度为O（n).</p>
</li>
</ul>
<h4 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">1.</span>线性表的顺序存储又称顺序表</span><br><span class="line">&gt; <span class="number">2.</span>元素的逻辑顺序与物理顺序相同</span><br><span class="line">&gt; <span class="number">3.</span>顺序存储结构是一种随机存储结构</span><br><span class="line">&gt; <span class="number">4.</span>特点：</span><br><span class="line">&gt; 	<span class="number">1</span>）顺序表的随机访问：通过首地址和元素符号在<span class="built_in">O</span>(<span class="number">1</span>)时间内找到指定的元素</span><br><span class="line">&gt;	<span class="number">2</span>）储存密度高，每个节点只存储数据元素</span><br><span class="line">&gt;	<span class="number">3</span>）由于逻辑相邻与物理相邻，所以插入和删除操作需要移动大量的元素</span><br><span class="line">一维数组可以是静态分配的，也可以是动态分配的。</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50  <span class="comment">//定义线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType data[MaxSize];   <span class="comment">//顺序表的元素</span></span><br><span class="line">	<span class="type">int</span> length;				  <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;					  <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line">动态分配时，存储数组的空间是在程序执行过程中通过动态存储语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为顺序表一次性划分所有空间。</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100  <span class="comment">//表长度的初始定义</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType *data;   <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">	<span class="type">int</span> MaxSize,length;				  <span class="comment">//数组最大容量和当前定义</span></span><br><span class="line">&#125;SeqList;					  <span class="comment">//动态分配数组顺序表的类型定义</span></span><br><span class="line">分配存储空间的语句</span><br><span class="line">C：	  L.data=(ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*InitSize);</span><br><span class="line">C++： L.data=<span class="keyword">new</span> <span class="built_in">ElemType</span>(InitSize);</span><br><span class="line">注意：动态分配并不是链式存储，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时动态决定。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>插入操作 【在顺序表L的第i（<span class="number">1</span>&lt;i&lt;L.length+<span class="number">1</span>）个位置插入新元素e】</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> data[MaxSize];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>)  <span class="comment">// 判断i的范围是否有效</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.length&gt;=MaxSize)	<span class="comment">//当前存储空间已满不能插入</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)  <span class="comment">//将第i个即以后元素往后移</span></span><br><span class="line">		L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">	L.data[i<span class="number">-1</span>]=e;   <span class="comment">//在位置i放置e</span></span><br><span class="line">	L.lenght++;      <span class="comment">//线性表长度+1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">................</span><br><span class="line">&#125;</span><br><span class="line">注意：区别顺序表的位序和数组下标。为何判断插入位置是否合法时 <span class="keyword">if</span>语句中用length+<span class="number">1</span>，而移动元素的<span class="keyword">for</span>语句中只用length？</span><br><span class="line">答：</span><br><span class="line">	<span class="number">1.</span>首先明确，位序从 <span class="number">1</span> 开始，数组下标从 <span class="number">0</span> 开始；这里 i 是指 位序；</span><br><span class="line">	<span class="number">2.</span><span class="keyword">if</span>语句：分析两种种情况(前提：线性表未满)：</span><br><span class="line">				<span class="number">1</span>）length+<span class="number">2</span>的情况：i的范围是[<span class="number">1</span>，length+<span class="number">2</span>],length+<span class="number">2</span>所插入的位置在顺序表上是断档，违背顺序表定义（一组地址连续的存储单元逻辑上相邻的两个元素的物理位置上也相邻）</span><br><span class="line">				<span class="number">2</span>）length的情况：i的范围是[<span class="number">1</span>，length],顺序表上length+<span class="number">1</span>位置是空的</span><br><span class="line"></span><br><span class="line">	<span class="number">3.f</span><span class="keyword">or</span>语句：到<span class="keyword">for</span>语句时，说明至少有一个可插入的位置；</span><br><span class="line">			   j=L.length时，保证最后一个数组元素可以移到数组的后一个位置而不产生数组越界异常</span><br><span class="line">		</span><br><span class="line"><span class="number">2.</span>在不同位置进行插入操作的时间复杂度（n为length）</span><br><span class="line">	<span class="number">1</span>)最好情况：表尾插入（i=n+<span class="number">1</span>），元素后移语句不执行，复杂度<span class="built_in">O</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="number">2</span>)最坏情况：表头插入(i=<span class="number">1</span>)，元素后移语句执行n次，复杂度<span class="built_in">O</span>(n);</span><br><span class="line">	<span class="number">3</span>)平均情况：略，复杂度<span class="built_in">O</span>(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>删除操作 【删除顺序表L中第<span class="built_in">i</span>(<span class="number">1</span>&lt;=i&lt;=L.length)个位置的元素，用引用变量e返回】</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> data[MaxSize];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">		reutrn <span class="literal">false</span>;</span><br><span class="line">	e=L.data[i<span class="number">-1</span>];     <span class="comment">//e保存将要被删的值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)    <span class="comment">//第i个位置后的元素前移</span></span><br><span class="line">		L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">................</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>在不同位置进行删除操作的时间复杂度（n为length）</span><br><span class="line">	<span class="number">1</span>)最好情况：删除表尾元素(i=n)，元素前移语句不执行，复杂度<span class="built_in">O</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="number">2</span>)最坏情况：删除表头元素（i=<span class="number">1</span>），元素前移语句执行n次，复杂度<span class="built_in">O</span>(n);</span><br><span class="line">	<span class="number">3</span>)平均情况：略，复杂度<span class="built_in">O</span>(n);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>按值查找（顺序查找）【在顺序表L中查找第一个元素值等于e的元素，并返回其位序】</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> data[MaxSize];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,Elem e)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">		<span class="keyword">if</span>(L.data[i]===e)</span><br><span class="line">			<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">................</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>时间复杂度（n为length）</span><br><span class="line">	<span class="number">1</span>)最好情况：查找的元素就在表头，仅需比较<span class="number">1</span>次，复杂度为<span class="built_in">O</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="number">2</span>)最坏情况：查找的元素就在表尾，需比较n次，复杂度为<span class="built_in">O</span>(n);</span><br><span class="line">	<span class="number">3</span>)平均情况：略，<span class="built_in">O</span>(n);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h3><p>例题将AB，插入C中 归并，尾插</p>
<p><img src="/../img/2-7.png"></p>
<p><img src="/../img/2-8.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span><br><span class="line">&#123;</span><br><span class="line"> 	LNode *P=A-&gt;next;<span class="comment">//p来跟踪A的最小值结点。A-&gt;next表示A链表的开始结点（头结点后边一个结点），A链表是递增，所以最前面的是最小节点。</span></span><br><span class="line">    LNode *q=B-&gt;next;</span><br><span class="line">    LNode *r;<span class="comment">//r始终指向C的终端结点</span></span><br><span class="line">    C=A;<span class="comment">//用A的头结点做C的头结点</span></span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);<span class="comment">//B头结点无用，释放掉</span></span><br><span class="line">    r=C;<span class="comment">//r指向C，因此头结点是终端结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)<span class="comment">//当p与q不空时，选取p与q所指结点中较小的插入c的尾部，</span></span><br><span class="line">       <span class="comment">//以下的if else语句中，r始终指向当前链表终端结点，作为接纳新结点的一个媒介，通过他，新节点被链接入c并且重新指向新的终端接点，以便接受下一个新节点，这里是尾插法的思想</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next=p;p=p-&gt;next;</span><br><span class="line">            r=er-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next=q;q=q-&gt;next</span><br><span class="line">                r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>；</span><br><span class="line">        <span class="comment">//以下两个语句将还有剩余的结点的链表连接在C的尾部</span></span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) r-&gt;next=p;</span><br><span class="line">        <span class="keyword">if</span>(q!=<span class="literal">NULL</span>) r-next=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>假设有n个元素已经存储数组a中，用尾插法建立链表c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createlistR</span><span class="params">(LNode *&amp;C,<span class="type">int</span> a[],<span class="type">int</span> n)</span><span class="comment">//要改变的变量用引用型</span></span><br><span class="line">&#123;</span><br><span class="line">	LNode *s,*r;<span class="comment">//s用来指向新申请的结点，r始终指向c的终端</span></span><br><span class="line">    <span class="type">int</span> i;<span class="comment">///</span></span><br><span class="line">    C=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//申请C的头结点空间</span></span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    r=c;<span class="comment">//r指向头结点，因为此时头结点就是终端结点</span></span><br><span class="line"> 	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++<span class="number">1</span>)<span class="comment">//循环申请n个结点来接受数组a中元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//s指向新申请的结点</span></span><br><span class="line">        s-&gt;data=a[i];<span class="comment">//用新申请的结点来接受a中的一个元素</span></span><br><span class="line">        r-&gt;next=s;<span class="comment">//用r来接纳新结点</span></span><br><span class="line">        r=r-&gt;next;<span class="comment">//r指向终端结点，以便于接纳下一个新到来的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;<span class="comment">//数组a中所有的元素都已经装入链表c中，c的终端结点的指针域置为为null，c建立完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>头插法建表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createlistF</span><span class="params">(LNode *&amp;C,<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    C=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=a[i];</span><br><span class="line">        <span class="comment">//下面两句是头插法的关键</span></span><br><span class="line">        s-&gt;next=C-&gt;next;<span class="comment">//s所指新节点的指针域next指向C中的开始结点</span></span><br><span class="line">        C-&gt;next=s;<span class="comment">//头指针的指针域next指向s结点，使得s成为新的开始结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>归并成递减的单链表的算法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span><br><span class="line">&#123;</span><br><span class="line">	LNode *p=A-&gt;next;</span><br><span class="line">    LNode *q=B-&gt;next;</span><br><span class="line">    LNode *s;</span><br><span class="line">    C=A;</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="comment">//头插法</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            s=p;p=p-&gt;next;</span><br><span class="line">            s-&gt;next=C-&gt;next;</span><br><span class="line">            C-next=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s=q;q=q-&gt;next;</span><br><span class="line">            s-&gt;next=C-&gt;next;</span><br><span class="line">            C-&gt;next=s;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下边这两个循环是和求增递归并序列不同的地方，必须将剩余元素逐个插入c的头部才能得到最终递减序列</span></span><br><span class="line">    <span class="keyword">while</span>(p!<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=q;</span><br><span class="line">        q=q-&gt;next;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>插入操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-next=s;</span><br></pre></td></tr></table></figure>

<p><strong>删除操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>


<h3 id="双链表的操作"><a href="#双链表的操作" class="headerlink" title="双链表的操作"></a>双链表的操作</h3><p><strong>1.采用尾插法建立双链表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createDlistR</span><span class="params">(DLNode *&amp;L.<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    DLNode *s,*r;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    L=(DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">    L-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    r=L;<span class="comment">//和单链表一样，r始终指向终端结点，开始头结点也是尾结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));<span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data=a[i];</span><br><span class="line">       <span class="comment">//下面3句将s插入到L的尾部，并且r指向s。</span></span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        s-&gt;prior=r;</span><br><span class="line">        r=s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><strong>2.查找结点的算法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">在双链表中查找第一个值为x的结点，从第一个结点开始，边扫描边比较，若找到这样的结点，则返回结点指针，否则返回<span class="literal">NULL</span>。</span><br><span class="line"></span><br><span class="line">DLNode* <span class="title function_">findNode</span><span class="params">(DLNode *C.,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    DLNode *p=C-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-data==x)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//如果找到，则p中内容是结点地址（循环因break结束）；如果没找到，则p中内容是Null(循环因p等于NULL而结束)。因此这一句话将要求的两种返回值得情况统一起来。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.插入结点的算法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">假设在双链表中p所指的结点之后插入一个结点s.</span><br><span class="line"></span><br><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">s-&gt;prior=p;</span><br><span class="line">p-&gt;next=s;</span><br><span class="line">s-&gt;next-&gt;prior=s;<span class="comment">//加入p指向最后一个结点，则本行可去掉</span></span><br></pre></td></tr></table></figure>

<p><img src="/../img/2-9.png"></p>
<p><strong>4.删除结点算法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">设要删除双链表中p结点的后继结点</span><br><span class="line"></span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior=p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2-10.png"></p>
<p>5.循环链表的操作<br>循环单链表和循环双链表是有对应的单链表和双链表改造来得，只需在终端结点和头结点建立联系即可。循环单链表终端结点的next结点指针向表头结点；循环双链表终端接结点的next指针指向表头结点，头结点的prior指针向表尾结点。需要注意的是，如果p指针压着循环链表行走，则判断p走到表尾结点的条件是p-&gt;next&#x3D;&#x3D;head.</p>
<p>6.逆置问题<br>给定一个线性表，如何将其中的元素逆置？可设置两个整型变量i和j，i指向最后一个元素，边交换i和j所指元素，边让i和j相向而行，直到遇到，实现代码如下：</p>
<p>假设元素存在于数组a[]中，left和right是数组两端元素的下标。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=left,j=right;i&lt;j;++i,--j)</span><br><span class="line">&#123;</span><br><span class="line">	temp=a[i];</span><br><span class="line">	a[i]=a[j];</span><br><span class="line">	a[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2-11.png"></p>
<p>分析：</p>
<p>（1）只需要逆置整个数组，即可满足前端k个元素逆序后放到数组的后端，如下图：</p>
<p><img src="/../img/2-12.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=left,j=right;i&lt;left+k;&amp;&amp;i&lt;j;++i,--j)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=a[i];</span><br><span class="line">		a[j]=a[j];</span><br><span class="line">		a[j]=temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(2)只需要将前端k个元素逆置，然后将整个数组逆置，即满足前端k个元素保持原序放到数组后端，如下图</p>
<p><img src="/../img/2-13.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveToEnd</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//调用（1）中的实现的reverse()函数：</span></span><br><span class="line">	reverse(a,<span class="number">0</span>,k<span class="number">-1</span>,k);</span><br><span class="line">	reverse(a,<span class="number">0</span>,n<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(3)只需要将0p-1位置逆置，在将pn-1位置元素逆置，然后再将整个数组逆置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">movep</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//调用（1）中实现的reverse（）函数：</span></span><br><span class="line">	reverse(a,<span class="number">0</span>,p<span class="number">-1</span>,p);</span><br><span class="line">	reverse(a,p,n<span class="number">-1</span>,n-p);</span><br><span class="line">	reverse(a,<span class="number">0</span>,n<span class="number">-1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	</p>
<p>​	</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">GETAGGT IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/04/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC/"
                    data-tooltip="springcloud整合oauth2------认证服务篇"
                    aria-label="FRÜHER: springcloud整合oauth2------认证服务篇"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">FRÜHER</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"
                    data-tooltip="数据结构的基本概念"
                    aria-label="NÄCHSTER: 数据结构的基本概念"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NÄCHSTER</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"
                    title="Teilen auf Facebook"
                    aria-label="Teilen auf Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"
                    title="Teilen auf Twitter"
                    aria-label="Teilen auf Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"
                    title="Teilen auf Google Plus"
                    aria-label="Teilen auf Google Plus"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 CSEN. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/04/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC/"
                    data-tooltip="springcloud整合oauth2------认证服务篇"
                    aria-label="FRÜHER: springcloud整合oauth2------认证服务篇"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">FRÜHER</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"
                    data-tooltip="数据结构的基本概念"
                    aria-label="NÄCHSTER: 数据结构的基本概念"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NÄCHSTER</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"
                    title="Teilen auf Facebook"
                    aria-label="Teilen auf Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"
                    title="Teilen auf Twitter"
                    aria-label="Teilen auf Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"
                    title="Teilen auf Google Plus"
                    aria-label="Teilen auf Google Plus"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"
                        aria-label="Teilen auf Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Teilen auf Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"
                        aria-label="Teilen auf Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Teilen auf Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=http://example.com/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-1/"
                        aria-label="Teilen auf Google Plus"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Teilen auf Google Plus</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
            <h4 id="about-card-name">CSEN</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                浙江温州
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-39paoi2hupf5wmw7ojejrxpco6edftjriz5ezbtp4grymrdceksftgan2adp.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
