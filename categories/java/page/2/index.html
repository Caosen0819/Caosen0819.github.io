
<!DOCTYPE html>
<html lang="zh-CH">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="森">
    <title>Kategorie: Java - 森</title>
    <meta name="author" content="CSEN">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="潮起潮落，云卷云舒">
<meta property="og:type" content="blog">
<meta property="og:title" content="森">
<meta property="og:url" content="http://example.com/categories/Java/page/2/index.html">
<meta property="og:site_name" content="森">
<meta property="og:description" content="潮起潮落，云卷云舒">
<meta property="og:locale" content="zh_CH">
<meta property="article:author" content="CSEN">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="http://example.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-w816scvuzwavitjylabixcb3ofuoklqul47j3rgwu1r0mxrxvbdehvp2jk5s.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            森
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Lesen Sie mehr über den Autor"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
                </a>
                <h4 class="sidebar-profile-name">CSEN</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="档案"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">档案</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/Caosen0819"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title=".github"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">.github</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/07/08/CS:%E8%BE%93%E5%85%A5%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"
                            aria-label=": 输入网络，期间发生了什么？"
                        >
                            输入网络，期间发生了什么？
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-08T00:00:00+08:00">
	
		    08 Jul 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？"><a href="#输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？" class="headerlink" title="输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？"></a>输入网络，期间发生了什么，或者说两个设备之间是怎么传输的？</h1><h2 id="1、解析url"><a href="#1、解析url" class="headerlink" title="1、解析url"></a>1、解析url</h2><p>首先，就是对我们输入的url进行解析，一般可以得到三个信息：协议，web服务器，文件的路径</p>
<p>拿到这三个信息之后我们就可以包装成一个http请求信息</p>
<p>![image-20230728193306158](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728193306158.png)</p>
<p>如图所示，一个是请求一个是响应报文</p>
<p>那我们生产出一个消息之后就要开始发送？那应该怎么发？往哪里发？</p>
<p>这就需要下面的知识。</p>
<h2 id="地址查询-——-DNS"><a href="#地址查询-——-DNS" class="headerlink" title="地址查询 —— DNS"></a>地址查询 —— DNS</h2><p>基于我们已经拿到的web服务器域名，我们可以先去浏览器缓存里面找有没有，如果有，就直接返回，如果没有那就问操作系统的缓存再去看hosts文件，如果都没有，那就看走下面</p>
<p>客户端首先会发出一个 DNS 请求，问 <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</p>
<p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a target="_blank" rel="noopener" href="http://www.xx.com,则它直接返回/">www.xx.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</p>
<p>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</p>
<p>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> 的 IP 地址吗？”</p>
<p>顶级域名服务器说：“我给你负责 <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</p>
<p>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.xx.com对应的IP是啥呀？”">www.xx.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</p>
<p>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</p>
<p>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接</p>
<p>![image-20230728193808617](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728193808617.png)</p>
<p>通过dns或者缓存获取到ip地址之后，我们就要为发送做一些准备，首先浏览器通过调用 Socket 库，来委托协议栈工作。</p>
<p>![image-20230728193955912](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728193955912.png)</p>
<p>说是协议栈，其实就是中间tcp udp ip这些协议。那下面我们就来仔细的看看</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>tcp段的头如下所示：</p>
<p>![image-20230728194108402](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728194108402.png)</p>
<p>TCP 传输数据之前，要先三次握手建立连接</p>
<p>前提：客户端 为closed状态，服务端变成listen状态</p>
<p>连接：</p>
<p>1、客户端向服务端发送连接syn，之后客户端处于syn-sent状态；</p>
<p>2、服务端接收到这个消息之后，会返回一个syn+ack，之后服务端处于syn-rcvd状态</p>
<p>3、客户端收到这个之后，再给服务端发送一个对syn的ack，之后客户端处于establish状态</p>
<p>服务端收到ack也变成了establish状态</p>
<p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p>
<p>假设我们已经建立了连接，我们要发送消息，但是消息要遵循tcp协议，他的消息大小是有限制的，不是每一次都可以发送全部消息。具体要求如下：</p>
<p>![image-20230728195857751](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728195857751.png)</p>
<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li>
</ul>
<p>所以如果http请求消息超过mss，那么就要分段发送。</p>
<p>到这里我们得到了一个tcp的报文段或者说包，下面我们就要把这个包发送给网络层，因为在传输层我们就是服务应用层，然后对好端口，确定好协议，之后的事情就不归传输层管控了。</p>
<p>到这里，我们的数据包的格式如下所示：</p>
<p>![image-20230728200405680](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728200405680.png)</p>
<h2 id="定位IP"><a href="#定位IP" class="headerlink" title="定位IP"></a>定位IP</h2><p>ip协议的最重要的功能就是寻址和路由，他要做到这两点就需要你遵循ip协议，那么遵循的要求就是你加一个ip头![image-20230728200452235](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728200452235.png)</p>
<p>加上ip头之后我们就知道了我们的源ip和目的ip地址，那么起点站和终点站就已经知道了</p>
<p>可以现在又有一个小问题，那就是路径怎么规划呢？这时候就需要用到Mac地址</p>
<h2 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h2><p><img src="/../images/typora-user-images/image-20230728202408619.png" alt="image-20230728202408619"></p>
<ul>
<li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li>
<li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询</li>
</ul>
<p>也就是说到了网络接口层，要发了，结果不知道往哪里发，这时候就按照上面两步得到mac地址</p>
<p>因为上面已经得到了ip地址，所以直接喊话：这个 IP 地址是谁的？请把你的 MAC 地址告诉我，就得到mac地址了。</p>
<p>到这里数据包还差最后一层包装</p>
<h2 id="出口–网卡"><a href="#出口–网卡" class="headerlink" title="出口–网卡"></a>出口–网卡</h2><p>![image-20230728204942674](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230728204942674.png)</p>
<p>最后一层包装就是上面图片提到的报头和起始帧分界符和fcs帧校验序列</p>
<p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p>
<p>到这里数据包就真正的包装结束了，最后网卡会将包转为电信号，通过网线发送出去。！！</p>
<h2 id="送别者—交换机"><a href="#送别者—交换机" class="headerlink" title="送别者—交换机"></a>送别者—交换机</h2><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p>
<p>一般在网线接口啊这些地方，其实路由器也可以作为交换机。</p>
<h3 id="交换机的包接收操作"><a href="#交换机的包接收操作" class="headerlink" title="交换机的包接收操作"></a>交换机的包接收操作</h3><p>交换机里的模块将电信号转换为数字信号。</p>
<p>然后通过包末尾的fcs校验错误，没问题就放到缓存区，这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p>
<h3 id="查询MAC-地址表"><a href="#查询MAC-地址表" class="headerlink" title="查询MAC 地址表"></a>查询<strong>MAC 地址表</strong></h3><p>如果找到，就发送到相应的端口，如果找不到，那说明该mac地址的设备还没有向我们交换机发送过包，那这时候我们主动的向除了源端口的所有端口都发送一遍，因为后面的设备他自己都有检测功能，所以不需要担心</p>
<p>这时候要么就发送到位，要么就可能离开子网了，离开子网需要用到路由器</p>
<h2 id="出境大门–路由器"><a href="#出境大门–路由器" class="headerlink" title="出境大门–路由器"></a>出境大门–路由器</h2><h3 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h3><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p>
<p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p>
<p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p>
<p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p>
<p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p>
<h3 id="路由器的发送操作"><a href="#路由器的发送操作" class="headerlink" title="路由器的发送操作"></a>路由器的发送操作</h3><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p>
<ul>
<li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li>
<li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li>
</ul>
<p>反正我们从路由表知道了ip地址，那么我们同样用这个地址去查mac地址</p>
<p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p>
<p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p>
<p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这边举个例子![image-20230729000740012](&#x2F;Users&#x2F;csen&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230729000740012.png)</p>
<p>子网1某个设备想要发送数据给子网2的某个设备</p>
<p>首先源ip和目的ip是知道的，如果只是简单的arp群发这个ip问是谁的ip地址，其实是找不到的，所以判断是否为同一子网，如果不是，就把目的mac改成网关的mac，然后数据发送到网关，这时候官网一查mac地址，发现属于子网2的设备，这时候修改源mac为自己的mac，修改目的mac为设备的地址，从子网2的网卡发出。</p>
<p>大多数情况下一个子网的默认网关就是一个，就基本代表着出口。复杂情况就需要某种选择算法了</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/07/08/CS:%E8%BE%93%E5%85%A5%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/07/08/CS:Kafka/"
                            aria-label=": Kafka知识"
                        >
                            Kafka知识
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-08T00:00:00+08:00">
	
		    08 Jul 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>常见面试问题：</p>
<p><font color='red'><u><em><strong>怎么配置</strong></em></u></font></p>
<blockquote>
<p><font color='red'><u><em><strong>比如你的秒杀商品有1000件，处理一次购买请求的时间是500ms，那么总共就需要500s的时间。这时，你部署10个队列处理程序，那么秒杀请求的处理时间就是50s，也就是说用户需要等待50s才可以看到秒杀的结果，这是可以接受的。这时会并发10个请求到达数据库，并不会对数据库造成很大的压力。</strong></em></u></font></p>
</blockquote>
<h2 id="使用场景和作用"><a href="#使用场景和作用" class="headerlink" title="使用场景和作用"></a>使用场景和作用</h2><blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><font color='green'><strong>1、日志收集</strong></font></p>
<p><font color='green'><strong>2、消息系统</strong></font></p>
<p><font color='green'><strong>3、用户活动追踪</strong></font></p>
<p><font color='green'><strong>4、运营指标监控</strong></font></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><font color='green'><strong>1、削峰解耦，假设A系统每秒就处理1000个请求，那A去Kafka里面慢慢自己拉取就可以了，不会一股脑全部打到A系统上</strong></font></p>
<p><font color='green'><strong>2、高性能，有4点</strong></font></p>
<p><font color='green'><strong>3、高可用，持久化，两点，一个broker一个副本机制</strong></font></p>
<p><font color='green'><strong>4、可扩展，加机器</strong></font></p>
</blockquote>
<h2 id="Kafka高性能的设计"><a href="#Kafka高性能的设计" class="headerlink" title="Kafka高性能的设计"></a><strong>Kafka高性能的设计</strong></h2><p><font color='red'><u><em><strong>1）分区设计，可以实现并行操作。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>2）磁盘顺序写（减少磁盘寻址时间）</strong></em></u></font></p>
<p><font color='red'><u><em><strong>3）MMF+页缓存</strong></em></u></font> 即使kafka是顺序写，这个本身比较快，但是即使这样，速度也追不上内存。所以Kafka不是实时写入磁盘，而是先把数据写到页缓存里面，满足一定条件在刷回磁盘。它的工作原理是MMF，直接利用操作系统的页缓存来实现磁盘文件到物理内存的直接映射，完成映射之后你对物理内存的操作会被同步到硬盘上（操作系统在适当的时候）。</p>
<p><font color='red'><u><em><strong>4）零拷贝</strong></em></u></font></p>
<p>传统的io，先读取、再发送，实际经过 4 次 copy。</p>
<p>分别是：</p>
<ol>
<li>第一次：将磁盘文件，读到内核缓冲区；</li>
<li>第二次：将内核缓冲区的数据，copy 到 application 应用程序的 buffer；</li>
<li>第三步：将 application 应用程序 buffer 中的数据，copy 到 socket 网络发送缓冲区(属于操作系统内核的缓冲区)；</li>
<li>第四次：将 socket buffer 的数据，copy 到网卡，由网卡进行网络传输。</li>
</ol>
<p>零拷贝是只拷贝两次，</p>
<ul>
<li><font color='blue'><u><em><strong>Sendfile 方法引发 DMA 引擎将文件内容拷贝到内核缓冲区，优化成了3次，后来在linux2.4里面直接可以用文件描述可以代替数据拷贝</strong></em></u></font></li>
<li>DMA 引擎直接把数据从内核缓冲区传输到协议引擎，</li>
</ul>
<p><strong>DMA（直接存储器访问）用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输，他本质是一个硬件技术，就是比如你要把外设A的数据传到内存B，你直接给A和B之间加一条数据通路，然后给几个配件就可以实现，传输操作交给DMAC控制器（类似CPU）</strong></p>
<p><img src="/../images/Kafka/image-20231116011032880.png" alt="image-20231116011032880"></p>
<p><font color='red'><u><em><strong>用户态和内核态的内存拷贝开销有什么区别</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>在用户态是个初级管理员，权限不高，只能通过系统调用进行内存拷贝，那就涉及到用户态和内核态的切换。</strong></font></p>
<p><font color='green'><strong>在内核态下高级管理员，进程具有直接访问物理内存的权限，可以直接进行内存拷贝操作，无需通过系统调用。这</strong></font></p>
</blockquote>
<h2 id="Kafka的高可用了解过吗"><a href="#Kafka的高可用了解过吗" class="headerlink" title="Kafka的高可用了解过吗"></a>Kafka的高可用了解过吗</h2><ul>
<li><p>集群：首先kafka集群由多个broker组成，一个broker宕机，其余的broker依旧提供服务。</p>
</li>
<li><p>副本机制：一个topic有多个分区，每个分区有多个副本 、存在不同的broker里面。然后如果leader故障了，会从ISR中选举新的leader（ISR中存活，并且排在AR列表前面的优先），通过高水位线保持同步。如果Follower挂了，先踢出ISR，如果恢复那就等日志末端位移追上leader的HW。</p>
<blockquote>
<table>
<thead>
<tr>
<th><strong>1.follower故障流程</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><img src="/../images/Kafka/b01dad78f006b40d82e719fe71caeb78.png" alt="image-20220902210759125"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2.leader故障流程</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="/../images/Kafka/1f96e55810be5ff8cbf64c04b5d37315.png" alt="image-20220902210830344"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<h2 id="消息保证消息不丢失？可靠性"><a href="#消息保证消息不丢失？可靠性" class="headerlink" title="消息保证消息不丢失？可靠性"></a>消息保证消息不丢失？可靠性</h2><blockquote>
<p>分成三个方面分析：</p>
<p><font color='red'><u><em><strong>生产者发送丢失：</strong></em></u></font></p>
<blockquote>
<p><font color='red'><u><em><strong>他是有一个main线程会把消息发到消息累加器里面，然后sender线程把消息从消息累加器发送到broker。</strong></em></u></font></p>
<p><font color='green'><strong>1、重试机制</strong></font></p>
<p><font color='green'>**2、注册回调函数处理异步发送结果，如果发送失败进行记录或者重发 **</font></p>
<p><font color='green'><strong>3、ACK确认机制</strong></font></p>
<p>0：发了就不管了，<font color='green'><u><em><strong>这意味着消息可能会在发送之后丢失，而生产者将无法知道它是否成功到达服务器</strong></em></u></font></p>
<p>1：需要leader成功接收，<font color='green'><u><em><strong>leader同步Follower之前宕机，那消息可能就丢失</strong></em></u></font></p>
<p>-1：所有ISR的follower都成功接收才可以</p>
</blockquote>
<p><font color='red'><u><em><strong>broker存储丢失：</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>replication.factor &gt;&#x3D; 3</strong></font></p>
<p><font color='green'><strong>min.insync.replicas：Kafka <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=ISR&spm=1001.2101.3001.7020">ISR</a> 列表中最小同步副本数</strong></font></p>
<p><font color='green'><strong>unclean.leader.election.enable&#x3D;false：非ISR的不能精选leader</strong></font></p>
</blockquote>
<p><font color='red'><u><em><strong>消费者消费丢失：</strong></em></u></font></p>
<blockquote>
<ul>
<li><font color='green'><strong>设置enable.auto.commit 为 false</strong></font></li>
<li><font color='green'><strong>commitSync() 和 commitAsync() 组合提交 try异步，final同步</strong></font></li>
</ul>
</blockquote>
</blockquote>
<h2 id="重复消费问题怎么解决？"><a href="#重复消费问题怎么解决？" class="headerlink" title="重复消费问题怎么解决？"></a>重复消费问题怎么解决？</h2><blockquote>
<p><font color='green'><strong>重复消费的话也分生产者和消费者。</strong></font></p>
<p><font color='green'><strong>生产者：两种重试机制</strong></font>，单分区内是可以用<font color='green'><u><em><strong>幂等性</strong></em></u></font>解决的。<font color='red'><u><em><strong>（enable.idempotence&#x3D;true）</strong></em></u></font></p>
<p><font color='green'><strong>消费者：消费者重复消费是因为自动提交，</strong></font>首先最好关闭自动提交，然后开启<font color='green'><u><em><strong>手动提交</strong></em></u></font>。用同步+异步的组合方式。最好我们给了一个保底的方案，就是防重字段。</p>
</blockquote>
<p><font color='green'><u><em><strong>Kafka并发数和消费者的实例数有关，和批的大小无关</strong></em></u></font></p>
<h2 id="怎么保证顺序性-？"><a href="#怎么保证顺序性-？" class="headerlink" title="怎么保证顺序性 ？"></a>怎么保证顺序性 ？</h2><p>一个topic的数据会通过那个分区分配器分发到某个分区，如果会发到多个分区，我们是不能保证顺序性的，但是我们可以用幂等性保证在一个分区内是顺序的。因为生产者发送消息给broker的时候会携带PID和sequence number，一个是生产者的id，一个是消息的序列号。我们靠这个可以保证顺序性。所以我们尽可能的要把消息发到一个分区里面。那这个就要配合分区器来使用，如果你指定了分区号或者指定key，那就代表指定了某个分区，这样就能实现顺序性。如果你用没有指定，他就会用随机粘性分区策略，那就不能保证顺序性。</p>
<blockquote>
<p>生产者发送消息给broker的时候会携带PID和sequence number，一个是生产者的id，一个是消息的序列号。</p>
<p>broker中会在内存维护一个pid+分区对应的序列号。如果收到的序列号正好比内存序列号大一，才存储消息，如果小于内存序列号，意味着消息重复，那么会丢弃消息，并应答。如果远大于内存序列号，意味着消息丢失，会抛出异常。</p>
<p>了解：</p>
<p>至少一次（At Least Once）： ACK级别设置为-1 + 分区副本大于等于2 + ISR里应答的最小副本数量&gt;&#x3D;2。可以保证数据不丢失，但是不能保证数据不重复。<br>最多一次（At Most Once）：ACK级别设置为0 。可以保证数据不重复，但是不能保证数据不丢失。<br>精确一次（Exactly Once）：至少一次 + 幂等性 。 Kafka 0.11版本引入一项重大特性：幂等性和事务。</p>
</blockquote>
<blockquote>
<p>AR &#x3D; ISR + ORS</p>
<p>ISR 表示在保持一定程度同步的 follower 副本；</p>
<p>OSR 表示不能保持一定程度同步的follower副本</p>
</blockquote>
<p><strong>数据完全可靠条件 &#x3D; ACK级别设置为-1 + 分区副本大于等于2 + ISR里应答的最小副本数量大于等于2</strong></p>
<blockquote>
<p>幂等性只能保证的是在单分区单会话内不重复。如果设计到跨区，为了保证同时发的多条消息，要么全成功，要么全失败。kafka引入了事务</p>
<p>开启事务需要producer设置transactional.id的值并同时开启幂等性。</p>
<h2 id="定位事务协调器"><a href="#定位事务协调器" class="headerlink" title="定位事务协调器"></a>定位事务协调器</h2><p>其本质也是一个后端的broker，只是这个broker起到了针对当前事务的协调作用，它是在transaction_state特殊主题里面根据transcationid%50在一个特殊主题里面选出对应节点。</p>
<p>事务初始化</p>
<p>事务启动，消息发送</p>
<p>事务提交</p>
</blockquote>
<h2 id="Kafka文件存储机制"><a href="#Kafka文件存储机制" class="headerlink" title="Kafka文件存储机制"></a>Kafka文件存储机制</h2><blockquote>
<p><font color='blue'><u><em><strong>文件存储实际是按分区存的，一个分区对应多个segment（删除和查找方便），每一个segment里面都有三个文件，分别是log日志文件，index索引文件，timeindex时间戳索引文件，producer的数据会追加到log里面，每次往log里面写4k数据，就会到index文件写一条索引。</strong></em></u></font></p>
</blockquote>
<h2 id="Kafka数据清理机制"><a href="#Kafka数据清理机制" class="headerlink" title="Kafka数据清理机制"></a>Kafka数据清理机制</h2><p>Kafka提供了两种日志清理策略。</p>
<p><font color='blue'><u>**日志删除(delete) **</u></font>: 日志删除也分两种</p>
<p>​		按照时间，当消息保存的时间超过指定的时间（默认七天），就会触发清理</p>
<p>​		按照文件大小：当topic所有 分区的数据总和达到了默认的阈值（1G），就开始删除最久的消息	</p>
<p><font color='blue'><u>**日志压缩(compact) **</u></font>:针对每个消息的key进行整合，对于有相同key的不同value值，只保留最后一个版本。</p>
<h2 id="消息堆积-（-消费者如何提高吞吐量）"><a href="#消息堆积-（-消费者如何提高吞吐量）" class="headerlink" title="消息堆积 （ 消费者如何提高吞吐量）"></a>消息堆积 （ 消费者如何提高吞吐量）</h2><blockquote>
<p><font color='green'><strong>上游可以增加分区数量和调整batchsize和lingerms</strong></font></p>
<p><font color='green'><strong>下游可以增加消费者数量和调大消费者每次拉取的消息大小</strong></font></p>
<p><font color='green'><strong>数据倾斜问题，那就调整一下消息分区的策略，使其平均的散发每一个分区</strong></font></p>
</blockquote>
<h2 id="Kafka选举机制："><a href="#Kafka选举机制：" class="headerlink" title="Kafka选举机制："></a>Kafka选举机制：</h2><p><font color='blue'><u><em><strong>broker（控制器）选leader</strong></em></u></font></p>
<blockquote>
<p>集群中由很多的broker选出一个leader，其他事follower。负责主题创建删除，管理broker，分区重分配，分区leader选举等等</p>
<p>方法简单粗暴：</p>
<p>每个broker都有唯一的brokerId，启动后会去竞争注册zookeeper上的Controller结点，谁先抢到，谁就是broker leader。一般第一个broker都是controller。而其他broker会监听该结点事件，以便后续leader下线后触发重新选举。</p>
<p><img src="/../images/Kafka/12b4f076e8f82c66b00ec8782433649f.png" alt="image-20220902200901222"></p>
</blockquote>
<p>分区多副本选leader</p>
<ul>
<li><font color='blue'><u><em><strong>由controller节点控制，决策是：ISR中存活，并且排在AR列表前面的优先，同时必须在isr里面。</strong></em></u></font></li>
</ul>
<blockquote>
<p><img src="/../images/Kafka/e5c14b9c17123faf3eefa58a22ab0668-20230928225949575.png" alt="image-20220902201352868"></p>
</blockquote>
<p><font color='blue'><u><em><strong>消费者选Leader</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>先用groupid%50 得到一个主题分区（consumer_offset），这个分区所属的节点的消费者协调器就作为这个消费者组的老大，每个消费者向这个协调器发送joinGroup请求，具体的选举方法是，取出HashMap里面的第一个，就是消费者组的信息是放在一个hashmap里面的，我么选的时候是直接拿出第一个就好。所以比较偏随机。</strong></font></p>
</blockquote>
<h2 id="Kafka分区机制"><a href="#Kafka分区机制" class="headerlink" title="Kafka分区机制"></a><font color='red'><u><em><strong>Kafka分区机制</strong></em></u></font></h2><blockquote>
<p>分为<font color='green'><strong>生产者分区和消费者分区</strong></font>。还有一种副本分区机制，那个先不说。</p>
<p>1、生产者分区就是依赖于main线程里面的消息分区器，他有一个默认的分区器DefaultPartitioner，支持4种分区策略 1) 指定分区； 2）指定key，计算hash得分区； 3）指定随机粘性分区以前是轮训；（4）还可以自定义分区器（见代码）（下图））</p>
<p>2、消费者分区就是谁去消费谁的问题，支持三种策略：RoundRobin、Range、sticky粘性分区</p>
</blockquote>
<h1 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h1><p>分布式的基于发布订阅模式的消息队列</p>
<p>主要应用场景包括：<strong>缓存消峰</strong>、<strong>解耦</strong>和<strong>异步通信。</strong></p>
<p>消息队列有两种模式：</p>
<ul>
<li>点对点模式：一个消费者消费一个主题，数据被消费后会删除</li>
<li>发布订阅模式：多个消费者消费多个主题，数据被消费不会删除</li>
</ul>
<p><strong>基础架构</strong>：</p>
<p><img src="/../images/Kafka/708e86e70504f41234b05cb3cc30dea7.png" alt="image-20220902125656203"></p>
<p>（1）Producer：消息生产者，就是向 Kafka broker 发消息的客户端。</p>
<p>（2）Consumer：消息消费者，向 Kafka broker 取消息的客户端。</p>
<p>（3）Consumer Group（CG）：消费者组，由多个 consumer 组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</p>
<p>（4）Broker：一台 Kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个broker 可以容纳多个 topic。</p>
<p>（5）Topic：可以理解为一个队列，生产者和消费者面向的都是一个 topic。</p>
<p>（6）Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。</p>
<p>（7）Replica：副本。一个 topic 的每个分区都有若干个副本，一个 Leader 和若干个Follower。</p>
<p>（8）Leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 Leader。</p>
<p>（9）Follower：每个分区多个副本中的“从”，实时从 Leader 中同步数据，保持和Leader 数据的同步。Leader 发生故障时，某个 Follower 会成为新的 Leader。</p>
<p>其实总的流程就是生产者发送数据到kafka，然后消费者从kafka拉取数据。所以架构中最主要的就是生产者、kafka集群和消费者这三个，其他的很多知识都是为了这三个服务的。</p>
<h1 id="2、生产者"><a href="#2、生产者" class="headerlink" title="2、生产者"></a>2、生产者</h1><p> 在消息发送的过程中，涉及到两个线程，<font color='red'><u><em><strong>main线程和sender线程。</strong></em></u></font></p>
<p>main线程的流程就是<strong>producer</strong>（就是生产者）、然后拦截器（相当于留了一个供我们修改的接口）、<strong>序列化器</strong>（消息发送总要有一种形式，什么json啊）、分区器（我们事先其实是分好了区，但是发送消息的时候发送到那一个区？<strong>分区器</strong>，他有一个默认的分区器DefaultPartitioner，支持三种分区策略 1) 指定分区； 2）指定key，计算hash得分区； 3）指定随机粘性分区；（4）还可以自定义分区器（见代码）（下图））<img src="/../images/Kafka/18a0b6ba56db8e5b16b3d6fac9ba7fb7.png" alt="image-20220902163808502"></p>
<p>但是，并不是来一条消息就发一次，他是把消息加入到一个叫消息累加器里面，然后进行批量发送，一次是16k，32M大小的内存。 我看了下代码，就是 累加器的存储形式为ConcurrentMap&lt;TopicPartition, Deque<ProducerBatch>&gt;，一个分区对应一个双端队列</p>
<p>真正的发送要靠sender线程。发送的时机是：当双端队列中的DQueue满足 batch.size 或者 linger.ms 条件时触发sender线程。 同时Sender线程默认每个分区容纳5个未确认的消息，消息发送失败后会进行重试。</p>
<p><img src="/../images/Kafka/cd41370a872e70b75435f35692925370.png" alt="image-20220902155220662"></p>
<h1 id="3、Broker"><a href="#3、Broker" class="headerlink" title="3、Broker"></a>3、Broker</h1><h2 id="Broker架构"><a href="#Broker架构" class="headerlink" title="Broker架构"></a>Broker架构</h2><p>一台机器一个broker</p>
<p><img src="/../images/Kafka/image-20231024150746020.png" alt="image-20231024150746020"></p>
<p><strong>Zookeeper</strong>的作用</p>
<blockquote>
<p>Zookeeper在Kafka中扮演了重要的角色，kafka使用zookeeper进行<font color='red'><u><em><strong>元数据管理，保存broker注册信息，包括主题（Topic）、分区（Partition）信息等，选择分区leader。</strong></em></u></font></p>
<p><img src="/../images/Kafka/b1f0ebc535b00384be6bf81540c5f416.png" alt="image-20220902200249692"></p>
</blockquote>
<h2 id="kafka分区策略"><a href="#kafka分区策略" class="headerlink" title="kafka分区策略"></a>kafka分区策略</h2><p>如果 kafka 服务器只有 4 个节点，那么设置 kafka 的分区数大于服务器台数，在 kafka底层如何分配存储副本呢？</p>
<ul>
<li>这里如果用默认的就是如下</li>
</ul>
<p><img src="/../images/Kafka/15514da0f22aca9e3017fa2305733ba4.png" alt="image-20220902211334365"></p>
<ul>
<li>也可以手动指定</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim increase-replication-factor.json</span><br><span class="line">输入如下内容：</span><br><span class="line">&#123;</span><br><span class="line">&quot;version&quot;:1,</span><br><span class="line">&quot;partitions&quot;:[</span><br><span class="line">&#123;&quot;topic&quot;:&quot;three&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[0,1]&#125;,</span><br><span class="line">&#123;&quot;topic&quot;:&quot;three&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[0,1]&#125;,</span><br><span class="line">&#123;&quot;topic&quot;:&quot;three&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,0]&#125;,</span><br><span class="line">&#123;&quot;topic&quot;:&quot;three&quot;,&quot;partition&quot;:3,&quot;replicas&quot;:[1,0]&#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1、分区自动调整"><a href="#1、分区自动调整" class="headerlink" title="1、分区自动调整"></a><strong>1、分区自动调整</strong></h3><p>这个是指broker故障，<font color='blue'><u><em><strong>leader集中在某台broker上的情况</strong></em></u></font>，造成集群负载不均衡，这时候就需要分区平衡。那他一般有个比例，就是不平衡比例超过10%，就需要再平衡。</p>
<p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p>
<h1 id="4、kafka消费者"><a href="#4、kafka消费者" class="headerlink" title="4、kafka消费者"></a>4、kafka消费者</h1><h2 id="1、Kafka-消费方式（pull拉）"><a href="#1、Kafka-消费方式（pull拉）" class="headerlink" title="1、Kafka 消费方式（pull拉）"></a>1、Kafka 消费方式（pull拉）</h2><p><font color='blue'><u><em><strong>为什么</strong></em></u></font></p>
<blockquote>
<p>能够匹配broker的发送速率和consumer的消费速率吧</p>
</blockquote>
<h2 id="2、消费者工作流程"><a href="#2、消费者工作流程" class="headerlink" title="2、消费者工作流程"></a>2、消费者工作流程</h2><p><strong>消费者组初始化流程</strong></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1767477534734641183&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1767477534734641183&amp;wfr=spider&amp;for=pc</a></p>
<p>多个消费者协调器发送JoinGroup请求，协调器选一个消费者leader，消费者leader指定消费方案，并发送给协调器，协调器把这个方案通知到每一个消费者。</p>
<p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235058845.png" alt="在这里插入图片描述"></p>
<p><strong>消费者组详细消费流程</strong></p>
<p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235306060.png" alt="在这里插入图片描述"></p>
<h2 id="3、消费者组再平衡"><a href="#3、消费者组再平衡" class="headerlink" title="3、消费者组再平衡"></a>3、消费者组再平衡</h2><p><font color='blue'><u><em><strong>消费者组里面的成员数量发生变化，心跳中断就会发生。</strong></em></u></font></p>
<p>有三种再平衡的方法：</p>
<p>Range、RoundRobin、Sticky</p>
<h2 id="4、消费者分区的分配"><a href="#4、消费者分区的分配" class="headerlink" title="4、消费者分区的分配"></a>4、消费者分区的分配</h2><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235523539.png" alt="在这里插入图片描述"></p>
<p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230928235554746.png" alt="在这里插入图片描述"></p>
<p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000334551.png" alt="在这里插入图片描述"></p>
<h5 id="Sticky-以及再平衡"><a href="#Sticky-以及再平衡" class="headerlink" title="Sticky 以及再平衡"></a>Sticky 以及再平衡</h5><p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000640458.png" alt="在这里插入图片描述"></p>
<p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000728390.png" alt="在这里插入图片描述"></p>
<h2 id="5、offset-位移"><a href="#5、offset-位移" class="headerlink" title="5、offset 位移"></a>5、offset 位移</h2><h5 id="1、offset-的默认维护"><a href="#1、offset-的默认维护" class="headerlink" title="1、offset 的默认维护"></a>1、offset 的默认维护</h5><blockquote>
<p><font color='blue'><u><em><strong>__consumer_offsets 主题里面采用 key 和 value 的方式存储数据。</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>key 是group.id+topic+分区号，value 就是当前 offset 的值。</strong></em></u></font></p>
</blockquote>
<p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929000851750.png" alt="在这里插入图片描述"></p>
<p><img src="/../images/Kafka/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zi_5piM5Zac5qyi5ZCD6buE5qGD,size_20,color_FFFFFF,t_70,g_se,x_16-20230929001509066.png" alt="在这里插入图片描述"></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/07/08/CS:Kafka/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/11/spring%20ioc%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"
                            aria-label=": Spring ioc加载流程"
                        >
                            Spring ioc加载流程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-11T00:00:00+08:00">
	
		    11 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><strong>在功能上，SpringBoot的容器启动过程基本遵循了Spring的标准启动过程，但是在具体实现上，SpringBoot提供了一些特殊的机制来简化Spring容器的配置和启动。</strong></p>
<p><strong>首先，SpringBoot自动配置了很多常用的第三方库和框架，使得在大多数情况下，开发者不需要手动配置就能够使用这些库和框架。其次，SpringBoot提供了一些基础设施和约定来简化Spring的配置，例如默认的目录结构、默认的配置文件名、默认的属性配置等，这些都能够减少开发者的配置工作。最后，SpringBoot提供了一些自定义扩展机制，例如通过@ConfigurationProperties注解来绑定配置文件属性到Java对象，通过SpringApplication类的addListeners()方法来添加自定义的启动监听器等等，这些扩展机制能够让开发者更加方便地自定义和扩展SpringBoot的功能。</strong></p>
<p><strong>总的来说，SpringBoot并没有改变Spring的核心机制和启动过程，但是它在具体实现上提供了很多便利和简化，让开发者能够更加快速地开发和部署应用程序</strong></p>
<p>总体分成两个阶段；</p>
<ul>
<li>一、refresh之前</li>
<li>二、调用refresh()方法刷新容器</li>
</ul>
<h2 id="一、初始化流程"><a href="#一、初始化流程" class="headerlink" title="一、初始化流程"></a>一、初始化流程</h2><ol>
<li>创建并实例化一个 ApplicationContextInitializer 列表，用于对 Spring 应用上下文进行初始化。ApplicationContextInitializer 是 Spring 4.1 引入的一个新特性，允许用户在容器启动之前，对 Spring 应用上下文进行一些额外的初始化工作。</li>
<li>创建并实例化一个 ResourceLoader 对象，用于加载配置文件。ResourceLoader 是一个接口，它定义了资源加载的基本方法。Spring 容器默认使用 DefaultResourceLoader 作为 ResourceLoader 实现类。</li>
<li>创建并实例化一个 PropertyResolver 对象，用于解析配置文件中的属性。PropertyResolver 也是一个接口，它定义了属性解析的基本方法。Spring 容器默认使用 PropertySourcesPlaceholderConfigurer 作为 PropertyResolver 实现类。</li>
<li>加载和解析配置文件，将解析后的配置信息封装成一个 Environment 对象。Environment 是 Spring 中用于描述应用环境的一个抽象概念，它包含了各种配置属性和属性值。</li>
<li>将解析后的配置信息封装成一个 ConfigurableEnvironment 对象，并将其设置到容器中。ConfigurableEnvironment 是 Environment 的一个子接口，它定义了一些额外的操作，如添加属性、激活配置文件等。</li>
<li>创建并实例化一个 BeanFactoryPostProcessor 列表，用于在 BeanFactory 加载 Bean 定义之后，对 Bean 定义进行进一步的处理。BeanFactoryPostProcessor 是一个接口，它提供了在 BeanFactory 加载 Bean 定义之后，修改 Bean 定义的机会。</li>
<li>创建并实例化一个 BeanPostProcessor 列表，用于在 Bean 实例化之后，对 Bean 进行进一步的处理。BeanPostProcessor 是一个接口，它提供了在 Bean 实例化之后，修改 Bean 实例的机会。</li>
<li>注册并加载 BeanFactory 中的 Bean 定义。在这个阶段，Spring 容器会扫描指定的包，查找标注了 @Component、@Service、@Repository、@Controller 等注解的 Bean，将其封装成 BeanDefinition 对象，注册到 BeanFactory 中。</li>
<li>调用 BeanFactoryPostProcessor 的 postProcessBeanFactory() 方法，对 BeanFactory 中的 Bean 定义进行进一步的处理。</li>
<li>注册并加载 BeanFactoryPostProcessor 中的 Bean 定义。BeanFactoryPostProcessor 可以通过实现 BeanDefinitionRegistryPostProcessor 接口，向 BeanFactory 中注册新的 Bean 定义。</li>
<li>初始化并注册 ConversionService。ConversionService 是 Spring 中用于类型转换的一个组件，它可以将一个对象转换成另一个类型的对象。在这个阶段，Spring 容器会注册一些默认的转换器。</li>
<li>初始化并注册 LoadTimeWeaver。LoadTimeWeaver 是 Spring 中用于支持动态类加载和增强的一个组件。它可以将类的字节码在运行时进行增强，从而实现 AOP 等功能。</li>
<li>初始化并注册 Resource</li>
</ol>
<p><strong>中间第8步解析过程如下：</strong></p>
<p>这个步骤主要是用来解析用户传入的 Spring 配置类，解析成一个 BeanDefinition 然后注册到容器中，主要源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; void doRegisterBean(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span><br><span class="line">		@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) &#123;</span><br><span class="line">	// 解析传入的配置类，实际上这个方法既可以解析配置类，也可以解析 Spring bean 对象</span><br><span class="line">	AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">	// 判断是否需要跳过，判断依据是此类上有没有 @Conditional 注解</span><br><span class="line">	if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">	ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">	abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">	String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));</span><br><span class="line">	// 处理类上的通用注解</span><br><span class="line">	AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">	if (qualifiers != null) &#123;</span><br><span class="line">		for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">			if (Primary.class == qualifier) &#123;</span><br><span class="line">				abd.setPrimary(true);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (Lazy.class == qualifier) &#123;</span><br><span class="line">				abd.setLazyInit(true);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				abd.addQualifier(new AutowireCandidateQualifier(qualifier));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 封装成一个 BeanDefinitionHolder</span><br><span class="line">	for (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">		customizer.customize(abd);</span><br><span class="line">	&#125;</span><br><span class="line">	BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);</span><br><span class="line">	// 处理 scopedProxyMode</span><br><span class="line">	definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line"> </span><br><span class="line">	// 把 BeanDefinitionHolder 注册到 registry</span><br><span class="line">	BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「扫描」在XML/注解/JavaConfig 中需要被Spring管理的Bean信息</span><br><span class="line"></span><br><span class="line">随后，会将这些信息封装成BeanDefinition，最后会把这些信息放到一个beanDefinitionMap中</span><br><span class="line">那么BeanDefintiions是什么勒？</span><br><span class="line"></span><br><span class="line">BeanDefintiions其实就是对Bean的一些元数据定义</span><br><span class="line">包括parenName 父类名称 baenClassName：类名，scope bean的作用域。Abstract是否是抽象的等信息。</span><br><span class="line">通过 BeanDefinitionReader获取到BeanDefinition之后 。我们在通过BeanDefinitionRegistry将beanDefinition注册到BeanFacory中。存储在BeanFactory的一个conCurrentHashMap中。key为beanName,Value就是BeanDefinition元数据。</span><br><span class="line">Spring通过BeanDefinationReader将配置元信息加载到内存生成相应的BeanDefination之后，就将其注册到BeanDefinationRegistry中，BeanDefinationRegistry就是一个存放BeanDefination的大篮子，它也是一种键值对的形式，通过特定的Bean定义的id，映射到相应的BeanDefination</span><br></pre></td></tr></table></figure>



<p><strong>接着会遍历这个beanDefinitionMap，执行BeanFactoryPostProcessor这个Bean工厂后置处理器的逻辑，比如替换<code>$</code>占位符</strong></p>
<p><img src="https://img-blog.csdnimg.cn/690f5df98811421ab1dc6e1495375d71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ0Nxd2Fz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="三、refresh-容器刷新流程-最重要"><a href="#三、refresh-容器刷新流程-最重要" class="headerlink" title="三、refresh()容器刷新流程(最重要)"></a>三、refresh()容器刷新流程(最重要)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、prepareRefresh()刷新前的预处理：</span><br><span class="line"></span><br><span class="line">（1）initPropertySources()：初始化一些属性设置，子类自定义个性化的属性设置方法；</span><br><span class="line">（2）getEnvironment().validateRequiredProperties()：检验属性的合法性</span><br><span class="line">（3）earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;()：保存容器中的一些早期的事件；</span><br><span class="line">2、obtainFreshBeanFactory()：获取在容器初始化时创建的BeanFactory：</span><br><span class="line"></span><br><span class="line">（1）refreshBeanFactory()：刷新BeanFactory，设置序列化ID；</span><br><span class="line">（2）getBeanFactory()：返回初始化中的GenericApplicationContext创建的BeanFactory对象，即【DefaultListableBeanFactory】类型</span><br><span class="line">3、prepareBeanFactory(beanFactory)：BeanFactory的预处理工作，向容器中添加一些组件：</span><br><span class="line"></span><br><span class="line">（1）设置BeanFactory的类加载器、设置表达式解析器等等</span><br><span class="line">（2）添加BeanPostProcessor【ApplicationContextAwareProcessor】</span><br><span class="line">（3）设置忽略自动装配的接口：EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware；</span><br><span class="line">（4）注册可以解析的自动装配类，即可以在任意组件中通过注解自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext</span><br><span class="line">（5）添加BeanPostProcessor【ApplicationListenerDetector】</span><br><span class="line">（6）添加编译时的AspectJ；</span><br><span class="line">（7）给BeanFactory中注册的3个组件：environment【ConfigurableEnvironment】、systemProperties【Map&lt;String, Object&gt;】、systemEnvironment【Map&lt;String, Object&gt;】</span><br><span class="line">4、postProcessBeanFactory(beanFactory)：子类重写该方法，可以实现在BeanFactory创建并预处理完成以后做进一步的设置</span><br><span class="line"></span><br><span class="line">5、invokeBeanFactoryPostProcessors(beanFactory)：在BeanFactory标准初始化之后执行BeanFactoryPostProcessor的方法，即BeanFactory的后置处理器：</span><br><span class="line"></span><br><span class="line">（1）先执行BeanDefinitionRegistryPostProcessor： postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class="line"></span><br><span class="line">① 获取所有的实现了BeanDefinitionRegistryPostProcessor接口类型的集合</span><br><span class="line">② 先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor</span><br><span class="line">③ 再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor</span><br><span class="line">④ 最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors        </span><br><span class="line">（2）再执行BeanFactoryPostProcessor的方法：postProcessor.postProcessBeanFactory(beanFactory)</span><br><span class="line"></span><br><span class="line">① 获取所有的实现了BeanFactoryPostProcessor接口类型的集合</span><br><span class="line">② 先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor</span><br><span class="line">③ 再执行实现了Ordered顺序接口的BeanFactoryPostProcessor</span><br><span class="line">④ 最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor</span><br><span class="line">6、registerBeanPostProcessors(beanFactory)：向容器中注册Bean的后置处理器BeanPostProcessor，它的主要作用是干预Spring初始化bean的流程，从而完成代理、自动注入、循环依赖等功能</span><br><span class="line"></span><br><span class="line">（1）获取所有实现了BeanPostProcessor接口类型的集合：</span><br><span class="line">（2）先注册实现了PriorityOrdered优先级接口的BeanPostProcessor；</span><br><span class="line">（3）再注册实现了Ordered优先级接口的BeanPostProcessor；</span><br><span class="line">（4）最后注册没有实现任何优先级接口的BeanPostProcessor；</span><br><span class="line">（5）最r终注册MergedBeanDefinitionPostProcessor类型的BeanPostProcessor：beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">（6）给容器注册一个ApplicationListenerDetector：用于在Bean创建完成后检查是否是ApplicationListener，如果是，就把Bean放到容器中保存起来：applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">此时容器中默认有6个默认的BeanProcessor(无任何代理模式下)：【ApplicationContextAwareProcessor】、【ConfigurationClassPostProcessorsAwareBeanPostProcessor】、【PostProcessorRegistrationDelegate】、【CommonAnnotationBeanPostProcessor】、【AutowiredAnnotationBeanPostProcessor】、【ApplicationListenerDetector】</span><br><span class="line"></span><br><span class="line">7、initMessageSource()：初始化MessageSource组件，主要用于做国际化功能，消息绑定与消息解析：</span><br><span class="line"></span><br><span class="line">（1）看BeanFactory容器中是否有id为messageSource 并且类型是MessageSource的组件：如果有，直接赋值给messageSource；如果没有，则创建一个DelegatingMessageSource；</span><br><span class="line">（2）把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource；</span><br><span class="line">8、initApplicationEventMulticaster()：初始化事件派发器，在注册监听器时会用到：</span><br><span class="line"></span><br><span class="line">（1）看BeanFactory容器中是否存在自定义的ApplicationEventMulticaster：如果有，直接从容器中获取；如果没有，则创建一个SimpleApplicationEventMulticaster</span><br><span class="line">（2）将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件就可以直接自动注入</span><br><span class="line">9、onRefresh()：留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑</span><br><span class="line"></span><br><span class="line">10、registerListeners()：注册监听器：将容器中所有的ApplicationListener注册到事件派发器中，并派发之前步骤产生的事件：</span><br><span class="line"></span><br><span class="line"> （1）从容器中拿到所有的ApplicationListener</span><br><span class="line">（2）将每个监听器添加到事件派发器中：getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">（3）派发之前步骤产生的事件applicationEvents：getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">11、finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；</span><br><span class="line"></span><br><span class="line">（1）获取容器中的所有beanDefinitionName，依次进行初始化和创建对象</span><br><span class="line">（2）获取Bean的定义信息RootBeanDefinition，它表示自己的BeanDefinition和可能存在父类的BeanDefinition合并后的对象</span><br><span class="line">（3）如果Bean满足这三个条件：非抽象的，单实例，非懒加载，则执行单例Bean创建流程：    </span><br><span class="line">（4）所有Bean都利用getBean()创建完成以后，检查所有的Bean是否为SmartInitializingSingleton接口的，如果是；就执行afterSingletonsInstantiated()；</span><br><span class="line">12、finishRefresh()：发布BeanFactory容器刷新完成事件：</span><br><span class="line"></span><br><span class="line">（1）initLifecycleProcessor()：初始化和生命周期有关的后置处理器：默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】，如果没有，则创建一个DefaultLifecycleProcessor()加入到容器；</span><br><span class="line">（2）getLifecycleProcessor().onRefresh()：拿到前面定义的生命周期处理器（LifecycleProcessor）回调onRefresh()方法</span><br><span class="line">（3）publishEvent(new ContextRefreshedEvent(this))：发布容器刷新完成事件；</span><br><span class="line">（4）liveBeansView.registerApplicationContext(this);</span><br></pre></td></tr></table></figure>

<p>可以看到这个方法里面调用了很多的方法，我们从开始说起：</p>
<ul>
<li><p>首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；</p>
</li>
<li><p>接着往下看prepareRefresh();这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。</p>
</li>
<li><p>下一步ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();这个就很重要了，这一步是把配置文件解析成一个个BeanDefinition，并且注册到BeanFactory中，注意**<u>这里只是注册进去，并没有实例化</u>**。先继续往下看，等会展开这个方法详细解读</p>
</li>
<li><p>然后是prepareBeanFactory(beanFactory);这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看</p>
</li>
<li><p>postProcessBeanFactory(beanFactory);<strong><u>方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。</u></strong></p>
</li>
<li><p>接下来是invokeBeanFactoryPostProcessors(beanFactory);<u><strong>这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</strong></u></p>
</li>
<li><p>然后是registerBeanPostProcessors(beanFactory);这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。然后回到refresh()方法中继续往下看</p>
</li>
<li><p>initMessageSource();方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下</p>
</li>
<li><p>initApplicationEventMulticaster();方法初始化当前 ApplicationContext 的事件广播器继续往下</p>
</li>
<li><p>onRefresh();<u>方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下</u></p>
</li>
<li><p>registerListeners();方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下</p>
</li>
<li><h5 id="重点到了：finishBeanFactoryInitialization-beanFactory-初始化所有的-singleton-beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说"><a href="#重点到了：finishBeanFactoryInitialization-beanFactory-初始化所有的-singleton-beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说" class="headerlink" title="重点到了：finishBeanFactoryInitialization(beanFactory);初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说"></a>重点到了：finishBeanFactoryInitialization(beanFactory);<u>初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说</u></h5></li>
<li><p>finishRefresh();方法是最后一步，广播事件，ApplicationContext 初始化完成</p>
</li>
</ul>
<h3 id="我们重点来看ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory-和finishBeanFactoryInitialization-beanFactory-这两个方法"><a href="#我们重点来看ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory-和finishBeanFactoryInitialization-beanFactory-这两个方法" class="headerlink" title="我们重点来看ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();和finishBeanFactoryInitialization(beanFactory);这两个方法"></a>我们重点来看<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code>和<code>finishBeanFactoryInitialization(beanFactory);</code>这两个方法</h3><p>先说<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</code>; 这一步上面简单介绍过了，作用是把配置文件解析成一个个BeanBeanDefinition，并且注册到BeanFactory中，点进去源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	return beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法中第一步refreshBeanFactory();方法的作用是关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等，然后getBeanFactory();就是返回刚刚创建的 BeanFactory(其实就是DefaultListableBeanFactory)，我们进入refreshBeanFactory();方法，在AbstractRefreshableApplicationContext类中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">	if (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">			this.beanFactory = beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个refreshBeanFactory()方法首先如果 ApplicationContext 中已经加载过 BeanFactory<br>了，销毁所有 Bean，关闭 BeanFactory；这里指的是当前ApplicationContext 是否有 BeanFactory。<br>然后createBeanFactory();初始化一个DefaultListableBeanFactory，这个DefaultListableBeanFactory是很重的一个类，为什么重要呢？可以看文章开头的BeanFactory继承图，DefaultListableBeanFactory是位于最下面的，他往上能走完BeanFactory继承图所有，所以他可以说是功能最大的BeanFactory。<br>beanFactory.setSerializationId(getId());方法用于 BeanFactory 的序列化<br>customizeBeanFactory(beanFactory);方法设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用，这个等会细说<br>loadBeanDefinitions(beanFactory);这个方法很重要：加载 Bean定义 到 BeanFactory 中，也是等会细说<br>下面看customizeBeanFactory(beanFactory);方法，这个方法作用：是否允许 Bean 覆盖、是否允许循环引用，这是什么意思呢？这就要说到BeanDefinition了，这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中，下面贴出来开头我说的大神的关于BeanDefinition接口的代码注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">AttributeAccessor</span>, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们可以看到，默认只提供 sington 和 prototype 两种，</span></span><br><span class="line">   <span class="comment">// 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span></span><br><span class="line">   <span class="comment">// 不过，它们属于基于 web 的扩展。</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 比较不重要，直接跳过吧</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_APPLICATION</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_SUPPORT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_INFRASTRUCTURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span></span><br><span class="line">   <span class="comment">// 一句话就是：继承父 Bean 的配置信息而已</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setParentName</span><span class="params">(String parentName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取父 Bean</span></span><br><span class="line">   String <span class="title function_">getParentName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setBeanClassName</span><span class="params">(String beanClassName)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取 Bean 的类名称</span></span><br><span class="line">   String <span class="title function_">getBeanClassName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 bean 的 scope</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(String scope)</span>;</span><br><span class="line"></span><br><span class="line">   String <span class="title function_">getScope</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setLazyInit</span><span class="params">(<span class="type">boolean</span> lazyInit)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isLazyInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span></span><br><span class="line">   <span class="comment">// 是 depends-on=&quot;&quot; 属性设置的值。</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setDependsOn</span><span class="params">(String... dependsOn)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该 Bean 的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span></span><br><span class="line">   <span class="comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setAutowireCandidate</span><span class="params">(<span class="type">boolean</span> autowireCandidate)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 是否可以注入到其他 Bean 中</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAutowireCandidate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setPrimary</span><span class="params">(<span class="type">boolean</span> primary)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是 primary 的</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrimary</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span></span><br><span class="line">   <span class="comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   String <span class="title function_">getFactoryBeanName</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的 工厂方法名称</span></span><br><span class="line">   String <span class="title function_">getFactoryMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   ConstructorArgumentValues <span class="title function_">getConstructorArgumentValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   MutablePropertyValues <span class="title function_">getPropertyValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span></span><br><span class="line">   <span class="comment">// 常用于作为 父bean 用于继承，其实也很少用......</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAbstract</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getRole</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getResourceDescription</span><span class="params">()</span>;</span><br><span class="line">   BeanDefinition <span class="title function_">getOriginatingBeanDefinition</span><span class="params">()</span>;</span><br><span class="line">&#125;BeanDefinition 的覆盖问题就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 <span class="literal">null</span>，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</span><br><span class="line">循环引用：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</span><br><span class="line">默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</span><br></pre></td></tr></table></figure>

<p>再看loadBeanDefinitions(beanFactory) 方法，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。先贴上源码：AbstractXmlApplicationContext类中</p>
<pre><code>@Override
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;
    // Create a new XmlBeanDefinitionReader for the given BeanFactory.
    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
  // Configure the bean definition reader with this context&#39;s
  // resource loading environment.
  beanDefinitionReader.setEnvironment(this.getEnvironment());
  beanDefinitionReader.setResourceLoader(this);
  beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

  // Allow a subclass to provide custom initialization of the reader,
  // then proceed with actually loading the bean definitions.
  initBeanDefinitionReader(beanDefinitionReader);
  loadBeanDefinitions(beanDefinitionReader);
</code></pre>
<p>}<br>这个源码中我们重点看loadBeanDefinitions(beanDefinitionReader);，再点进去源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">	Resource[] configResources = getConfigResources();</span><br><span class="line">	<span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">		reader.loadBeanDefinitions(configResources);</span><br><span class="line">	&#125;</span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	<span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">		reader.loadBeanDefinitions(configLocations);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在这段源码中我么可以看到2个reader.loadBeanDefinitions()方法，其实两个最终都到了：AbstractBeanDefinitionReader类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">	<span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">		counter += loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法里面，for循环每一个文件是一个resource，最终返回 counter，表示总共加载了多少的 BeanDefinition。<br>进入loadBeanDefinitions(resource);方法，看源码：<br>XmlBeanDefinitionReader类中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line">  Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">  <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">    currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">        <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">      <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">        inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">        <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中可以看到try代码块中一开始是根据外层循环调用的每一个Resource解析成一个InputStream 然后根据这个输入流解析；<br>这段源码的核心在doLoadBeanDefinitions(inputSource, encodedResource.getResource());继续进源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">		<span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="string">&quot; in XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在这个方法里面可以看到doLoadDocument(inputSource, resource);方法是将 xml 文件(输入流和Resource)转换为 Document 对象，然后继续进源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里创建了一个BeanDefinitionDocumentReader，然后spring通过BeanDefinitionDocumentReader 会进行委托bean定义的创建；<br>继续这个方法里面看：documentReader.registerBeanDefinitions(doc, createReaderContext(resource));点进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">	logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line">	<span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">	doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>里面的doRegisterBeanDefinitions(root);方法就是从 xml 根节点开始解析文件，经过很多的步骤，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，可以看到上面有个 for 循环的(loadBeanDefinitions(resource);是在for循环里面的)，进入doRegisterBeanDefinitions(root);方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">	<span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">	<span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">	<span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">	<span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">	<span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">	<span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">	<span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">	<span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">          profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">          logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">              <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">  postProcessXml(root);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码中可以看到BeanDefinitionDocumentReader最终是创建了一个BeanDefinitionParserDelegate ，把bean定义的创建委托给了BeanDefinitionParserDelegate 进行创建，这就是委托模式的提现。<br>同时也可以看到这段代码中先把this.delegate给了一个parent，然后又创建了一个Delegate，然后执行最后又把这个parent给回去了this.delegate，这是为了处理<beans>标签嵌套<beans>的问题，其实是个类似递归的操作。这里大家可以debugger试试嵌套的情况就明白了。</p>
<h5 id="再看preProcessXml-root-，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式-模板方法模式不了解的可以看我的这篇文章-，同理postProcessXml-root-也一样，就是在Bean定义创建前后提供扩展点。"><a href="#再看preProcessXml-root-，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式-模板方法模式不了解的可以看我的这篇文章-，同理postProcessXml-root-也一样，就是在Bean定义创建前后提供扩展点。" class="headerlink" title="再看preProcessXml(root)，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式(模板方法模式不了解的可以看我的这篇文章)，同理postProcessXml(root)也一样，就是在Bean定义创建前后提供扩展点。"></a>再看preProcessXml(root)，点进去一看是空实现，并且是protected的，那么很明显这就是一个模板方法模式(模板方法模式不了解的可以看我的这篇文章)，同理postProcessXml(root)也一样，就是在Bean定义创建前后提供扩展点。</h5><p>那继续进入parseBeanDefinitions(root, this.delegate);看重点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">			<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">				<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">				<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">					<span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">					<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">						parseDefaultElement(ele, delegate);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						delegate.parseCustomElement(ele);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			delegate.parseCustomElement(root);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>这段代码是循环解析Element 的每一个节点，一般我们的普通bean都是走parseDefaultElement(ele, delegate);默认的解析流程。<br>但是这里有个else的自定义解析，这个很多人都忽略了，其实如果我们xml的配置文件中定义了<a href="aop:config">aop:config</a> 标签，他就会走这个自定义解析，然后解析aop内容，后续会在分析AOP源码，可以看这篇文章)说<a href="aop:config">aop:config</a>的时候讲这里。<br>这里我们还是走普通的beand解析逻辑parseDefaultElement(ele, delegate)，跟进去看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">			importBeanDefinitionResource(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">			processAliasRegistration(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">			processBeanDefinition(ele, delegate);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">			<span class="comment">// recurse</span></span><br><span class="line">			doRegisterBeanDefinitions(ele);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>这个方法见名知意，解析默认的Element，是4个if分支，第一个是解析import类型的，第二个是alias的，第三个是bean的(也就是我们普通bean默认的)，第四个是beans，也就是嵌套的(这里这个嵌套的就回到上面doRegisterBeanDefinitions方法了，也就是为什么说上面其实类似递归的原因)<br>这里我们只分析普通bean的解析处理，进入processBeanDefinition(ele, delegate);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">					bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send registration event.</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这段代码首先通过delegate创建一个bean定义的持有者BeanDefinitionHolder，<strong>这一步其实BeanDefinition也在里面已经创建出来了</strong>。进入delegate.parseBeanDefinitionElement(ele)看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">		<span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">	List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">		String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">		aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">		beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">		checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">	<span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">					beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">							beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">					<span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">					<span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">					<span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">					<span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">					<span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">							beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">							!<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">						aliases.add(beanClassName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				error(ex.getMessage(), ele);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这段代码中有一个parseBeanDefinitionElement(ele, beanName, containingBean)，<strong>返回了一个AbstractBeanDefinition，这个方法里面实际是创建了一个GenericBeanDefinition</strong>，这里就不跟进去看了，代码篇幅太长了，这个里面很简单没啥绕的逻辑，大家跟着点点就能看到了。创建完GenericBeanDefinition之后设置了Class属性、构造器等等一些创建Bean实例需要的东西之后就返回了。</p>
<p>然后回到processBeanDefinition(ele, delegate);看BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());，由于这个时候<strong>已经创建了BeanDefinition</strong>并且有持有者BeanDefinitionHolder进行注册，所以继续跟进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">      <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">	String[] aliases = definitionHolder.getAliases();</span><br><span class="line">	<span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显继续跟进到registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());，这里是一个接口调用，肯定是到了DefaultListableBeanFactory，但是在这个接口调用时我们需要注意的是第二个参数，从BeanDefinitionHolder中获取到了BeanDefinition对象，这个就是创建Bean定义持有者的时候顺带获取的BeanDefinition，通过上面的解析我们知道这个时候BeanDefinition已经创建好了，然后跟进这个方法进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">	Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">			<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">						existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">			<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">				updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				<span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">				removeManualSingletonName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Still in startup registration phase</span></span><br><span class="line">			<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			<span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">			removeManualSingletonName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法里面就可以看到经过一系列验证等等操作，最后把BeanDefinition放入了beanDefinitionMap，到这里bean定义就完成并注册到org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap里面了</p>
<p>然后我们回到refresh() 方法，就是文章前部分的那个refresh() 方法…TvT<br>再贴一下refresh() 方法的源码吧，方便阅读：<br>我直接贴大神带注释的代码吧，看起来更方便一点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">   <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">  prepareRefresh();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">  <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">  <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">  <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">  <span class="comment">// 这块待会会展开说</span></span><br><span class="line">  prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">     <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">     <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">     postProcessBeanFactory(beanFactory);</span><br><span class="line">     <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span></span><br><span class="line">     invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">     <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">     <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span></span><br><span class="line">     registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">     initMessageSource();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">     initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span></span><br><span class="line">     <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">     onRefresh();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">     registerListeners();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 重点，重点，重点</span></span><br><span class="line">     <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">     <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">     finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span></span><br><span class="line">     finishRefresh();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">     <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">              <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">     <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">     destroyBeans();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">     cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 把异常往外抛</span></span><br><span class="line">     <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">     <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">     resetCommonCaches();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="到此为止，ConfigurableListableBeanFactory-beanFactory-x3D-obtainFreshBeanFactory-结束"><a href="#到此为止，ConfigurableListableBeanFactory-beanFactory-x3D-obtainFreshBeanFactory-结束" class="headerlink" title="到此为止，ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();结束"></a>到此为止，ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();结束</h4><hr>
<h3 id="下面我们来看finishBeanFactoryInitialization-beanFactory"><a href="#下面我们来看finishBeanFactoryInitialization-beanFactory" class="headerlink" title="下面我们来看finishBeanFactoryInitialization(beanFactory)"></a>下面我们来看finishBeanFactoryInitialization(beanFactory)</h3><p>到这一步为止BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些<strong>特殊的 Bean，如 ‘environment’、‘systemProperties’ 等</strong>。剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。点进去看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">	<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">  <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">  <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>在这段代码中：首先初始化名字为 “conversionService” 的 Bean，为什么是conversionService 呢？原因是注册这个bean之后，类似于前端传给后端的非基础类型和基础类型的包装类之外，其他的就可以考虑采用ConversionService来进行类型等的转换，初始化这个 “conversionService” 实在上面源码中的beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));进行的。然后直接跳过来到beanFactory.preInstantiateSingletons();这个方法，这里开始初始化。点进去：<br>DefaultListableBeanFactory这个类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">  <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="type">boolean</span> isEagerInit;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<ol>
<li><p>迭代所有的BeanDefinitionNames集合，挨个初始化所有非懒加载的单例类。</p>
</li>
<li><p>BeanDefinitionNames是在注册BeanDefinitionMap时同时注册的集合。该集合，主要用在<strong>这里</strong>进行迭代初始化Spring Bean，并且也方便一些类似获取BeanDefinitionName的方法使用。</p>
</li>
<li><p>初始化的时候还对FactoryBean进行判断，因为默认FactoryBean默认是惰性初始化，如果实现SmartFactoryBean设置isEagerInit为true，则代表该类需要急切的进行初始化，会即刻开始初始化FactoryBean里getObject返回的类。</p>
</li>
<li><p>关于getMergedLocalBeanDefinition和getBean：Spring通过getBean来完成类的初始化并添加到Spring容器内（即Spring的一级缓存：单例池里面），而在初始化时需要当前类的相关信息：即BeanDefinition，而BeanDefinition是可以存在父子关系（并非真的继承，而是BeanDefinition可以设置父BeanDefinition），所以Spring通过getMergedLocalBeanDefinition来获取当前类的完整信息。</p>
</li>
</ol>
<p>getBean-》doGetBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="comment">// 1.转换beanName，主要处理别名、以&amp;开头的name</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.尝试从单例缓存中获取bean实例</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">	<span class="comment">// 3. 获取bean实例</span></span><br><span class="line">	<span class="comment">// 3.1 缓存中已存在bean实例</span></span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 省略日志输出代码...</span></span><br><span class="line">		<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 省略父工厂处理相关代码...</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 省略dependsOn相关代码...</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3.2 创建单例bean</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3.3 创建原型bean实例</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">				<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3.4 根据scope创建bean实例</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">				<span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">				<span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					<span class="comment">// 从bean实例中获取对象（本章重点，获取实例中的对象）</span></span><br><span class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="comment">// 省略异常处理代码...</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略其他代码.</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>}</p>
<p><strong>在可以看到上面有四种情况：缓存中存在bean实例、创建单例bean、创建原型bean、根据scope创建bean，都调用了getObjectForBeanInstance()方法，接下来我们就点进去看看。</strong></p>
<p><em><strong>getObjectForBeanInstance是从bean实例中获取对象（本章重点，获取实例中的对象）</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">		Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 如果是工厂引用(即name以&amp;开头)，但该实例又不是FactoryBean类型，则抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 如果该实例不是FactoryBean类型，或者是工厂引用都直接返回该实例</span></span><br><span class="line">	<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 尝试从缓存中加载bean</span></span><br><span class="line">		object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 把初始bean实例强转为FactoryBean</span></span><br><span class="line">		FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">		<span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 是否是用户自定义的beanDefinition(默认是false)</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">		<span class="comment">// 重点方法，跟进去</span></span><br><span class="line">		object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>从FactoryBean中获取对象：getObjectFromFactoryBean()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 单例模式</span></span><br><span class="line">	<span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 真正获取对象的方法(重点方法)</span></span><br><span class="line">				object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">				<span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">				<span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;</span><br><span class="line">					object = alreadyThere;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">						<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">							<span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">							<span class="keyword">return</span> object;</span><br><span class="line">						&#125;</span><br><span class="line">						beforeSingletonCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="comment">// 调用bean的后置处理器(有兴趣的可以点进去看下，后面的章节会单独讲述)</span></span><br><span class="line">							object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">									<span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterSingletonCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">						<span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> object;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 2. 原型模式</span></span><br><span class="line">		<span class="comment">// 真正获取对象的方法(重点方法)</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">		<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>真正从FactoryBean中获取对象的逻辑：doGetObjectFromFactoryBean()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">	Object object;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 权限验证</span></span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> getAccessControlContext();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">				<span class="keyword">throw</span> pae.getException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 终于看到你了！</span></span><br><span class="line">			object = factory.getObject();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName, ex.toString());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do not accept a null value for a FactoryBean that&#x27;s not fully</span></span><br><span class="line">	<span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line">	<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(</span><br><span class="line">					beanName, <span class="string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		object = <span class="keyword">new</span> <span class="title class_">NullBean</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终发现其实获取对象的方法，就是一行调用FactoryBean的getObject()方法。</p>
<h4 id="在上面的方法中有个bean的实例化过程我们必须知道"><a href="#在上面的方法中有个bean的实例化过程我们必须知道" class="headerlink" title="在上面的方法中有个bean的实例化过程我们必须知道"></a>在上面的方法中有个bean的实例化过程我们必须知道</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//推断当前Beandefinition的beanClass</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 准备方法重写 包括lookup-method和replaced-method的处理，本文暂不展开</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 第一次调用后置处理器：初始化Bean之前，InstantiationAwareBeanPostProcessor,</span></span><br><span class="line">      <span class="comment">// 根据BeanDefinition获取到了对应的class类</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//创建Bean</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">      <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">      <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>}</p>
<p>docreatebean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">//从未完成的 FactoryBean 实例中移除</span></span><br><span class="line">			instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">//实例化对象(仅仅是生成对象，并非添加到spring单例池中，即目前并没有成为Spring Bean)，</span></span><br><span class="line">			<span class="comment">//并且第二次调用 后置处理器 determineConstructorsFromBeanPostProcessors</span></span><br><span class="line"> 			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">		<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">			mbd.resolvedTargetType = beanType;</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line"> 		... </span><br><span class="line">     	...  </span><br><span class="line">     	...   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先通过createBeanInstance方法调用后置处理器推断其构造函数，并反射创建BeanDefinition对应的实例。<strong>实例化 Bean</strong></p>
<p><strong>注意此时只是创建了类对象，但还没有添加到Spring的单例池中，即还没有加入到Spring容器内部。</strong><br><strong>可以理解为此时只是完成了类对象的声明：即类似于A a&#x3D;null</strong></p>
<p>添加到Spring的单例池是在getSingleton（）的addSingleton中。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38289451/article/details/121965628">https://blog.csdn.net/qq_38289451/article/details/121965628</a></p>
<p>createBeanInstance() 方法是 spring 实例化 bean 的核心代码，它根据不同的情况会调用四种实例化方法</p>
<ul>
<li>obtainFromSupplier() ：通过 Supplier 实例化</li>
<li>instantiateUsingFactoryMethod()：通过工厂方法实例化</li>
<li>autowireConstructor()：用合适的构造函数实例化</li>
<li>instantiateBean()：用无参构造函数实例化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;</span><br><span class="line">    </span><br><span class="line">	// 确认需要创建的bean实例的类可以实例化</span><br><span class="line">	Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">	// 确保class不为空，并且访问权限是public</span><br><span class="line">	if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">		throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">				&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot; + beanClass.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * ----------1，通过Supplier实例化------------</span><br><span class="line">	 */</span><br><span class="line">	Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">	if (instanceSupplier != null) &#123;</span><br><span class="line">		return obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	/**</span><br><span class="line">	 * ----------2，通过工厂方法实例化------------</span><br><span class="line">	 */</span><br><span class="line">	if (mbd.getFactoryMethodName() != null) &#123;</span><br><span class="line">		return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">	 * ----------3，用合适的构造函数实例化------------</span><br><span class="line">	 *</span><br><span class="line">	 *  一个类可能有多个构造器，所以Spring得根据参数个数、类型确定需要调用的构造器。</span><br><span class="line">	 *  在使用构造器创建实例后，Spring会将解析过后确定下来的构造器或工厂方法保存在缓存中，</span><br><span class="line">	 *  避免再次创建相同bean时再次解析</span><br><span class="line">	 */</span><br><span class="line">	// 标记下，防止重复创建同一个bean</span><br><span class="line">	boolean resolved = false;</span><br><span class="line">	// 是否需要自动装配，构造有参数的需要</span><br><span class="line">	boolean autowireNecessary = false;</span><br><span class="line">	// 如果没有参数</span><br><span class="line">	if (args == null) &#123;</span><br><span class="line">		synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">			// 一个类中有多个构造函数，每个构造函数都有不同的参数，所以调用前需要先根据参数锁定构造函数或对应的工厂方法</span><br><span class="line">			if (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class="line">				resolved = true;</span><br><span class="line">				autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 有构造参数的或者工厂方法</span><br><span class="line">	if (resolved) &#123;</span><br><span class="line">		// 构造器有参数</span><br><span class="line">		if (autowireNecessary) &#123;</span><br><span class="line">			// 构造函数自动注入</span><br><span class="line">			return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// 使用默认构造函数构造</span><br><span class="line">			return instantiateBean(beanName, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 从bean后置处理器中为自动装配寻找构造方法</span><br><span class="line">	Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">	if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">			mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">		return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 找出最合适的默认构造方法</span><br><span class="line">	ctors = mbd.getPreferredConstructors();</span><br><span class="line">	if (ctors != null) &#123;</span><br><span class="line">		// 构造函数自动注入</span><br><span class="line">		return autowireConstructor(beanName, mbd, ctors, null);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">	 * ----------4，使用默认构造函数构造------------</span><br><span class="line">	 */</span><br><span class="line">	return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="新增ObjectFactory到第三级缓存"><a href="#新增ObjectFactory到第三级缓存" class="headerlink" title="新增ObjectFactory到第三级缓存"></a>新增ObjectFactory到第三级缓存</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">    	throws BeanCreationException &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        //允许后置处理器重新定义beanDefinition</span><br><span class="line">		synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">			if (!mbd.postProcessed) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					//第三次调用后置处理器 MergedBeanDefinitionPostProcessors</span><br><span class="line">					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				catch (Throwable ex) &#123;</span><br><span class="line">					throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">							&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				mbd.postProcessed = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//判断是否允许循环依赖，默认是允许的，可以通过代码修改的一般只有allowCircularReferences的值</span><br><span class="line">		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">						&quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			// getEarlyBeanReference里面包含了又一次后置处理器的调用，SmartInstantiationAwareBeanPostProcessor </span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="属性填充：populateBean"><a href="#属性填充：populateBean" class="headerlink" title="属性填充：populateBean"></a>属性填充：populateBean</h4><p>然后做一些处理比如循环依赖等，直到看到populateBean(beanName, mbd, instanceWrapper);这个代码，这一步负责属性装配，很重要，因为前面的实例只是实例化了，并没有设值，这里就是设值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//填充属性（即自动注入） 完成第五次和第六次后置处理器的调用</span></span><br><span class="line">        <span class="comment">// InstantiationAwareBeanPostProcessor.after</span></span><br><span class="line">        <span class="comment">// hasInstantiationAwareBeanPostProcessors</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">//完成第七次和第八次后置处理器的调用，</span></span><br><span class="line">        <span class="comment">//判断当前Bean，是否是BeanNameAware、BeanClassLoaderAware、BeanFactoryAware并分别设置相关内容</span></span><br><span class="line">        <span class="comment">//applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line">        <span class="comment">//applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">populateBean方法完成属性填充，跟进</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在设置属性之前，让任何 InstantiationAwareBeanPostProcessors 有机会修改 bean 的状态。例如，这可用于支持字段注入样式。</span></span><br><span class="line">  <span class="comment">//扩展点，又一次调用后置处理器，</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果后置处理器修改了Beandefinition，则判断是否已经修改过了属性值的相关配置</span></span><br><span class="line">   <span class="comment">//如果修改了，则按照器byName或byType的方式直接完成装载</span></span><br><span class="line">   <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">      <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   [] filteredPds = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">         pvs = mbd.getPropertyValues();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">//利用后置处理器，处理属性的获取</span></span><br><span class="line">            <span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">                  filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">               &#125;</span><br><span class="line">               pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">      <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">         filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      &#125;</span><br><span class="line">      checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//根据PropertyValues完成属性填充</span></span><br><span class="line">      applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>populateBean里面再次调用后置处理器，spring在这里提供了一个扩展点，允许开发者在属性填充这个阶段修改Bean的状态（使用后置处理器的方式）。并且可能直接依据byName和byType装载属性值。</p>
<p>我们知道，使用自动装载这一功能时，我们可以使用@Autowired和@Resource。这两个注解的功能也不一样。那么解析的方式也应当不一样。</p>
<h3 id="factorybean和beanfactory"><a href="#factorybean和beanfactory" class="headerlink" title="factorybean和beanfactory"></a>factorybean和beanfactory</h3><p>在我们的开发工作中应该都见过或使用过FactoryBean这个类，也许你会看成了BeanFactory这个类。FactoryBean和BeanFactory虽然长的很像，但是他们的作用确实完全不像。这里你可以想象一下，你会在什么样的场景下使用FactoryBean这个接口？FactoryBean是一个工厂Bean，可以生成某一个类型Bean实例，它最大的一个作用是：可以让我们自定义Bean的创建过程。BeanFactory是Spring容器中的一个基本类也是很重要的一个类，在BeanFactory中可以创建和管理Spring容器中的Bean，它对于Bean的创建有一个统一的流程。下面我们先看一下FactoryBean中有什么东西：</p>
<p>背景<br>假设我们有这种需求，像Mybaits需要将这些接口注入到Spring容器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface OneTestDao &#123;</span><br><span class="line">    @Select(&quot;SELECT name FROM user WHERE id = 1&quot;)</span><br><span class="line">    String query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface TwoTestDao &#123;</span><br><span class="line">    @Select(&quot;SELECT name FROM user WHERE id = 2&quot;)</span><br><span class="line">    String query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先我们想将我们的自己的Bean(比如代理对象)注入到Spring容器中，有什么方式呢？</p>
<p>一般都是通过Spring扫描Resouce资源然后解析为BeanDefinition，才能从getBean时解析BeanDefinition实例化对象放入此单例缓存中.但是我们这里的是接口，没法直接注入到Spring容器中。</p>
<p>不过Spring提供了一些扩展接口来供我们在Bean加载、初始化、加载完提供了一些接口，供我们扩展。<br>比如BeanFactoryPostProcessor</p>
<p>从测试结果中得知，我们虽然配置的是<code>MapperFactoryBean</code>的实列，但是根据id拿到的是<code>getObject</code>方法创建的对象。其实在容器中创建的对象仍然是<code>MapperFactoryBean</code>的实列，只是在获取的时候会判断这个结果对象是不是派生于<code>FactoryBean</code>，如果是的话则返回<code>getObject</code>方法创建的对象，并且这个对象并不是容器初始化时创建的，而是使用<code>context.getBean()</code>方法时才创建。当然了，如果你确实想要获取<code>FactoryBean</code>实例，你需要这样写: <em><code>MapperFactoryBean mapper = context.getBean(&quot;&amp;mapper&quot;, MapperFactoryBean.class);</code></em> 只需要在bean的名字ID前加上&amp;符号。</p>
<p>非常重要：想知道factory流程，请结合</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30881367/article/details/98567729?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mapperfactorybean%E7%9A%84%E4%BD%9C%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-98567729.nonecase&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_30881367/article/details/98567729?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mapperfactorybean%E7%9A%84%E4%BD%9C%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-98567729.nonecase&amp;spm=1018.2226.3001.4187</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Roger_CX/article/details/120739214?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168111515116800192294702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168111515116800192294702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-120739214-null-null.142%5Ev82%5Ekoosearch_v1,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=FactoryBean%E4%BD%9C%E7%94%A8&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/Roger_CX/article/details/120739214?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168111515116800192294702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168111515116800192294702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-120739214-null-null.142^v82^koosearch_v1,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=FactoryBean%E4%BD%9C%E7%94%A8&amp;spm=1018.2226.3001.4187</a></p>
<p><strong>FactoryBean是一个能生产或修饰对象生成的工厂Bean</strong>。一个Bean如果实现了FactoryBean接口，那么<strong>根据该Bean的名称获取到的实际上是getObject返回的对象</strong>，而不是这个Bean自身实例，如果<strong>要获取这个Bean自身实例，那么需要在名称前面加上’&amp;’符号</strong>。</p>
<p>创建bean的两种方式：</p>
<p>第一种，单例在Spring容器初始化之前， 就已经创建了bean，且整个应用只有一个。</p>
<p>第二种，多例在用到对象的时候，才创建对象，当我们在A类中需要用到B类时，通过@Autowired注解注入用到时。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/11/spring%20ioc%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/04/04/CS:%E5%9C%BA%E6%99%AF%E9%A2%98/"
                            aria-label=": 待定"
                        >
                            待定
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-04T00:00:00+08:00">
	
		    04 Apr 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><strong>订单超时自动取消功能如何设计？</strong></p>
<blockquote>
<p>首先，这个订单肯定已经是产生了的。</p>
<p>一种方法就是：定时任务+轮训，但是如果订单很多的情况下，就合适了。</p>
<p>时间轮算法：受到内存限制，可能会OOM，甚至说浪费空间。</p>
<p>redis过期事件：</p>
<p>延迟消息mq，设置一个时间，等到这个时间到了我们去检查用户是否支付</p>
<p>最好还是用消息队列mq</p>
</blockquote>
<p><strong>在 2G 大小的文件中，找出高频top100的单词</strong></p>
<blockquote>
<p>关于这个问题，我说一下我的回答思路 1. 把 2G 的文件进行分割成大小为 512KB 小文件，总共得到2048 个小文件，避免一次性读入整个文件造成内存不足。 2. 定义一个长度为 2048 的 hash 表数组，用来统计每个小文件中单词出现的频率。3. 使用多线程并行遍历 2048 个小文件，针对每个单词进行 hash 取模运算分别存储到长度为 2048 的 hash 表数组中 inthash&#x3D;Math.abs(word.hashCode() %hashTableSize); hashTables[hash].merge(word, 1, Integer::sum); 4. 接着再遍历这 2048 个 hash 表，把频率前 100 的单词存入小顶堆中5. 最后，小顶堆中最终得到的 100 个单词，就是 top 100 了。这种解决方案的核心思想是将大文件分割为多个小文件，然后采用分治和堆的算法，来解决这个问题。</p>
</blockquote>
<p><strong>设目前有一千万个字符串,请你统计最热门的10个查询</strong><br>要求使用的内存不能超过1G。</p>
<blockquote>
<p>1、可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数，用最小堆处理每个小文件的top10，最后扫描小文件的以得到最后的结。</p>
</blockquote>
<p><strong>40亿个非负整数中找到没出现的数</strong></p>
<blockquote>
<p>布隆过滤器</p>
</blockquote>
<p><strong>40亿个非负整数中找到出现两次的数</strong></p>
<blockquote>
<p>两个布隆过滤器，出现1次01，出现两次10，出现三次11，出现0次00.</p>
</blockquote>
<p><strong>求中位数</strong></p>
<blockquote>
<p><strong>桶排序</strong></p>
<p>1.假设整数为有符号的32位数据，其取值范围是[-2^31, 2^31-1]，将范围等份划分10000段，即thread_1[],thread_2[]…thread_10000[]。</p>
<p>　　2.将数据分为10组依次读入。首先装载第一个1G个数，遍历这些数，看它们落入thread_1[]至thread_10000[]的哪个区间，落入的对应区间统计计数增1；然后装载第二个1亿个数，重复比较与计数。</p>
<p>　　3.数据全部装载一次之后，从thread_1[]的计数开始累加，直至计数累加到全部数据的一半（假设为N&#x2F;2），那么第N&#x2F;2个元素所在的区间thread_i[]就包含了中位数。</p>
<p>　　4.假设中位数区间的范围是[a, b]，且前面所有区间的数据计数共有m个，再次按照每组1G个元素遍历全部数据，对于处在thread_i[]区间的每个元素都进行计数。</p>
<p>　　5.当thread_i[]区间每个元素的计数累加之和加上m第一次超过N&#x2F;2时，该计数处的元素就是中位数。</p>
<p>　　这种方法需要两次遍历全部数据，效率较高。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/04/04/CS:%E5%9C%BA%E6%99%AF%E9%A2%98/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/20/%E5%AF%B9%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%96%B0%E7%90%86%E8%A7%A3/"
                            aria-label=": 对权限校验和token的新理解"
                        >
                            对权限校验和token的新理解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-20T14:43:00+08:00">
	
		    20 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="对权限校验和token的新理解"><a href="#对权限校验和token的新理解" class="headerlink" title="对权限校验和token的新理解"></a>对权限校验和token的新理解</h1><p>在我们前端页面发出请求的时候，会先发出一个预检请求，看看这个接口是否好用，但不会去检验这个接口是否正确。比如说：发出get请求，对info这个接口进行校验，所以他会先发一个get的预检验去看看你这个接口能不能收到我这个get。如果可以，get请求返回之后会告诉我们前端可以发送，这时候前端发出真正的请求（带着参数的那种）。</p>
<p>下面简单讲一下权限校验的流程，以防止自己忘记和供大家参考（勿喷）。</p>
<p>首先我们前端服务启动之后，假设端口是8090，我们输入账号密码点击登陆，这时候前端服务会<br>将其发送到另一个端口，这里涉及跨域了，一般前端会有个简单的处理，然后后端也会有一个允许跨域什么的配置（有可能是在security里面设置或者是自己configuration一个配置文件）。</p>
<p>假设我们转发到了8201接口，那么请问这个接口是什么服务的接口呢？答案揭晓，一般是网关服务这边借鉴我自己的项目，用的是gateway的。</p>
<p>然而我们知道gateway服务一般会进行拦截访问校验权限这类工作。那么这个gateway服务，对于这种登陆的接口访问，又会做出什么样子的判断呢？其实对于这类我们会把他列入白名单，所以举个login例子，我在8090端口发出&#x2F;admin&#x2F;login命令，然后遇到gateway网关，网关直接放行，那么我们假设admin端口是8080端口，那这时候request是不是通过转发变成了：8080&#x2F;admin&#x2F;login，然后带一些账号密码这类参数什么的。</p>
<p>下面很关键。</p>
<p>一般我们的login命令是不是首先要取得授权啊，你不授权你登陆各寂寞呢。那么这时候就要请出我们的授权服务了，Auth服务。我们可以直接在login的controller里面写调用获取授权的服务。</p>
<p>那用什么授权呢，举个例子token或者是token的变体。下面用spring security oauth2讲一下这个token怎么获取，又怎么调教。</p>
<p>其实大家不用吧授权服务想的很难，无非就是自己写了一些接口，你去调用，然后判断，如果对就通过，如果错误就失败。</p>
<p>那么这边我们举个例子<br>在login函数里面调用这个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CommonResult restResult = authService.getAccessToken(params);</span><br></pre></td></tr></table></figure>
<p>然后authService如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(&quot;auth-server&quot;)</span><br><span class="line">public interface AuthService &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(value = &quot;/oauth/token&quot;)</span><br><span class="line">    CommonResult getAccessToken(@RequestParam Map&lt;String, String&gt; parameters);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候通过注解直接跑掉另一个端口服务了。</p>
<h1 id="Auth服务"><a href="#Auth服务" class="headerlink" title="Auth服务"></a>Auth服务</h1><h2 id="token的生成"><a href="#token的生成" class="headerlink" title="token的生成"></a>token的生成</h2><p>我们需要配置令牌访问的端点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void configure(AuthorizationServerEndpointsConfigurer endpoints)</span><br></pre></td></tr></table></figure>
<p>在这里我们可以自定义授权方式，比如说微信授权、手机号授权等等。当时我们先讲token的生成</p>
<p>1、用户发起获取token的请求，请求&#x2F;oauth&#x2F;token接口</p>
<p>2、首先要过一道关卡是ClientCredentialsTokenEndpointFilter</p>
<ol>
<li>通过clientId查询生成一个Authentication对象</li>
<li>将clientId和clientSecret构造成UsernamePasswordAuthenticationToken,交给ProviderManager，然后ProviderManager代理AuthenticationProvider去认证，最后真正执行的是DaoAuthenticationProvider，通过UserDetailsService.loadUserByUsername向表oauth_client_details查询clientDetails信息</li>
</ol>
<p>3、 以上认证客户端信息的逻辑全部通过后，会进入地址&#x2F;oauth&#x2F;token，即TokenEndpoint的postAccessToken方法(当然这个方法我们可以自定义)中。</p>
<p>4、 postAccessToken方法中会验证Scope，然后验证是否是refreshToken请求等</p>
<p>5、 AbstractTokenGranter(此时的实现类是ResourceOwnerPasswordTokenGranter)中的grant方法</p>
<p>6、 之后调用AbstractTokenGranter(此时的实现类ResourceOwnerPasswordTokenGranter)中的grant方法</p>
<p>7、 grant方法中调用getAccessToken方法，在这个方法中又逐步调用到WebSecurityConfigurerAdapter的AbstractUserDetailsAuthenticationProvider的authenticate方法（<br>非常关键的一点</p>
<ul>
<li>先看缓存有没有</li>
<li>看数据库UserDetails loadedUser &#x3D; this.getUserDetailsService().loadUserByUsername(username);</li>
</ul>
<p>），对username与password进行认证</p>
<p>8、 验证通过后，把得到Authentication认证结果对象包装成OAuth2Authentication认证对象。然后传给DefaultTokenServices类的tokenStore的getAccessToken方法，利用OAuth2Authentication对象中的信息查找tokenStore中是否已经存在token，存在则返回OAuth2AccessToken对象。如果不存在DefaultTokenServices则调用createAccessToken（增强方法就在这里实现，这个方法主要做了五件事情，</p>
<ul>
<li>使用UUID生成Token</li>
<li>判断Token是否过期，如果没过期，就把过期时间设为当前时间加1000s</li>
<li>设置刷新令牌</li>
<li>设置权限</li>
<li>判断是否有增强器，如果有就调用它的enhance方法）</li>
</ul>
<p>方法创建OAuth2AccessToken对象。</p>
<p>9、 然后将OAuth2AccessToken对象包装进响应流返回。</p>
<h2 id="token刷新"><a href="#token刷新" class="headerlink" title="token刷新"></a>token刷新</h2><p>刷新token（refresh token）的流程与获取token的流程只有8有所区别：</p>
<p>1.获取token调用的是AbstractTokenGranter中的getAccessToken方法，然后调用tokenStore中的getAccessToken方法获取token。</p>
<p>2.刷新token调用的是RefreshTokenGranter中的getAccessToken方法，然后使用tokenStore中的refreshAccessToken方法获取token。</p>
<h2 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h2><p>当我们拿到token之后我们会拿着这个token去访问其他的接口，比如说我们login接口成功返回之后，你马上紧接着就访问info接口，你直接8080&#x2F;admin&#x2F;info这么发过去，首先找到gateway，gateway首先要鉴定一下你这个是不是有权限是不是啊？那么这里就涉及了鉴权服务。<br>这个鉴权服务分为两个部分：</p>
<p>1、token 检验<br>首先调用下面这个代码，不过readaccesstoken具体的实现我们可以自定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OAuth2AccessToken oAuth2AccessToken = this.tokenStore.readAccessToken(accessToken);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总之就去去查你这个token有没有，没有的话，就返回没有token的信息错误。<br>如果有，继续判断是不是过期了，如果过期了，就返回过期的错误信息<br>然后通过这个token去缓存或者数据库里面找到OAuth2Authentication对象，如果没有再次返回无效异常，如果有，那我们就通过token的校验，进入到权限的校验。</p>
<p>OAuth2AccessToken和OAuth2Authentication是好基友，TokenStore同时存储OAuth2AccessToken和OAuth2Authentication</p>
<p>2、权限检验</p>
<p>进来之后如果是白名单，我们就放行，毕竟有些东西确实不需要什么权限。</p>
<p>跨域的预检也放行，这一点在上面也提到过，预检验，你要是把他拦下来，那就没必要了。</p>
<p>下面进入真正的检验从request获取token，提取信息组装成一个对象（dto）</p>
<p>非管理端直接放行，这个意思是，我们的后台服务不是所有人都能进来的，要是你一个用户能进我们的后台那就完蛋了。</p>
<p>去缓存里面拿到资源规则，然后对比两者的访问路径，要是匹配得上就把相应的权限加到一个集合里面。</p>
<p>这时候我们就得到访问这个路径需要的权限，那我们就用自己的权限去对比，要是比他高，那就通过，要是不如，那就拒绝。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/20/%E5%AF%B9%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%96%B0%E7%90%86%E8%A7%A3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/04/spring%E6%95%B4%E5%90%88docker-compose/"
                            aria-label=": springboot/cloud整合docker-compose"
                        >
                            springboot/cloud整合docker-compose
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-04T21:25:08+08:00">
	
		    04 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>docker-compose是一个定义复杂应用的工具，我们平时使用docker，一般是docker run ….</p>
<p>然而这样每次只能运行一个镜像，而且不能保证各个容器之间是能够正常通信的，如果想要用docker做到这种容器之间相互通信，要么你每次的命令加上一大串的参数，比如说同一个网络名字啊，link啊，dependon啊，如此之类的，然而单单跑一个容器的命令的够长了，这个容器要是和4、5个其他的容器通信，那怎么写？</p>
<p>这就引出了我们的第二种方法：docker-compose，<br>关于这个工具我们需要下载，如果我们使用的是docker-desktop这种可视化客户端，那么他已经安装好了：怎么判断自己是不是已经完成了docker-compose的下载？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose -v   即可</span><br></pre></td></tr></table></figure>
<p>博主跑一个微服务的项目一般喜欢先把环境搭好，然后在测试我么的项目正确性。<br>所以这里就分成了两个docker-compose文件，一个是env，一个是我们的项目app。</p>
<p>这里先介绍一下docker-compse的用法。<br>我们写好一个yml文件，然后docker-compose命令去执行，而这个文件就相当于pom配置文件。<br>具体举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose -f XXXX.yml up 要是路径上面只有一个docker-compose.yml文件那么</span><br><span class="line">-f也可以不加上去，反正就是寻找的意思。</span><br></pre></td></tr></table></figure>
<p>先介绍docker-compose-env.yml, 这里截取一部分，来讲一讲都是什么含义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:8.0.26</span><br><span class="line">    container_name: mysql</span><br><span class="line">    command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 185450844 #设置root帐号密码</span><br><span class="line">    ports:</span><br><span class="line">      - 3307:3306</span><br><span class="line">    volumes:</span><br><span class="line">      - /Users/csen/dockerProject/mydata/mysql/data/db:/var/lib/mysql #数据文件挂载</span><br><span class="line">      - /Users/csen/dockerProject/mydata/mysql/data/conf:/etc/mysql/conf.d #配置文件挂载</span><br><span class="line">      - /Users/csen/dockerProject/mydata/mysql/log:/var/log/mysql #日志文件挂载</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>command：声明启动参数</li>
<li>image：你docker里面的镜像名字</li>
<li>container_name：启动后的容器名字</li>
<li>environment：设置容器中的环境变量</li>
<li>privileged：用来给容器root权限，不安全的</li>
<li>network_mode： 设置容器的网络模式</li>
<li>ports：端口</li>
<li>volumes：挂载，这个大家都没说清楚，就是用冒号前面的路径代替后面，这样一些数据啊配置啊就可以跟着你的要求走。前面的是自己的，后面的是容器的。</li>
</ul>
<p>下面介绍docker-compose-app.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  XXXX:</span><br><span class="line">    image: XXXX:latest</span><br><span class="line">    container_name: XXXX</span><br><span class="line">    ports:</span><br><span class="line">      - 8081:8081</span><br><span class="line">    volumes:</span><br><span class="line">      - /Users/csen/dockerProject/XXXX/logs:/var/logs</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br><span class="line">    environment:</span><br><span class="line">      - &#x27;TZ=&quot;Asia/Shanghai&quot;&#x27;</span><br><span class="line">    external_links:</span><br><span class="line">      - elasticsearch:es #可以用es这个域名访问elasticsearch服务</span><br><span class="line">      - mysql:db #可以用db这个域名访问mysql服务</span><br><span class="line">      - nacos-registry:nacos</span><br></pre></td></tr></table></figure>
<p>和docker-compose-env很像，不过我只是用来启动我们的微服务项目，这里面关键就是external_links，我们在项目中使用的很多localhost要替换成这些域名。</p>
<p>这里的image是我们build好的项目镜像，这里就要提一嘴了。这个是我们build的镜像<br>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，用于构建镜像。每一条指令构建一层镜像，因此每一条指令的内容，就是描述该层镜像应当如何构建<br>具体的可见这篇大佬的博客：  <a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46090675/article/details/121846718?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166489555716782417065884%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166489555716782417065884&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121846718-null-null.142%5Ev51%5Econtrol,201%5Ev3%5Econtrol&utm_term=dockerfile&spm=1018.2226.3001.4187">Dockerfile</a>。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/04/spring%E6%95%B4%E5%90%88docker-compose/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/04/docker%E6%95%B4%E5%90%88springboot:cloud%E2%80%94%E2%80%94nacos2.1.0/"
                            aria-label=": docker整合springboot/cloud——nacos2.1.0"
                        >
                            docker整合springboot/cloud——nacos2.1.0
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-04T21:25:08+08:00">
	
		    04 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>前言：<br>博主从win换成mac后，想试着自己配一下docker环境，花了足足3到4天的时间。<br>由于中土存在各种中间件的兼容问题，mac版和win版的不一致，中间件版本过新等问题，且大多数博客对于版本的描述不够清晰，很难帮到忙，故博主斗胆记录一下，希望对大家有帮助。</p>
<p>环境：</p>
<ul>
<li>springboot: 2.7.0</li>
<li>nacos: 2.1.0</li>
<li>elasticsearch: 8.2.0</li>
<li>kibana: 8.2.0</li>
<li>springcloud: 2021.0.3</li>
<li>springcloudalibaba: 2021.0.1</li>
<li>mysql: 8.0.26</li>
<li>redis: 7</li>
<li>rabbitmq: 3.9.11</li>
<li>jdk: 8</li>
<li>kafka: 3.5.11</li>
</ul>
<h2 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h2><p>这个只说一点就可以了，当然这也是所有中间件的选择方案。版本选对，由于mac有芯片有两代，i5i7和m1m2，这两代的架构是不一样的，所以去hub里面找相应的版本大下载就可以了，举个例子：</p>
<p>我们要下载2.1.0版本的nacos，我们打开hub.docker.com然后搜索nacos，去tag里面输入2.1.0，你会发现，有好多版本，这时候我们要看【os&#x2F;arch】这一栏，你去看看他到底是哪种架构的，有的是linux&#x2F;amd64，有的是linux&#x2F;arm64，有的是两者皆有。如果是i5i7的就去下带amd64的，如果是m1m2的就去下载带arm64的。</p>
<p>不过这里提一嘴，m1m2芯片他自带了转译的功能，也就是说即使是amd64的他也有能力转成适合自己的，但是可能存在两代电脑环境配置的问题，大家还是下载各自适合的最好。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/04/docker%E6%95%B4%E5%90%88springboot:cloud%E2%80%94%E2%80%94nacos2.1.0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/04/docker%E6%95%B4%E5%90%88springboot:cloud%E2%80%94%E2%80%94kibana8.2.0/"
                            aria-label=": docker整合springboot/cloud——kibana8.2.0"
                        >
                            docker整合springboot/cloud——kibana8.2.0
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-04T21:25:08+08:00">
	
		    04 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>前言：<br>博主从win换成mac后，想试着自己配一下docker环境，花了足足3到4天的时间。<br>由于中土存在各种中间件的兼容问题，mac版和win版的不一致，中间件版本过新等问题，且大多数博客对于版本的描述不够清晰，很难帮到忙，故博主斗胆记录一下，希望对大家有帮助。</p>
<p>环境：</p>
<ul>
<li>springboot: 2.7.0</li>
<li>nacos: 2.1.0</li>
<li>elasticsearch: 8.2.0</li>
<li>kibana: 8.2.0</li>
<li>springcloud: 2021.0.3</li>
<li>springcloudalibaba: 2021.0.1</li>
<li>mysql: 8.0.26</li>
<li>redis: 7</li>
<li>rabbitmq: 3.9.11</li>
<li>jdk: 8</li>
<li>kafka: 3.5.11</li>
</ul>
<h2 id="2、kibana8-2-0"><a href="#2、kibana8-2-0" class="headerlink" title="2、kibana8.2.0"></a>2、kibana8.2.0</h2><p>kibana安装完成后打开5601端口，他会在页面左上角显示一段英文串，意思就是没准备好，但实际是因为权限问题，人家进不去。</p>
<p>这个问题大多数博主都没讲到。</p>
<p>解决办法是：你告诉kibana，es的账号密码，我们会发现，在es设置密码的时候有6个用户，那我们到底用哪一个呢？这里有点歧义，我的选择是直接用kibana_system这个用户。因为我们就是kibana所以没什么问题，但是有一个博主用的elastic用户，而我使用这个用户会提示错误，所以大家可以先试试kibana_system然后elastic，具体操作如下：</p>
<p>首先挂载config，把原本自带的挤掉，因为我们在docker修改起来也不方便，所以直接挂载是最简单的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volumes:</span><br><span class="line">     - /Users/csen/dockerProject/mydata/kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml </span><br><span class="line">     - </span><br></pre></td></tr></table></figure>
<p>挂载成功后，在我们的kibana.yml文件中修改内容</p>
<p>1、要对应你们自己修改的密码。如果是elastic那就完全复制，如果不是，就自己改一下密码。<br>2、elasticseatch.hosts那一栏我写的是es：9200，因为我的elasticsearch容器跑通之后，在springboot项目中的别名叫做es，大家根据自己的改哦，别死抄。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># ** THIS IS AN AUTO-GENERATED FILE **</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Default Kibana configuration for docker target</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">server.shutdownTimeout: &quot;5s&quot;</span><br><span class="line">elasticsearch.hosts: [ &quot;http://es:9200&quot; ]</span><br><span class="line">monitoring.ui.container.elasticsearch.enabled: true</span><br><span class="line"># 这里配置中文显示，默认为英文 【English - en (default)、Chinese - zh-CN、Japanese - ja-JP】</span><br><span class="line">i18n.locale: &quot;zh-CN&quot;</span><br><span class="line"># 此处设置elastic的用户名和密码</span><br><span class="line">elasticsearch.username: kibana_system</span><br><span class="line">elasticsearch.password: elastic</span><br><span class="line"></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/04/docker%E6%95%B4%E5%90%88springboot:cloud%E2%80%94%E2%80%94kibana8.2.0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/04/springboot%E6%95%B4%E5%90%88kafka3.1%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/"
                            aria-label=": springboot整合kafka3.1，实现基本配置和操作"
                        >
                            springboot整合kafka3.1，实现基本配置和操作
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-04T21:25:08+08:00">
	
		    04 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="springboot整合kafka3-1，实现基本配置和操作"><a href="#springboot整合kafka3-1，实现基本配置和操作" class="headerlink" title="springboot整合kafka3.1，实现基本配置和操作"></a>springboot整合kafka3.1，实现基本配置和操作</h1><p>这篇是单机的zookeeper形式，适用于入门。等有时间会更新kraft搭建。</p>
<p>博主自己装了双系统，虚拟机刚刚删了，所以没去做集群，不过当大家的kafka版本来到3.1，建议大家去学习KRaft集群搭建而不是去整合zookeeper。下面介绍一下怎么整合，正所谓举一反三，这个会了，到时候换个环境就ok，讲的不好的地方还请见谅。</p>
<p>@[toc]</p>
<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><h3 id="1、springboot"><a href="#1、springboot" class="headerlink" title="1、springboot"></a>1、springboot</h3><p>博主自己用的是2.7版本的</p>
<p>一般关于springboot我会引入一下依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2、kafka"><a href="#2、kafka" class="headerlink" title="2、kafka"></a>2、kafka</h3><h4 id="1、kafka下载"><a href="#1、kafka下载" class="headerlink" title="1、kafka下载"></a>1、kafka下载</h4><p><a target="_blank" rel="noopener" href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a>  这里下载，这里再提一句，建议直接放到d盘e盘一级子目录里面，否则有可能出现启动的时候名字太长的问题</p>
<p>下载之后修改配置文件server.properties</p>
<p>log.dirs&#x3D;E:\kafka_2.13-3.2.3\kafka-logs</p>
<h4 id="2、项目引入依赖"><a href="#2、项目引入依赖" class="headerlink" title="2、项目引入依赖"></a>2、项目引入依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;根据自己的版本选择&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>这里提一句：不一样的springboot对应的kafka依赖版本也不一样，所以先去官网查看依赖版本。</p>
<p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-kafka">https://spring.io/projects/spring-kafka</a>   点这个链接去找对应的，别自己乱下最新的。</p>
<h5 id="新版本的kafka命令和老版本的不一样。"><a href="#新版本的kafka命令和老版本的不一样。" class="headerlink" title="新版本的kafka命令和老版本的不一样。"></a>新版本的kafka命令和老版本的不一样。</h5><p>试着启动，命令看你在哪个文件夹，如果是kafka，用下面的，如果是linux，把bat换成sh</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-server-start.bat config\server.properties</span><br></pre></td></tr></table></figure>

<p>简单使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test（自己取）</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>



<h3 id="3、zookeeper"><a href="#3、zookeeper" class="headerlink" title="3、zookeeper"></a>3、zookeeper</h3><p>新版本的kafka其实自己集成了zookeeper，博主这里同样介绍两种方式，一种自己重新去下个zookeeper，一种用kafka自带的。</p>
<h4 id="1、自带的"><a href="#1、自带的" class="headerlink" title="1、自带的"></a>1、自带的</h4><p>修改配置zookeeper.properties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataDir=/opt/kafka/zookeeper/data/dataDir</span><br><span class="line">dataLogDir=/opt/kafka/zookeeper/data/dataLogDir</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line"># disable the per-ip limit on the number of connections since <span class="built_in">this</span> is a non-production config</span><br><span class="line">maxClientCnxns=<span class="number">100</span></span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line">initLimit=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br></pre></td></tr></table></figure>

<h4 id="2、自己下载zookeeper"><a href="#2、自己下载zookeeper" class="headerlink" title="2、自己下载zookeeper"></a>2、自己下载zookeeper</h4><p>由于是自己下载所以也不用去配置kafka文件中的zookeeper.properties</p>
<p><a target="_blank" rel="noopener" href="https://zookeeper.apache.org/releases.html#download">https://zookeeper.apache.org/releases.html#download</a>  这是下载地址</p>
<p>进去之后很简单，一样改配置，进入conf目录下，将<code>zoo_example.cfg</code>重命名为<code>zoo.cfg</code></p>
<p>同样修改dataDir和log， 我的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">example sakes.</span><br><span class="line"></span><br><span class="line">dataDir=E:\\java-configuration\\apache-zookeeper-<span class="number">3.7</span><span class="number">.1</span>-bin\\data</span><br><span class="line"></span><br><span class="line">存放事务日志目录</span><br><span class="line"></span><br><span class="line">dataLogDir=E:\\java-configuration\\apache-zookeeper-<span class="number">3.7</span><span class="number">.1</span>-bin\\logs</span><br></pre></td></tr></table></figure>

<p>然后运行zkserver.cmd和zkcli.cmd, 一个是启动我们的zookeeper服务器，一个是客户端。</p>
<h2 id="springboot整合操作kafka"><a href="#springboot整合操作kafka" class="headerlink" title="springboot整合操作kafka"></a>springboot整合操作kafka</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-KCJ0jkN3-1664006842070)(C:\Users\CSEN\AppData\Roaming\Typora\typora-user-images\image-20220924153503966.png)]</p>
<p>这里用一张图作为流程讲解如何整合。</p>
<h3 id="1、config"><a href="#1、config" class="headerlink" title="1、config"></a>1、config</h3><p>其实可以把下面的conponent exception filter什么的都丢进来，可以配一些生产者消费者的信息，想配什么都可以，这个就不展示了。</p>
<h3 id="2、回调（conponent）"><a href="#2、回调（conponent）" class="headerlink" title="2、回调（conponent）"></a>2、回调（conponent）</h3><p>回调有多种写法，这里介绍三种</p>
<h4 id="1、较为泛用的"><a href="#1、较为泛用的" class="headerlink" title="1、较为泛用的"></a>1、较为泛用的</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class KafkaSendResultHandler implements ProducerListener &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSuccess(ProducerRecord producerRecord, RecordMetadata recordMetadata) &#123;</span><br><span class="line">        System.out.println(&quot;Message send success : &quot; + producerRecord.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(ProducerRecord producerRecord, RecordMetadata recordMetadata, Exception exception) &#123;</span><br><span class="line">        System.out.println(&quot;Message send error : &quot; + producerRecord.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在生产者里面使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private KafkaSendResultHandler kafkaSendResultHandler;</span><br><span class="line"></span><br><span class="line">。。。。。省略</span><br><span class="line"></span><br><span class="line">kafkaTemplate.setProducerListener(kafkaSendResultHandler);    </span><br></pre></td></tr></table></figure>

<h4 id="2、一个方法对应一个特定的回调"><a href="#2、一个方法对应一个特定的回调" class="headerlink" title="2、一个方法对应一个特定的回调"></a>2、一个方法对应一个特定的回调</h4><h5 id="1、第一种写法"><a href="#1、第一种写法" class="headerlink" title="1、第一种写法"></a>1、第一种写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(<span class="string">&quot;topic1&quot;</span>, callbackMessage).addCallback(success -&gt;&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> success.getRecordMetadata().topic();</span><br><span class="line">    <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> success.getRecordMetadata().partition();</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> success.getRecordMetadata().offset();</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息成功:&quot;</span> + topic + <span class="string">&quot;-&quot;</span> + partition + <span class="string">&quot;-&quot;</span> + offset);</span><br><span class="line"></span><br><span class="line">&#125;, failure -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息失败:&quot;</span> + failure.getMessage());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="2、第二种写法"><a href="#2、第二种写法" class="headerlink" title="2、第二种写法"></a>2、第二种写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(<span class="string">&quot;topic1&quot;</span>, callbackMessage).addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;SendResult&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息失败：&quot;</span>+ex.getMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult&lt;String, Object&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：&quot;</span> + result.getRecordMetadata().topic() + <span class="string">&quot;-&quot;</span></span><br><span class="line">                + result.getRecordMetadata().partition() + <span class="string">&quot;-&quot;</span> + result.getRecordMetadata().offset());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3、consumer-消费者"><a href="#3、consumer-消费者" class="headerlink" title="3、consumer(消费者)"></a>3、consumer(消费者)</h3><p>使用KafkaListener，指定消息类型（必选）和groupid，partitions offset（可选）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, groupId = &quot;felix-group0&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage1(ConsumerRecord&lt;?,?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;简单消费：&quot; + record.topic() + &quot;--&quot; + record.partition() + &quot;--&quot; + record.value());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@KafkaListener(id = &quot;comsumer1&quot;, groupId = &quot;felix-group1&quot;, topicPartitions = &#123;</span><br><span class="line">        @TopicPartition(topic = &quot;topic1&quot;, partitions = &#123;&quot;0&quot;&#125;),</span><br><span class="line">        @TopicPartition(topic = &quot;topic2&quot;, partitionOffsets = @PartitionOffset(partition = &quot;0&quot;, initialOffset = &quot;8&quot;))</span><br><span class="line">&#125; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage2(ConsumerRecord&lt;?, ?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;topic:&quot;+record.topic()+&quot;|partition:&quot;+record.partition()+&quot;|offset:&quot;+record.offset()+&quot;|value:&quot;+record.value());</span><br><span class="line">&#125;</span><br><span class="line">@KafkaListener(id = &quot;consumer2&quot;,groupId = &quot;felix-group2&quot;, topics = &quot;topic1&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage3(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records) &#123;</span><br><span class="line">    System.out.println(&quot;&gt;&gt;&gt;批量消费一次，records.size()=&quot;+records.size());</span><br><span class="line">    for (ConsumerRecord&lt;?, ?&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、controller生产者（produces）"><a href="#4、controller生产者（produces）" class="headerlink" title="4、controller生产者（produces）"></a>4、controller生产者（produces）</h3><h4 id="1、同步发送"><a href="#1、同步发送" class="headerlink" title="1、同步发送"></a>1、同步发送</h4><p>如果需要使用同步发送，可以在每次发送之后使用get方法，因为producer.send方法返回一个Future类型的结果，Future的get方法会一直阻塞直到该线程的任务得到返回值，也就是broker返回发送成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(&quot;test&quot;, message).get();</span><br></pre></td></tr></table></figure>

<h4 id="2、异步发送"><a href="#2、异步发送" class="headerlink" title="2、异步发送"></a>2、异步发送</h4><p>可以从返回的future对象中稍后获取发送的结果，ProducerRecord、RecordMetadata包含了返回的结果信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(&quot;test&quot;, message);</span><br></pre></td></tr></table></figure>

<h4 id="3-使用ack机制实现可靠"><a href="#3-使用ack机制实现可靠" class="headerlink" title="3. 使用ack机制实现可靠"></a>3. 使用ack机制实现可靠</h4><p>producers可以一步的并行向kafka发送消息，但是通常producer在发送完消息之后会得到一个响应，返回的是offset值或者发送过程中遇到的错误。这其中有个非常重要的参数“request.required.acks”，这个参数决定了producer要求leader partition收到确认的副本个数：</p>
<ul>
<li>如果acks设置为0，表示producer不会等待broker的相应，所以，producer无法知道消息是否发生成功，这样有可能导致数据丢失，但同时，acks值为0会得到最大的系统吞吐量。</li>
<li>若acks设置为1，表示producer会在leader partition收到消息时得到broker的一个确认，这样会有更好的可靠性，因为客户端会等待知道broker确认收到消息。</li>
<li>若设置为-1，producer会在所有备份的partition收到消息时得到broker的确认，这个设置可以得到最高的可靠性保证。</li>
</ul>
<h3 id="5、exception"><a href="#5、exception" class="headerlink" title="5、exception"></a>5、exception</h3><p>bean注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ConsumerAwareListenerErrorHandler consumerAwareErrorHandler() &#123;</span><br><span class="line">    return (message, exception, consumer) -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;消费异常：&quot;+message.getPayload());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费异常配置注解实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, groupId = &quot;felix-group0&quot; ,errorHandler = &quot;consumerAwareErrorHandler&quot;)</span><br><span class="line">public void onMessage1(ConsumerRecord&lt;?,?&gt; record)&#123;</span><br><span class="line">    System.out.println(&quot;简单消费：&quot; + record.topic() + &quot;--&quot; + record.partition() + &quot;--&quot; + record.value());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6、filter"><a href="#6、filter" class="headerlink" title="6、filter"></a>6、filter</h3><p>bean注入factory的时候配置好消息过滤策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置消息过滤策略</span><br><span class="line">    @Bean(value = &quot;filterContainerFactory&quot;)</span><br><span class="line">    public ConcurrentKafkaListenerContainerFactory concurrentKafkaListenerContainerFactory() &#123;</span><br><span class="line">        ConcurrentKafkaListenerContainerFactory factory = new ConcurrentKafkaListenerContainerFactory();</span><br><span class="line">        factory.setConsumerFactory(consumerFactory);</span><br><span class="line">        // 被过滤的消息将被丢弃</span><br><span class="line">        factory.setAckDiscarded(true);</span><br><span class="line">        // 消息过滤策略</span><br><span class="line">        factory.setRecordFilterStrategy(consumerRecord -&gt; &#123;</span><br><span class="line">            if (Integer.parseInt(consumerRecord.value().toString()) % 2 == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return factory;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>消费异常配置注解实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息过滤监听</span><br><span class="line">    @KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, containerFactory = &quot;filterContainerFactory&quot;)</span><br><span class="line">    public void onMessage6(ConsumerRecord&lt;?, ?&gt; record) &#123;</span><br><span class="line">        System.out.println(record.value());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>e {<br>                return true;<br>            }<br>        });</p>
<pre><code>    return factory;

&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">消费异常配置注解实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 消息过滤监听<br>    @KafkaListener(topics &#x3D; {“topic1”}, containerFactory &#x3D; “filterContainerFactory”)<br>    public void onMessage6(ConsumerRecord<?, ?> record) {<br>        System.out.println(record.value());<br>    }</p>
<h3 id="7、序列化编码解码"><a href="#7、序列化编码解码" class="headerlink" title="7、序列化编码解码"></a>7、序列化编码解码</h3><p>序列化器都实现了接口（<code>org.apache.kafka.common.serialization.Serializer</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Serializer&lt;T&gt; extends Closeable &#123;</span><br><span class="line">	default void configure(Map&lt;String, ?&gt; configs, Boolean isKey) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	byte[] serialize(String var1, T var2);</span><br><span class="line">	default byte[] serialize(String topic, Headers headers, T data) &#123;</span><br><span class="line">		return this.serialize(topic, data);</span><br><span class="line">	&#125;</span><br><span class="line">	default void close() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们只用去实现serialize即可</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><pre><code>public class MySerializer implements Serializer &#123;
    @Override
    public byte[] serialize(String s, Object o) &#123;
        String json = JSON.toJSONString(o);
        return json.getBytes();
&#125;
&#125;
</code></pre>
<h4 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyDeserializer implements Deserializer &#123;</span><br><span class="line">    private final static Logger logger = LoggerFactory.getLogger(MyDeserializer.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object deserialize(String s, byte[] bytes) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String json = new String(bytes,&quot;utf-8&quot;);</span><br><span class="line">            return JSON.parse(json);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后在application中配置key-serializer 和 value-serializer</p>
<h3 id="8、分区策略"><a href="#8、分区策略" class="headerlink" title="8、分区策略"></a>8、分区策略</h3><p>分区策略一般分为四种情况：</p>
<ul>
<li>有分区号，直接将数据发送到指定的分区里面去</li>
<li>没有分区号，但是给了数据的key值，根据key取hashCode进行分区</li>
<li>分区号和key值都没有，直接使用默认的轮循分区</li>
<li>自定义分区</li>
</ul>
<h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试</span><br><span class="line">        kafkaTemplate.send(&quot;test&quot;, 0, key, &quot;key=&quot; + key + &quot;，msg=指定0号分区&quot;);</span><br><span class="line">        kafkaTemplate.send(&quot;test&quot;, key, &quot;key=&quot; + key + &quot;，msg=不指定分区&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line"><span class="comment">//        定义自己的分区策略</span></span><br><span class="line"><span class="comment">//                如果key以0开头，发到0号分区</span></span><br><span class="line"><span class="comment">//                其他都扔到1号分区</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyStr</span> <span class="operator">=</span> key+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (keyStr.startsWith(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitionTemplate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.kafka.bootstrap-servers&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKafkaTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);</span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        <span class="comment">//注意分区器在这里！！！</span></span><br><span class="line">        props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, MyPartitioner.class);</span><br><span class="line">        <span class="built_in">this</span>.kafkaTemplate = <span class="keyword">new</span> <span class="title class_">KafkaTemplate</span>&lt;String, String&gt;(<span class="keyword">new</span> <span class="title class_">DefaultKafkaProducerFactory</span>&lt;&gt;(props));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> KafkaTemplate <span class="title function_">getKafkaTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试自定义分区发送</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitionProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyPartitionTemplate template;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    使用0开头和其他任意字母开头的key发送消息</span></span><br><span class="line"><span class="comment">//    看控制台的输出，在哪个分区里？</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/kafka/myPartitionSend/&#123;key&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartition</span><span class="params">(<span class="meta">@PathVariable(&quot;key&quot;)</span> String key)</span> &#123;</span><br><span class="line">        template.getKafkaTemplate().send(<span class="string">&quot;test&quot;</span>, key,<span class="string">&quot;key=&quot;</span>+key+<span class="string">&quot;，msg=自定义分区策略&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/04/springboot%E6%95%B4%E5%90%88kafka3.1%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/10/04/%E6%95%B4%E5%90%88docker%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%B0%E5%BD%95/"
                            aria-label=": 整合docker和中间件记录"
                        >
                            整合docker和中间件记录
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-10-04T21:23:41+08:00">
	
		    04 Oct 2022
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>前言：<br>博主从win换成mac后，想试着自己配一下docker环境，花了足足3到4天的时间。<br>由于中土存在各种中间件的兼容问题，mac版和win版的不一致，中间件版本过新等问题，且大多数博客对于版本的描述不够清晰，很难帮到忙，故博主斗胆记录一下，希望对大家有帮助。</p>
<p>环境：</p>
<ul>
<li>springboot: 2.7.0</li>
<li>nacos: 2.1.0</li>
<li>elasticsearch: 8.2.0</li>
<li>kibana: 8.2.0</li>
<li>springcloud: 2021.0.3</li>
<li>springcloudalibaba: 2021.0.1</li>
<li>mysql: 8.0.26</li>
<li>redis: 7</li>
<li>rabbitmq: 3.9.11</li>
<li>jdk: 8</li>
<li>kafka: 3.5.11</li>
</ul>
<h2 id="1、elasticsearch8-2-0"><a href="#1、elasticsearch8-2-0" class="headerlink" title="1、elasticsearch8.2.0"></a>1、elasticsearch8.2.0</h2><p>当es和kibana到达8版本后，出现了很多变化，而且兼容mac版本的镜像提示不够明确  </p>
<p>可能出现的问题：</p>
<p>1、装好es之后你打开9200端口，发现他要求你输入密码，但是你其实根本就没有告诉你初始账号密码和默认的账号密码</p>
<p>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csen@CsendeMBA Sen-Blog % docker exec -it (容器名字) /bin/bash</span><br><span class="line">elasticsearch@52142308d267:~$ ls</span><br><span class="line">LICENSE.txt  README.asciidoc  config  jdk  logs     plugins</span><br><span class="line">NOTICE.txt   bin              data    lib  modules</span><br><span class="line">elasticsearch@52142308d267:~$ cd config</span><br><span class="line">elasticsearch@52142308d267:~/config$ ls</span><br><span class="line">certs                              jvm.options             role_mapping.yml</span><br><span class="line">elasticsearch-plugins.example.yml  jvm.options.d           roles.yml</span><br><span class="line">elasticsearch.keystore             log4j2.file.properties  users</span><br><span class="line">elasticsearch.yml                  log4j2.properties       users_roles</span><br><span class="line">elasticsearch@52142308d267:~/config$ </span><br></pre></td></tr></table></figure>
<p>你会看到有一个文件叫做elasticsearch.yml,我们需要做的就是修改这个文件</p>
<p>修改文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster.name: &quot;docker-cluster&quot;</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"># Enable security features</span><br><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.security.enrollment.enabled: true（可以先不加，上面的必须加）</span><br></pre></td></tr></table></figure>

<p>当你修改之后，重启容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart 容器名字</span><br></pre></td></tr></table></figure>
<p>等重启之后，进入容器的es内部（可以直接docker desk客户端的cli那里，也可以像上面一样命令行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/share/elasticsearch/bin/x-pack/setup-passwords interactive</span><br></pre></td></tr></table></figure>

<p>依此设置elastic、apm_system、kibana_system、logstash_system、beats_system、remote_monitoring_user6个用户的密码，每设置一个都要验证一次，所以要按12次，建议直接用一个密码就行，我用的是elastic</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initiating the setup of passwords for reserved users elastic,apm_system,kibana,kibana_system,logstash_system,beats_system,remote_monitoring_user.</span><br><span class="line">You will be prompted to enter passwords as the process progresses.</span><br><span class="line">Please confirm that you would like to continue [y/N]y</span><br><span class="line">Enter password for [elastic]: </span><br><span class="line">Reenter password for [elastic]: </span><br><span class="line">Enter password for [apm_system]: </span><br><span class="line">Reenter password for [apm_system]: </span><br><span class="line">Enter password for [kibana_system]: </span><br><span class="line">Reenter password for [kibana_system]: </span><br><span class="line">Enter password for [logstash_system]: </span><br><span class="line">Reenter password for [logstash_system]: </span><br><span class="line">Enter password for [beats_system]: </span><br><span class="line">Reenter password for [beats_system]: </span><br><span class="line">Enter password for [remote_monitoring_user]: </span><br><span class="line">Reenter password for [remote_monitoring_user]: </span><br><span class="line">Changed password for user [apm_system]</span><br><span class="line">Changed password for user [kibana_system]</span><br><span class="line">Changed password for user [kibana]</span><br><span class="line">Changed password for user [logstash_system]</span><br><span class="line">Changed password for user [beats_system]</span><br><span class="line">Changed password for user [remote_monitoring_user]</span><br><span class="line">Changed password for user [elastic]</span><br></pre></td></tr></table></figure>
<p>这时候登陆9200端口查看是否成功，如果成功他会返回一个json串，一看就知道成功的json串，有name clustername、version这些属性。</p>
<h2 id="2、kibana8-2-0"><a href="#2、kibana8-2-0" class="headerlink" title="2、kibana8.2.0"></a>2、kibana8.2.0</h2><p>kibana安装完成后打开5601端口，他会在页面左上角显示一段英文串，意思就是没准备好，但实际是因为权限问题，人家进不去。</p>
<p>这个问题大多数博主都没讲到。</p>
<p>解决办法是：你告诉kibana，es的账号密码，我们会发现，在es设置密码的时候有6个用户，那我们到底用哪一个呢？这里有点歧义，我的选择是直接用kibana_system这个用户。因为我们就是kibana所以没什么问题，但是有一个博主用的elastic用户，而我使用这个用户会提示错误，所以大家可以先试试kibana_system然后elastic，具体操作如下：</p>
<p>首先挂载config，把原本自带的挤掉，因为我们在docker修改起来也不方便，所以直接挂载是最简单的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volumes:</span><br><span class="line">     - /Users/csen/dockerProject/mydata/kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml </span><br><span class="line">     - </span><br></pre></td></tr></table></figure>
<p>挂载成功后，在我们的kibana.yml文件中修改内容</p>
<p>1、要对应你们自己修改的密码。如果是elastic那就完全复制，如果不是，就自己改一下密码。<br>2、elasticseatch.hosts那一栏我写的是es：9200，因为我的elasticsearch容器跑通之后，在springboot项目中的别名叫做es，大家根据自己的改哦，别死抄。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># ** THIS IS AN AUTO-GENERATED FILE **</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Default Kibana configuration for docker target</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">server.shutdownTimeout: &quot;5s&quot;</span><br><span class="line">elasticsearch.hosts: [ &quot;http://es:9200&quot; ]</span><br><span class="line">monitoring.ui.container.elasticsearch.enabled: true</span><br><span class="line"># 这里配置中文显示，默认为英文 【English - en (default)、Chinese - zh-CN、Japanese - ja-JP】</span><br><span class="line">i18n.locale: &quot;zh-CN&quot;</span><br><span class="line"># 此处设置elastic的用户名和密码</span><br><span class="line">elasticsearch.username: kibana_system</span><br><span class="line">elasticsearch.password: elastic</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h2><p>这个只说一点就可以了，当然这也是所有中间件的选择方案。版本选对，由于mac有芯片有两代，i5i7和m1m2，这两代的架构是不一样的，所以去hub里面找相应的版本大下载就可以了，举个例子：</p>
<p>我们要下载2.1.0版本的nacos，我们打开hub.docker.com然后搜索nacos，去tag里面输入2.1.0，你会发现，有好多版本，这时候我们要看【os&#x2F;arch】这一栏，你去看看他到底是哪种架构的，有的是linux&#x2F;amd64，有的是linux&#x2F;arm64，有的是两者皆有。如果是i5i7的就去下带amd64的，如果是m1m2的就去下载带arm64的。</p>
<p>不过这里提一嘴，m1m2芯片他自带了转译的功能，也就是说即使是amd64的他也有能力转成适合自己的，但是可能存在两代电脑环境配置的问题，大家还是下载各自适合的最好。</p>
<h2 id="mysql8"><a href="#mysql8" class="headerlink" title="mysql8"></a>mysql8</h2><p>目前网上的博客大多都是mysql5.7版本之类的，8版本的较少，所以会出一些错误。</p>
<p>特别是连接数据库的时候，大家发现明明我的账号密码都对的，为什么还是说连接错误呢？这其实很可能不是我们自己的问题。</p>
<p>下面给出我的连接数据库的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  url: jdbc:mysql://db:3306/mall?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span><br><span class="line">  username: root</span><br><span class="line">  password: XXXXXXXX</span><br><span class="line">  druid:</span><br><span class="line">    initial-size: 5 #连接池初始化大小</span><br><span class="line">    min-idle: 10 #最小空闲连接数</span><br><span class="line">    max-active: 20 #最大连接数</span><br><span class="line">    web-stat-filter:</span><br><span class="line">      exclusions: &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot; #不统计这些请求数据</span><br><span class="line">    stat-view-servlet: #访问监控网页的登录用户名和密码</span><br><span class="line">      login-username: druid</span><br><span class="line">      login-password: druid</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是一下几点：</p>
<p>1、如果你把项目放到docker里面，就不要用localhost了，要么你直接用ip地址，要么就和我一样用这种别名。<br>而这种别名的配置则放在docker-compose里面。<br>这个在文章最后会给大家放一个链接将docker-compose怎么写。</p>
<p>2、由于版本升级和docker的原因，在连接数据库的时候最好加上这些后缀：</p>
<p>2.1、useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8：一旦设置了之后，不管数据库是什么编码，读取的时候都会转换成UTF-8，存取的时候还是会按数据库编码存</p>
<p>2.2、serverTimezone&#x3D;Asia&#x2F;Shanghai：问题在 MySQL8.0的驱动包跟之前不一样了，默认时区是全球统一时间 (UTC)，北京时间是 UTC+8，这句话不加就导致了很多人就算不在docker里面都连不上数据库，mysql8就很烦。</p>
<p>2.3、useSSL&#x3D;false：useSSL&#x3D;true是进行安全验证，一般通过证书或者令牌什么的，useSSL&#x3D;false就是通过账号密码进行连接，通常使用useSSL&#x3D;false，这个也是mysql8的问题，不过这个问题并不是到了8之后才有的，5.7之后就存在这个问题了。ssl会认证用户的服务器，然后加密数据，最后维护数据的完整性。但是我们用docker相当于把它部署到一个linux服务器上，所以用不到这个。</p>
<p>2.4、allowPublicKeyRetrieval&#x3D;true。</p>
<p>这个指令比较玄学，是由于报了下面错误才用的，Public Key Retrieval is not allowed（不允许检索公钥）。博主也去网上查了很多资料，大家的话大差不差，就是在第一次连接的时候会出问题，第二次连的时候貌似数据库就缓存的这个配置信息，既然加上能用，大家就加上。有一些朋友也说到，如果我们使用一些可视化工具比如navicat这类的也能解决。</p>
<p>另一种法是：使用指令mysql -u root -p指令进入mysql，将验证方式修改为“mysql_native_password”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE mysql; </span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/10/04/%E6%95%B4%E5%90%88docker%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%B0%E5%BD%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/categories/Java/"
                aria-label="NEUERE BEITRÄGE"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEUERE BEITRÄGE</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/categories/Java/page/3/"
                aria-label="ÄLTERE BEITRÄGE"
            >
              <span>ÄLTERE BEITRÄGE</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">Seite 2 von 4</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 CSEN. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
            <h4 id="about-card-name">CSEN</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                浙江温州
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-39paoi2hupf5wmw7ojejrxpco6edftjriz5ezbtp4grymrdceksftgan2adp.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
