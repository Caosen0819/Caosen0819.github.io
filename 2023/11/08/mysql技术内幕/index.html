
<!DOCTYPE html>
<html lang="zh-CH">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="森">
    <title>mysql技术内幕 innodb存储引擎 - 森</title>
    <meta name="author" content="CSEN">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CSEN","sameAs":["https://github.com/Caosen0819"],"image":"head.jpg"},"articleBody":"首先来了解一下InnoDB的体系架构：\n体系架构\n我觉的用一句话概括，就是由很多内存块组成的内存池维护一系列后台线程，然后这些后台线程去负责最重要的工作。主要是内存和后台线程。\n1、后台线程\n主要有：\nmaster thread：最重要的，脏页刷新、合并insert buffer，undo 页的回收，redolog buffer。不过后来脏页回收放到了单独的线程，也就是page thread\nIO thread: 负责异步io的回调\npurge thread: 负责undolog清理\npage clean thread：负责脏页刷新\n\n1、master thread本质是一个循环\n每秒都会进行一次操作：重做日志缓冲刷新、合并insertbuffer，脏页刷新被放到了page clean 线程\n每十秒会进行的操作：重做日志缓冲刷新、合并insertbuffer、脏页刷新被放到了page clean 线程、删除无用的undo 页\n2、内存内存方面就是缓冲池、lrulist freelist flushlist、redo log buffer 三块，还有一些额外内存池（为了数据结构的内存申请服务）\n1、缓冲池本质就是一块内存，缓冲池里面有数据页、索引页、undo 页、insert buffer、自适应哈希索引、锁信息、数据字典。\n所以修改操作，基本都现修改缓冲池里面的数据，然后按照一定刷回机制磁盘。\n2、List缓冲池是通过改进的LRU算法（在原本的基础上加了midpoint，新加入的页放到这里，默认5&#x2F;8）进行管理的，方法就是LRUlist、freelist flushlist。如果缓冲池不能放新的，就把lru里面末尾的释放掉。处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部；否则不变。\n改进lru的原因：有可能新页仅仅是这次查询需要用到，并不是真正的热点数据，这样反而有可能将真正的热点数据淘汰。\nflushlist就是脏页列表，就像上面说的，用checkpoint机制刷新\n一页16k\n说了这么多checkpoint，什么是checkpoint？（当前要刷回的位置）\n1、checkpoint解决问题：\n\n缩短数据库恢复时间？\n\n即使发生宕机， 因为checkpoint之前多页已经刷新回磁盘，所以只需要对checkpoint之后对进行恢复\n\n缓冲池不够时，可以将脏页刷回磁盘？\n\n缓冲池不够用的时候，根据lru找lru末尾的页，如果是脏页，就强制执行checkpoint，讲脏页刷新回磁盘\n\n重做日志不可用，刷新脏页。\n\n重做日志两个文件是循环使用，为了不让他一直无限变大，不可用是指重做日志已经不被需要了可以被覆盖。如果宕机，数据库恢复操作不需要这部分的重做日志就可以覆盖重用。如果此时重做日志还需要用，就必须强制产生checkpoint将讲缓冲池的页至少刷新到当前重做日志的位置\n所以总归checkpoint做的事情就是把脏页刷回磁盘。（脏页刷时机）？\n\n1. redo log 写满。会造成mysql不接受更新。2. 内存不足。3. 空闲时间，认为目前压力不大。（主流）4. Mysql关闭时。\n5、脏页数量太多\n一个是脏页比例，一个是 redo log 写盘速度去计算刷盘的速度。\n\n这里有两种checkpoint，分别是：\n\nsharp checkpoint\nfuzzy checkpoint\n\n\nsharp checkpoint就是在数据库关闭的时候全部刷新到磁盘\nfuzzy checkpoint是刷新部分脏页？刷新到时机如下：\nmaster thread checkpoint（空闲）\nflushlrulist checkpoint：这饿是lru列表需要有100个空闲的页，否则移除lru末尾的页，如果有脏页就checkpoint（内存不足）\nasync sycn flush checkpoint：这个是**重做日志文件不可用的情况，需要强制将一些刷新回磁盘  **（redo）\ndirty page too much：这个是脏页数量太多了，强制checkpoint ，脏页的比例达到75%\n\n3、Redo log buffer这个是innodb独有的，重做日志信息 -&gt;Redo log buffer -〉 重做日志文件，为重做日志文件服务，重做日志文件本身是为了数据库的恢复功能，但是同样的，为了缓解和磁盘的差距，我们给他加一个buffer。\n刷回时机：\n\nmaster thread 每秒\n每个事务提交的时候，有个参数，1代表完全同步，0代表不写磁盘，2表示写到page cache里面，具体刷回靠操作系统\n重做日志缓冲 剩余空间小于1&#x2F;2\n正常关闭\n\n4、额外的缓冲池对于一些数据结构本身的内存分配服务\n关键特性前三个最重要：\n\n1、插入缓冲\n2、两次写\n3、自适应哈希\n4、异步io\n5、刷新邻接页\n\n1、插入缓冲1、insert buffer\n数据插入的时候还是按照主键的位置存放的，但是这个表如果有辅助索引，那么这条记录也会插入辅助索引，但是这时候他就不是顺序插入了，而是离散的插入。我们在对非聚集索引的插入的时候不会实时的插入，而是先判断有没有在缓冲池里面，有的话直接插入，没有的话，先构造一个searchkey，放到一个insert buffer里面。后面再以一定的频率进行insertbuffer和非聚集索页子节点的merge操作。\nchangebuffer的存在让普通索引优于唯一索引。普通索引和唯一索引的查询效率差不多，对于已经在内存的数据更新也差不多。但是对于没有在内存的数据更新操作差很多，因为唯一索引为了保证唯一性，会把数据从磁盘读到内存，这一步是数据库成本最高的操作之一。\ninsert buffer 升级为了 change buffer，对插入更新删除操作都准备了缓冲\n2、insert buffer的内部实现全局唯一的b+树的形式，负责对所有表的辅助索引进行insert buffer，存放在共享表空间，就是ibdata1。但是我们知道，我们可以有独立表ibdata，但是恢复的时候最好用共享表里面的。\n因为是树，所以有非叶子结点和叶子结点。\n非叶子结点放的是searchkey，所以插入非聚集索引的时候，如果不在缓冲池，那么要加入这颗唯一的insertbuffer，实现构造一个searchkey，我想通过这个searchkey找到我要插入的位置，然后再构造一个叶子结点，放进去。\n3、Merge insert buffer所以后面就是合并操作，合并的时机：\n1、master thread\n2、辅助索引页被读到缓冲池里去，然后这个是要执行正常的查询语句了，就去检查这个insert buffer bitmap，确认这个该辅助索引是不是在insert buffer b+书里面，如果有，就把树里面的记录查到辅助索引里面。\n\n2、两次写doublewrite的目的是为了数据的可靠性。\n\n具体实现的话，是依赖于两个部分，一个是内存中的doublewrite buffer，2m。另一部分是磁盘里的共享表空间里面有一个连续的128页，也是2m。\n流程分三步。\n1、我先不直接写磁盘，我先复制到这个内存的doublewrite buffer里面\n2、然后分两次写入，每次1m写入共享表空间的物理磁盘，（顺序写）\n3、然后马上调用fsync函数，同步磁盘。（离散写）\n所以，如果写的时候崩溃了，那就把这个共享表空间里面的副本拿出来配合redo log进行恢复。\n\n\n3、自适应哈希InnoDB会自动为某些访问频率非常高的页建立哈希索引，而哈希索引比起b+树更快，所以也是一种提高性能手段。\n但是有一个比较大的痛点就是他只能用于做 等值查询，如果遇到范围查到，就无能为力。\n文件文件包括mysql文件和innodb文件\n1、参数文件\n2、日志文件、\n3、socket文件\n4、pid文件\n5、mysql表结构文件\n6、存储引擎文件\n我们这里只讲几个\n2、日志文件日志文件有错误日志、慢查询日志、查询日志、二进制日志，我们着重可以讲一下二进制日志\n提问？如何定位慢查询？1、可以用普罗米修斯、skywalking这些工具\n2、或者开启慢查询日志。然后设置一个值，一旦sql超过这个值就会被记录。\n接着问？执行很慢？怎么分析？用explain，他会展示sql执行的情况，有几个字段是关键的需要掌握\n\nextra：mrr优化等等\n\n1、二进制日志\n它是server层 的日志，记录了对mysql数据库更改的所有操作。主要用于备份恢复和主从同步：不包括selectshow这类操作\n过程主要是：\n他的写入逻辑是：事务执行过程中，先把日志写到 binlog cache、事务提交的时候，再把 binlog cache 写到 binlog 文件中。\n这个刷盘的机制就依赖于sync_binlog这个参数\n\nsync_binlog &#x3D; 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；\nsync_binlog &#x3D; 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；\nsync_binlog &#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。\n\n还有个需要关注的点就是它落盘的形式，就是怎么记录的？\n这个是依赖于binlog——format这个参数，他就是记录二进制的格式，有三种、statement、row、mixed。\nstatement就是最简单的sql语句，但是他有个很大的问题就是如果用到了uuid rand udf这些函数或触发器，或者索引选择的问题，那么会导致主从不一致，那我们可以用row的格式，row的话就是记录表的行修改情况。同样的他也有一个很大问题就是要求的容量比较大。那还有一种mixed格式就是混用，正常情况下我按照statement记录sql语句，但是在uuid rand udf这些特殊情况我用row的格式进行记录。\n\n了解：\n\n\n恢复：某些数据需要二进制日志。比如数据库全备文件恢复之后，通过二进制进行point-in-time的恢复\n复制；主从同步，那canal也是通过这种方式去监听binlog\n审计：用户通过二进制的信息判断是否有对数据库进行注入的攻击\n\n\n2、表结构定义文件这个文件的后缀是.frm，每个文件都会有这个一个frm文件，记录了该表的表结构定义\n3、Innodb存储引擎文件1、表空间文件首当其冲的就是表空间文件，情况下我们会放到ibdata那个文件里面，但是我们可以通过设置一个参数去产生一个自己表的独立表空间，然后这些独立的表空间记录该表的数据，索引信息，其余的还是放在共享表空间里面。\n2、redolog\n他是引擎层的文件，它为了防止断电导致数据丢失的问题。他的使用流程是：当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改记录到redolog buffer里面，然后按照一定的机制刷回redolog文件。这里两段式提交， redo log 和 binlog 的数据一致性。\n后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 WAL （Write-Ahead Logging）技术。\nWAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。\n主要有下面几个时机：\n\nMySQL 正常关闭时；\n当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；\nInnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。\n每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。\n\n由参数 innodb_flush_log_at_trx_commit 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：\n\n当设置该参数为 0 时，表示每次事务提交时 ，还是将 redo log 留在 redo log buffer 中 ，该模式下在事务提交时不会主动触发写入磁盘的操作。\n当设置该参数为 1 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘，这样可以保证 MySQL 异常重启之后数据不会丢失。\n当设置该参数为 2 时，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看这篇 (opens new window)），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。\n\n\n索引前的准备知识https://baijiahao.baidu.com/s?id=1709211669369376612&amp;wfr=spider&amp;for=pc\n这里我们首先要问三个重要的问题去扒一扒MySQL的InnoDB存储引擎\n\nMySQL的记录是怎么存储的？\n页内记录到底是怎么维护的？\n页内查询过程是怎样的\n\n穿上第一件：Page页面MySQL管理数据的一个单位叫Page页面，数据都是存在页面里的。那咱们想要知道数据是怎么存，就需要了解页面长什么样子。\n直接爆照：\n\n页头（Page Header）：存一些统计信息，记录页面的控制信息，共占56字节，包括页面空间使用情况、页的左右兄弟页面指针（这个就是双向链表，把左右兄弟页面的指针给拿到了）等。\n虚记录：分为最大虚记录与最小虚记录，它俩把这页里面存储的数据的范围框住了。那怎么比较谁大谁小？用的是主键去比较：最大虚记录比页内最大主键还大，最小虚记录比页内最小主键还小。那主键到底是怎么存的呢？InnoDB用的是聚簇索引——数据和主键存到一起、数据和索引存到一起，数据按主键顺序存储。\n记录堆：这部分就是存储记录的区域，分为有效记录和已删除记录。已被删除的记录构成一个链表，叫做自由空间链表，如图蓝色已经被删除的数据，用一个链表把它们连起来。\n未分配空间：页面未使用的存储空间，除了用了一部分的橙色的区域和已删除的蓝色的数据，剩下的就是未分配空间了，后面有新的数据插入，往里放就行了。\nSlot：这一块对数据检索非常有用，卖个关子，后面详细说。\n页尾（Page Tailer）：页面的最后部分，占8个字节，主要存储页面的校验信息。这一页如果写坏了，数据不对了，通过校验位可以检查出来。\n好了，到这里一个页面咱们了解了，了解数据大概是怎么分布的，那接下来需要考虑哪些点呢？我们接下来研究一下——页面记录是怎么维护的\n穿上第二件\n那这个数据在里边到底是怎么存的？换个说法——数据的顺序是怎么保证的？到底是物理有序，还是逻辑有序？\n我们再回顾一下大学的知识——物理有序写入不友好，查询友好；逻辑有序查询不友好，插入友好，两者优缺点互补。\n再回到正题，了解了这两种不同存储方式的特性，反观页面是怎么做的。\n先看下面这幅图，思考一下插入主键为10，9，8的数据，是按物理有序存储还是逻辑有序存储：\n\n数据插入是写入IO，数据查询是读IO，不管是写还是读，在分析存储的时候，无非是这四种：顺序写、随机写、顺序读、随机读。如果是顺序写，数据会有各种移动，写入性能肯定非常糟糕。但是没办法，优化写入的手段十分有限，不过呢我们却有很多办法优化读。\n所以想都不用想，页内数据存储的顺序就是逻辑有序。\n重新梳理一下，Page与Page之间由双向链表连接，页内是用小的链表连起来的：\n\n我们再来重新画一下这棵树：\n\n这里要注意，每个Page的索引的每个节点，也就是树的每个节点，它也是一个Page。既然是个Page，也会有页头，也会有双向链表，如图蓝色与紫色相间那部分节点数据。\n接下来咱分析一下它的插入策略。\n蓝色部分已删除的空间（记录堆）怎么办呢？我们得想办法尽量把它们利用上，这个换谁做数据库设计都要这么设计。\n其实，插入策略就是先使用自由空间链表，再使用未使用空间，把数据库“空洞”给补上。不过呢，自由空间链表的空间也不能完全利用上，比如旧的数据占25个字节，新的数据假设都只有20个字节，那剩下这5个字节基本也利用不上，这样一来就会产生越来越多的“碎片”。经过长时间的插入删除插入删除以后，我们就得考虑给数据库做一次收缩，比如通过两次主从表的双向同步，把所有表数据重新插一遍。\n我们接下来研究一下——页内查询是怎么做的？\n穿上第三件：Slot槽页内的数据是遍历还是二分查找？\n无论数据是物理连续还是逻辑有序，都不能二分查找，都得用遍历的办法。如果我们设计一款数据库，通过索引找到数据在哪个Page里面，要是Page这一层通过遍历的方式，那效率实在是太低了，所以数据库肯定不能这样设计。\n遍历不行，那就使用二分查找吧，提高一下效率。那MySQL是怎么做的呢？看看这张图：\n\n如图，最小虚记录和最大虚记录之间形成一个链表，这时候Slot区就派上用场了，每个Slot槽指向链表中的某一个位置，每个槽的大小一样，可以理解为一个指针，这样我们只需要用一个算法把每个子链表的长度拆成差不多大小就行了。\n在查找的时候，先基于Sn、S0找到指向的最大最小虚记录，在Slot区进行二分：先找到Sn和S0的中间位置，中间找到某个Slot，然后再一步步进行比较，通过几次二分后找到具体的子链表，最后，在子链表内进行遍历找到最终的记录。这样我们借助Slot区实现了一个近似二分查找的方法。这特别像Java里面的跳表结构，一次查找跳一次，再一次查找再跳一次，效率就特别高了\n索引where a&#x3D;1 and b &gt;1 and c&#x3D;1;\n\n假如创建一个（a,b,c)的联合索引，那么它的索引树是这样的：\n\n(a,b,c)联合索引 where a &#x3D; ‘xxx’ b is null c &#x3D; ‘xxx’怎么走索引\nis null是一个比例，可以优化成a&#x3D; c&#x3D; b&#x3D;\n\nin会导致索引失效吗\n当in的条件命中的数量很少时，是走索引的；但是当in的条件命中的数量超过30%时，索引失效，走全表扫描；\n普通索引和唯一索引，应该怎么选择？查询和对已经在内存的更新差距不大。但是对于不在内存的数据，唯一索引有唯一性要求，要先加到内存（相当于用不了changebuffer），但是普通索引不需要，只需要存到change buffer里面就可以。\n添加索引的原则\n\n超大分页优化\n\n***子查询+ 覆盖索引 + where 语句 ***\n先通过覆盖索引得到id，然后对id排序，那这个id和原来的表做关联查询\n\n索引失效情况；\n\n1、违反最左前缀原则：\n2、范围查找右边的会失效\n3、在索引列有函数操作，包括显示的函数和隐式的类型转换\n4、优化器觉得全局更快，索引也会失效\n\nmysql优化\n\n表结构的优化：分库分表、读写分离、\n如果是sql语句的优化：explain命令去分析sql语句，看看能不能优化\n参数方面：buffer pool的大小，刷盘策略，最大连接数\n\n\nMySQL为什么有时候会选错索引？\n\n优化器是找到一个最优的方案，以最小的代价去执行。\n1)我们是根据基数来估计行数，那基数是怎么得到的？是通过采样统计。InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了基数。\n2)还有一个问题就是优化器还要判断，执行这个语句本身要扫描多少行，\n解决方法？\n1）forceindex\n2）修改语句，引导 MySQL 使用我们期望的索引\n3）新建索引\n\n 怎么给字符串字段加索引？\n\n1、前缀索引。这里要关注的区分度，就是前缀索引是几个字符的时候区分度较大，又能节省空间，这个可能需要用到count函数去比较一下。\nPs：用前缀索引就用不上覆盖索引对查询性能的优化了，都要回表\n其他方法？\n2、倒序存储\n3、hash\n差别在于，空间，查询效率，区间查找\n\n对于函数操作，不管有没有改变有序性，都不走索引。\n由于上面这条规则， 所以一些在索引字段上面做隐式转换和隐式编码转换，也不走索引。P：在mysql里面字符串和数字的隐式转换是字符串转成数字，字符编码从少的往多的转。\ninnodb最常见的索引就是：\nb+树索引 （b+树只能找到数据行所在的页，然后把页读到内存里面，进行查找）\n哈希索引（自动生成）\n全文索引\n1、B+树索引为什么不用b树，b树的非叶子节点会保存数据，b+树不会，所以b树能保存的指针就好了，这样树的高度就会变大。\n为什么不用红黑树，红黑树是一个二叉树，这个高度肯定是不如b+树这样的多叉树，然后我们时间消耗上，就是这个磁盘io很关键。\n\nb+树是为了磁盘或其他直接存取辅助设备设计的一种多叉平衡查找树\nb+树的所有记录结点都是按照键值的大小顺序存放到同一层的叶子结点，他们之间通过叶子结点指针进行连接，中间的都是searchkey\n\n1、操作1、插入\n2、旋转旋转发生在leaf page已经满了，但是左右兄弟还没有满，这时候会把记录平移到兄弟结点上面，左兄弟优先\n3、删除\n2、分类b+树可以分成聚集索引、辅助索引，这两个到区别就是叶子结点放的到底是不是一行信息\n1、聚集索引\n聚集索引就是按照主键构造的索引b+树，所以叶子结点存放的就是整张表的数据，叶子结点也叫做数据页。非叶子结点的索引页存放的仅仅是键值和指向数据页的偏移量。\n选取规则：主键 -》唯一-》rowid\n\n2、辅助索引\n辅助索引的叶子结点不包含行记录的全部数据。叶子结点包含键值和书签，书签用来告诉引擎哪里能找到真正的行数据。由于innodb是索引组织表，所以辅助索引的书签就是行记录的聚集索引键。所以辅助索引就是包含了索引那列的值和主键的值。\n\n3、B+树索引的管理\n1、索引管理创建和删除可以通过两种方法。一种是alter table。另一种是create&#x2F;drop index。\n查看：show index from XX\n4、Online DDL允许在辅助索引创建的同时，还允许insert update等DML操作\n有三种算法：\ncopy：执行insert update delete这些操作的时候，先把操作日志写入一个缓存里面，然后，索引建立后重做表上面\nreplace ：replace就是不需要临时表。\ninstant ：直接对元数据进行修改，无需拷贝数据也无需重建整表\n5、cardinality值他是一个统计信息，优化器会根据这个值来判断我们用不用索引，表示索引中唯一值的数据的估计值，如果是性别这种，重复的非常多，我们叫低选择性，不适合做索引。反之高选择性就比较适合，尤其是在高选择性属性字段里面取出一小部分数据，那就更有必要了。\n\n统计的方式？\n\n所以我们用的是采样的方法（（对8或20个叶子结点进行采样预估，取出平均值））。cardinality值的更新发生在insert和update操作，但是肯定不是每一次inser tupdate都去更新，具体策略如下：\n1、表中1&#x2F;16数据发生了变化\n2、计数器超过20亿\n\n4、B+树索引的使用\n1、联合索引本质也是一颗二叉树，之前是a,b,c,d现在是（a,b）(c,d)\n第一个好处：对于联合查询和单列的第一列的查询都可以用联合查询\n第二个好处：一句对第二个键值进行了排序处理，可以缩短某些情况的查询时间\n2、覆盖索引覆盖索引的意思是，从辅助索引中就直接可以得到想要查询的记录，不需要回表。\n第一个好处是：辅助索引本身不包括整行记录，所以大小远小于聚集索引，减少io操作\n第二个好处是：对于某些统计问题，存储引擎并不会通过聚集索引，辅助索引远远小于聚集索引，\n4、MRR优化（多范围读取、只支持非聚集索引）（离散读变成顺序读）工作方式：\n\n把辅助索引读出来放到一个缓存里面\n把缓存中根据rowid进行排序\n然后根据rowid去找数据\n\n他适用于某些范围查找，\n而且还可以对某些范围查找进行拆分，变成成键值对的等值查找。直接就过滤了一些不符合条件的数据。\n好处：\n\n数据访问更加顺序，\n减少缓冲池页的替换\n\n5、索引下推ICP优化（只支持非聚集索引）原本我们通过索引进行查询的时候，首先根据索引查找记录，然后根据where条件过滤记录。ICP是在取出索引的同时，判断是否可以进行where条件的过滤，也就是讲where的部分过滤操作放到了存储引擎层。联合索引\n场景：\n假设表TB1上有索引IDX_C1_C2_C3(C1,C2,C3)，对于查询SELECT * FROM TB1 WHERE C1&#x3D;’XXX’ AND C3&#x3D;’XXX’\n在MySQL 5.6版本以前，由于缺少C2的过滤条件，Innodb存储引擎层只能使用索引IDX_C1_C2_C3按照C1&#x3D;’XXX’条件找出所有满足条件的索引记录，再根据这些索引记录去聚集索引中查找，将找到的表数据返回给MySQL Server层，然后由MySQL Server层使用C3&#x3D;’XXX’条件进行过滤得到最终结果。\n假设满足C1&#x3D;’XXX’条件的数据行为100000条，而满足C1&#x3D;’XXX’ AND C3&#x3D;’XXX’的数据行为100条，则：\n1、回表100000次，给server层传100000条数据\n2、回表100次，Innodb存储引擎层向MySQL Server层传递100行数据。\n\n5、自适应哈希索引InnoDB中的哈希用的字典进行查找，冲突用链表解决，哈希函数用除法散列\n自适应哈希索引就是用的这种方法。\n6、全文检索\n全文检索一般使用倒排索引。\n1、倒排索引它在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关键数组实现，其拥有两种表现形式：inverted file index：其表现形式为{单词，单词所在文档的ID}full inverted index：其表现形式为{单词，(单词所在文档的ID，在文档中的具体位置)}\n2、InnoDB全文检索的实现InnoDB全文索引有3个非常重要的东西，一个是辅助表，一个是FTS Index Cache、一个是FTS DOUCUMENT id\n1、Auxiliary Table（辅助表）辅助表是把文档，分词然后规范化后的结果，\n辅助表的话采用“full inverted index”的方式有两个列：\n一个是word字段。在word字段上有设有索引，另一个是ilist字段，（DocumentId,Position）\n2、FTS INDEX Cache（全文检索缓存）他是一个红黑树的结构：我执行插入操作，插入的数据已经更新了对应的表，但是我们的辅助表可能还没更新，这个更新还停留在FTS cache里面。如果没插一次就更新这是不合理的，那具体同步到辅助表的时机：\n1、在我进行全文检索查询的时候，我把FTS INDEX cache里的word字段合并到辅助表，然后查询。有点类似于insert buffer\n2、数据库关闭的时候会同步\n3、cache满了\t\n数据库宕机时：一些FTS InDEX Cache中的数据库可能未被同步到磁盘上。那么下次重启时，当用户对表进行全文检索（查询或者插入操作）时，InnoDB会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入到FTS Index Cache中\n对于InnoDB来说，其总是在事务提交时将分词写入到FTS Index Cache。\n3、FTS DOUCUMENT ID为了支持全文检索，我们每一行数据必须有一个列与word进行映射：\n\n在InnoDB中这个列被命名为FTS_DOC_ID，他是自动创建的\n其类型必须是bigint unsigned not null\n并且InnoDB自动会在该列上加入一个名为FTS_DOC_ID_INDEX的unique index索引\n用户也可以在建表时自动添加FTS_DOC_ID，以及相应的Unique Index\n\nDeleted auxiliary table文档中分词的插入操作是在事务提交时完成的，然而对于删除操作，其在事务提交时不删除磁盘Auxiliary Table中的记录，而只是删除FTS Index Cache中的记录。对于Auxiliary Table中被删除的记录，InnoDB会记录其FTS Document ID，并将其保存在Deleted auxiliary table中\n由于文档的DML操作实际并不删除索引中的数据，相反还会在对应的DELETED表中插入记录，因此随着应用程序的允许，索引会变得非常大，即使索引列中的有些数据已经被删除，查询也不会使用到。为了，InnoDB存储引擎提供了一种方式，允许用户手动地将已删除的记录从索引中彻底删除，该命令就是OPTIMIZE TABLE\n\n锁锁机制是用于管理对共享资源的并发访问，保证数据的完整性和一致性。\n1、锁的类型1、全局锁\n典型的使用场景就是做全库的逻辑备份\n\n一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态\n\n两种方法flush tables with read lock;mysqldump -single-tranctionssingle-transaction只适用于支持事务引擎的库，如果支持的话建议用single-transactions，否则用flush table with read lock\n\n2、表级锁\n表级锁，主要分为4类：\n\n表锁\n元数据锁（meta data lock，MDL）\n意向锁\n自增锁\n\n\n1、表锁表锁就是对表加锁，分读锁和写锁，读琐和读锁是兼容，读锁和写锁、写锁和写锁是不兼容的。\n2、元数据锁\n再来说说元数据锁（MDL）,它 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。我们不需要显示的使用 MDL，会自动给这个表加上 MDL：\n\n对一张表进行 CRUD 操作时，加的是 MDL 读锁；\n对一张表做结构变更操作的时候，加的是 MDL 写锁；\n\n\n\nMDL 不需要显示调用，那它是在什么时候释放的?\n\nMDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。\n3、意向锁\n我觉得意向锁主要还是解决行锁和表锁之间的冲突问题\n\n在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；\n在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；\n\n\n也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加行级独占锁。\n\n\n所以，意向锁的目的是为了快速判断表里是否有记录被加锁。\n4、自增锁\n主键设置成自增之后，会自动给主键赋递增的值，5.7保存在内存里面，但是8.0以后保存在redo log里面\n然后这里有两种方式。一种是，AUTO-INC 锁，不是一个事务提交后才释放，而是在执行完插入语句后就会立即释放。\n后面提供了一种轻量级锁，申请完就释放，但是伴随着两个问题：1、自增主键不是连续的。2、主库和从库不一致。\n自增逐渐不连续的原因：唯一键的冲突、事务回滚、批量插入\n主库存库不一致的原因：批量插入\n所以后面InnoDB 存储引擎提供了一种轻量级的锁，并且提供了一个参数，叫innodb autoinc lock mode\n\n当 innodb_autoinc_lock_mode &#x3D; 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；\n当 innodb_autoinc_lock_mode &#x3D; 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。\n当 innodb_autoinc_lock_mode &#x3D; 1：\n普通 insert 语句，自增锁在申请之后就马上释放；\n类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放（因为“不知道要预先申请多少个 id）\n原因如下：\n\nsession A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后两个 session 同时执行向表 t2 中插入数据。\n如果 innodb_autoinc_lock_mode &#x3D; 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：\n\nsession B 先插入了两个记录，(1,1,1)、(2,2,2)；\n然后，session A 来申请自增 id 得到 id&#x3D;3，插入了（3,5,5)；\n之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。\n\n可以看到，session B 的 insert 语句，生成的 id 不连续。\n当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format&#x3D;statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。\n但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致。\n要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。\n所以，当 innodb_autoinc_lock_mode &#x3D; 2 时，并且 binlog_format &#x3D; row，既能提升并发性，又不会出现数据一致性问题。\n\n3、行锁\nMySQL 的行锁是在引擎层由各个引擎自己实现的。\n\n\nInnoDB有三种行锁的算法：Record Lock：记录锁、Gap Lock：间隙锁，锁定一个范围，但不包括记录本身，Next-Key Lock（临建锁）：Record Lock + Gap Lock 左开右闭\nInnoDB就是用Next-Key去解决幻读问题（同一事务下，连续执行两次相同的sql语句可能导致不同的结果，第二次sql可能会返回之前不存在的行）间隙锁在可重复读才生效\n加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。 \n\n原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭 区间。 \n原则 2：查找过程中访问到的对象才会加锁。 \n优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。 \n优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，nextkey lock 退化为间隙锁。 \n一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。\n\n\n\n\n\n\n\n两阶段锁协议：\n\n在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。\n\n\n\n\n2、一致性非锁定读（快照读）一致性非锁定读是指InnoDb通过多版本控制（MVCC）的方式读一个我能看到的数据。\n所以我们要讲一下这个MVCC，他这个就依赖于undolog版本链和readView。\n首先，每一行数据其实都有两个隐藏列，一个是trxid一个是rollpointer，trxid 表示最新修改事务的id，rollpointer表示指向旧版本undo log\n我们修改的数据的时候，我们把该行数据拷贝到 undo log作为旧版本。进行真正的修改操作，同时修改trxid 和roll_pointer，这样就形成了一个版本链条，那至于我们能看到哪个版本的就依赖于readview\nReadView，里面有四个比较关键的东西：\n一个是m_ids，这个就是说事务开启那一刻有哪些事务在Mysql里面执行还没有提交的；\n一个是min_trx_id，就是m_ids里最小的事务id的值；\n一个是max_trx_id，就是此刻mysql下一个要生成的事务id，就是最大事务id；\n一个是creator_trx_id，就是你这个事务的id。\n如果比mintexid小或者等于creatoridexid，我们可以看得见。\n比如一条记录旧版本里面有三条记录：10，20，30。然后我们的事务id是15，m_ids里面有20，30。这里的min_trx_id就是20，我们的15比她小，说明还没有提交。因为隔离性所以肯定是看不到的，然后再去找更前面版本，我们就找到了10，发现10可以，所以我们这次读到的数据就是事务id为10的那一个版本。\n3、一致性锁定读（当前读）有时候用户需要些显式的对读操作进行加锁保证一致性。 select for share mode， for update还有update也是当前读\n\n5、锁问题（并发事务带来的问题）1、脏读 or 不可重复读 or 幻读脏读：读到了其他事务没有提交的数据\n不可重复读：两次读，读的不一样。\n幻读：一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。\n不可重复读的原因：readview是每一次读生成一次的。\n幻读innoDB的解决方法：\n\n针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。\n针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）（前开后闭区间）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。\n行锁是加在索引上的\n\n3、丢失更新是指一个事务的操作被另一个事务的操作覆盖了，但是当前数据库的任何隔离级别都对行或者粗粒度的对象加锁，所以还是比较难发生。\n\n6、死锁死锁是指两个或以上的事务争夺资源造成的一种互相等待的现象\n\n互斥条件\n请求和保持条件\n不可剥夺条件\n循环等待条件\n解决方法：\n1、设置超时的阈值，回滚一个死锁的事务\n2、wait-for-graph 等待图。检测是否有回路。通常用深度优先。1.2版本开始就变成非递归\n如果有死锁，那就回归undo量最少的\n\n7、锁升级InnoDB中不存在锁升级的问题，因为InnoDB不是更具每个记录来产生锁的，相反，其根据每个事务访问的每个页对锁进行管理，采用的是位图的方式。所以不管你锁住的是页中的一个记录或者多个记录，开销一样\n\n事务1、认识事务1、四个特性：acid。原子性：要么成功要么失败\n一致性：讲数据库从一种状态转变为下一种一致的状态，完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。\n隔离性Isolation：一个事务提交之前对其他事物不可见\nDurability：一旦提交，那么结果是永久性的\n可以举个例子：就是转账。\n2、事务的实现事务的隔离性由锁机制来实现。\n原子性、一致性、持久性通过redo log和undo log完成\nredo log保证持久性\nundo log保证事务的原子性，一致性\n1、redo log它为了防止断电导致数据丢失的问题，当有一条更新操作的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，InnoDB 引擎会在适当的时候，在 Buffer Pool 的脏页刷新到磁盘里。这就是 WAL （Write-Ahead Logging）技术。\nWAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。\n主要有下面几个时机：\n\nMySQL 正常关闭时；\n当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；\nInnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。\n每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。\n\n由参数 innodb_flush_log_at_trx_commit 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：\n\n当设置该参数为 0 时，表示每次事务提交时 ，还是将 redo log 留在 redo log buffer 中 ，该模式下在事务提交时不会主动触发写入磁盘的操作。\n当设置该参数为 1 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘，这样可以保证 MySQL 异常重启之后数据不会丢失。\n当设置该参数为 2 时，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看这篇 (opens new window)），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。\n\n事务提交的时候必须把事务的所有日志写入重做日志文件进行持久化。这个的所有日志包括redo log 和undo log\n\n\n\n2、undo log\nundo log最主要的作用有两点：一个是事务回滚，保证原子性；还有一个是支持mvcc\n那我们先讲第一个，就是事务提交之前，如果发生意外，这时候你用redolog是没有办法恢复的，所以我们可以使用undolog，因为undolog他记录的是修改前的记录。\n另外一个大的作用是mvcc，mvcc他是基于undo log版本链和ReadView实现\n首先，每一行数据其实都有两个隐藏列，一个是trxid一个是rollpointer，trxid 表示最新修改事务的id，rollpointer表示指向旧版本log\nundolog版本链形成的原因是，我们修改的数据的时候，我们把该行数据拷贝到 undo log作为旧版本。进行真正的修改操作，同时修改trxid 和roll_pointer。\nReadView，里面有四个比较关键的东西：\n一个是m_ids，这个就是说事务开启那一刻有哪些事务在Mysql里面执行还没有提交的；\n一个是min_trx_id，就是m_ids里最小的事务id的值；\n一个是max_trx_id，就是此刻mysql下一个要生成的事务id，就是最大事务id；\n一个是creator_trx_id，就是你这个事务的id。\n如果比mintexid小或者等于creatoridexid，我们可以看得见。\n比如一条记录旧版本里面有三条记录：10，20，30。然后我们的事务id是15，m_ids里面有20，30。这里的min_trx_id就是20，我们的15比她小，说明还没有提交。因为隔离性所以肯定是看不到的，然后再去找更前面版本，我们就找到了10，发现10可以，所以我们这次读到的数据就是事务id为10的那一个版本。\n\nrr：事务第一次读的时候创建readview\nrc：每次查询都会创建一个readview\nmvcc是快照读，update是当前读，但是要注意两阶段锁协议\n主从同步\n","dateCreated":"2023-11-08T00:00:00+08:00","dateModified":"2024-02-02T20:55:12+08:00","datePublished":"2023-11-08T00:00:00+08:00","description":"","headline":"mysql技术内幕 innodb存储引擎","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"},"publisher":{"@type":"Organization","name":"CSEN","sameAs":["https://github.com/Caosen0819"],"image":"head.jpg","logo":{"@type":"ImageObject","url":"head.jpg"}},"url":"http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/","keywords":"Mysql"}</script>
    <meta name="description" content="首先来了解一下InnoDB的体系架构： 体系架构 我觉的用一句话概括，就是由很多内存块组成的内存池维护一系列后台线程，然后这些后台线程去负责最重要的工作。主要是内存和后台线程。 1、后台线程 主要有： master thread：最重要的，脏页刷新、合并insert buffer，undo 页的回收，redolog buffer。不过后来脏页回收放到了单独的线程，也就是page thread IO">
<meta property="og:type" content="blog">
<meta property="og:title" content="mysql技术内幕 innodb存储引擎">
<meta property="og:url" content="http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/index.html">
<meta property="og:site_name" content="森">
<meta property="og:description" content="首先来了解一下InnoDB的体系架构： 体系架构 我觉的用一句话概括，就是由很多内存块组成的内存池维护一系列后台线程，然后这些后台线程去负责最重要的工作。主要是内存和后台线程。 1、后台线程 主要有： master thread：最重要的，脏页刷新、合并insert buffer，undo 页的回收，redolog buffer。不过后来脏页回收放到了单独的线程，也就是page thread IO">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231004235405057.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231021153343267.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115150005784.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115150305270.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/42a98226cffc1e171d3b202cf4e9e50a728de9ae.jpeg">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/c9fcc3cec3fdfc032a5c874b6446949da5c2269b.jpeg">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/e850352ac65c103892bb2f180b68801ab27e89a2.jpeg">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/9825bc315c6034a8191108a4766a5a5d082376a2.jpeg">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/80cb39dbb6fd5266c5d8021702618422d5073647.jpeg">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/3b87e950352ac65c1fead4dc4c8ba11892138a30.jpeg">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/867078-20200703134853993-1354025866.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115165553203.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115170958089.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231005201534270.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231005202324173.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/20e0f35589584352bd15e817668a0886.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/6e6b275c2d6d4dfcbbb338be4f61bee9.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20230805221422216.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115193544143.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231006204601132.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231007131604938.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231007131752781.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231007131726290.png">
<meta property="og:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115220333308.png">
<meta property="article:published_time" content="2023-11-07T16:00:00.000Z">
<meta property="article:modified_time" content="2024-02-02T12:55:12.532Z">
<meta property="article:author" content="CSEN">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231004235405057.png">
    
    
        
    
    
        <meta property="og:image" content="http://example.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-w816scvuzwavitjylabixcb3ofuoklqul47j3rgwu1r0mxrxvbdehvp2jk5s.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            森
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Lesen Sie mehr über den Autor"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
                </a>
                <h4 class="sidebar-profile-name">CSEN</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="档案"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">档案</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/Caosen0819"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title=".github"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">.github</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            mysql技术内幕 innodb存储引擎
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-11-08T00:00:00+08:00">
	
		    08 Nov 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>首先来了解一下InnoDB的体系架构：</p>
<h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231004235405057.png" alt="image-20231004235405057"></p>
<p><font color='red'><u><em><strong>我觉的用一句话概括，就是由很多内存块组成的内存池维护一系列后台线程，然后这些后台线程去负责最重要的工作。主要是内存和后台线程。</strong></em></u></font></p>
<h2 id="1、后台线程"><a href="#1、后台线程" class="headerlink" title="1、后台线程"></a>1、后台线程</h2><blockquote>
<p>主要有：</p>
<p><font color='red'><u><em><strong>master thread</strong></em></u></font>：最重要的，脏页刷新、合并insert buffer，undo 页的回收，redolog buffer。不过后来脏页回收放到了单独的线程，也就是page thread</p>
<p>IO thread: 负责异步io的回调</p>
<p>purge thread: 负责undolog清理</p>
<p>page clean thread：负责脏页刷新</p>
</blockquote>
<h3 id="1、master-thread"><a href="#1、master-thread" class="headerlink" title="1、master thread"></a>1、master thread</h3><p>本质是一个循环</p>
<p>每秒都会进行一次操作：重做日志缓冲刷新、合并insertbuffer，脏页刷新被放到了page clean 线程</p>
<p>每十秒会进行的操作：重做日志缓冲刷新、合并insertbuffer、脏页刷新被放到了page clean 线程、删除无用的undo 页</p>
<h2 id="2、内存"><a href="#2、内存" class="headerlink" title="2、内存"></a>2、内存</h2><p>内存方面就是缓冲池、lrulist freelist flushlist、redo log buffer 三块，还有一些额外内存池（为了数据结构的内存申请服务）</p>
<h3 id="1、缓冲池"><a href="#1、缓冲池" class="headerlink" title="1、缓冲池"></a>1、缓冲池</h3><p><font color='red'><u><em><strong>本质就是一块内存，缓冲池里面有数据页、索引页、undo 页、insert buffer、自适应哈希索引、锁信息、数据字典。</strong></em></u></font></p>
<p>所以修改操作，基本都现修改缓冲池里面的数据，然后按照一定刷回机制磁盘。</p>
<h3 id="2、List"><a href="#2、List" class="headerlink" title="2、List"></a>2、List</h3><p>缓冲池是通过改进的LRU算法（在原本的基础上加了midpoint，新加入的页放到这里，默认<font color='red'><u><em><strong>5&#x2F;8</strong></em></u></font>）进行管理的，方法就是LRUlist、freelist flushlist。如果缓冲池不能放新的，就把lru里面末尾的释放掉。<font color='red'><u><em><strong>处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部；否则不变。</strong></em></u></font></p>
<p>改进lru的原因：有可能新页仅仅是这次查询需要用到，并不是真正的热点数据，这样反而有可能将真正的热点数据淘汰。</p>
<p>flushlist就是脏页列表，就像上面说的，用checkpoint机制刷新</p>
<p>一页16k</p>
<p>说了这么多checkpoint，什么是checkpoint？（当前要刷回的位置）</p>
<h4 id="1、checkpoint"><a href="#1、checkpoint" class="headerlink" title="1、checkpoint"></a>1、checkpoint</h4><p>解决问题：</p>
<ul>
<li>缩短数据库恢复时间？</li>
</ul>
<p>即使发生宕机， 因为checkpoint之前多页已经刷新回磁盘，所以只需要对checkpoint之后对进行恢复</p>
<ul>
<li>缓冲池不够时，可以将脏页刷回磁盘？</li>
</ul>
<p>缓冲池不够用的时候，根据lru找lru末尾的页，如果是脏页，就强制执行checkpoint，讲脏页刷新回磁盘</p>
<ul>
<li>重做日志不可用，刷新脏页。</li>
</ul>
<p>重做日志两个文件是循环使用，为了不让他一直无限变大，不可用是指重做日志已经不被需要了可以被覆盖。如果宕机，数据库恢复操作不需要这部分的重做日志就可以覆盖重用。如果此时重做日志还需要用，就必须强制产生checkpoint将讲缓冲池的页至少刷新到当前重做日志的位置</p>
<p>所以总归checkpoint做的事情就是把脏页刷回磁盘。<font color='red'><u><em><strong>（脏页刷时机）？</strong></em></u></font></p>
<blockquote>
<p><font color='red'><u><strong>1. redo log 写满。会造成mysql不接受更新。</strong></u></font><br><font color='red'><u><strong>2. 内存不足。</strong></u></font><br><font color='red'><u><em><strong>3. 空闲时间，认为目前压力不大。（主流）</strong></em></u></font><br><font color='red'><u><em><strong>4. Mysql关闭时。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>5、脏页数量太多</strong></em></u></font></p>
<p>一个是脏页比例，一个是 redo log 写盘速度去计算刷盘的速度。</p>
</blockquote>
<p>这里有两种checkpoint，分别是：</p>
<blockquote>
<p>sharp checkpoint</p>
<p>fuzzy checkpoint</p>
</blockquote>
<blockquote>
<p>sharp checkpoint就是在<font color='red'><u><em><strong>数据库关闭的时候全部刷新到磁盘</strong></em></u></font></p>
<p>fuzzy checkpoint是刷新部分脏页？刷新到时机如下：</p>
<p>master thread checkpoint（空闲）</p>
<p>flushlrulist checkpoint：这饿是lru列表需要有100个空闲的页，否则移除lru末尾的页，如果有脏页就checkpoint（内存不足）</p>
<p>async sycn flush checkpoint：这个是<font color='red'><u>**重做日志文件不可用的情况，需要强制将一些刷新回磁盘  **</u></font>（redo）</p>
<p>dirty page too much：这个是脏页数量太多了，强制checkpoint ，脏页的比例达到75%</p>
</blockquote>
<h3 id="3、Redo-log-buffer"><a href="#3、Redo-log-buffer" class="headerlink" title="3、Redo log buffer"></a>3、Redo log buffer</h3><p>这个是innodb独有的，重做日志信息 -&gt;Redo log buffer -〉 重做日志文件，为重做日志文件服务，重做日志文件本身是为了数据库的恢复功能，但是同样的，为了缓解和磁盘的差距，我们给他加一个buffer。</p>
<p>刷回时机：</p>
<blockquote>
<p><font color='red'><u><em><strong>master thread 每秒</strong></em></u></font></p>
<p><font color='red'><u><em><strong>每个事务提交的时候，有个参数，1代表完全同步，0代表不写磁盘，2表示写到page cache里面，具体刷回靠操作系统</strong></em></u></font></p>
<p><font color='red'><u><em><strong>重做日志缓冲 剩余空间小于1&#x2F;2</strong></em></u></font></p>
<p><font color='red'><u><em><strong>正常关闭</strong></em></u></font></p>
</blockquote>
<h3 id="4、额外的缓冲池"><a href="#4、额外的缓冲池" class="headerlink" title="4、额外的缓冲池"></a>4、额外的缓冲池</h3><p>对于一些数据结构本身的内存分配服务</p>
<h1 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h1><p>前三个最重要：</p>
<blockquote>
<p>1、插入缓冲</p>
<p>2、两次写</p>
<p>3、自适应哈希</p>
<p>4、异步io</p>
<p>5、刷新邻接页</p>
</blockquote>
<h2 id="1、插入缓冲"><a href="#1、插入缓冲" class="headerlink" title="1、插入缓冲"></a>1、插入缓冲</h2><h3 id="1、insert-buffer"><a href="#1、insert-buffer" class="headerlink" title="1、insert buffer"></a>1、insert buffer</h3><blockquote>
<p>数据插入的时候还是按照主键的位置存放的，但是这个表如果有辅助索引，那么这条记录也会插入辅助索引，但是这时候他就不是顺序插入了，而是离散的插入。我们在对非聚集索引的插入的时候不会实时的插入，而是先判断有没有在缓冲池里面，有的话直接插入，没有的话，先构造一个searchkey，放到一个insert buffer里面。后面再以一定的频率进行insertbuffer和非聚集索页子节点的merge操作。</p>
<p><strong>changebuffer的存在让普通索引优于唯一索引。</strong>普通索引和唯一索引的查询效率差不多，对于已经在内存的数据更新也差不多。但是对于没有在内存的数据更新操作差很多，因为唯一索引为了保证唯一性，会把数据从磁盘读到内存，这一步是数据库成本最高的操作之一。</p>
<p>insert buffer 升级为了 change buffer，对插入更新删除操作都准备了缓冲</p>
<h3 id="2、insert-buffer的内部实现"><a href="#2、insert-buffer的内部实现" class="headerlink" title="2、insert buffer的内部实现"></a>2、insert buffer的内部实现</h3><p>全局唯一的b+树的形式，负责对<font color='red'><u><em><strong>所有表</strong></em></u></font>的辅助索引进行insert buffer，存放在共享表空间，就是ibdata1。但是我们知道，我们可以有独立表ibdata，但是恢复的时候最好用共享表里面的。</p>
<p>因为是树，所以有非叶子结点和叶子结点。</p>
<p>非叶子结点放的是searchkey，所以插入非聚集索引的时候，如果不在缓冲池，那么要加入这颗唯一的insertbuffer，实现构造一个searchkey，我想通过这个searchkey找到我要插入的位置，然后再构造一个叶子结点，放进去。</p>
<h3 id="3、Merge-insert-buffer"><a href="#3、Merge-insert-buffer" class="headerlink" title="3、Merge insert buffer"></a>3、Merge insert buffer</h3><p>所以后面就是合并操作，合并的时机：</p>
<p><font color='red'><u><em><strong>1、master thread</strong></em></u></font></p>
<p><font color='red'><u><em><strong>2、辅助索引页被读到缓冲池里去</strong></em></u></font>，然后这个是要执行正常的查询语句了，就去检查这个insert buffer bitmap，确认这个该辅助索引是不是在insert buffer b+书里面，如果有，就把树里面的记录查到辅助索引里面。</p>
</blockquote>
<h2 id="2、两次写"><a href="#2、两次写" class="headerlink" title="2、两次写"></a>2、两次写</h2><p><font color='red'><u><em><strong>doublewrite的目的是为了数据的可靠性。</strong></em></u></font></p>
<blockquote>
<p>具体实现的话，是依赖于两个部分，一个是<font color='red'><u><em><strong>内存中的doublewrite buffer</strong></em></u></font>，2m。另一部分是磁盘里的<font color='red'><u><em><strong>共享表空间里面有一个连续的128页</strong></em></u></font>，也是2m。</p>
<p>流程分三步。</p>
<p><font color='red'><u><em><strong>1、我先不直接写磁盘，我先复制到这个内存的doublewrite buffer里面</strong></em></u></font></p>
<p><font color='red'><u><em><strong>2、然后分两次写入，每次1m写入共享表空间的物理磁盘，（顺序写）</strong></em></u></font></p>
<p><font color='red'><u><em><strong>3、然后马上调用fsync函数，同步磁盘。（离散写）</strong></em></u></font></p>
<p>所以，如果写的时候崩溃了，那就把这个共享表空间里面的副本拿出来配合redo log进行恢复。</p>
</blockquote>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231021153343267.png" alt="image-20231021153343267"></p>
<h2 id="3、自适应哈希"><a href="#3、自适应哈希" class="headerlink" title="3、自适应哈希"></a>3、自适应哈希</h2><p>InnoDB会自动为某些访问频率非常高的页建立哈希索引，而哈希索引比起b+树更快，所以也是一种提高性能手段。</p>
<p>但是有一个<font color='blue'><u><em><strong>比较大的痛点就是他只能用于做 等值查询，如果遇到范围查到，就无能为力。</strong></em></u></font></p>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>文件包括mysql文件和innodb文件</p>
<p>1、参数文件</p>
<p>2、日志文件、</p>
<p>3、socket文件</p>
<p>4、pid文件</p>
<p>5、mysql表结构文件</p>
<p>6、存储引擎文件</p>
<p>我们这里只讲几个</p>
<h2 id="2、日志文件"><a href="#2、日志文件" class="headerlink" title="2、日志文件"></a>2、日志文件</h2><p>日志文件有错误日志、慢查询日志、查询日志、二进制日志，我们着重可以讲一下二进制日志</p>
<h5 id="提问？如何定位慢查询？"><a href="#提问？如何定位慢查询？" class="headerlink" title="提问？如何定位慢查询？"></a><font color='red'><u><em><strong>提问？如何定位慢查询？</strong></em></u></font></h5><p>1、可以用普罗米修斯、skywalking这些工具</p>
<p>2、或者开启慢查询日志。然后设置一个值，一旦sql超过这个值就会被记录。</p>
<h6 id="接着问？执行很慢？怎么分析？"><a href="#接着问？执行很慢？怎么分析？" class="headerlink" title="接着问？执行很慢？怎么分析？"></a><font color='red'><u><em><strong>接着问？执行很慢？怎么分析？</strong></em></u></font></h6><p>用explain，他会展示sql执行的情况，有几个字段是关键的需要掌握</p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115150005784.png" alt="image-20231115150005784"></p>
<p>extra：mrr优化等等</p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115150305270.png" alt="image-20231115150305270"></p>
<h3 id="1、二进制日志"><a href="#1、二进制日志" class="headerlink" title="1、二进制日志"></a>1、二进制日志</h3><blockquote>
<p><font color='red'><u><em><strong>它是server层 的日志，记录了对mysql数据库更改的所有操作。</strong></em></u></font><font color='red'><u><em><strong>主要用于备份恢复和主从同步：</strong></em></u></font>不包括selectshow这类操作</p>
<p>过程主要是：</p>
<p><font color='red'><u><em><strong>他的写入逻辑是：事务执行过程中，先把日志写到 binlog cache、事务提交的时候，再把 binlog cache 写到 binlog 文件中。</strong></em></u></font></p>
<p>这个刷盘的机制就依赖于sync_binlog这个参数</p>
<ul>
<li>sync_binlog &#x3D; 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog &#x3D; 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog &#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p><font color='red'><u><em><strong>还有个需要关注的点就是它落盘的形式，就是怎么记录的？</strong></em></u></font></p>
<p>这个是依赖于binlog——format这个参数，他就是记录二进制的格式，有三种、statement、row、mixed。</p>
<p>statement就是最简单的sql语句，但是他有个很大的问题就是如果用到了uuid rand udf这些函数或触发器，或者索引选择的问题，那么会导致主从不一致，那我们可以用row的格式，row的话就是记录表的行修改情况。同样的他也有一个很大问题就是要求的容量比较大。那还有一种mixed格式就是混用，正常情况下我按照statement记录sql语句，但是在uuid rand udf这些特殊情况我用row的格式进行记录。</p>
<blockquote>
<p>了解：</p>
</blockquote>
<blockquote>
<p>恢复：某些数据需要二进制日志。比如数据库全备文件恢复之后，通过二进制进行point-in-time的恢复</p>
<p>复制；主从同步，那canal也是通过这种方式去监听binlog</p>
<p>审计：用户通过二进制的信息判断是否有对数据库进行注入的攻击</p>
</blockquote>
</blockquote>
<h3 id="2、表结构定义文件"><a href="#2、表结构定义文件" class="headerlink" title="2、表结构定义文件"></a>2、表结构定义文件</h3><p>这个文件的后缀是.frm，每个文件都会有这个一个frm文件，记录了该表的表结构定义</p>
<h3 id="3、Innodb存储引擎文件"><a href="#3、Innodb存储引擎文件" class="headerlink" title="3、Innodb存储引擎文件"></a>3、Innodb存储引擎文件</h3><h4 id="1、表空间文件"><a href="#1、表空间文件" class="headerlink" title="1、表空间文件"></a>1、表空间文件</h4><p>首当其冲的就是表空间文件，情况下我们会放到ibdata那个文件里面，但是我们可以通过设置一个参数去产生一个自己表的独立表空间，然后这些<font color='red'><u><em><strong>独立的表空间记录该表的数据，索引信息，其余的还是放在共享表空间里面。</strong></em></u></font></p>
<h4 id="2、redolog"><a href="#2、redolog" class="headerlink" title="2、redolog"></a>2、redolog</h4><blockquote>
<p>他是引擎层的文件，它为了防止断电导致数据丢失的问题。他的使用流程是：当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改记录到redolog buffer里面，然后按照一定的机制刷回redolog文件。这里两段式提交， redo log 和 binlog 的数据一致性。</p>
<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p>
<p><font color='red'><u><em><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。</strong></em></u></font></p>
<p>主要有下面几个时机：</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。</li>
</ul>
<p>由参数 <code>innodb_flush_log_at_trx_commit</code> 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：</p>
<ul>
<li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li>
<li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li>
<li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/6_file_system/pagecache.html">这篇 (opens new window)</a>），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li>
</ul>
</blockquote>
<h1 id="索引前的准备知识"><a href="#索引前的准备知识" class="headerlink" title="索引前的准备知识"></a>索引前的准备知识</h1><p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1709211669369376612&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1709211669369376612&amp;wfr=spider&amp;for=pc</a></p>
<p><strong>这里我们首先要问三个重要的问题去扒一扒MySQL的InnoDB存储引擎</strong></p>
<ol>
<li><strong>MySQL的记录是怎么存储的？</strong></li>
<li><strong>页内记录到底是怎么维护的？</strong></li>
<li><strong>页内查询过程是怎样的</strong></li>
</ol>
<h3 id="穿上第一件：Page页面"><a href="#穿上第一件：Page页面" class="headerlink" title="穿上第一件：Page页面"></a>穿上第一件：Page页面</h3><p>MySQL管理数据的一个单位叫Page页面，数据都是存在页面里的<strong>。</strong>那咱们想要知道数据是怎么存，就<strong>需要了解页面长什么样子</strong>。</p>
<p>直接爆照：</p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/42a98226cffc1e171d3b202cf4e9e50a728de9ae.jpeg" alt="img"></p>
<p>页头（Page Header）：存一些统计信息，记录页面的控制信息，共占56字节，包括页面空间使用情况、页的左右兄弟页面指针（<strong>这个就是双向链表，把左右兄弟页面的指针给拿到了</strong>）等。</p>
<p>虚记录：分为最大虚记录与最小虚记录，<strong>它俩把这页里面存储的数据的范围框住了。</strong>那怎么比较谁大谁小？用的是主键去比较：最大虚记录比页内最大主键还大，最小虚记录比页内最小主键还小<strong>。</strong>那主键到底是怎么存的呢？InnoDB用的是聚簇索引——<strong>数据和主键存到一起、数据和索引存到一起，数据按主键顺序存储。</strong></p>
<p>记录堆：<strong>这部分就是存储记录的区域</strong>，分为有效记录和已删除记录。已被删除的记录构成一个链表，叫做自由空间链表<strong>，</strong>如图蓝色已经被删除的数据，<strong>用一个链表把它们连起来</strong>。</p>
<p>未分配空间：页面未使用的存储空间，除了用了一部分的橙色的区域和已删除的蓝色的数据，剩下的就是未分配空间了，<strong>后面有新的数据插入，往里放就行了</strong>。</p>
<p>Slot：<strong>这一块对数据检索非常有用</strong>，卖个关子，后面详细说。</p>
<p>页尾（Page Tailer）：页面的最后部分，占8个字节，主要存储页面的校验信息。<strong>这一页如果写坏了，数据不对了，通过校验位可以检查出来。</strong></p>
<p>好了，到这里一个页面咱们了解了，了解数据大概是怎么分布的，<strong>那接下来需要考虑哪些点呢？</strong>我们接下来研究一下——页面记录是怎么维护的</p>
<h3 id="穿上第二件"><a href="#穿上第二件" class="headerlink" title="穿上第二件"></a>穿上第二件</h3><p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/c9fcc3cec3fdfc032a5c874b6446949da5c2269b.jpeg" alt="img"></p>
<p><strong>那这个数据在里边到底是怎么存的</strong>？换个说法——数据的顺序是怎么保证的？<strong>到底是物理有序，还是逻辑有序？</strong></p>
<p>我们再回顾一下大学的知识——<strong>物理有序写入不友好，查询友好；逻辑有序查询不友好，插入友好</strong>，两者优缺点互补。</p>
<p>再回到正题，了解了这两种不同存储方式的特性，反观页面是怎么做的。</p>
<p>先看下面这幅图，思考一下插入主键为10，9，8的数据，是按物理有序存储还是逻辑有序存储：</p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/e850352ac65c103892bb2f180b68801ab27e89a2.jpeg" alt="img"></p>
<p>数据插入是写入IO，数据查询是读IO，不管是写还是读，在分析存储的时候，无非是这四种：顺序写、随机写、顺序读、随机读。<strong>如果是顺序写，数据会有各种移动，写入性能肯定非常糟糕</strong>。但是没办法，<strong>优化写入的手段十分有限，不过呢我们却有很多办法优化读</strong>。</p>
<p><strong>所以想都不用想，页内数据存储的顺序就是逻辑有序</strong>。</p>
<p>重新梳理一下，<font color='red'><u><em><strong>Page与Page之间由双向链表连接，页内是用小的链表连起来的：</strong></em></u></font></p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/9825bc315c6034a8191108a4766a5a5d082376a2.jpeg" alt="img"></p>
<p>我们再来重新画一下这棵树：</p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/80cb39dbb6fd5266c5d8021702618422d5073647.jpeg" alt="img"></p>
<p>这里要注意，每个Page的索引的每个节点，也就是树的每个节点，它也是一个Page。<strong>既然是个Page，也会有页头，也会有双向链表</strong>，如图蓝色与紫色相间那部分节点数据。</p>
<p><strong>接下来咱分析一下它的插入策略。</strong></p>
<p>蓝色部分已删除的空间（记录堆）怎么办呢？<strong>我们得想办法尽量把它们利用上</strong>，这个换谁做数据库设计都要这么设计<strong>。</strong></p>
<p>其实，插入策略就是先使用自由空间链表，再使用未使用空间，<strong>把数据库“空洞”给补上。</strong>不过呢，自由空间链表的空间也不能完全利用上，比如旧的数据占25个字节，新的数据假设都只有20个字节，<strong>那剩下这5个字节基本也利用不上，这样一来就会产生越来越多的“碎片”</strong>。经过长时间的插入删除插入删除以后，我们就得考虑给数据库做一次收缩，比如通过两次主从表的双向同步，<strong>把所有表数据重新插一遍</strong>。</p>
<p><strong>我们接下来研究一下——页内查询是怎么做的？</strong></p>
<h3 id="穿上第三件：Slot槽"><a href="#穿上第三件：Slot槽" class="headerlink" title="穿上第三件：Slot槽"></a>穿上第三件：Slot槽</h3><p><strong>页内的数据是遍历还是二分查找？</strong></p>
<p>无论数据是物理连续还是逻辑有序，都不能二分查找，都得用遍历的办法。如果我们设计一款数据库，通过索引找到数据在哪个Page里面，要是Page这一层通过遍历的方式，那效率实在是太低了，所以数据库肯定不能这样设计。</p>
<p>遍历不行，那就使用二分查找吧，提高一下效率。那MySQL是怎么做的呢？看看这张图：</p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/3b87e950352ac65c1fead4dc4c8ba11892138a30.jpeg" alt="img"></p>
<p>如图，最小虚记录和最大虚记录之间形成一个链表，这时候Slot区就派上用场了，每个Slot槽指向链表中的某一个位置，每个槽的大小一样，可以理解为一个指针，<strong>这样我们只需要用一个算法把每个子链表的长度拆成差不多大小就行了</strong>。</p>
<p>在查找的时候，先基于Sn、S0找到指向的最大最小虚记录，在Slot区进行二分：<strong>先找到Sn和S0的中间位置，中间找到某个Slot，然后再一步步进行比较，通过几次二分后找到具体的子链表，最后，在子链表内进行遍历找到最终的记录</strong>。这样我们借助Slot区实现了一个近似二分查找的方法。这特别像Java里面的跳表结构，一次查找跳一次，再一次查找再跳一次，效率就特别高了</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><font color='red'><u><em><strong>where a&#x3D;1 and b &gt;1 and c&#x3D;1;</strong></em></u></font></p>
<blockquote>
<p>假如创建一个（a,b,c)的联合索引，那么它的索引树是这样的：</p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/867078-20200703134853993-1354025866.png" alt="img"></p>
<p><font color='red'><u><em><strong>(a,b,c)联合索引 where a &#x3D; ‘xxx’ b is null c &#x3D; ‘xxx’怎么走索引</strong></em></u></font></p>
<p>is null是一个比例，可以优化成a&#x3D; c&#x3D; b&#x3D;</p>
</blockquote>
<p><strong>in会导致索引失效吗</strong></p>
<p>当in的条件命中的数量很少时，是走索引的；但是当in的条件命中的数量超过30%时，索引失效，走全表扫描；</p>
<p><strong>普通索引和唯一索引，应该怎么选择？</strong>查询和对已经在内存的更新差距不大。但是对于不在内存的数据，唯一索引有唯一性要求，要先加到内存（相当于用不了changebuffer），但是普通索引不需要，只需要存到change buffer里面就可以。</p>
<p><strong>添加索引的原则</strong></p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115165553203.png" alt="image-20231115165553203"></p>
<p><strong>超大分页优化</strong></p>
<blockquote>
<p><font color='red'><u>***子查询+ 覆盖索引 + where 语句 ***</u></font></p>
<p>先通过覆盖索引得到id，然后对id排序，那这个id和原来的表做关联查询</p>
</blockquote>
<p><strong>索引失效情况</strong>；</p>
<blockquote>
<p>1、违反最左前缀原则：</p>
<p>2、范围查找右边的会失效</p>
<p>3、在索引列有函数操作，包括显示的函数和隐式的类型转换</p>
<p>4、优化器觉得全局更快，索引也会失效</p>
</blockquote>
<p><strong>mysql优化</strong></p>
<blockquote>
<p><font color='red'><u><em><strong>表结构的优化：分库分表、读写分离、</strong></em></u></font></p>
<p><font color='red'><u><em><strong>如果是sql语句的优化：explain命令去分析sql语句，看看能不能优化</strong></em></u></font></p>
<p><font color='red'><u><em><strong>参数方面：buffer pool的大小，刷盘策略，最大连接数</strong></em></u></font></p>
</blockquote>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115170958089.png" alt="image-20231115170958089"></p>
<p><strong>MySQL为什么有时候会选错索引？</strong></p>
<blockquote>
<p>优化器是找到一个最优的方案，以最小的代价去执行。</p>
<p>1)我们是根据基数来估计行数，那基数是怎么得到的？是通过采样统计。InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了基数。</p>
<p>2)还有一个问题就是优化器还要判断，执行这个语句本身要扫描多少行，</p>
<p>解决方法？</p>
<p>1）forceindex</p>
<p>2）<strong>修改语句，引导 MySQL 使用我们期望的索引</strong></p>
<p>3）新建索引</p>
</blockquote>
<p> <strong>怎么给字符串字段加索引？</strong></p>
<blockquote>
<p>1、前缀索引。这里要关注的区分度，就是前缀索引是几个字符的时候区分度较大，又能节省空间，这个可能需要用到count函数去比较一下。</p>
<p>Ps：用前缀索引就用不上覆盖索引对查询性能的优化了，都要回表</p>
<p>其他方法？</p>
<p>2、倒序存储</p>
<p>3、hash</p>
<p>差别在于，空间，查询效率，区间查找</p>
</blockquote>
<p><strong>对于函数操作，不管有没有改变有序性，都不走索引。</strong></p>
<p>由于上面这条规则， 所以一些在索引字段上面做隐式转换和隐式编码转换，也不走索引。P：在mysql里面字符串和数字的隐式转换是<font color='red'><u><em><strong>字符串转成数字</strong></em></u></font>，字符编码从少的往多的转。</p>
<p>innodb最常见的索引就是：</p>
<p><font color='red'><u><em><strong>b+树索引 （b+树只能找到数据行所在的页，然后把页读到内存里面，进行查找）</strong></em></u></font></p>
<p><font color='red'><u><em><strong>哈希索引（自动生成）</strong></em></u></font></p>
<p><font color='red'><u><em><strong>全文索引</strong></em></u></font></p>
<h2 id="1、B-树索引"><a href="#1、B-树索引" class="headerlink" title="1、B+树索引"></a>1、B+树索引</h2><p>为什么不用b树，b树的非叶子节点会保存数据，b+树不会，所以b树能保存的指针就好了，这样树的高度就会变大。</p>
<p>为什么不用红黑树，红黑树是一个二叉树，这个高度肯定是不如b+树这样的多叉树，然后我们时间消耗上，就是这个磁盘io很关键。</p>
<blockquote>
<p>b+树是为了磁盘或其他直接存取辅助设备设计的一种多叉平衡查找树</p>
<p>b+树的所有记录结点都是按照键值的大小顺序存放到同一层的叶子结点，他们之间通过叶子结点指针进行连接，中间的都是searchkey</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3></blockquote>
<h3 id="1、操作"><a href="#1、操作" class="headerlink" title="1、操作"></a>1、操作</h3><h4 id="1、插入"><a href="#1、插入" class="headerlink" title="1、插入"></a>1、插入</h4><p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231005201534270.png" alt="image-20231005201534270"></p>
<h4 id="2、旋转"><a href="#2、旋转" class="headerlink" title="2、旋转"></a>2、旋转</h4><p>旋转发生在leaf page已经满了，但是左右兄弟还没有满，这时候会把记录平移到兄弟结点上面，左兄弟优先</p>
<h4 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h4><p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231005202324173.png" alt="image-20231005202324173"></p>
<h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><p>b+树可以分成聚集索引、辅助索引，这两个到区别就是叶子结点放的到底是不是一行信息</p>
<h4 id="1、聚集索引"><a href="#1、聚集索引" class="headerlink" title="1、聚集索引"></a>1、聚集索引</h4><blockquote>
<p><font color='red'><u><em><strong>聚集索引就是按照主键构造的索引b+树，所以叶子结点存放的就是整张表的数据</strong></em></u></font>，叶子结点也叫做数据页。非叶子结点的索引页存放的仅仅是键值和指向数据页的偏移量。</p>
<p>选取规则：主键 -》唯一-》rowid</p>
</blockquote>
<h4 id="2、辅助索引"><a href="#2、辅助索引" class="headerlink" title="2、辅助索引"></a>2、辅助索引</h4><blockquote>
<p><font color='red'><u><em><strong>辅助索引的叶子结点不包含行记录的全部数据。叶子结点包含键值和书签，书签用来告诉引擎哪里能找到真正的行数据。</strong></em></u></font>由于innodb是索引组织表，所以辅助索引的书签就是行记录的聚集索引键。所以辅助索引就是包含了索引那列的值和主键的值。</p>
</blockquote>
<h3 id="3、B-树索引的管理"><a href="#3、B-树索引的管理" class="headerlink" title="3、B+树索引的管理"></a>3、B+树索引的管理</h3><blockquote>
<h4 id="1、索引管理"><a href="#1、索引管理" class="headerlink" title="1、索引管理"></a>1、索引管理</h4><p>创建和删除可以通过两种方法。一种是alter table。另一种是create&#x2F;drop index。</p>
<p>查看：show index from XX</p>
<h4 id="4、Online-DDL"><a href="#4、Online-DDL" class="headerlink" title="4、Online DDL"></a><font color='red'><u><em><strong>4、Online DDL</strong></em></u></font></h4><p>允许在辅助索引创建的同时，还允许insert update等DML操作</p>
<p>有三种算法：</p>
<p>copy：执行insert update delete这些操作的时候，<font color='red'><u><em><strong>先把操作日志写入一个缓存里面，然后，索引建立后重做表上面</strong></em></u></font></p>
<p>replace ：replace就是不需要临时表。</p>
<p>instant ：直接对元数据进行修改，无需拷贝数据也无需重建整表</p>
<h4 id="5、cardinality值"><a href="#5、cardinality值" class="headerlink" title="5、cardinality值"></a><font color='red'><u><em><strong>5、cardinality值</strong></em></u></font></h4><p>他是一个统计信息，优化器会根据这个值来判断我们用不用索引，表示索引中唯一值的数据的估计值，如果是性别这种，重复的非常多，我们叫低选择性，不适合做索引。反之高选择性就比较适合，尤其是在高选择性属性字段里面取出一小部分数据，那就更有必要了。</p>
<ul>
<li><strong>统计的方式</strong>？</li>
</ul>
<p>所以我们用的是<font color='red'><u><em><strong>采样</strong></em></u></font>的方法（<font color='red'><u><em><strong>（对8或20个叶子结点进行采样预估，取出平均值）</strong></em></u></font>）。cardinality值的<font color='red'><u><em><strong>更新</strong></em></u></font>发生在insert和update操作，但是肯定不是每一次inser tupdate都去更新，具体策略如下：</p>
<p>1、表中1&#x2F;16数据发生了变化</p>
<p>2、计数器超过20亿</p>
</blockquote>
<h3 id="4、B-树索引的使用"><a href="#4、B-树索引的使用" class="headerlink" title="4、B+树索引的使用"></a>4、B+树索引的使用</h3><blockquote>
<h4 id="1、联合索引"><a href="#1、联合索引" class="headerlink" title="1、联合索引"></a>1、联合索引</h4><p>本质也是一颗二叉树，之前是a,b,c,d现在是（a,b）(c,d)</p>
<p>第一个好处：对于联合查询和单列的第一列的查询都可以用联合查询</p>
<p>第二个好处：一句对第二个键值进行了排序处理，可以缩短某些情况的查询时间</p>
<h4 id="2、覆盖索引"><a href="#2、覆盖索引" class="headerlink" title="2、覆盖索引"></a>2、覆盖索引</h4><p>覆盖索引的意思是，从辅助索引中就直接可以得到想要查询的记录，不需要回表。</p>
<p>第一个好处是：辅助索引本身不包括整行记录，所以大小远小于聚集索引，减少io操作</p>
<p>第二个好处是：对于某些统计问题，存储引擎并不会通过聚集索引，辅助索引远远小于聚集索引，</p>
<h4 id="4、MRR优化（多范围读取、只支持非聚集索引）（离散读变成顺序读）"><a href="#4、MRR优化（多范围读取、只支持非聚集索引）（离散读变成顺序读）" class="headerlink" title="4、MRR优化（多范围读取、只支持非聚集索引）（离散读变成顺序读）"></a>4、MRR优化（多范围读取、只支持非聚集索引）<font color='red'><u><em><strong>（离散读变成顺序读）</strong></em></u></font></h4><p>工作方式：</p>
<ul>
<li>把辅助索引读出来放到一个缓存里面</li>
<li>把缓存中根据rowid进行排序</li>
<li>然后根据rowid去找数据</li>
</ul>
<p>他适用于某些范围查找，</p>
<p>而且还可以对某些范围查找进行拆分，变成成键值对的等值查找。直接就过滤了一些不符合条件的数据。</p>
<p>好处：</p>
<ul>
<li>数据访问更加顺序，</li>
<li>减少缓冲池页的替换</li>
</ul>
<h4 id="5、索引下推ICP优化（只支持非聚集索引）"><a href="#5、索引下推ICP优化（只支持非聚集索引）" class="headerlink" title="5、索引下推ICP优化（只支持非聚集索引）"></a>5、索引下推ICP优化（只支持非聚集索引）</h4><p>原本我们通过索引进行查询的时候，首先根据索引查找记录，然后根据where条件过滤记录。ICP是在取出索引的同时，判断是否可以进行where条件的过滤，也就是讲where的部分过滤操作放到了存储引擎层。<font color='red'><u><em><strong>联合索引</strong></em></u></font></p>
<p>场景：</p>
<p>假设表TB1上有索引IDX_C1_C2_C3(C1,C2,C3)，对于查询SELECT * FROM TB1 WHERE C1&#x3D;’XXX’ AND C3&#x3D;’XXX’</p>
<p>在MySQL 5.6版本以前，由于缺少C2的过滤条件，Innodb存储引擎层只能使用索引IDX_C1_C2_C3按照C1&#x3D;’XXX’条件找出所有满足条件的索引记录，再根据这些索引记录去聚集索引中查找，将找到的表数据返回给MySQL Server层，然后由MySQL Server层使用C3&#x3D;’XXX’条件进行过滤得到最终结果。</p>
<p>假设满足C1&#x3D;’XXX’条件的数据行为100000条，而满足C1&#x3D;’XXX’ AND C3&#x3D;’XXX’的数据行为100条，则：</p>
<p>1、回表100000次，给server层传100000条数据</p>
<p>2、回表100次，Innodb存储引擎层向MySQL Server层传递100行数据。</p>
</blockquote>
<h3 id="5、自适应哈希索引"><a href="#5、自适应哈希索引" class="headerlink" title="5、自适应哈希索引"></a>5、自适应哈希索引</h3><p>InnoDB中的哈希用的字典进行查找，冲突用链表解决，哈希函数用除法散列</p>
<p>自适应哈希索引就是用的这种方法。</p>
<h3 id="6、全文检索"><a href="#6、全文检索" class="headerlink" title="6、全文检索"></a>6、全文检索</h3><blockquote>
<p>全文检索一般使用倒排索引。</p>
<h5 id="1、倒排索引"><a href="#1、倒排索引" class="headerlink" title="1、倒排索引"></a>1、倒排索引</h5><p>它在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关键数组实现，其拥有两种表现形式：<br>inverted file index：其表现形式为{单词，单词所在文档的ID}<br>full inverted index：其表现形式为{单词，(单词所在文档的ID，在文档中的具体位置)}</p>
<h5 id="2、InnoDB全文检索的实现"><a href="#2、InnoDB全文检索的实现" class="headerlink" title="2、InnoDB全文检索的实现"></a>2、InnoDB全文检索的实现</h5><p><font color='red'><u><strong>InnoDB全文索引有3个非常重要的东西，一个是辅助表，一个是FTS Index Cache、一个是FTS DOUCUMENT id</strong></u></font></p>
<h6 id="1、Auxiliary-Table（辅助表）"><a href="#1、Auxiliary-Table（辅助表）" class="headerlink" title="1、Auxiliary Table（辅助表）"></a><strong>1、Auxiliary Table（辅助表）</strong></h6><p><font color='red'><u><em><strong>辅助表是把文档，分词然后规范化后的结果，</strong></em></u></font></p>
<p><font color='red'><u><em><strong>辅助表的话采用“full inverted index”的方式有两个列：</strong></em></u></font></p>
<p><font color='red'><u><em><strong>一个是word字段。在word字段上有设有索引，另一个是ilist字段，（DocumentId,Position）</strong></em></u></font></p>
<h6 id="2、FTS-INDEX-Cache（全文检索缓存）"><a href="#2、FTS-INDEX-Cache（全文检索缓存）" class="headerlink" title="2、FTS INDEX Cache（全文检索缓存）"></a><strong>2、FTS INDEX Cache（全文检索缓存）</strong></h6><p>他是一个红黑树的结构：<font color='red'><u><em><strong>我执行插入操作，插入的数据已经更新了对应的表，但是我们的辅助表可能还没更新，这个更新还停留在FTS cache里面</strong></em></u></font>。如果没插一次就更新这是不合理的，那具体同步到辅助表的时机：</p>
<p>1、在我进行全文检索查询的时候，我把FTS INDEX cache里的word字段合并到辅助表，然后查询。有点类似于insert buffer</p>
<p>2、数据库关闭的时候会同步</p>
<p>3、cache满了	</p>
<p>数据库宕机时：一些FTS InDEX Cache中的数据库可能未被同步到磁盘上。那么下次重启时，当用户对表进行全文检索（查询或者插入操作）时，InnoDB会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入到FTS Index Cache中</p>
<p>对于InnoDB来说，其总是在事务提交时将分词写入到FTS Index Cache。</p>
<h6 id="3、FTS-DOUCUMENT-ID"><a href="#3、FTS-DOUCUMENT-ID" class="headerlink" title="3、FTS DOUCUMENT ID"></a>3、FTS DOUCUMENT ID</h6><p><font color='red'><u><em><strong>为了支持全文检索，我们每一行数据必须有一个列与word进行映射：</strong></em></u></font></p>
<ul>
<li>在InnoDB中这个列<strong>被命名为FTS_DOC_ID</strong>，他是自动创建的</li>
<li>其<strong>类型必须是</strong>bigint unsigned not null</li>
<li>并且InnoDB自动会在该列上加入一个<strong>名为FTS_DOC_ID_INDEX的unique index索引</strong></li>
<li><strong>用户也可以在建表时自动添加FTS_DOC_ID，以及相应的Unique Index</strong></li>
</ul>
<p>Deleted auxiliary table<br>文档中分词的插入操作是在事务提交时完成的，然而对于删除操作，其在事务提交时不删除磁盘Auxiliary Table中的记录，而只是删除FTS Index Cache中的记录。对于Auxiliary Table中被删除的记录，InnoDB会记录其FTS Document ID，并将其保存在Deleted auxiliary table中</p>
<p>由于文档的DML操作实际并不删除索引中的数据，相反还会在对应的DELETED表中插入记录，因此随着应用程序的允许，索引会变得非常大，即使索引列中的有些数据已经被删除，查询也不会使用到。为了，InnoDB存储引擎提供了一种方式，允许用户手动地将已删除的记录从索引中彻底删除，该命令就是OPTIMIZE TABLE</p>
</blockquote>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁机制是用于管理对共享资源的并发访问，保证数据的完整性和一致性。</p>
<h2 id="1、锁的类型"><a href="#1、锁的类型" class="headerlink" title="1、锁的类型"></a>1、锁的类型</h2><h3 id="1、全局锁"><a href="#1、全局锁" class="headerlink" title="1、全局锁"></a>1、全局锁</h3><blockquote>
<p><font color='red'><u><em><strong>典型的使用场景就是做全库的逻辑备份</strong></em></u></font></p>
<ul>
<li>一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态</li>
</ul>
<p><font color='red'><u><em><strong>两种方法<br>flush tables with read lock;<br>mysqldump -single-tranctions<br>single-transaction只适用于支持事务引擎的库，如果支持的话建议用single-transactions，否则用flush table with read lock</strong></em></u></font></p>
</blockquote>
<h3 id="2、表级锁"><a href="#2、表级锁" class="headerlink" title="2、表级锁"></a>2、表级锁</h3><blockquote>
<p>表级锁，主要分为4类：</p>
<ul>
<li>表锁</li>
<li>元数据锁（meta data lock，MDL）</li>
<li>意向锁</li>
<li>自增锁</li>
</ul>
</blockquote>
<h4 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h4><p>表锁就是对表加锁，分读锁和写锁，读琐和读锁是兼容，读锁和写锁、写锁和写锁是不兼容的。</p>
<h4 id="2、元数据锁"><a href="#2、元数据锁" class="headerlink" title="2、元数据锁"></a>2、元数据锁</h4><blockquote>
<p>再来说说<strong>元数据锁</strong>（MDL）,<font color='red'><u><em><strong>它 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。我们不需要显示的使用 MDL，会自动给这个表加上 MDL：</strong></em></u></font></p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
</blockquote>
<blockquote>
<p>MDL 不需要显示调用，那它是在什么时候释放的?</p>
</blockquote>
<p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
<h4 id="3、意向锁"><a href="#3、意向锁" class="headerlink" title="3、意向锁"></a>3、意向锁</h4><blockquote>
<p><font color='red'><u><strong>我觉得意向锁主要还是解决行锁和表锁之间的冲突问题</strong></u></font></p>
<ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li>
</ul>
</blockquote>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加行级独占锁。</p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/20e0f35589584352bd15e817668a0886.png" alt="img"></p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/6e6b275c2d6d4dfcbbb338be4f61bee9.png" alt="img"></p>
<p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p>
<h4 id="4、自增锁"><a href="#4、自增锁" class="headerlink" title="4、自增锁"></a>4、自增锁</h4><blockquote>
<p><font color='red'><u><em><strong>主键设置成自增之后，会自动给主键赋递增的值，5.7保存在内存里面，但是8.0以后保存在redo log里面</strong></em></u></font></p>
<p>然后这里有两种方式。一种是，AUTO-INC 锁<strong>，</strong>不是一个事务提交后才释放，而是在<font color='red'><u><em><strong>执行完插入语句后就会立即释放。</strong></em></u></font></p>
<p>后面提供了一种轻量级锁，申请完就释放，但是伴随着两个问题：1、自增主键不是连续的。2、主库和从库不一致。</p>
<p><font color='red'><u><em><strong>自增逐渐不连续的原因：唯一键的冲突、事务回滚、批量插入</strong></em></u></font></p>
<p><font color='red'><u><em><strong>主库存库不一致的原因：批量插入</strong></em></u></font></p>
<p>所以后面InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>，并且提供了一个参数，叫innodb autoinc lock mode</p>
<ul>
<li>当 innodb_autoinc_lock_mode &#x3D; 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 2，就采用轻量级锁，<font color='green'><u><em><strong>申请自增主键后就释放锁</strong></em></u></font>，并不需要等语句执行后才释放。</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 1：</li>
<li>普通 insert 语句，自增锁在申请之后就马上释放；</li>
<li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放<font color='red'><u><em><strong>（因为“不知道要预先申请多少个 id）</strong></em></u></font></li>
<li>原因如下：</li>
</ul>
<p>session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后<strong>两个 session 同时执行向表 t2 中插入数据</strong>。</p>
<p>如果 innodb_autoinc_lock_mode &#x3D; 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：</p>
<ul>
<li>session B 先插入了两个记录，(1,1,1)、(2,2,2)；</li>
<li>然后，session A 来申请自增 id 得到 id&#x3D;3，插入了（3,5,5)；</li>
<li>之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</li>
</ul>
<p>可以看到，<strong>session B 的 insert 语句，生成的 id 不连续</strong>。</p>
<p>当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format&#x3D;statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。</p>
<p>但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在<strong>从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致</strong>。</p>
<p>要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。</p>
<p>所以，<strong>当 innodb_autoinc_lock_mode &#x3D; 2 时，并且 binlog_format &#x3D; row，既能提升并发性，又不会出现数据一致性问题</strong>。</p>
</blockquote>
<h3 id="3、行锁"><a href="#3、行锁" class="headerlink" title="3、行锁"></a>3、行锁</h3><blockquote>
<p><strong>MySQL 的行锁是在引擎层由各个引擎自己实现的。</strong></p>
</blockquote>
<blockquote>
<p><font color='red'><u><em><strong>InnoDB有三种行锁的算法：Record Lock：记录锁、Gap Lock：间隙锁，锁定一个范围，但不包括记录本身，Next-Key Lock（临建锁）：Record Lock + Gap Lock 左开右闭</strong></em></u></font></p>
<p><font color='red'><u><em><strong>InnoDB就是用Next-Key去解决幻读问题（同一事务下，连续执行两次相同的sql语句可能导致不同的结果，第二次sql可能会返回之前不存在的行）间隙锁在可重复读才生效</strong></em></u></font></p>
<p>加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。 </p>
<ol>
<li>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭 区间。 </li>
<li>原则 2：查找过程中访问到的对象才会加锁。 </li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。 </li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，nextkey lock 退化为间隙锁。 </li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<blockquote>
<p><strong>两阶段锁协议</strong>：</p>
<blockquote>
<p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</strong></p>
</blockquote>
<blockquote>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20230805221422216.png" alt="image-20230805221422216"></p>
</blockquote>
<h2 id="2、一致性非锁定读（快照读）"><a href="#2、一致性非锁定读（快照读）" class="headerlink" title="2、一致性非锁定读（快照读）"></a>2、一致性非锁定读（快照读）</h2><p>一致性非锁定读是指InnoDb通过多版本控制（MVCC）的方式读一个我能看到的数据。</p>
<p>所以我们要讲一下这个MVCC，他这个就依赖于undolog版本链和readView。</p>
<p>首先，每一行数据其实都有两个隐藏列，一个是trxid一个是rollpointer，trxid 表示最新修改事务的id，rollpointer表示指向旧版本undo log</p>
<p>我们修改的数据的时候，我们把该行数据拷贝到 <code>undo log</code>作为旧版本。进行真正的修改操作，同时修改trxid 和roll_pointer，这样就形成了一个版本链条，那至于我们能看到哪个版本的就依赖于readview</p>
<p>ReadView，里面有四个比较关键的东西：</p>
<p>一个是m_ids，这个就是说事务开启那一刻有哪些事务在Mysql里面执行还没有提交的；</p>
<p>一个是min_trx_id，就是m_ids里最小的事务id的值；</p>
<p>一个是max_trx_id，就是此刻mysql下一个要生成的事务id，就是最大事务id；</p>
<p>一个是creator_trx_id，就是你这个事务的id。</p>
<p><font color='red'><u><em><strong>如果比mintexid小或者等于creatoridexid，我们可以看得见。</strong></em></u></font></p>
<p>比如一条记录旧版本里面有三条记录：10，20，30。然后我们的事务id是15，m_ids里面有20，30。这里的min_trx_id就是20，我们的15比她小，说明还没有提交。因为隔离性所以肯定是看不到的，然后再去找更前面版本，我们就找到了10，发现10可以，所以我们这次读到的数据就是事务id为10的那一个版本。</p>
<h2 id="3、一致性锁定读（当前读）"><a href="#3、一致性锁定读（当前读）" class="headerlink" title="3、一致性锁定读（当前读）"></a>3、一致性锁定读（当前读）</h2><p>有时候用户需要些显式的对读操作进行加锁保证一致性。 <font color='red'><u><em><strong>select for share mode， for update还有update也是当前读</strong></em></u></font></p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115193544143.png" alt="image-20231115193544143"></p>
<h2 id="5、锁问题（并发事务带来的问题）"><a href="#5、锁问题（并发事务带来的问题）" class="headerlink" title="5、锁问题（并发事务带来的问题）"></a>5、锁问题（并发事务带来的问题）</h2><h3 id="1、脏读-or-不可重复读-or-幻读"><a href="#1、脏读-or-不可重复读-or-幻读" class="headerlink" title="1、脏读 or 不可重复读 or 幻读"></a>1、脏读 or 不可重复读 or 幻读</h3><p>脏读：<font color='blue'><u><em><strong>读到了其他事务没有提交的数据</strong></em></u></font></p>
<p>不可重复读：<font color='blue'><u><em><strong>两次读，读的不一样。</strong></em></u></font></p>
<p>幻读：<font color='blue'><u><em><strong>一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</strong></em></u></font></p>
<p>不可重复读的原因：<font color='blue'><u><em><strong>readview是每一次读生成一次的。</strong></em></u></font></p>
<p>幻读innoDB的解决方法：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<font color='red'><u><em><strong>通过 next-key lock（记录锁+间隙锁）（前开后闭区间）</strong></em></u></font><strong>方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
<li>行锁是加在索引上的</li>
</ul>
<h3 id="3、丢失更新"><a href="#3、丢失更新" class="headerlink" title="3、丢失更新"></a>3、丢失更新</h3><p>是指一个事务的操作被另一个事务的操作覆盖了，但是当前数据库的任何隔离级别都对行或者粗粒度的对象加锁，所以还是比较难发生。</p>
</blockquote>
<h2 id="6、死锁"><a href="#6、死锁" class="headerlink" title="6、死锁"></a>6、死锁</h2><p>死锁是指两个或以上的事务争夺资源造成的一种互相等待的现象</p>
<blockquote>
<p><font color='blue'><u><em><strong>互斥条件</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>请求和保持条件</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>不可剥夺条件</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>循环等待条件</strong></em></u></font></p>
<p>解决方法：</p>
<p>1、设置超时的阈值，回滚一个死锁的事务</p>
<p>2、wait-for-graph 等待图。检测是否有回路。通常用深度优先。1.2版本开始就变成非递归</p>
<p>如果有死锁，那就回归undo量最少的</p>
</blockquote>
<h2 id="7、锁升级"><a href="#7、锁升级" class="headerlink" title="7、锁升级"></a>7、锁升级</h2><p>InnoDB中不存在锁升级的问题，因为InnoDB不是更具每个记录来产生锁的，相反，其根据每个事务访问的每个页对锁进行管理，采用的是位图的方式。所以不管你锁住的是页中的一个记录或者多个记录，开销一样</p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231006204601132.png" alt="image-20231006204601132"></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="1、认识事务"><a href="#1、认识事务" class="headerlink" title="1、认识事务"></a>1、认识事务</h2><h3 id="1、四个特性：acid。"><a href="#1、四个特性：acid。" class="headerlink" title="1、四个特性：acid。"></a>1、四个特性：acid。</h3><p>原子性：要么成功要么失败</p>
<p>一致性：讲数据库从一种状态转变为下一种一致的状态，完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p>
<p>隔离性Isolation：一个事务提交之前对其他事物不可见</p>
<p>Durability：一旦提交，那么结果是永久性的</p>
<p>可以举个例子：就是转账。</p>
<h2 id="2、事务的实现"><a href="#2、事务的实现" class="headerlink" title="2、事务的实现"></a>2、事务的实现</h2><p>事务的隔离性由锁机制来实现。</p>
<p>原子性、一致性、持久性通过redo log和undo log完成</p>
<p>redo log保证持久性</p>
<p>undo log保证事务的原子性，一致性</p>
<h3 id="1、redo-log"><a href="#1、redo-log" class="headerlink" title="1、redo log"></a>1、redo log</h3><p><font color='red'><u><em><strong>它为了防止断电导致数据丢失的问题</strong></em></u></font>，<font color='red'><u><em><strong>当有一条更新操作的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，InnoDB 引擎会在适当的时候，在 Buffer Pool 的脏页刷新到磁盘里</strong></em></u></font>。这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p>
<p><font color='red'><u><em><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。</strong></em></u></font></p>
<p>主要有下面几个时机：</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。</li>
</ul>
<p>由参数 <code>innodb_flush_log_at_trx_commit</code> 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：</p>
<ul>
<li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li>
<li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li>
<li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/6_file_system/pagecache.html">这篇 (opens new window)</a>），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li>
</ul>
<p>事务提交的时候必须把事务的所有日志写入重做日志文件进行持久化。这个的所有日志包括redo log 和undo log</p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231007131604938.png" alt="image-20231007131604938"></p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231007131752781.png" alt="image-20231007131752781"></p>
<p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231007131726290.png" alt="image-20231007131726290"></p>
<h3 id="2、undo-log"><a href="#2、undo-log" class="headerlink" title="2、undo log"></a>2、undo log</h3><blockquote>
<p>undo log最主要的作用有两点：<font color='red'><u><em><strong>一个是事务回滚，保证原子性；还有一个是支持mvcc</strong></em></u></font></p>
<p>那我们先讲第一个，就是事务提交之前，如果发生意外，这时候你用redolog是没有办法恢复的，所以我们可以使用undolog，因为undolog他记录的是修改前的记录。</p>
<p>另外一个大的作用是mvcc，mvcc他是基于undo log版本链和ReadView实现</p>
<p>首先，每一行数据其实都有两个隐藏列，一个是trxid一个是rollpointer，trxid 表示最新修改事务的id，rollpointer表示指向旧版本log</p>
<p>undolog版本链形成的原因是，我们修改的数据的时候，我们把该行数据拷贝到 <code>undo log</code>作为旧版本。进行真正的修改操作，同时修改trxid 和roll_pointer。</p>
<p>ReadView，里面有四个比较关键的东西：</p>
<p>一个是m_ids，这个就是说事务开启那一刻有哪些事务在Mysql里面执行还没有提交的；</p>
<p>一个是min_trx_id，就是m_ids里最小的事务id的值；</p>
<p>一个是max_trx_id，就是此刻mysql下一个要生成的事务id，就是最大事务id；</p>
<p>一个是creator_trx_id，就是你这个事务的id。</p>
<p><font color='red'><u><em><strong>如果比mintexid小或者等于creatoridexid，我们可以看得见。</strong></em></u></font></p>
<p>比如一条记录旧版本里面有三条记录：10，20，30。然后我们的事务id是15，m_ids里面有20，30。这里的min_trx_id就是20，我们的15比她小，说明还没有提交。因为隔离性所以肯定是看不到的，然后再去找更前面版本，我们就找到了10，发现10可以，所以我们这次读到的数据就是事务id为10的那一个版本。</p>
</blockquote>
<p>rr：事务第一次读的时候创建readview</p>
<p>rc：每次查询都会创建一个readview</p>
<p>mvcc是快照读，update是当前读，但是要注意两阶段锁协议</p>
<h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><p><img src="/../images/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/image-20231115220333308.png" alt="image-20231115220333308"></p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">GETAGGT IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Mysql/" rel="tag">Mysql</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/11/08/JUC/"
                    data-tooltip="JUC"
                    aria-label="FRÜHER: JUC"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">FRÜHER</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/11/04/JVM/"
                    data-tooltip="JVM"
                    aria-label="NÄCHSTER: JVM"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NÄCHSTER</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"
                    title="Teilen auf Facebook"
                    aria-label="Teilen auf Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"
                    title="Teilen auf Twitter"
                    aria-label="Teilen auf Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"
                    title="Teilen auf Google Plus"
                    aria-label="Teilen auf Google Plus"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 CSEN. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/11/08/JUC/"
                    data-tooltip="JUC"
                    aria-label="FRÜHER: JUC"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">FRÜHER</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/11/04/JVM/"
                    data-tooltip="JVM"
                    aria-label="NÄCHSTER: JVM"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NÄCHSTER</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"
                    title="Teilen auf Facebook"
                    aria-label="Teilen auf Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"
                    title="Teilen auf Twitter"
                    aria-label="Teilen auf Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"
                    title="Teilen auf Google Plus"
                    aria-label="Teilen auf Google Plus"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"
                        aria-label="Teilen auf Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Teilen auf Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"
                        aria-label="Teilen auf Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Teilen auf Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=http://example.com/2023/11/08/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"
                        aria-label="Teilen auf Google Plus"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Teilen auf Google Plus</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
            <h4 id="about-card-name">CSEN</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                浙江温州
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-39paoi2hupf5wmw7ojejrxpco6edftjriz5ezbtp4grymrdceksftgan2adp.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
