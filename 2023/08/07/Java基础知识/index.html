
<!DOCTYPE html>
<html lang="zh-CH">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="森">
    <title>Java基础知识 - 森</title>
    <meta name="author" content="CSEN">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CSEN","sameAs":["https://github.com/Caosen0819"],"image":"head.jpg"},"articleBody":"讲讲Java的代理代理分成静态代理和动态代理，静态代理需要自己实现对每一个方法对代理，那么如果新增一个方法，那就要手动修改目标对象代理对象的代码，非常繁琐。动态代理更加灵活，不需要你一个一个的对方法进行代理。\n动态代理就是运行的时候生成class。这个DynamicProxy其实就是一个Proxy，\n动态代理有两种方式一种是jdk方法，一种是cglib方法\n我们先来讲jdk代理：\nJDK代理依赖于Proxy类和InvocationHandler接口，InvocationHandler接口他只有一个invoke方法，三个参数是代理类，被代理方法，方法参数组。代理方法和参数组其实我们可以利用反射得到，所以参数其实是可以变化的，那这样就成功的实现了动态的代理。\n那我们怎么去调用这个方法呢？依赖于Proxy类和他的方法newproxyInstance，得到的代理类，调用方法其实会直接调用我们实现InvocationHandler接口的invoke方法\n下面来讲CGLIB代理\n在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。你可以通过 Enhancer类来动态获取被代理类，\n  CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，每次调用代理类的方法都会被方法拦截器拦截，在拦截器中才是调用目标类的该方法的逻辑。所以我们说，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。\n二者区别总结一下两者的区别吧：\nJDK 动态代理基于接口，CGLIB 动态代理基于类。因为 JDK 动态代理生成的代理类需要继承Proxy，所以，只能基于接口；CGLIB 动态代理是根据类创建此类的子类，所以，此类不能被 final 修饰JDK 是自带的、CGLIB需要加载包\nJDK是反射机制，CGLIB是使用ASM框架。\n为什么Java不能多继承？\n会出现方法冲突和变量冲突\n集合\nArraylist底层原理可以从底层数据结构，构造函数和关键方法理解。\n\nArraylist的底层数据结构是object[]数组，构造函数分有参无参，如果是无参就是空数组，如果是有参，就用你定义的那个初始大小。如果参数是容器，那就是把容器转成数组copy给object。关键方法就是add方法，需要保证容量够用才能添加元素，所以会在添加之前进行一个ensurecapacity的过程。他会先计算mincapacity的值，他会拿mincapacity去和现在的数组长度比较，如果大了说明要扩容，扩容的过程是先×1.5看看够不够，够的话就1.5，不够就用新的这个mincapacity。如果minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8\n\n了解比较简单\n对于插入：如果不需要扩容，其实无论是头插指定位置插入都是O(n)，尾插是O(1)。如果需要扩容，就得再做一次扩容，O(n)，然后在插入，就是刚才讲的时间复杂度。\n对于删除：头删和指定位置删除是O(n)，尾部删除是O(1)\n\n\nLinkedlist\nLinkedlist 是双向链表，因为是链表，所以没什么扩容的问题，基本的方法都是围绕前节点、后节点、节点值展开的。\n\n头部插入&#x2F;删除： O(1)。\n尾部插入&#x2F;删除： O(1)。\n指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。\n\n\n如何实现数组和arraylist之间的转换List.toarray  (修改原先list，array不受影响)\nArrays.aslist （受影响）\n\n&lt;?&gt;\n主要用于类或方法上，对这个类或者方法里面的泛型全是一样的。\n一般用在变量上，有界通配符，对类型做一定的限制。\n\n## \n\nArrayList 与 LinkedList 区别?\n底层数据结构： ArrayList 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构\n插入和删除的时间复杂度：arraylist，头插、指定插、头删、指定删除都是On，尾插和尾删除是O1\nlingklist 头插和尾插、头删除、尾删除都是O1，指定位置是On\n内存空间占用：linkedlist每个节点要存前后指针，所以内存占用大。\n是否安全：两个都是不安全的，局部变量\n\n\n比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\nHashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。\n底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。\n\n\nQueue 与 Deque 的区别\nQueue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。\nDeque 是双端队列，在队列的两端均可以插入或删除元素。\n\nArrayDeque 与 LinkedList 的区别\nArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能\nArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。\nArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。\n\n什么是 BlockingQueue？\nBlockingQueue （阻塞队列）是一个接口，继承自 Queue。没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。线程安全。\n阻塞队列有哪些\n\nArrayBlockingqueue：底层是数组、有界队列。一把锁\n\n\nLinkBlockingQueue：底层是链表、默认无界但是支持有界。头尾两把锁\n\n\nDelayedWorkQueue\n\n\nSynchronousQueue\n\n\nHashmap：\nHashMap 的底层实现底层数据结构+构造函数+put方法回答\nJDK1.8 之前 HashMap 底层是 数组和链表。1.8之后是数组+链表+红黑树\n构造函数是懒加载，没有初始化数据，就是把负载因子赋为0.75。\nput的时候，先判断数组是否为空，如果为空，就初始化为16大小。通过 key 的 hashcode 经过扰动函数（右移16位再异或），然后通过   hash &amp; (n - 1) 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果定位到的数组位置没有元素 就直接插入。如果有数据，就判断key是不是相同，相同就覆盖，不相同就判断是不是红黑树，如果是就调用putTree，如果是链表就遍历链表，看看key有没有，有就覆盖，没有就在尾部插入新的节点，然后判断长度是否大于8，大于8就去尝试转红黑树，插入结束后，最后要判断一下是否需要扩容，\n\n\nhashmap扩容过程扩容简单来说就是做了两件事。1：创建一个新数组，原来的两倍大。2：遍历旧数组每个槽如果槽位中是一个普通节点，则将节点放在新数组中，所在新数组中的下标计算方式为：e.hash &amp; (newCap - 1);如果槽位中是一个树节点，则进行红黑树的迁移操作，新数组中下标计算方式同普通节点；如果槽位中是一个链表节点，则将链表拆为高位链表和低位链表，就是拿hash值和旧容量做与操作，等于0就放入放入新数组的旧数组的下标位置和，不等于0会放到（旧数组下标 + 旧数组容量）下标位置；最后返回新数组。\nHashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）扩容问题和头插法问题\n假设两个线程同时对hashmap进行扩容，这时候两个都指向首节点A，后面的节点分别是bcd。\n那么这时候线程1正常执行，线程2卡住了。但是A执行完后因为是头插法所以abc变成了cba。线程2唤醒启动，线程2第一个e还是指向a，a的next指向b，这样子就出现了问题，但是还没出现环状。那我们继续执行。把e也就是a赋放到新链表，a &#x3D;\na的next其实就是b，b拿过来，然后b&#x3D;b的next，b的next是谁呢，就是a，然后a指向链表头，这个头节点就是b呀！这里就出问题了。\n解决的方法：concurrenthashmap，推荐；hashtable安全，不建议；或者直接加锁，也不建议。或者头插法改成尾插法。\nHashMap 为什么线程不安全？一方面就是多线程操作导致的死循环问题。\n另一方面就是两个线程 1,2 进行 put 操作，线程1 执行的时候通过判断发现没有出发hash碰撞，但是时间片用完了挂起，这时候线程2也判断有没有hash碰撞发现没有，因为线程1还没来得及插入。这时候线程2插入一个b值结束了，线程1重新获得时间片，因为之前已经成功判断过了，所以直接插入一个a值，那么这样b值就被a值覆盖了。\nHashMap 的长度为什么是 2 的幂次方散列采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 **采用二进制位操作 &amp;，相对于%能够提高运算效率）\nloadFactor 负载因子\nloadFactor 负载因子是控制数组存放数据多少的参数和扩容的界限。默认0.75\n给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。\nHashMap 和 Hashtable 的区别\n线程是否安全：HashMap 是非线程安全的，Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）\n\n效率： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；\n\n初始容量大小和每次扩充容量大小的不同： ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。\n\n底层数据结构： hashmap 数组+链表+红黑树，hashtable 数组+链表\n\n\nhashmap的key规范用自定义类作为key，必须重写equals()和hashCode()方法。\n\nConcurrentHashMap\nConcurrentHashMap是线程安全的，而是通过原子操作和局部加锁的方法保证了多线程的线程安全。\n1.8以前是用16个Segment 分段锁加的Reentranlock。1.8以后现在采用数组+链表+红黑树的形式。添加元素的时候按照代码的流程先判断是不是初始化、节点为空就cas添加，如果正在扩容，就帮助扩容；如果冲突就加synchronized后再插入。\nJava 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。\n具体的代码层面：\n\n元素排序 Comparable 和 Comparator 有什么区别？Comparable：实现 Comparable 接口并重写 compareTo 方法就可以实现某个类的排序了，它支持 Collections.sort 和 Arrays.sort 的排序。compareTo 方法接收的参数 p 是要对比的对象，排序规则是用当前对象和要对比的对象进行比较，然后返回一个 int 类型的值。正序从小到大的排序规则是：使用当前的对象值减去要对比对象的值；而倒序从大到小的排序规则刚好相反：是用对比对象的值减去当前对象的值。\nComparator 除了可以通过创建自定义比较器外，还可以通过匿名类的方式，更快速、便捷的完成自定义比较器的功能，具体的代码实现如下：\nComparable 必须由自定义类内部实现排序方法，而 Comparator 是外部定义并实现排序的\nLinux常用命令：cat, pwd, ls、TOP，mpstat，chattr，lsattr\n怎么排查项目故障：\n\n可以用top先看看是cpu还是内存的问题，cpu的话，可以拿到进程id，然后ps H -eo pid,tid,%cpu | grep进程id查看线程，最好jstack查看堆栈信息。内存泄漏的话就jmap -dump一个内存快照，然后加载到visualVM里面。\n标高的原因：死锁？死循环？频繁fullgc？一些复杂计算、\n\n查看机器的负载情况linux\n\nTop htop mpstat vmstat\n\nSpirngBean是线程安全的吗？\n\n默认单例（可以多例），但是不是线程安全。因为Bean内部的成员变量是共享可修改的。\n\nAOP是什么？\n\n*aop是面向切面编程， 把一些和业务无关的公共的代码抽出来自己弄成一个模块。然后在不改变原有的逻辑情况下动态的切入到类的指定方法、指定位置上，这个就是aop 底层是动态代理JDK和CGLIB\n有没有用过AOP\n有的，我之前在一个分库分表的组件项目里面用到过，就是分库分表要切换数据源，我就是用aop切面去计算出落到哪个库哪个表里面，切入点是一个注解。\n\nIOC\n\n控制反转的意思，以前我们创建的时候new，但是这种方法很麻烦，且很难处理对象直接的依赖关系。他是把对象创建和对象之间的调用过程，交给spring进行管理。\n\nSpring事务失效的场景?\n\n\n自己捕获异常。如果没有抛出会失效，解决方法：手动抛出异常\n\n抛出检查异常，因为spring默认只回滚非检查异常。解决方法就是transcantional加rollbackfor &#x3D; exception.class\n\n没有用public修饰，\n\n\n\nBean的生命周期？\n\n1 通过XML、注解和配置类等方式加载Spring Bean\n2、用BeanDefinitionReader把Bean解析成BeanDefinition结构，放到beanDefinitionMap，扫描这个\n4、从Bean定义里面拿BeanClass的构造函数，通过反射创建Bean，这里构造函数的选用，一般先选有autowire修饰和无参构造函数。\n5、依赖注入\n6、处理三个Aware接口，\t\n7、BeanPostProcessor：自定义的逻辑\n8、 调用初始化Bean（InitializingBean和init-method，Bean的初始化才算完成）\n9、BeanPostProcessor：自定义的逻辑 aop核心底层动态代理\n\nBeanBeanFactory和FactoryBean的区别！\n\nBeanFactory是管理Bean的容器，FactoryBean是一个生产Bean的工厂。\n\nBean的循环依赖？\n\nSpring解决这个是用三级缓存或者懒加载（构造函数的循环依赖问题），三次缓存中：一级缓存存放完整的bean，二级缓存存放半成品Bean、三级缓存放ObjectFactory。\n为什么三层？\n所以如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题，如果加上AOP，两级缓存是无法解决的。如果对象被AOP代理了，我每次从三级缓存中拿到singleFactory对象，执行getObject()方法会产生新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象\n\n\nSpring用到的设计模式\n单例模式：这个在创建Bean的时候用到，创建单例Bean的时候会先去缓存里面找，如果找不到，在触发createBean方法。\n工厂模式：就是BeanFactory接口了\n代理模式：就是aop。jdk和cglib\n模版模式：jdbcTemplate\n容器初始化流程\n1、prepareRefresh()刷新前的预处理：2、obtainFreshBeanFactory()：创建容器对象，实际就是获取一个DefaultListenableBeanFactory：3、prepareBeanFactory(beanFactory)：BeanFactory的预处理工作，向容器中添加一些组件：4、postProcessBeanFactory(beanFactory)：\n5、invokeBeanFactoryPostProcessors(beanFactory)：即BeanFactory的后置处理器：6、registerBeanPostProcessors(beanFactory)：向容器中注册Bean的后置处理器BeanPostProcessor，它的主要作用是干预Spring初始化bean的流程，从而完成代理、自动注入、循环依赖等功能\n7、initMessageSource()：初始化MessageSource组件，主要用于做国际化功能，消息绑定与消息解析：8、initApplicationEventMulticaster()：初始化事件派发器，在注册监听器时会用到：\n9、onRefresh()：留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑\n10、registerListeners()：注册监听器：将容器中所有的ApplicationListener注册到事件派发器中，并派发之前步骤产生的事件：11、finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；12、finishRefresh()：发布BeanFactory容器刷新完成事件：\n综上所述：\n\n其实我觉得Spring的IOC容器，主要做三步：\n1、初始化Spring容器，创建一个DefaultListableBeanFactory\n2、将配置类的BeanDefinition注册到容器。\n3、Refresh，Refresh又分12步。这12步，可以分成几块。\n第一块：预处理，包括刷新的预处理，然后获取我们刚刚创建的BeanFactory再做预处理。\n第二块：后置处理器，执行BeanFactory的后置处理器，然后在容器里面注册一个Bean的后置处理器。\n第三块：就是一些国际化，事件分派器的东西。\n第四块：非常重要了，finishBeanFactoryInitailization，初始化所有剩下的单实例bean，bean的生命周期也从这里开始。\n\nSpringboot启动流程\n\n主要分为4步：服务构建、环境准备、容器创建、填充容器。\n1、服务构建就是构造springapplication，包括主方法类、确认web服务器、加载spring.factories下的所有初始化类。\n2、然后调用run方法进入环境准备，通过配置类、和配置文件构造出一个environment，用于后面的容器创建。\n3、容器创建的话，其实就是创建一个BeanFactory，然后加载bean信息，通过beanDefinitionReader把bean信息读成BeanDefinition并且把他放到beanDefinitionMap里面\n4、填充容器。就是我们的refresh（）方法，一个12步，但是可以分成四块，预处理，后置处理器，国际化分派器，实例化剩下的所有bean。\n\nSpringboot自动配置？\nspringboot的main方法会有一个springbootapplication的注解，这个注解有三个注解组成、ComponentScan（扫描包和子包，加载符合条件的组件或bean定义）、SpringbootConfiguration（声明当前是配置类，然后去找被configuration修饰的类，读取信息）、还有一个最重要的EnableAutoConfiguraion，这个就是来启动自动化配置的。这个注解里面有一个Import注解，这个注解会加入一个配置选择类，他会去这个项目和项目引用的jar包的meta-inf的spring.factories找全类名，然后在这些配置类里面根据注解@comditionnalXXX 定义的条件进行选择加载\nMVC的执行流程\n请求发到前端控制器上，然后用处理器映射器找到具体的处理器，使用处理器适配器调用真正的处理器，然后结果转化成JSON响应。\n\n\n\nMybatis怎么传多个参数：\n\n顺序传参\nmap传参\n用mybatis的注解\n\nMyBatis中${} 和 #{} 有什么区别\n1、功能不同： #{} 是占位符，${} 是直接替换，；2、使用场景不同：普通参数使用 #{}，如果传递的是 SQL 命令或 SQL 关键字，需要使用 ${}，但在使用前一定要做好安全验证；3、安全性不同：使用 ${} 存在安全问题，而 #{} 则不存在安全问题。\nsetNX有什么缺陷？\n有单点风险\n可能会导致同一把锁被多人使用\nredlock\n","dateCreated":"2023-08-07T00:00:00+08:00","dateModified":"2024-01-07T08:50:59+08:00","datePublished":"2023-08-07T00:00:00+08:00","description":"","headline":"Java基础知识","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},"publisher":{"@type":"Organization","name":"CSEN","sameAs":["https://github.com/Caosen0819"],"image":"head.jpg","logo":{"@type":"ImageObject","url":"head.jpg"}},"url":"http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","keywords":"Java基础知识"}</script>
    <meta name="description" content="讲讲Java的代理代理分成静态代理和动态代理，静态代理需要自己实现对每一个方法对代理，那么如果新增一个方法，那就要手动修改目标对象代理对象的代码，非常繁琐。动态代理更加灵活，不需要你一个一个的对方法进行代理。 动态代理就是运行的时候生成class。这个DynamicProxy其实就是一个Proxy， 动态代理有两种方式一种是jdk方法，一种是cglib方法 我们先来讲jdk代理： JDK代理依赖于">
<meta property="og:type" content="blog">
<meta property="og:title" content="Java基础知识">
<meta property="og:url" content="http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="森">
<meta property="og:description" content="讲讲Java的代理代理分成静态代理和动态代理，静态代理需要自己实现对每一个方法对代理，那么如果新增一个方法，那就要手动修改目标对象代理对象的代码，非常繁琐。动态代理更加灵活，不需要你一个一个的对方法进行代理。 动态代理就是运行的时候生成class。这个DynamicProxy其实就是一个Proxy， 动态代理有两种方式一种是jdk方法，一种是cglib方法 我们先来讲jdk代理： JDK代理依赖于">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="http://example.com/images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231116121230926.png">
<meta property="og:image" content="http://example.com/images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231222001434059.png">
<meta property="og:image" content="http://example.com/images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231118193113289.png">
<meta property="article:published_time" content="2023-08-06T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-07T00:50:59.861Z">
<meta property="article:author" content="CSEN">
<meta property="article:tag" content="Java基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231116121230926.png">
    
    
        
    
    
        <meta property="og:image" content="http://example.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-w816scvuzwavitjylabixcb3ofuoklqul47j3rgwu1r0mxrxvbdehvp2jk5s.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            森
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Lesen Sie mehr über den Autor"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
                </a>
                <h4 class="sidebar-profile-name">CSEN</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="档案"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">档案</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/Caosen0819"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title=".github"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">.github</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Java基础知识
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-08-07T00:00:00+08:00">
	
		    07 Aug 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2 id="讲讲Java的代理"><a href="#讲讲Java的代理" class="headerlink" title="讲讲Java的代理"></a>讲讲Java的代理</h2><p>代理分成静态代理和动态代理，静态代理需要自己实现对每一个方法对代理，那么如果新增一个方法，那就要手动修改目标对象代理对象的代码，非常繁琐。动态代理更加灵活，不需要你一个一个的对方法进行代理。</p>
<p>动态代理就是运行的时候生成class。这个DynamicProxy其实就是一个Proxy，</p>
<p>动态代理有两种方式一种是jdk方法，一种是cglib方法</p>
<p><strong>我们先来讲jdk代理：</strong></p>
<p>JDK代理依赖于Proxy类和InvocationHandler接口，InvocationHandler接口他只有一个invoke方法，三个参数是代理类，被代理方法，方法参数组。代理方法和参数组其实我们可以利用反射得到，所以参数其实是可以变化的，那这样就成功的实现了动态的代理。</p>
<p>那我们怎么去调用这个方法呢？依赖于Proxy类和他的方法newproxyInstance，得到的代理类，调用方法其实会直接调用我们实现InvocationHandler接口的invoke方法</p>
<p><strong>下面来讲CGLIB代理</strong></p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。你可以通过 <code>Enhancer</code>类来动态获取被代理类，</strong></p>
<p>  CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，每次调用代理类的方法都会被方法<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8B%A6%E6%88%AA%E5%99%A8&spm=1001.2101.3001.7020">拦截器</a>拦截，在拦截器中才是调用目标类的该方法的逻辑。所以我们说，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<p><strong>二者区别</strong><br>总结一下两者的区别吧：</p>
<p>JDK 动态代理基于接口，CGLIB 动态代理基于类。因为 JDK 动态代理生成的代理类需要继承Proxy，所以，只能基于接口；CGLIB 动态代理是根据类创建此类的子类，所以，此类不能被 final 修饰<br>JDK 是自带的、CGLIB需要加载包</p>
<p>JDK是反射机制，CGLIB是使用ASM框架。</p>
<p><strong>为什么Java不能多继承？</strong></p>
<p>会出现方法冲突和变量冲突</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231116121230926.png" alt="image-20231116121230926"></p>
<h2 id="Arraylist底层原理"><a href="#Arraylist底层原理" class="headerlink" title="Arraylist底层原理"></a>Arraylist底层原理</h2><p>可以从底层数据结构，构造函数和关键方法理解。</p>
<blockquote>
<p><font color='red'><u><em><strong>Arraylist的底层数据结构是object[]数组，构造函数分有参无参，如果是无参就是空数组，如果是有参，就用你定义的那个初始大小。如果参数是容器，那就是把容器转成数组copy给object。关键方法就是add方法，需要保证容量够用才能添加元素，所以会在添加之前进行一个ensurecapacity的过程。他会先计算mincapacity的值，他会拿mincapacity去和现在的数组长度比较，如果大了说明要扩容，扩容的过程是先×1.5看看够不够，够的话就1.5，不够就用新的这个mincapacity。</strong></em></u></font>如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code></p>
<blockquote>
<p>了解比较简单</p>
<p><font color='blue'><u><em><strong>对于插入</strong></em></u></font>：如果不需要扩容，其实无论是头插指定位置插入都是O(n)，尾插是O(1)。如果需要扩容，就得再做一次扩容，O(n)，然后在插入，就是刚才讲的时间复杂度。</p>
<p><font color='blue'><u><em><strong>对于删除</strong></em></u></font>：头删和指定位置删除是O(n)，尾部删除是O(1)</p>
</blockquote>
</blockquote>
<h2 id="Linkedlist"><a href="#Linkedlist" class="headerlink" title="Linkedlist"></a>Linkedlist</h2><blockquote>
<p><font color='red'><u><em><strong>Linkedlist 是双向链表，因为是链表，所以没什么扩容的问题，基本的方法都是围绕前节点、后节点、节点值展开的。</strong></em></u></font></p>
<ul>
<li>头部插入&#x2F;删除： O(1)。</li>
<li>尾部插入&#x2F;删除： O(1)。</li>
<li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li>
</ul>
</blockquote>
<h2 id="如何实现数组和arraylist之间的转换"><a href="#如何实现数组和arraylist之间的转换" class="headerlink" title="如何实现数组和arraylist之间的转换"></a>如何实现数组和arraylist之间的转换</h2><p>List.toarray  (修改原先list，array不受影响)</p>
<p>Arrays.aslist （受影响）</p>
<blockquote>
<p><T>&lt;?&gt;</p>
<p><T>主要用于类或方法上，对这个类或者方法里面的泛型全是一样的。</p>
<?>一般用在变量上，有界通配符，对类型做一定的限制。

## 
</blockquote>
<h2 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h2><blockquote>
<p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</p>
<p><strong>插入和删除的时间复杂度</strong>：arraylist，头插、指定插、头删、指定删除都是On，尾插和尾删除是O1</p>
<p>lingklist 头插和尾插、头删除、尾删除都是O1，指定位置是On</p>
<p><strong>内存空间占用</strong>：linkedlist每个节点要存前后指针，所以内存占用大。</p>
<p>是否安全：两个都是不安全的，局部变量</p>
</blockquote>
<hr>
<h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul>
<li><font color='red'><u><em><strong><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</strong></em></u></font></li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<hr>
<h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><blockquote>
<p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
</blockquote>
<h2 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h2><blockquote>
<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能</p>
<p><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</p>
<p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
</blockquote>
<h3 id="什么是-BlockingQueue？"><a href="#什么是-BlockingQueue？" class="headerlink" title="什么是 BlockingQueue？"></a>什么是 BlockingQueue？</h3><blockquote>
<p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code>。<code>没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</code>线程安全。</p>
<p><font color='red'><u><em><strong>阻塞队列有哪些</strong></em></u></font></p>
<blockquote>
<p>ArrayBlockingqueue：底层是数组、有界队列。一把锁</p>
</blockquote>
<blockquote>
<p>LinkBlockingQueue：底层是链表、默认无界但是支持有界。头尾两把锁</p>
</blockquote>
<blockquote>
<p>DelayedWorkQueue</p>
</blockquote>
<blockquote>
<p>SynchronousQueue</p>
</blockquote>
</blockquote>
<h1 id="Hashmap："><a href="#Hashmap：" class="headerlink" title="Hashmap："></a>Hashmap：</h1><blockquote>
<h2 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h2><p>底层数据结构+构造函数+put方法回答</p>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong>。1.8之后是数组+链表+红黑树</p>
<p>构造函数是懒加载，没有初始化数据，就是把负载因子赋为0.75。</p>
<p>put的时候，先判断数组是否为空，如果为空，就初始化为16大小。通过 key 的 <code>hashcode</code> 经过扰动函数（右移16位再异或），然后通过 <code>  hash &amp; (n - 1)</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果定位到的数组位置没有元素 就直接插入。如果有数据，就判断key是不是相同，相同就覆盖，不相同就判断是不是红黑树，如果是就调用putTree，如果是链表就遍历链表，看看key有没有，有就覆盖，没有就在尾部插入新的节点，然后判断长度是否大于8，大于8就去尝试转红黑树，插入结束后，最后要判断一下是否需要扩容，</p>
</blockquote>
<blockquote>
<h2 id="hashmap扩容过程"><a href="#hashmap扩容过程" class="headerlink" title="hashmap扩容过程"></a>hashmap扩容过程</h2><p>扩容简单来说就是做了两件事。1：创建一个新数组，原来的两倍大。2：遍历旧数组每个槽<br>如果槽位中是一个普通节点，则将节点放在新数组中，所在新数组中的下标计算方式为：e.hash &amp; (newCap - 1);<br>如果槽位中是一个树节点，则进行红黑树的迁移操作，新数组中下标计算方式同普通节点；<br>如果槽位中是一个链表节点，则将链表拆为高位链表和低位链表，就是拿hash值和旧容量做与操作，等于0就放入放入新数组的旧数组的下标位置和，不等于0会放到（旧数组下标 + 旧数组容量）下标位置；<br>最后返回新数组。</p>
<h2 id="HashMap-多线程操作导致死循环问题（1-7会，1-8是在树操作）"><a href="#HashMap-多线程操作导致死循环问题（1-7会，1-8是在树操作）" class="headerlink" title="HashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）"></a>HashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）</h2><p><font color='red'><u><em><strong>扩容问题和头插法问题</strong></em></u></font></p>
<p>假设两个线程同时对hashmap进行扩容，这时候两个都指向首节点A，后面的节点分别是bcd。</p>
<p>那么这时候线程1正常执行，线程2卡住了。但是A执行完后因为是头插法所以abc变成了cba。线程2唤醒启动，线程2第一个e还是指向a，a的next指向b，这样子就出现了问题，但是还没出现环状。那我们继续执行。把e也就是a赋放到新链表，a &#x3D;</p>
<p>a的next其实就是b，b拿过来，然后b&#x3D;b的next，b的next是谁呢，就是a，然后a指向链表头，这个头节点就是b呀！这里就出问题了。</p>
<p>解决的方法：concurrenthashmap，推荐；hashtable安全，不建议；或者直接加锁，也不建议。或者头插法改成尾插法。</p>
<h2 id="HashMap-为什么线程不安全？"><a href="#HashMap-为什么线程不安全？" class="headerlink" title="HashMap 为什么线程不安全？"></a>HashMap 为什么线程不安全？</h2><p><font color='red'><u><em><strong>一方面就是多线程操作导致的死循环问题。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>另一方面就是两个线程 1,2 进行 put 操作，线程1 执行的时候通过判断发现没有出发hash碰撞，但是时间片用完了挂起，这时候线程2也判断有没有hash碰撞发现没有，因为线程1还没来得及插入。这时候线程2插入一个b值结束了，线程1重新获得时间片，因为之前已经成功判断过了，所以直接插入一个a值，那么这样b值就被a值覆盖了。</strong></em></u></font></p>
<h2 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h2><p>散列采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 **采用二进制位操作 &amp;，相对于%能够提高运算效率）</p>
<p><strong>loadFactor 负载因子</strong></p>
<p>loadFactor 负载因子是控制数组存放数据多少的参数和扩容的界限。默认0.75</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
<h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><ul>
<li><p><strong>线程是否安全：</strong><code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）</p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p>
</li>
<li><p><strong>底层数据结构：</strong> <strong>hashmap 数组+链表+红黑树，hashtable 数组+链表</strong></p>
</li>
</ul>
<h2 id="hashmap的key规范"><a href="#hashmap的key规范" class="headerlink" title="hashmap的key规范"></a>hashmap的key规范</h2><p>用自定义类作为key，必须<font color='red'><u><em><strong>重写equals()和hashCode()方法。</strong></em></u></font></p>
</blockquote>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><strong>ConcurrentHashMap</strong></h2><blockquote>
<p><code>ConcurrentHashMap</code>是线程安全的，而是通过原子操作和局部加锁的方法保证了多线程的线程安全。</p>
<p>1.8以前是用16个<code>Segment</code> 分段锁加的Reentranlock。1.8以后现在采用数组+链表+红黑树的形式。添加元素的时候按照代码的流程先判断是不是初始化、节点为空就cas添加，如果正在扩容，就帮助扩容；如果冲突就加synchronized后再插入。</p>
<p>Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p>
<p>具体的代码层面：</p>
</blockquote>
<h2 id="元素排序-Comparable-和-Comparator-有什么区别？"><a href="#元素排序-Comparable-和-Comparator-有什么区别？" class="headerlink" title="元素排序 Comparable 和 Comparator 有什么区别？"></a>元素排序 Comparable 和 Comparator 有什么区别？</h2><p>Comparable：实现 Comparable 接口并重写 compareTo 方法就可以实现某个类的排序了，它支持 Collections.sort 和 Arrays.sort 的排序。compareTo 方法接收的参数 p 是要对比的对象，排序规则是用当前对象和要对比的对象进行比较，然后返回一个 int 类型的值。正序从小到大的排序规则是：使用当前的对象值减去要对比对象的值；而倒序从大到小的排序规则刚好相反：是用对比对象的值减去当前对象的值。</p>
<p>Comparator 除了可以通过创建自定义比较器外，还可以通过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8C%BF%E5%90%8D%E7%B1%BB&spm=1001.2101.3001.7020">匿名类</a>的方式，更快速、便捷的完成自定义比较器的功能，具体的代码实现如下：</p>
<p><font color='red'><u><em><strong>Comparable 必须由自定义类内部实现排序方法，而 Comparator 是外部定义并实现排序的</strong></em></u></font></p>
<p><font color='green'><u><em><strong>Linux常用命令</strong></em></u></font>：cat, pwd, ls、TOP，mpstat，chattr，lsattr</p>
<p><font color='green'><u><em><strong>怎么排查项目故障</strong></em></u></font>：</p>
<blockquote>
<p>可以用top先看看是cpu还是内存的问题，cpu的话，可以拿到进程id，然后ps H -eo pid,tid,%cpu | grep进程id查看线程，最好jstack查看堆栈信息。内存泄漏的话就jmap -dump一个内存快照，然后加载到visualVM里面。</p>
<p>标高的原因：死锁？死循环？频繁fullgc？一些复杂计算、</p>
</blockquote>
<p><strong>查看机器的负载情况linux</strong></p>
<blockquote>
<p>Top htop mpstat vmstat</p>
</blockquote>
<h1 id="Spirng"><a href="#Spirng" class="headerlink" title="Spirng"></a>Spirng</h1><p><strong>Bean是线程安全的吗？</strong></p>
<blockquote>
<p>默认单例（可以多例），但是不是线程安全。因为Bean内部的成员变量是共享可修改的。</p>
</blockquote>
<p><font color='red'><u><em><strong>AOP是什么？</strong></em></u></font></p>
<blockquote>
<p><font color='red'><u>*<strong>aop是面向切面编程， 把一些和业务无关的公共的代码抽出来自己弄成一个模块。然后在不改变原有的逻辑情况下动态的切入到类的指定方法、指定位置上，这个就是aop 底层是动态代理JDK和CGLIB</strong></u></font></p>
<p><font color='green'><u><em><strong>有没有用过AOP</strong></em></u></font></p>
<p><font color='red'><u><em><strong>有的，我之前在一个分库分表的组件项目里面用到过，就是分库分表要切换数据源，我就是用aop切面去计算出落到哪个库哪个表里面，切入点是一个注解。</strong></em></u></font></p>
</blockquote>
<p><strong>IOC</strong></p>
<blockquote>
<p><font color='red'><u><em><strong>控制反转的意思，以前我们创建的时候new，但是这种方法很麻烦，且很难处理对象直接的依赖关系。他是把对象创建和对象之间的调用过程，交给spring进行管理。</strong></em></u></font></p>
</blockquote>
<p><strong>Spring事务失效的场景?</strong></p>
<blockquote>
<ul>
<li><p>自己捕获异常。如果没有抛出会失效，解决方法：手动抛出异常</p>
</li>
<li><p>抛出检查异常，因为spring默认只回滚非检查异常。解决方法就是transcantional加rollbackfor &#x3D; exception.class</p>
</li>
<li><p>没有用public修饰，</p>
</li>
</ul>
</blockquote>
<p><strong>Bean的生命周期？</strong></p>
<blockquote>
<p>1 通过<strong>XML</strong>、注解和配置类等方式加载<strong>Spring Bean</strong></p>
<p>2、用<strong>BeanDefinitionReader</strong>把Bean解析成BeanDefinition结构，放到beanDefinitionMap，扫描这个</p>
<p>4、从Bean定义里面拿BeanClass的构造函数，通过反射创建Bean，这里构造函数的选用，一般先选有autowire修饰和无参构造函数。</p>
<p>5、依赖注入</p>
<p>6、处理三个Aware接口，	</p>
<p>7、<em><strong>BeanPostProcessor：自定义的逻辑</strong></em></p>
<p>8、 调用初始化Bean（InitializingBean和init-method，Bean的初始化才算完成）</p>
<p>9、<em><strong>BeanPostProcessor：自定义的逻辑</strong></em> aop核心底层动态代理</p>
</blockquote>
<p><strong>BeanBeanFactory和FactoryBean的区别！</strong></p>
<blockquote>
<p>BeanFactory是管理Bean的容器，FactoryBean是一个生产Bean的工厂。</p>
</blockquote>
<p><font color='green'><u><em><strong>Bean的循环依赖？</strong></em></u></font></p>
<blockquote>
<p>Spring解决这个是用三级缓存或者懒加载（构造函数的循环依赖问题），三次缓存中：<font color='green'><u><em><strong>一级缓存存放完整的bean，二级缓存存放半成品Bean、三级缓存放ObjectFactory。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>为什么三层？</strong></em></u></font></p>
<p><strong>所以如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题，如果加上AOP，两级缓存是无法解决的。如果对象被AOP代理了，我每次从三级缓存中拿到singleFactory对象，执行getObject()方法会产生新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象</strong></p>
</blockquote>
<p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231222001434059.png" alt="image-20231222001434059"></p>
<p><strong>Spring用到的设计模式</strong></p>
<p>单例模式：这个在创建Bean的时候用到，创建单例Bean的时候会先去缓存里面找，如果找不到，在触发createBean方法。</p>
<p>工厂模式：就是BeanFactory接口了</p>
<p>代理模式：就是aop。jdk和cglib</p>
<p>模版模式：jdbcTemplate</p>
<p><strong>容器初始化流程</strong></p>
<p>1、prepareRefresh()刷新前的预处理：<br>2、obtainFreshBeanFactory()：创建容器对象，实际就是获取一个DefaultListenableBeanFactory：<br>3、prepareBeanFactory(beanFactory)：BeanFactory的预处理工作，向容器中添加一些组件：<br>4、postProcessBeanFactory(beanFactory)：</p>
<p>5、invokeBeanFactoryPostProcessors(beanFactory)：即BeanFactory的后置处理器：<br>6、registerBeanPostProcessors(beanFactory)：向容器中注册Bean的后置处理器BeanPostProcessor，它的主要作用是干预Spring初始化bean的流程，从而完成代理、自动注入、循环依赖等功能</p>
<p>7、initMessageSource()：初始化MessageSource组件，主要用于做国际化功能，消息绑定与消息解析：<br>8、initApplicationEventMulticaster()：初始化事件派发器，在注册监听器时会用到：</p>
<p>9、onRefresh()：留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑</p>
<p>10、registerListeners()：注册监听器：将容器中所有的ApplicationListener注册到事件派发器中，并派发之前步骤产生的事件：<br>11、finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；<br>12、finishRefresh()：发布BeanFactory容器刷新完成事件：</p>
<p>综上所述：</p>
<blockquote>
<p>其实我觉得Spring的IOC容器，主要做三步：</p>
<p>1、初始化Spring容器，创建一个DefaultListableBeanFactory</p>
<p>2、将配置类的BeanDefinition注册到容器。</p>
<p>3、Refresh，Refresh又分12步。这12步，可以分成几块。</p>
<p>第一块：预处理，包括刷新的预处理，然后获取我们刚刚创建的BeanFactory再做预处理。</p>
<p>第二块：后置处理器，执行BeanFactory的后置处理器，然后在容器里面注册一个Bean的后置处理器。</p>
<p>第三块：就是一些国际化，事件分派器的东西。</p>
<p>第四块：非常重要了，finishBeanFactoryInitailization，<strong>初始化所有剩下的单实例bean</strong>，bean的生命周期也从这里开始。</p>
</blockquote>
<p><font color='red'><u><em><strong>Springboot启动流程</strong></em></u></font></p>
<blockquote>
<p>主要分为4步：服务构建、环境准备、容器创建、填充容器。</p>
<p>1、服务构建就是构造springapplication，包括主方法类、确认web服务器、加载spring.factories下的所有初始化类。</p>
<p>2、然后调用run方法进入环境准备，通过配置类、和配置文件构造出一个environment，用于后面的容器创建。</p>
<p>3、容器创建的话，其实就是创建一个BeanFactory，然后加载bean信息，通过beanDefinitionReader把bean信息读成BeanDefinition并且把他放到beanDefinitionMap里面</p>
<p>4、填充容器。就是我们的refresh（）方法，一个12步，但是可以分成四块，预处理，后置处理器，国际化分派器，实例化剩下的所有bean。</p>
</blockquote>
<p><font color='red'><u><em><strong>Springboot自动配置？</strong></em></u></font></p>
<p>springboot的main方法会有一个springbootapplication的注解，这个注解有三个注解组成、ComponentScan（扫描包和子包，加载符合条件的组件或bean定义）、SpringbootConfiguration（声明当前是配置类，然后去找被configuration修饰的类，读取信息）、还有一个最重要的EnableAutoConfiguraion，这个就是来启动自动化配置的。这个注解里面有一个Import注解，这个注解会加入一个配置选择类，他会去这个项目和项目引用的jar包的meta-inf的spring.factories找全类名，然后在这些配置类里面根据注解@comditionnalXXX 定义的条件进行选择加载</p>
<p><strong>MVC的执行流程</strong></p>
<p>请求发到前端控制器上，然后用处理器映射器找到具体的处理器，使用处理器适配器调用真正的处理器，然后结果转化成JSON响应。</p>
<blockquote>
<p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231118193113289.png" alt="image-20231118193113289"></p>
</blockquote>
<p><strong>Mybatis怎么传多个参数：</strong></p>
<blockquote>
<p>顺序传参</p>
<p>map传参</p>
<p>用mybatis的注解</p>
</blockquote>
<p><strong>MyBatis中${} 和 #{} 有什么区别</strong></p>
<p>1、功能不同： #{} 是占位符，${} 是直接替换，；2、使用场景不同：普通参数使用 #{}，如果传递的是 SQL 命令或 SQL 关键字，需要使用 ${}，但在使用前一定要做好安全验证；3、安全性不同：使用 ${} 存在安全问题，而 #{} 则不存在安全问题。</p>
<p><strong>setNX有什么缺陷？</strong></p>
<p>有单点风险</p>
<p>可能会导致同一把锁被多人使用</p>
<p>redlock</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">GETAGGT IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">Java基础知识</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/10/09/Redis/"
                    data-tooltip="Redis"
                    aria-label="FRÜHER: Redis"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">FRÜHER</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/07/08/%E8%BE%93%E5%85%A5%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"
                    data-tooltip="输入网络，期间发生了什么？"
                    aria-label="NÄCHSTER: 输入网络，期间发生了什么？"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NÄCHSTER</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
                    title="Teilen auf Facebook"
                    aria-label="Teilen auf Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
                    title="Teilen auf Twitter"
                    aria-label="Teilen auf Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
                    title="Teilen auf Google Plus"
                    aria-label="Teilen auf Google Plus"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 CSEN. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/10/09/Redis/"
                    data-tooltip="Redis"
                    aria-label="FRÜHER: Redis"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">FRÜHER</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2023/07/08/%E8%BE%93%E5%85%A5%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"
                    data-tooltip="输入网络，期间发生了什么？"
                    aria-label="NÄCHSTER: 输入网络，期间发生了什么？"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NÄCHSTER</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
                    title="Teilen auf Facebook"
                    aria-label="Teilen auf Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
                    title="Teilen auf Twitter"
                    aria-label="Teilen auf Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
                    title="Teilen auf Google Plus"
                    aria-label="Teilen auf Google Plus"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
                        aria-label="Teilen auf Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Teilen auf Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
                        aria-label="Teilen auf Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Teilen auf Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=http://example.com/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
                        aria-label="Teilen auf Google Plus"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Teilen auf Google Plus</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
            <h4 id="about-card-name">CSEN</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                浙江温州
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-39paoi2hupf5wmw7ojejrxpco6edftjriz5ezbtp4grymrdceksftgan2adp.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
