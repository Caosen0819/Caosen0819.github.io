<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java基础知识 | 森</title>
  <meta name="keywords" content=" Java基础知识 ">
  <meta name="description" content="Java基础知识 | 森">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="潮起潮落，云卷云舒">
<meta property="og:type" content="website">
<meta property="og:title" content="all-tags">
<meta property="og:url" content="http://example.com/all-tags/index.html">
<meta property="og:site_name" content="森">
<meta property="og:description" content="潮起潮落，云卷云舒">
<meta property="og:locale" content="zh_CH">
<meta property="article:published_time" content="2023-04-12T03:28:50.336Z">
<meta property="article:modified_time" content="2023-04-12T03:28:48.541Z">
<meta property="article:author" content="CSEN">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/cs.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/cs.jpg"/>
</a>
<div class="author">
    <span>CSEN</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/Caosen0819"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="csdn"
               href="https://blog.csdn.net/weixin_45592424?type=blog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-csdn"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:caosen0819@163.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1667018430&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=406574616"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(46)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="去雾算法">
            
            去雾算法
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="微信小程序">
            
            微信小程序
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="项目实践">
            
            项目实践
            <small>(9)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="学习资料">
            
            学习资料
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Java">
            
            Java
            <small>(32)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="new">
            
            new
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="46">
<input type="hidden" id="yelog_site_word_count" value="131.1k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>暗通道</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>测试</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>场景题</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>计算机网络</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>微信小程序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>整合中间件</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>BUG</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>DBRouter-starter</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java并发</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java基础知识</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JVM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Kafka</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>lucky项目</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mybatis-starter</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Mysql</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>new</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Oauth2</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring勇攀高峰</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 Java "
           href="/2024/02/02/CS:MySQL45-1/"
           data-tag="Mysql"
           data-author="" >
            <span class="post-title" title="MySQL45">MySQL45</span>
            <span class="post-date" title="2024-02-02 21:29:04">2024/02/02</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/11/08/CS:JUC/"
           data-tag="Java并发"
           data-author="" >
            <span class="post-title" title="JUC">JUC</span>
            <span class="post-date" title="2023-11-08 00:00:00">2023/11/08</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/11/08/CS:mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"
           data-tag="Mysql"
           data-author="" >
            <span class="post-title" title="mysql技术内幕">mysql技术内幕</span>
            <span class="post-date" title="2023-11-08 00:00:00">2023/11/08</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/11/04/CS:JVM/"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM">JVM</span>
            <span class="post-date" title="2023-11-04 00:00:00">2023/11/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/10/10/CS:%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <span class="post-date" title="2023-10-10 00:00:00">2023/10/10</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/10/09/CS:Redis/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis">Redis</span>
            <span class="post-date" title="2023-10-09 00:00:00">2023/10/09</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/08/07/CS:Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
           data-tag="Java基础知识"
           data-author="" >
            <span class="post-title" title="Java基础知识">Java基础知识</span>
            <span class="post-date" title="2023-08-07 00:00:00">2023/08/07</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/"
           data-tag="计算机网络"
           data-author="" >
            <span class="post-title" title="计算机网络3">计算机网络3</span>
            <span class="post-date" title="2023-07-08 00:00:00">2023/07/08</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/"
           data-tag="计算机网络"
           data-author="" >
            <span class="post-title" title="计算机网络2">计算机网络2</span>
            <span class="post-date" title="2023-07-08 00:00:00">2023/07/08</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"
           data-tag="计算机网络"
           data-author="" >
            <span class="post-title" title="计算机网络1">计算机网络1</span>
            <span class="post-date" title="2023-07-08 00:00:00">2023/07/08</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/07/08/CS:%E8%BE%93%E5%85%A5%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"
           data-tag="计算机网络"
           data-author="" >
            <span class="post-title" title="输入网络，期间发生了什么？">输入网络，期间发生了什么？</span>
            <span class="post-date" title="2023-07-08 00:00:00">2023/07/08</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/07/08/CS:Kafka/"
           data-tag="Kafka"
           data-author="" >
            <span class="post-title" title="Kafka知识">Kafka知识</span>
            <span class="post-date" title="2023-07-08 00:00:00">2023/07/08</span>
        </a>
        
        
        <a  class="全部文章 项目实践 "
           href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A32/"
           data-tag="mybatis-starter"
           data-author="" >
            <span class="post-title" title="mybatis组件的整合理解2">mybatis组件的整合理解2</span>
            <span class="post-date" title="2023-04-27 00:00:00">2023/04/27</span>
        </a>
        
        
        <a  class="全部文章 项目实践 "
           href="/2023/04/27/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A33/"
           data-tag="mybatis-starter"
           data-author="" >
            <span class="post-title" title="mybatis组件的整合理解3">mybatis组件的整合理解3</span>
            <span class="post-date" title="2023-04-27 00:00:00">2023/04/27</span>
        </a>
        
        
        <a  class="全部文章 项目实践 "
           href="/2023/04/26/mybatis%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/"
           data-tag="mybatis-starter"
           data-author="" >
            <span class="post-title" title="mybatis组件的整合理解1">mybatis组件的整合理解1</span>
            <span class="post-date" title="2023-04-26 00:00:00">2023/04/26</span>
        </a>
        
        
        <a  class="全部文章 项目实践 "
           href="/2023/04/22/CS:DBRouter%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E5%90%88%E7%90%86%E8%A7%A31/"
           data-tag="DBRouter-starter"
           data-author="" >
            <span class="post-title" title="DBRouter组件的整合理解">DBRouter组件的整合理解</span>
            <span class="post-date" title="2023-04-22 00:00:00">2023/04/22</span>
        </a>
        
        
        <a  class="全部文章 项目实践 "
           href="/2023/04/11/spring%E6%95%B4%E5%90%88mybatis/"
           data-tag="mybatis-starter"
           data-author="" >
            <span class="post-title" title="Spring整合mybatis">Spring整合mybatis</span>
            <span class="post-date" title="2023-04-11 00:00:00">2023/04/11</span>
        </a>
        
        
        <a  class="全部文章 学习资料 "
           href="/2023/04/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"
           data-tag="测试"
           data-author="" >
            <span class="post-title" title="参考资料">参考资料</span>
            <span class="post-date" title="2023-04-11 00:00:00">2023/04/11</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/04/11/spring%20ioc%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"
           data-tag="spring勇攀高峰"
           data-author="" >
            <span class="post-title" title="Spring ioc加载流程">Spring ioc加载流程</span>
            <span class="post-date" title="2023-04-11 00:00:00">2023/04/11</span>
        </a>
        
        
        <a  class="全部文章 项目实践 "
           href="/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A10/"
           data-tag="lucky项目"
           data-author="" >
            <span class="post-title" title="章节：10">章节：10</span>
            <span class="post-date" title="2023-04-04 00:00:00">2023/04/04</span>
        </a>
        
        
        <a  class="全部文章 项目实践 "
           href="/2023/04/04/%E7%AB%A0%E8%8A%82%EF%BC%9A7-10%EF%BC%8C%E5%90%8C%E6%97%B6%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8B4-6%E7%9A%84%E5%86%85%E5%AE%B9/"
           data-tag="lucky项目"
           data-author="" >
            <span class="post-title" title="章节：7-10，同时回顾一下4-6的内容">章节：7-10，同时回顾一下4-6的内容</span>
            <span class="post-date" title="2023-04-04 00:00:00">2023/04/04</span>
        </a>
        
        
        <a  class="全部文章 new "
           href="/2023/04/04/New%20page/"
           data-tag="new"
           data-author="" >
            <span class="post-title" title="待定">待定</span>
            <span class="post-date" title="2023-04-04 00:00:00">2023/04/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2023/04/04/CS:%E5%9C%BA%E6%99%AF%E9%A2%98/"
           data-tag="场景题"
           data-author="" >
            <span class="post-title" title="待定">待定</span>
            <span class="post-date" title="2023-04-04 00:00:00">2023/04/04</span>
        </a>
        
        
        <a  class="全部文章 项目实践 "
           href="/2023/04/03/%E7%AB%A0%E8%8A%82%EF%BC%9A11-13/"
           data-tag="lucky项目"
           data-author="" >
            <span class="post-title" title="章节：11-13">章节：11-13</span>
            <span class="post-date" title="2023-04-03 00:00:00">2023/04/03</span>
        </a>
        
        
        <a  class="全部文章 项目实践 "
           href="/2023/04/03/%E7%AB%A0%E8%8A%82%EF%BC%9A%E5%B0%8F%E7%9F%A5%E8%AF%86/"
           data-tag="lucky项目"
           data-author="" >
            <span class="post-title" title="章节：小知识">章节：小知识</span>
            <span class="post-date" title="2023-04-03 00:00:00">2023/04/03</span>
        </a>
        
        
        <a  class="全部文章 去雾算法 "
           href="/2022/10/23/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"
           data-tag="暗通道"
           data-author="" >
            <span class="post-title" title="暗通道去雾算法总结">暗通道去雾算法总结</span>
            <span class="post-date" title="2022-10-23 13:03:43">2022/10/23</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/20/%E5%AF%B9%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%96%B0%E7%90%86%E8%A7%A3/"
           data-tag="Oauth2"
           data-author="" >
            <span class="post-title" title="对权限校验和token的新理解">对权限校验和token的新理解</span>
            <span class="post-date" title="2022-10-20 14:43:00">2022/10/20</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/spring%E6%95%B4%E5%90%88docker-compose/"
           data-tag="docker,整合中间件"
           data-author="" >
            <span class="post-title" title="springboot/cloud整合docker-compose">springboot/cloud整合docker-compose</span>
            <span class="post-date" title="2022-10-04 21:25:08">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/docker%E6%95%B4%E5%90%88springboot:cloud%E2%80%94%E2%80%94nacos2.1.0/"
           data-tag="docker,整合中间件"
           data-author="" >
            <span class="post-title" title="docker整合springboot/cloud——nacos2.1.0">docker整合springboot/cloud——nacos2.1.0</span>
            <span class="post-date" title="2022-10-04 21:25:08">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/docker%E6%95%B4%E5%90%88springboot:cloud%E2%80%94%E2%80%94kibana8.2.0/"
           data-tag="docker,整合中间件"
           data-author="" >
            <span class="post-title" title="docker整合springboot/cloud——kibana8.2.0">docker整合springboot/cloud——kibana8.2.0</span>
            <span class="post-date" title="2022-10-04 21:25:08">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/springboot%E6%95%B4%E5%90%88kafka3.1%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/"
           data-tag="docker,整合中间件"
           data-author="" >
            <span class="post-title" title="springboot整合kafka3.1，实现基本配置和操作">springboot整合kafka3.1，实现基本配置和操作</span>
            <span class="post-date" title="2022-10-04 21:25:08">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/%E6%95%B4%E5%90%88docker%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%B0%E5%BD%95/"
           data-tag="整合中间件"
           data-author="" >
            <span class="post-title" title="整合docker和中间件记录">整合docker和中间件记录</span>
            <span class="post-date" title="2022-10-04 21:23:41">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/%E6%95%B4%E5%90%88elasticsearch8-2-0/"
           data-tag="整合中间件"
           data-author="" >
            <span class="post-title" title="springboot整合elasticsearch8.2.0">springboot整合elasticsearch8.2.0</span>
            <span class="post-date" title="2022-10-04 13:40:04">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/%E6%95%B4%E5%90%88kafka3-1-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C/"
           data-tag="整合中间件"
           data-author="" >
            <span class="post-title" title="springboot整合kafka3.1-基本配置和操作">springboot整合kafka3.1-基本配置和操作</span>
            <span class="post-date" title="2022-10-04 13:38:01">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/%E6%95%B4%E5%90%88OAuth2%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/"
           data-tag="Oauth2,整合中间件"
           data-author="" >
            <span class="post-title" title="springboot整合OAuth2认证服务">springboot整合OAuth2认证服务</span>
            <span class="post-date" title="2022-10-04 13:35:52">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/springboot%E6%95%B4%E5%90%88elasticsearch8.2%E6%8A%A5%E9%94%99unable%20to%20parse%20response%20body%20for%20Response%7BrequestLine/"
           data-tag="整合中间件,BUG"
           data-author="" >
            <span class="post-title" title="springboot整合elasticsearch8.2报错unable to parse response body for Response{requestLine">springboot整合elasticsearch8.2报错unable to parse response body for Response{requestLine</span>
            <span class="post-date" title="2022-10-04 13:35:52">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/springcloud%E6%95%B4%E5%90%88oauth2-----%E4%BB%A4%E7%89%8C%E9%85%8D%E7%BD%AE/"
           data-tag="Oauth2,整合中间件"
           data-author="" >
            <span class="post-title" title="springcloud整合oauth2-----令牌配置">springcloud整合oauth2-----令牌配置</span>
            <span class="post-date" title="2022-10-04 13:35:52">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/springcloud%E6%95%B4%E5%90%88oauth2-----%E9%89%B4%E6%9D%83%E6%9C%8D%E5%8A%A1%E7%AF%87/"
           data-tag="Oauth2,整合中间件"
           data-author="" >
            <span class="post-title" title="springcloud整合oauth2-----鉴权服务篇">springcloud整合oauth2-----鉴权服务篇</span>
            <span class="post-date" title="2022-10-04 13:35:52">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/springcloud%E6%95%B4%E5%90%88oauth2-----%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86springsecurity/"
           data-tag="Oauth2,整合中间件"
           data-author="" >
            <span class="post-title" title="springcloud整合oauth2-----前置知识springsecurity">springcloud整合oauth2-----前置知识springsecurity</span>
            <span class="post-date" title="2022-10-04 13:35:52">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/springcloud%E6%95%B4%E5%90%88oauth2-----%E5%BC%82%E5%B8%B8%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"
           data-tag="Oauth2,整合中间件"
           data-author="" >
            <span class="post-title" title="springcloud整合oauth2-----异常配置总结">springcloud整合oauth2-----异常配置总结</span>
            <span class="post-date" title="2022-10-04 13:35:52">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 微信小程序 "
           href="/2022/10/04/%E5%85%BB%E7%94%9F%E6%89%93%E5%8D%A1%E5%81%A5%E5%BA%B7%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%89/"
           data-tag="微信小程序"
           data-author="" >
            <span class="post-title" title="养生打卡健康小程序（云开发）">养生打卡健康小程序（云开发）</span>
            <span class="post-date" title="2022-10-04 13:35:52">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 微信小程序 "
           href="/2022/10/04/%E6%97%A5%E5%B8%B8%E6%89%93%E5%8D%A1%E7%A7%AF%E5%88%86%E5%88%B6%E8%87%AA%E5%BE%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%89/"
           data-tag="微信小程序"
           data-author="" >
            <span class="post-title" title="日常打卡积分制自律小程序（云开发）">日常打卡积分制自律小程序（云开发）</span>
            <span class="post-date" title="2022-10-04 13:35:52">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/%E6%95%B4%E5%90%88OAuth2%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1_%E5%89%AF%E6%9C%AC/"
           data-tag="Oauth2,整合中间件"
           data-author="" >
            <span class="post-title" title="springboot整合OAuth2认证服务">springboot整合OAuth2认证服务</span>
            <span class="post-date" title="2022-10-04 13:35:52">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87/"
           data-tag="Oauth2,整合中间件"
           data-author="" >
            <span class="post-title" title="springcloud整合oauth2------认证服务篇">springcloud整合oauth2------认证服务篇</span>
            <span class="post-date" title="2022-10-04 13:35:52">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/springcloud%E6%95%B4%E5%90%88oauth2------%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AF%87_%E5%89%AF%E6%9C%AC/"
           data-tag="Oauth2,整合中间件"
           data-author="" >
            <span class="post-title" title="springcloud整合oauth2------认证服务篇">springcloud整合oauth2------认证服务篇</span>
            <span class="post-date" title="2022-10-04 13:35:52">2022/10/04</span>
        </a>
        
        
        <a  class="全部文章 Java "
           href="/2022/10/04/docker%E6%95%B4%E5%90%88springboot:cloud%E2%80%94mysql8.0.26/"
           data-tag="整合中间件"
           data-author="" >
            <span class="post-title" title="docker整合springboot/cloud—mysql8.0.26">docker整合springboot/cloud—mysql8.0.26</span>
            <span class="post-date" title="2022-10-04 00:00:00">2022/10/04</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-CS:Java基础知识" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java基础知识</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Java">Java</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color4">Java基础知识</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-05-10 00:53:58'>2023-08-07 00:00</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:10.4k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2Java%E7%9A%84%E4%BB%A3%E7%90%86"><span class="toc-text">讲讲Java的代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Arraylist%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">Arraylist底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linkedlist"><span class="toc-text">Linkedlist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList-%E4%B8%8E-LinkedList%E5%8C%BA%E5%88%AB"><span class="toc-text">ArrayList 与 LinkedList区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayDeque-%E4%B8%8E-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">ArrayDeque 与 LinkedList 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E5%92%8Chashset"><span class="toc-text">hashmap和hashset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue-%E4%B8%8E-Deque-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Queue 与 Deque 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">HashMap 的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B"><span class="toc-text">hashmap扩容过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%881-7%E4%BC%9A%EF%BC%8C1-8%E6%98%AF%E5%9C%A8%E6%A0%91%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-text">HashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">HashMap 为什么线程不安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9"><span class="toc-text">HashMap 的长度为什么是 2 的幂次方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E7%9A%84key%E8%A7%84%E8%8C%83"><span class="toc-text">hashmap的key规范</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8"><span class="toc-text">线程安全容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81ConcurrentHashMap"><span class="toc-text">1、ConcurrentHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81CopyOnWriteArrayList%EF%BC%88%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%EF%BC%89"><span class="toc-text">2、CopyOnWriteArrayList（读多写少）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81BlockingQueue"><span class="toc-text">3、BlockingQueue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81CompletableFuture"><span class="toc-text">3、CompletableFuture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F-Comparable-%E5%92%8C-Comparator-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">元素排序 Comparable 和 Comparator 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spirng"><span class="toc-text">Spirng</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyBatis"><span class="toc-text">MyBatis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GIT"><span class="toc-text">GIT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>反射</strong></p>
<blockquote>
<p><font color='red'><u>*** Java的反射机制是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法。***</u></font></p>
<p> 获得Class对象的三种方式：</p>
<p><font color='green'><strong>(1)使用Class.forName方法(“类的全路径名”)；</strong></font></p>
<p><font color='green'><strong>(2)使用需要反射的类名调用class方法；</strong></font></p>
<p><font color='green'><strong>(3)使用需要反射的类的对象调用getClass方法</strong></font></p>
<p>缺点：</p>
<p><font color='green'><strong>耗时</strong></font></p>
</blockquote>
<p><font color='red'><u><em><strong>Error和Exception</strong></em></u></font></p>
<blockquote>
<p><font color='green'>*<strong>Throwable为基类，Error和Exception继承Throwable。Error是程序员解决不了比如OOM，SOF。Exception分为未检查异常和检查异常。检查异常：编译的时候就出问题非检查：运行的时候出问题，非检查异常像是空指针，类型转换都是。检查异常比如文件没找到异常</strong></font></p>
</blockquote>
<blockquote>
<p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240214002243390.png" alt="image-20240214002243390"></p>
</blockquote>
<p><strong>BIO NIO AIO</strong></p>
<blockquote>
<p>首先我们知道用户缓冲区去内核缓冲区读数据的时候，有两个耗时的过程，一个是等待从网卡来的数据，一个是内核拷贝到用户缓冲区。bio在网卡到内核缓冲区和内核缓冲区到用户缓冲区都是阻塞的。阻塞io和非阻塞io都是先调用revfrom，阻塞io两个都要等、非阻塞需要等待拷贝这个过程。但是io多路复用，先监听一个socket集合，然后某个socket数据就绪了，发了个可读的通知，这时候才调用revfrom去读。</p>
<p><font color='green'><strong>BIO :同步并阻塞,一个线程处理一个请求，一个请求过来我就为他创建一个线程。</strong></font></p>
<p><font color='green'><strong>NIO :同步非阻塞,一个线程处理多个请求。Channel(通道，构件连接) ，Buffer( 缓冲区，存取数据), Selector( 选择器，用来监听多个channel的，select，poll链表，epoll红黑树)，他的非阻塞是指数据从网卡通过DMA到内核缓冲区这一块他是不阻塞的，但是如果你到了内核缓冲区了，那其实从内核缓冲区到用户缓冲区还是有阻塞的</strong></font></p>
<p><font color='green'><strong>AIO(NIO.2) :异步非阻塞，服务器实现模式为一 个有效请求一个线程，关键就是异步，不回去等待，你空闲的时候做自己的事情就好，等socket就绪了，你再来读就可以。</strong></font></p>
<p>selectIO多路复用：这个就是一个线程处理多个socket请求。</p>
</blockquote>
<p><strong>String StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？</strong></p>
<blockquote>
<p><font color='green'><strong>String是字符串常量，因为定义的char数组是final的。而StringBuffer和StringBuilder是字符串变量。由String创建的字符内容是不可改变的，而由StringBuffer和StringBuidler创建的字符内容是可以改变的。</strong></font></p>
<p><font color='green'><strong>StringBuffer是线程安全的，而StringBuilder是非线程安全的</strong></font></p>
</blockquote>
<p><strong>equals与&#x3D;&#x3D;的区别</strong></p>
<blockquote>
<p>&#x3D;&#x3D; 基本类型比较值，引用类型比地址。</p>
<p>equals是object的方法，在object类里面其实用的还是&#x3D;&#x3D;，如果对象类重写了equals，那就走重写的规则。</p>
</blockquote>
<p><strong>深拷贝和浅拷贝</strong></p>
<blockquote>
<p><font color='green'><strong>如果变量本身就是基本数据类型，其实没有浅拷贝和深拷贝的问题，都是如果变量是引用类型，就得分一下浅拷贝和深拷贝了</strong></font></p>
<p><font color='green'><strong>浅拷贝：基本类型的成员变量拷贝值，引用类型成员变量拷贝引用地址</strong></font></p>
<p><font color='green'><strong>深拷贝：基本类型的成员变量拷贝值，引用类型是创建新的对象保存成员变量</strong></font></p>
<p><font color='red'><u><em><strong>通过实现clone方法实现浅拷贝和深拷贝</strong></em></u></font></p>
</blockquote>
<p><strong>字符型常量和字符串常量的区别</strong></p>
<blockquote>
<p>1.形式上: <font color='green'><strong>单引号，双引号</strong></font><br>2.含义上:<font color='green'><strong>字符常量相当于一个整形值( ASCII 值)</strong></font>,可以参加表达式运算；<font color='green'><strong>字符串常量代表一个地址值</strong></font>(该字符串在内存中存放位置，相当于对象)</p>
<p>3.占内存大小：<font color='green'><strong>字符常量只占2个字节；字符串常量占若干个字节2N</strong></font></p>
</blockquote>
<p><strong>自动装箱和自动拆箱</strong></p>
<blockquote>
<p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p>
</blockquote>
<p><strong>请说出作用域public，private，protected，以及不写时的区别。</strong></p>
<blockquote>
<p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240213231737281.png" alt="image-20240213231737281"></p>
</blockquote>
<p><font color='red'><u><em><strong>创建几个对象？</strong></em></u></font></p>
<blockquote>
<p>1、String a&#x3D;”123”;</p>
<p><em>创建了1个对象</em></p>
<p>jvm在编译阶段会判断常量池中是否有 “123” 这个常量对象如果有，a直接指向这个常量的引用，如果没有会在常量池里创建这个常量对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、<span class="title class_">String</span> a=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><em>创建了2个对象</em></p>
<p>同情况1，jvm编译阶段判断常量池中 “123”存在与否，进而来判断是否创建常量对象，然后运行阶段通过new关键字在java heap创建String对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>、<span class="title class_">String</span> a=<span class="string">&quot;123&quot;</span>+<span class="string">&quot;456&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><font color='green'><em><strong>创建了1个对象</strong></em></font></p>
<p>jvm编译阶段过编译器优化后会把字符串常量直接合并成”123456”，所有创建对象时最多会在常量池中创建1个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">4</span>、<span class="title class_">String</span> a=<span class="string">&quot;123&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;456&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><em>创建了4个对象</em></p>
</blockquote>
<h2 id="讲讲Java的代理"><a href="#讲讲Java的代理" class="headerlink" title="讲讲Java的代理"></a>讲讲Java的代理</h2><blockquote>
<p>代理分成静态代理和动态代理，静态代理需要自己实现对每一个方法对代理，那么如果新增一个方法，那就要手动修改目标对象代理对象的代码，非常繁琐。动态代理更加灵活，不需要你一个一个的对方法进行代理。</p>
<p>动态代理就是运行的时候生成class。这个DynamicProxy其实就是一个Proxy，</p>
<p>动态代理有两种方式一种是jdk方法，一种是cglib方法</p>
<p><strong>我们先来讲jdk代理：</strong></p>
<blockquote>
<p><font color='blue'><u><em><strong>JDK代理依赖于Proxy类和InvocationHandler接口，InvocationHandler接口他只有一个invoke方法，三个参数是代理类，被代理方法，方法参数组。代理方法和参数组其实我们可以利用反射得到，所以参数其实是可以变化的，那这样就成功的实现了动态的代理。</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>那我们怎么去调用这个方法呢？依赖于Proxy类和他的方法newproxyInstance，得到的代理类，调用方法其实会直接调用我们实现InvocationHandler接口的invoke方法</strong></em></u></font></p>
</blockquote>
<p><strong>下面来讲CGLIB代理</strong></p>
<blockquote>
<blockquote>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。你可以通过 <code>Enhancer</code>类来动态获取被代理类，</strong></p>
<p>  CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，每次调用代理类的方法都会被方法<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8B%A6%E6%88%AA%E5%99%A8&spm=1001.2101.3001.7020">拦截器</a>拦截，在拦截器中才是调用目标类的该方法的逻辑。所以我们说，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
</blockquote>
<p><strong>二者区别</strong><br>总结一下两者的区别吧：</p>
<p><font color='blue'><u><em><strong>JDK 动态代理基于接口，CGLIB 动态代理基于类。</strong></em></u></font><font color='green'><strong>因为 JDK 动态代理生成的代理类需要继承Proxy，所以，只能基于接口；CGLIB 动态代理是根据类创建此类的子类，所以，此类不能被 final 修饰</strong></font><br><font color='blue'><u><em><strong>JDK 是自带的、CGLIB需要加载包</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>JDK是反射机制，CGLIB是使用ASM框架。</strong></em></u></font></p>
</blockquote>
</blockquote>
<p><strong>为什么Java不能多继承？</strong></p>
<blockquote>
<p>会出现方法冲突和变量冲突</p>
</blockquote>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231116121230926.png" alt="image-20231116121230926"></p>
<h2 id="Arraylist底层原理"><a href="#Arraylist底层原理" class="headerlink" title="Arraylist底层原理"></a>Arraylist底层原理</h2><p>可以从底层数据结构，构造函数和关键方法理解。</p>
<blockquote>
<p><font color='red'><u><em><strong>Arraylist的底层数据结构是object[]数组，构造函数分有参无参，如果是无参就是空数组，如果是有参，就用你定义的那个初始大小。如果参数是容器，那就是把容器转成数组copy给object。关键方法就是add方法，需要保证容量够用才能添加元素，所以会在添加之前进行一个ensurecapacity的过程。他会先计算mincapacity的值，他会拿mincapacity去和现在的数组长度比较，如果大了说明要扩容，扩容的过程是先×1.5看看够不够，够的话就1.5，不够就用新的这个mincapacity。</strong></em></u></font>如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code></p>
<blockquote>
<p><font color='blue'><u><em><strong>对于插入</strong></em></u></font>：如果不需要扩容，<font color='green'><strong>头插和指定位置插入都是O(n)，尾插是O(1)</strong></font>。如果需要扩容，就得再做一次扩容，O(n)，然后在插入，就是刚才讲的时间复杂度。</p>
<p><font color='blue'><u><em><strong>对于删除</strong></em></u></font>：头删和指定位置删除是O(n)，尾部删除是O(1)</p>
</blockquote>
</blockquote>
<h2 id="Linkedlist"><a href="#Linkedlist" class="headerlink" title="Linkedlist"></a>Linkedlist</h2><blockquote>
<p><font color='red'><u><em><strong>Linkedlist 是双向链表，因为是链表，所以没什么扩容的问题，基本的方法都是围绕前节点、后节点、节点值展开的。</strong></em></u></font></p>
<ul>
<li>头部插入&#x2F;删除： O(1)。</li>
<li>尾部插入&#x2F;删除： O(1)。</li>
<li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li>
</ul>
</blockquote>
<h2 id="ArrayList-与-LinkedList区别"><a href="#ArrayList-与-LinkedList区别" class="headerlink" title="ArrayList 与 LinkedList区别?"></a>ArrayList 与 LinkedList区别?</h2><blockquote>
<p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构，内存一个是连续一个不是连续</p>
<p><strong>插入和删除的时间复杂度</strong>：arraylist，头插、指定插、头删、指定删除都是On，尾插和尾删除是O1。linkedlist 头插和尾插、头删除、尾删除都是O1，指定位置是On</p>
<p><strong>内存空间占用</strong>：<font color='blue'><u><em><strong>linkedlist每个节点要存前后指针，所以内存占用大。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>使用场景：</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>如果需要频繁进行随机访问和查询操作的场景，例如按索引读取数据或搜索特定元素，应该选择ArrayList。</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>如果需要频繁进行插入、删除或位置变动较多的场景，特别是在链表的首尾位置进行操作，那么LinkedList是更合适的选择。</strong></em></u></font></p>
<h2 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h2><blockquote>
<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能</p>
<p><code>ArrayDeque</code> 是<font color='green'><strong>基于可变长的数组和双指针来实现</strong></font>，而 <code>LinkedList</code> 则通过链表来实现。</p>
<p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
</blockquote>
<p><font color='red'><u><em><strong>LinkedList和ArrayList存储了一定数据，循环查询了上亿次</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>array底层是数组，读取的时候会将相邻的数据读进来，而linked是分散，要找到才读，而且array是随机读，link是遍历到该位置，所以array快。</strong></font></p>
</blockquote>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p><font color='blue'><u><em><strong>如何实现数组和arraylist之间的转换</strong></em></u></font></p>
<p>List.toarray  (修改原先list，array不受影响)</p>
<p>Arrays.aslist （受影响）</p>
<blockquote>
<p><T>&lt;?&gt;</p>
<p><T>主要用于类或方法上，对这个类或者方法里面的泛型全是一样的。</p>
<?>一般用在变量上，有界通配符，对类型做一定的限制。
</blockquote>
<h2 id="hashmap和hashset"><a href="#hashmap和hashset" class="headerlink" title="hashmap和hashset"></a><font color='red'><u><em><strong>hashmap和hashset</strong></em></u></font></h2><blockquote>
<p>hashset还是比较适合去重和集合运算</p>
<p>hashmap比较适合键值对这类数据</p>
</blockquote>
<h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul>
<li><font color='red'><u><em><strong><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</strong></em></u></font></li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><blockquote>
<p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
</blockquote>
</blockquote>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>hashmap最关键的是他的<font color='blue'><u><em><strong>底层数据结构、put 扩容 和 线程安全方面的知识。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>为什么用红黑树</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>普通二叉树会形成链表；</strong></font></p>
<p><font color='green'><strong>平衡二叉树插入的时候会左旋右旋保持绝对平衡</strong></font></p>
<p><font color='green'><strong>红黑树，插入最多两次旋转，删除最多三次</strong></font></p>
</blockquote>
<blockquote>
<h2 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h2><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong>。1.8之后是数组+链表+红黑树</p>
<p>构造函数是懒加载，没有初始化数据，就是把负载因子赋为0.75。</p>
<p><font color='green'><strong>put的时候，先判断数组是否为空，如果为空，就初始化为16大小。通过 key 的 <code>hashcode</code> 经过扰动函数（右移16位再异或），然后通过 <code>  hash &amp; (n - 1)</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果定位到的数组位置没有元素 就直接插入。如果有数据，就判断key是不是相同，相同就覆盖，不相同就判断是不是红黑树，如果是就调用putTree，如果是链表就遍历链表，看看key有没有，有就覆盖，没有就在尾部插入新的节点，然后判断长度是否大于8，大于8就去尝试转红黑树，插入结束后，最后要判断一下是否需要扩容。</strong></font></p>
</blockquote>
<blockquote>
<h2 id="hashmap扩容过程"><a href="#hashmap扩容过程" class="headerlink" title="hashmap扩容过程"></a>hashmap扩容过程</h2><p>扩容简单来说就是做了两件事。1：创建一个新数组，原来的两倍大。2：遍历旧数组每个槽<br>如果槽位中是一个普通节点，则将节点放在新数组中，所在新数组中的下标计算方式为：e.hash &amp; (newCap - 1);<br>如果槽位中是一个树节点，则进行红黑树的迁移操作，新数组中下标计算方式同普通节点；<br>如果槽位中是一个链表节点，则将链表拆为高位链表和低位链表，就是拿hash值和旧容量做与操作，等于0就放入放入新数组的旧数组的下标位置和，不等于0会放到（旧数组下标 + 旧数组容量）下标位置；<br>最后返回新数组。</p>
<h2 id="HashMap-多线程操作导致死循环问题（1-7会，1-8是在树操作）"><a href="#HashMap-多线程操作导致死循环问题（1-7会，1-8是在树操作）" class="headerlink" title="HashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）"></a>HashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）</h2><p><font color='red'><u><em><strong>扩容问题和头插法问题</strong></em></u></font></p>
<p>假设两个线程同时对hashmap进行扩容，这时候两个都指向首节点A，后面的节点分别是bcd。</p>
<p>那么这时候线程1正常执行，线程2卡住了。但是A执行完后因为是头插法所以abc变成了cba。线程2唤醒启动，线程2第一个e还是指向a，a的next指向b，这样子就出现了问题，但是还没出现环状。那我们继续执行。把e也就是a赋放到新链表，a &#x3D;</p>
<p>a的next其实就是b，b拿过来，然后b&#x3D;b的next，b的next是谁呢，就是a，然后a指向链表头，这个头节点就是b呀！这里就出问题了。</p>
<p>解决的方法：concurrenthashmap，推荐；hashtable安全，不建议；或者直接加锁，也不建议。或者头插法改成尾插法。</p>
<h2 id="HashMap-为什么线程不安全？"><a href="#HashMap-为什么线程不安全？" class="headerlink" title="HashMap 为什么线程不安全？"></a>HashMap 为什么线程不安全？</h2><p><font color='red'><u><em><strong>一方面就是多线程操作导致的死循环问题。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>另一方面就是两个线程 1,2 进行 put 操作，线程1 执行的时候通过判断发现没有出发hash碰撞，但是时间片用完了挂起，这时候线程2也判断有没有hash碰撞发现没有，因为线程1还没来得及插入。这时候线程2插入一个b值结束了，线程1重新获得时间片，因为之前已经成功判断过了，所以直接插入一个a值，那么这样b值就被a值覆盖了。</strong></em></u></font></p>
<h2 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h2><p>散列采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 **采用二进制位操作 &amp;，相对于%能够提高运算效率）</p>
<p><strong>loadFactor 负载因子</strong></p>
<p>loadFactor 负载因子是控制数组存放数据多少的参数和扩容的界限。默认0.75</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
<h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><ul>
<li><p><strong>线程是否安全：</strong><code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）</p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> <font color='blue'><u><em><strong>默认的初始化大小为 16</strong></em></u></font>。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p>
</li>
<li><p><strong>底层数据结构：</strong> <strong>hashmap 数组+链表+红黑树，hashtable 数组+链表</strong></p>
</li>
</ul>
<h2 id="hashmap的key规范"><a href="#hashmap的key规范" class="headerlink" title="hashmap的key规范"></a>hashmap的key规范</h2><p>用自定义类作为key，必须<font color='red'><u><em><strong>重写equals()和hashCode()方法。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>Hashcode和equals</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>两个对象相同的话，他们的HashCode一定相等；</strong></font></p>
<p><font color='green'><strong>两个对象HashCode相等，equals不一定是同一个对象；</strong></font></p>
</blockquote>
<p>transient</p>
<blockquote>
<p>简单来说就是为了避免多余元素的序列化，用 transient  标记了 elementData 字段避免使用默认的序列化方式，定义了  writeObject 和 readObject 实现了自定义的序列化方式。</p>
</blockquote>
</blockquote>
<h1 id="线程安全容器"><a href="#线程安全容器" class="headerlink" title="线程安全容器"></a><font color='red'><u><em><strong>线程安全容器</strong></em></u></font></h1><blockquote>
<h2 id="1、ConcurrentHashMap"><a href="#1、ConcurrentHashMap" class="headerlink" title="1、ConcurrentHashMap"></a>1、<strong>ConcurrentHashMap</strong></h2><p><font color='red'><u><em><strong><code>ConcurrentHashMap</code>1.8的底层数据结构采用数组+链表+红黑树的形式。是线程安全的，而是通过CAS+Synchronized的方法保证了多线程的线程安全。1.8以前是用16个<code>Segment</code> 分段锁加的Reentranlock。添加元素的时候，1，先判断key和value是不是空，如果空就抛异常。2，然后hashcode扰动函数模运算得到下标索引。3、先判断是不是初始化。4、节点为空就cas添加。5、如果正在扩容，就帮助扩容；6、如果冲突就加synchronized后再插入。7、看看能不能转成红黑树</strong></em></u></font></p>
<p>Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p>
<p><font color='green'><strong>1.7 size（）返回各个segment的size和，如果写入频繁，就加锁，全局锁</strong></font></p>
<p>1.8</p>
<h2 id="2、CopyOnWriteArrayList（读多写少）"><a href="#2、CopyOnWriteArrayList（读多写少）" class="headerlink" title="2、CopyOnWriteArrayList（读多写少）"></a>2、CopyOnWriteArrayList（读多写少）</h2><p><font color='red'><u><em><strong>原理：读的时候不加锁，对数组进行改变的时候，通过锁 + 数组拷贝 + volatile 关键字保证了线程安全；</strong></em></u></font></p>
<ul>
<li><font color='red'><u><em><strong>加锁</strong></em></u></font>；<font color='blue'><u><em><strong>ReentrantLock</strong></em></u></font></li>
<li><font color='red'><u><em><strong>从原数组中拷贝出新数组</strong></em></u></font>；</li>
<li><font color='red'><u><em><strong>在新数组上进行操作，并把新数组赋值回去</strong></em></u></font>；</li>
<li><font color='red'><u><em><strong>解锁</strong></em></u></font></li>
</ul>
<h2 id="3、BlockingQueue"><a href="#3、BlockingQueue" class="headerlink" title="3、BlockingQueue"></a>3、BlockingQueue</h2><p><code>BlockingQueue</code> （阻塞队列）是一个接口，<font color='red'><u><em><strong>没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。&#96;</strong></em></u></font></p>
<p><font color='red'><u><em><strong>阻塞队列有哪些</strong></em></u></font></p>
<blockquote>
<p>ArrayBlockingqueue：底层是数组、有界队列。一把锁，锁是不分离的</p>
<p>LinkBlockingQueue：底层是链表、默认无界但是支持有界。头尾两把锁</p>
<p>PriorityBlockingQueue 由优先级堆支持的无界优先级队列</p>
<p>DelayedWorkQueue：<font color='blue'><u><em><strong>DelayedWorkQueue是基于堆的数据结构，按照时间顺序将每个任务进行排序，将待执行时间越近的任务放在在队列的队头位置，以便于最先进行执行</strong></em></u></font></p>
<p>SynchronousQueue</p>
</blockquote>
</blockquote>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><font color='red'><u><em><strong>线程池</strong></em></u></font></h1><blockquote>
<p><font color='red'><u><em><strong>创建线程池的方式</strong></em></u></font></p>
<p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造方法来创建（推荐）。</strong></p>
<p><strong>方式二： <code>Executors的工厂方法：比如Executors.newCachedThreadPool()</code>（不推荐）。</strong></p>
<p>两种方法都在concurrent包下面。</p>
<blockquote>
<p>为什么不推荐？我觉得就是Executors提供的创建的几个线程池都有点局限性，都有不足的地方。</p>
<p>然后像Fixed和Single用的<font color='red'><u><em><strong>工作队列是无界队列</strong></em></u></font>，可能会堆积大量的请求,导致OOM</p>
<p>还有<font color='red'><u><em><strong>cached和Schedule最大的线程数量是Integer.MAX_VALUE</strong></em></u></font>，可能堆积大量的线程，导致OOM</p>
</blockquote>
<ul>
<li>1、ThreadPoolExecutor</li>
</ul>
<blockquote>
<p> <font color='red'><u><em><strong>线程池的类型</strong></em></u></font></p>
<blockquote>
<p>FixedThreadPool，没有救济的线程，只有核心线程。阻塞队列是LinkedBlockingQueue，默认大小是Integer的MaxValue</p>
<p>SingleThreadPool，核心线程和最大线程就1个。阻塞队列是LinkedBlockingQueue，默认大小是Integer的MaxValue</p>
<p>CachedThreadPool：这个是没有核心线程数，全都是救济线程。阻塞队列是SynchronousQueue</p>
</blockquote>
</blockquote>
<ul>
<li>2、ScheduledThreadPoolExecutor</li>
</ul>
<blockquote>
<p><font color='blue'><u><em><strong>ScheduledThreadPool：这个是定时执行任务，阻塞队列是DelayedWorkQueue（基于小根堆实现的延时优先级）</strong></em></u></font></p>
</blockquote>
<blockquote>
<p>ScheduledThreadPoolExecutor继承了<code>ThreadPoolExecutor</code>，也实现了一个ScheduledExecutorService接口，所以有一些特有的方法：比如schedule</p>
<p>他有个类DelayedWorkQueue，见上面。还有一个**<code>ScheduledFutureTask</code>**</p>
<p><font color='red'><u><em><strong>ScheduledThreadPoolExecutor相比Threadpoolexcutor，具备延时执行任务和可周期性执行任务的特性</strong></em></u></font></p>
</blockquote>
<h2 id="3、CompletableFuture"><a href="#3、CompletableFuture" class="headerlink" title="3、CompletableFuture"></a>3、CompletableFuture</h2><p><code>CompletableFuture</code>是对<code>Future</code>的扩展和增强。<code>CompletableFuture</code>实现了<code>Future</code>接口，并在此基础上进行了丰富的扩展，完美弥补了<code>Future</code>的局限性，<strong>同时<code>CompletableFuture</code>实现了对任务编排的能力</strong></p>
</blockquote>
<h2 id="元素排序-Comparable-和-Comparator-有什么区别？"><a href="#元素排序-Comparable-和-Comparator-有什么区别？" class="headerlink" title="元素排序 Comparable 和 Comparator 有什么区别？"></a>元素排序 Comparable 和 Comparator 有什么区别？</h2><blockquote>
<p>Comparable：实现 Comparable 接口并重写 compareTo 方法就可以实现某个类的排序了，它支持 Collections.sort 和 Arrays.sort 的排序。compareTo 方法接收的参数 p 是要对比的对象，排序规则是用当前对象和要对比的对象进行比较，然后返回一个 int 类型的值。正序从小到大的排序规则是：使用当前的对象值减去要对比对象的值；而倒序从大到小的排序规则刚好相反：是用对比对象的值减去当前对象的值。</p>
<p>Comparator 除了可以通过创建自定义比较器外，还可以通过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8C%BF%E5%90%8D%E7%B1%BB&spm=1001.2101.3001.7020">匿名类</a>的方式，更快速、便捷的完成自定义比较器的功能，具体的代码实现如下：</p>
<p><font color='red'><u><em><strong>Comparable 必须由自定义类内部实现排序方法，而 Comparator 是外部定义并实现排序的</strong></em></u></font></p>
</blockquote>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><font color='red'><u><em><strong>Linux常用命令</strong></em></u></font>：<font color='blue'><u><em><strong>cat, pwd, ls、TOP，mpstat，chattr -i +i不可修改删除，lsattr,chmod 777 (读写执行)</strong></em></u></font></p>
<blockquote>
<p><strong>lsof -i:9080</strong>可以查看9080端口正在运行的程序 kill -9 进程号</p>
<p>kill -9 PID 是操作系统从内核级别强制杀死一个进程.</p>
<p>kill -15 PID 可以理解为操作系统发送一个通知告诉应用主动关闭.</p>
</blockquote>
<p><font color='red'><u><em><strong>查日志的命令</strong></em></u></font>：cat tail head</p>
<p><font color='red'><u><em><strong>怎么排查项目故障</strong></em></u></font>：</p>
<blockquote>
<p><font color='green'><strong>可以用top先看看是cpu还是内存的问题，cpu的话，可以拿到进程id，然后ps H -eo pid,tid,%cpu | grep进程id 或者top -H -p pid，查看线程情况，拿到线程id，最后jstack查看堆栈信息。内存泄漏的话就jmap -dump一个内存快照，然后加载到visualVMEclipse Memory Analyzer里面。或者jstat看看各个分区的情况和gc的压力。还有那个HeapDumpOnMemoryError这个JVM的配置</strong></font></p>
</blockquote>
<p>标高的原因：</p>
<blockquote>
<p>死锁？死循环？频繁fullgc？一些复杂计算</p>
</blockquote>
<p><strong>查看机器的负载情况linux</strong></p>
<blockquote>
<p>Top htop mpstat vmstat</p>
</blockquote>
<h1 id="Spirng"><a href="#Spirng" class="headerlink" title="Spirng"></a>Spirng</h1><p><font color='red'><u><em><strong>springboot和spring</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>SpringBoot 是一个在spring基础上进行简化 配置和开发流程的web整合的轻量级框架</strong></font></p>
<p>@SpringBootApplication</p>
<p>@EnableAutoConfiguration</p>
<p>@ComponentScan</p>
</blockquote>
<p><font color='red'><u><em><strong>@Transactional（既可以jdk也可以cglib，默认是jdk）</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>是一个事务注解，底层是AOP，Spring 会创建一个代理对象来包装该方法，并在方法执行前和后添加代码，以启动和提交、回滚事务。在写代码的时候一般单表查询我们不需要加，如果是多个写操作，那就得用上这个，也得防止失效</strong></font></p>
<p><font color='green'><strong>他可以用于<code>接口</code>、<code>类</code>、<code>方法</code>。把注解放到类上，那所有的public方法都配置了相同的事务配置信息，作用于方法，那方法的事务会覆盖类的事务配置信息</strong></font>。</p>
<p><font color='red'><u><em><strong>使用Transcantional需要注意的点</strong></em></u></font></p>
<blockquote>
<p><font color='red'><u><em><strong>1、@Transactional 只能应用到 public 方法才有效</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>Spring 会调用一个叫做 computeTransactionAttribute 方法去获取 @Transactional 注解的事务配置信息，这个方法里面会判断你是不是为public，如果是才能往下走，</strong></font></p>
<p><font color='green'><strong>还有一个层面，aop底层是两种代理方式吗，如果是基于接口，那你就得是public，因为接口的性质。如果你是基于类的，那我们cglib的原理是重写父类的方法，你如果是private，那都对子类不可见，那更不要说其他的了</strong></font></p>
</blockquote>
<p><font color='red'><u><em><strong>2、异常类型不匹配：或者异常被吃掉了</strong></em></u></font></p>
<p><font color='green'><strong><code>@Transactional</code> 默认只在运行时异常（RuntimeException）发生时才回滚，对检查异常（Checked Exception）不回滚。</strong></font></p>
<p><font color='red'><u><em><strong>3、自调用失效：</strong></em></u></font></p>
<p><font color='green'><strong>当一个标记为 <code>@Transactional</code> 的方法内部调用另一个 <code>@Transactional</code> 方法时，内部方法的事务设置可能不会生效。</strong></font></p>
<p><font color='red'><u><em><strong>4、多个库，这个不是失效，</strong></em></u></font></p>
<blockquote>
<p><font color='green'>**我们说同一个事务，是指同一个数据库连接。继承AbstractRoutingDataSource，重写determineTargetDataSource。这个方法是核心，你会调用determineCurrentLookupKey，他就用来决定切换到哪一个数据源	**</font></p>
</blockquote>
</blockquote>
<p><font color='red'><u><em><strong>Spring事务基于Spring AOP，Spring AOP底层用的动态代理，动态代理有两种方式：</strong></em></u></font></p>
<blockquote>
<p>基于接口代理(JDK代理)</p>
<ul>
<li>基于接口代理，凡是类的方法非public修饰，或者用了static关键字修饰，那这些方法都不能被Spring AOP增强</li>
</ul>
<p>基于CGLib代理(子类代理)</p>
<ul>
<li>基于子类代理，凡是类的方法使用了private、static、final修饰，那这些方法都不能被Spring AOP增强 由于是继承关系，无法代理final的类和方法(无法继承)，或是private的方法(对子类不可见)。</li>
</ul>
</blockquote>
<p>————————————————</p>
<p>这个注解有几个核心的字段，</p>
<p><font color='green'><strong>事务的隔离级别</strong></font></p>
<p><code>isolation</code> ：事务的隔离级别，默认值为 <code>Isolation.DEFAULT</code>。</p>
<table>
<thead>
<tr>
<th>Isolation.DEFAULT：使用底层数据库默认的隔离级别。</th>
</tr>
</thead>
<tbody><tr>
<td>Isolation.READ_UNCOMMITTED</td>
</tr>
<tr>
<td>Isolation.READ_COMMITTED</td>
</tr>
<tr>
<td>Isolation.REPEATABLE_READ</td>
</tr>
<tr>
<td>Isolation.SERIALIZABLE</td>
</tr>
</tbody></table>
<p><font color='green'><strong>传播机制</strong></font></p>
<blockquote>
<table>
<thead>
<tr>
<th><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。**(** 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 <strong>）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行</td>
</tr>
<tr>
<td><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</td>
</tr>
<tr>
<td><code>Propagation.REQUIRES_NEW</code>：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。**(** 当类A中的 a 方法用默认<code>Propagation.REQUIRED</code>模式，类B中的 b方法加上采用 <code>Propagation.REQUIRES_NEW</code>模式，然后在 a 方法中调用 b方法操作数据库，然而 a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停 a方法的事务 <strong>)</strong></td>
</tr>
<tr>
<td><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</td>
</tr>
<tr>
<td><code>Propagation.NEVER</code>：以非事务的方式运行，如果当前存在事务，则抛出异常。</td>
</tr>
</tbody></table>
</blockquote>
<p><font color='green'><strong>是否为只读</strong></font></p>
<blockquote>
<p>默认情况下是false，如果你的事务确实只有查询的需求，那就可以这里设置为true；</p>
</blockquote>
</blockquote>
<blockquote>
<p><font color='red'><u><em><strong>常用的注解？</strong></em></u></font></p>
<p><a target="_blank" rel="noopener" href="https://nageoffer.com/pages/7563ce/#%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3">https://nageoffer.com/pages/7563ce/#%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3</a></p>
<blockquote>
<p><font color='red'><u><em><strong>spring常用的注解</strong></em></u></font></p>
</blockquote>
<blockquote>
<p>@Component(“foo”) &#x2F;&#x2F; 声明一个 Foo 类型的 Bean，其 beanName 为 “foo”<br>@Named(“a”) &#x2F;&#x2F; &#x3D;&#x3D; @Component(“a”)<br>@ManagedBean &#x2F;&#x2F; &#x3D;&#x3D; @Component<br>@Configuration &#x2F;&#x2F; 声明一个配置类，其本身也视为一个 Bean<br>@Bean &#x2F;&#x2F;注解用于注解在工厂方法上，标明该方法返回的对象需要作为一个 Bean 交由 Spring 管理。<br>@Lazy 懒加载：延迟单例 Bean 的加载时机，在不被其他非懒加载 Bean 依赖的情况下，不在 AbstractApplicationContext.refresh 执行过程中随其他单例 Bean 提前实例化，而是等到被从 Spring 容器获取时再初始化</p>
</blockquote>
<blockquote>
<p>@PostConstruct &#x2F;&#x2F;被 @PostConstruct 注解的方法会在 Bean 初始化后调用</p>
</blockquote>
<blockquote>
<hr>
</blockquote>
<blockquote>
<p><font color='red'><u><em><strong>Spring Web常用的注解</strong></em></u></font></p>
</blockquote>
<blockquote>
<p>1、@Controller &amp; @Service &amp; @Repository<br>2、@RequestMapping：<br>@Controller<br>@RequestMapping(“&#x2F;example”) &#x2F;&#x2F; 当放在类上时，等同于定义公共路径前缀<br> @RequestMapping(<br>        path &#x3D; {“&#x2F;method1”, “&#x2F;method”}, &#x2F;&#x2F; 支持同时映射多个路径<br>        method &#x3D; RequestMethod.GET<br>    )<br> public String method1() {<br>     &#x2F;&#x2F; 处理 &#x2F;example&#x2F;method1 或 &#x2F;example&#x2F;method 的 get 请求<br>     return “view1”;<br> }<br>@RequestParam、@PathVariable、@RequestBody不同<br><a target="_blank" rel="noopener" href="http://localhost:8080/find/1/china/2?id=100&amp;name=zhangSan%E3%80%82%E5%88%99">http://localhost:8080/find/1/china/2?id=100&amp;name=zhangSan。则</a> @RequestParam 可以用来获取 “?” 后面的 id、name 参数，而 @PathVariable 则是获取 url 中的参数，如里面的 “1”、”china”、”2”</p>
</blockquote>
<blockquote>
<ol start="3">
<li>@ResponseBody<br> 直接放回JSON数据，不需要渲染<br> 7.@ControllerAdvice官方提供的仅针对控制器的切面注解<br> 依赖注入的注解<br> 1、@Autowired @Qualifier 等同与@Inject @Named<br> 2、@Resource<br> 3、@Value 注解可以使用 ${} 语法注入配置文件的某些配置，也可以使用 #{} 语法注入 Spring 容器中的 Bean</li>
</ol>
</blockquote>
<blockquote>
<hr>
<p><font color='red'><u><em><strong>Spring上下文注解</strong></em></u></font></p>
</blockquote>
<blockquote>
<ol>
<li>@ComponentScan</li>
</ol>
</blockquote>
<p><font color='red'><u><em><strong>AOP是什么？</strong></em></u></font></p>
<p><font color='green'><u><em><strong>aop是面向切面编程， 把一些和业务无关的公共的代码抽出来自己弄成一个模块。然后在不改变原有的逻辑情况下动态的切入到类的指定方法、指定位置上，这个就是aop 底层是动态代理JDK和CGLIB</strong></em></u></font></p>
<p><font color='red'><u><em><strong>有没有用过AOP</strong></em></u></font></p>
<p><font color='green'><u><em><strong>有的，我之前在一个分库分表的组件项目里面用到过，就是分库分表要切换数据源，我就是用aop切面去计算出落到哪个库哪个表里面，切入点是一个注解。Transactional这个注解其实也是aop，还有一些监控到注解什么的</strong></em></u></font></p>
<p><font color='red'><u><em><strong>aop的实现方式</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>1、Spring API实现AOP，</strong></font></p>
</blockquote>
<blockquote>
<p><font color='green'><strong>2、自定义切面类，用xml配置</strong></font></p>
</blockquote>
<blockquote>
<p><font color='green'><strong>3、通过注解实现AOP，Aspect</strong></font></p>
</blockquote>
<p><font color='red'><u><em><strong>aop失效的原因和解决方法</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>关键是就是自己内部调用的问题：CGLib代理生成一个子类，重写了父类的非final非private的方法,  jdk代理是基于接口的，代理对象是接口的实现类。但是无论是那种方法，由于没有修改父类的字节码, 所以, 在父类方法中, 仍然会调用父类自己的添加事务的方法，一个类中有，两个方法A和B，B被aop增强了，此时A调用父类中的方法。</strong></font></p>
</blockquote>
<blockquote>
<p><font color='blue'><u><em><strong>解决方法：在方法a中获取当前代理对象p, 执行p.a()可使得事务生效</strong></em></u></font></p>
</blockquote>
<p><font color='red'><u><em><strong>aop用那种动态代理</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>能用 JDK 做动态代理就用 JDK，不能用 JDK 做动态代理就用 Cglib，即首选 JDK 做动态代理。</strong></font></p>
</blockquote>
<p><font color='red'><u><em><strong>IOC</strong></em></u></font></p>
<blockquote>
<p><font color='green'><u><em><strong>控制反转的意思，以前我们创建的时候new，但是这种方法很麻烦，且很难处理对象直接的依赖关系。他是把对象创建和对象之间的调用过程，交给spring进行管理。</strong></em></u></font></p>
</blockquote>
<blockquote>
<p><font color='green'><u><em><strong>Spring有几种容器</strong></em></u></font></p>
</blockquote>
<blockquote>
<ol>
<li><strong>BeanFactory</strong>: BeanFactory是Spring框架最基本的IOC容器。</li>
<li><strong>ApplicationContext</strong>: ApplicationContext是BeanFactory的子接口，提供了更多的企业级功能，如国际化处理、事件传播、应用层面的异常处理等。它对BeanFactory进行了扩展，是Spring中最常用的IOC容器。</li>
<li><strong>ClassPathXmlApplicationContext</strong>: ClassPathXmlApplicationContext是从类路径下加载配置文件的容器，通过XML文件配置来管理Bean。</li>
<li><strong>FileSystemXmlApplicationContext</strong>: FileSystemXmlApplicationContext从文件系统中加载配置文件的容器，同样也是通过XML文件配置来管理Bean。</li>
<li><strong>AnnotationConfigApplicationContext</strong>: AnnotationConfigApplicationContext是通过Java类配置来管理Bean的容器，不需要XML配置文件，而是通过注解来完成Bean的定义和依赖注入。</li>
</ol>
</blockquote>
<p><font color='red'><u>**BeanFactory和FactoryBean，ApplicationContext的区别？ **</u></font></p>
<blockquote>
<p><font color='green'><strong>答：①BeanFactory是⼀个Factory接⼝，是⽤来管理bean的IOC容器或对象⼯⼚。 ②FactoryBean是⼀个Bean接⼝，是⼀个可以⽣产或者装饰对象的⼯⼚Bean，可以通过 实现该接⼝⾃定义的实例化Bean的逻辑。③ApplicationConext是BeanFactory的⼦接 ⼝，扩展了其功能，ApplicationContext是⽴即加载</strong></font></p>
</blockquote>
<p><font color='red'><u><em><strong>创建Bean的方式</strong></em></u></font></p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42764468/article/details/103286994#1bean_8">1.使用默认的构造函数创建bean对象</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42764468/article/details/103286994#2bean_25">2.通过静态工厂方法创建bean</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42764468/article/details/103286994#3bean_90">3.通过实例工厂方法创建bean</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42764468/article/details/103286994#4FactoryBean_141">4.实现FactoryBean接口</a></li>
</ul>
</blockquote>
<p><font color='red'><u><em><strong>Bean的生命周期？</strong></em></u></font></p>
<blockquote>
<p>1 通过<strong>XML</strong>、注解和配置类等方式加载<strong>Spring Bean</strong></p>
</blockquote>
<blockquote>
<p>2、用<strong>BeanDefinitionReader</strong>把Bean解析成BeanDefinition结构，放到beanDefinitionMap，扫描这个</p>
</blockquote>
<blockquote>
<p>4、从Bean定义里面拿BeanClass的构造函数，通过反射创建Bean，这里构造函数的选用，一般先选有autowire修饰和无参构造函数。</p>
</blockquote>
<blockquote>
<p>5、依赖注入</p>
</blockquote>
<blockquote>
<p>6、处理三个Aware接口，</p>
</blockquote>
<blockquote>
<p>7、<em><strong>BeanPostProcessor：自定义的逻辑</strong></em></p>
</blockquote>
<blockquote>
<p>8、 调用初始化Bean（InitializingBean和init-method，Bean的初始化才算完成）</p>
</blockquote>
<blockquote>
<p>9、<em><strong>BeanPostProcessor：自定义的逻辑</strong></em> aop核心底层动态代理</p>
</blockquote>
<p><font color='red'><u><em><strong>依赖注入有哪些方法</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>我之前看到官网的解释是两类1、构造器；2、setter。其余都是基于他们的变形。包括我们熟知的字段注入，他底层是Filed.set反射的方式注入的，也算是setter的一个变形吧</strong></font>。自动注入模式有四种：</p>
</blockquote>
<blockquote>
<p><font color='green'><strong>1、no；2、byName；3、byType；4、constructor</strong></font></p>
</blockquote>
<p><font color='red'><u><em><strong>为什么依赖注入不适合用字段注入？</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>2、会导致循环依赖</strong></font></p>
</blockquote>
<blockquote>
<p><font color='green'><strong>3、无法为静态变量和final修饰的进行注入，原因是变量必须在类实例化进行初始化</strong></font></p>
</blockquote>
<p><font color='red'><u><em><strong>Bean的循环依赖？</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>循环依赖问题在Spring中主要有三种情况：</strong></font></p>
</blockquote>
<blockquote>
<ul>
<li><font color='green'><strong>第一种：通过构造方法进行依赖注入时产生的循环依赖问题。</strong></font></li>
<li><font color='green'><strong>第二种：通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</strong></font></li>
<li><font color='green'><strong>第三种：通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</strong></font></li>
</ul>
</blockquote>
<blockquote>
<p>只有【第三种方式】的循环依赖问题被 Spring 解决了。</p>
</blockquote>
<blockquote>
<p>Spring解决这个是用三级缓存或者懒加载（构造函数的循环依赖问题），三次缓存中：<font color='green'><u><em><strong>一级缓存存放完整的bean，二级缓存存放半成品Bean、三级缓存放ObjectFactory。</strong></em></u></font></p>
</blockquote>
<blockquote>
<p><font color='red'><u><em><strong>为什么三层？</strong></em></u></font></p>
</blockquote>
<blockquote>
<p><strong>所以如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题，如果加上AOP，两级缓存是无法解决的。如果对象被AOP代理了，我每次从三级缓存中拿到singleFactory对象，执行getObject()方法会产生新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象</strong></p>
</blockquote>
<p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231222001434059.png" alt="image-20231222001434059"></p>
<p><font color='red'><u><em><strong>可以直接调用bean.init的进行初始化吗？</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>最好不要，如果你在new之后直接调用init方法，那会出现一种情况，假设这个bean里面有个Car类，然后我做初始化setName结果人家刚刚实例化，就会报空指针异常。</strong></font></p>
</blockquote>
<blockquote>
<ul>
<li><font color='green'><strong><code>private Car car;</code> 这行代码在栈内存中为 <code>car</code> 引用变量分配空间。这个空间只是用来存储引用的</strong></font></li>
<li><font color='green'><strong><code>car = new Car();</code> 这行代码在堆内存中为 <code>Car</code> 对象分配空间，并将堆内存中的对象地址赋值给 <code>car</code> 引用变量。</strong></font></li>
</ul>
</blockquote>
<blockquote>
<p><font color='red'><u><em><strong>Springboot启动流程</strong></em></u></font></p>
</blockquote>
<blockquote>
<p><font color='red'><u><em><strong>主要分为4步：服务构建、环境准备、容器创建、填充容器。</strong></em></u></font></p>
</blockquote>
<blockquote>
<p><font color='green'><strong>1、服务构建就是构造springapplication，包括确认web服务器、加载spring.factories下的所有初始化类监听器，找到主导方法。</strong></font></p>
</blockquote>
<blockquote>
<p><font color='green'><strong>2、然后调用run方法进入环境准备，通过配置类、和配置文件构造出一个environment，用于后面的容器创建。</strong></font></p>
</blockquote>
<blockquote>
<p><font color='green'><strong>3、容器创建的话，其实就是创建一个BeanFactory，然后加载bean信息，通过beanDefinitionReader把bean信息读成BeanDefinition并且把他放到beanDefinitionMap里面</strong></font></p>
</blockquote>
<blockquote>
<p><font color='green'><strong>4、填充容器。就是我们的refresh（）方法，一个12步，但是可以分成四块，预处理，后置处理器，国际化分派器，实例化剩下的所有bean。</strong></font></p>
</blockquote>
<p><font color='red'><u><em><strong>容器初始化流程</strong></em></u></font></p>
<blockquote>
<p>1、prepareRefresh()刷新前的预处理：<br>2、obtainFreshBeanFactory()：创建容器对象，实际就是获取一个DefaultListenableBeanFactory：<br>3、prepareBeanFactory(beanFactory)：BeanFactory的预处理工作，向容器中添加一些组件：<br>4、postProcessBeanFactory(beanFactory)：</p>
</blockquote>
<blockquote>
<p>5、invokeBeanFactoryPostProcessors(beanFactory)：即BeanFactory的后置处理器：<br>6、registerBeanPostProcessors(beanFactory)：向容器中注册Bean的后置处理器BeanPostProcessor，它的主要作用是干预Spring初始化bean的流程，从而完成代理、自动注入、循环依赖等功能</p>
</blockquote>
<blockquote>
<p>7、initMessageSource()：初始化MessageSource组件，主要用于做国际化功能，消息绑定与消息解析：<br>8、initApplicationEventMulticaster()：初始化事件派发器，在注册监听器时会用到：</p>
</blockquote>
<blockquote>
<p>9、onRefresh()：留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑</p>
</blockquote>
<blockquote>
<p>10、registerListeners()：注册监听器：将容器中所有的ApplicationListener注册到事件派发器中，并派发之前步骤产生的事件：<br>11、finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；<br>12、finishRefresh()：发布BeanFactory容器刷新完成事件：</p>
</blockquote>
<blockquote>
<p>可以分成四块</p>
</blockquote>
<blockquote>
<p><font color='green'><strong>第一步：预处理，包括刷新的预处理，然后获取我们刚刚创建的BeanFactory再做预处理。</strong></font></p>
</blockquote>
<blockquote>
<p><font color='green'><strong>第二步：后置处理器，执行BeanFactory的后置处理器，然后在容器里面注册一个Bean的后置处理器。</strong></font></p>
</blockquote>
<blockquote>
<p><font color='green'><strong>第三步：就是一些国际化，事件分派器的东西。</strong></font></p>
</blockquote>
<blockquote>
<p><font color='green'><strong>第四步：非常重要了，finishBeanFactoryInitailization，初始化所有剩下的单实例bean，bean的生命周期也从这里开始。</strong></font></p>
</blockquote>
<p><font color='red'><u><em><strong>Spring用到的设计模式</strong></em></u></font></p>
<blockquote>
<p>单例模式：这个在创建Bean的时候用到，创建单例Bean的时候会先去缓存里面找，如果找不到，在触发createBean方法。</p>
</blockquote>
<blockquote>
<p>工厂模式：就是BeanFactory接口了</p>
</blockquote>
<blockquote>
<p>代理模式：就是aop。jdk和cglib</p>
</blockquote>
<blockquote>
<p>模版模式：jdbcTemplate</p>
</blockquote>
<p><font color='red'><u><em><strong>Springboot自动装配？</strong></em></u></font></p>
<blockquote>
<p><font color='blue'><u><em><strong>springboot的自动装配是依赖于springbootapplication这个注解，这个注解是一个复合注解，真正实现自动装配的是一个enableautoConfiguration这个注解。 我们引入的starter里面会有@Configuration配置类，然后这个配置类的路径放在spirng.factories下，我们用springfactoryloader找到配置类，最后我们spring会通过ImportSelector接口去实现动态的加载，@ConditionalOnBean和@ConditionalOnMissingBean 定义的条件进行选择加载。</strong></em></u></font></p>
</blockquote>
<p><font color='red'><u><em><strong>Autowire和Resourse</strong></em></u></font></p>
<blockquote>
<p><font color='blue'><u><em><strong>spring推荐setter和构造器，但是我们用字段注入比较简单，idea明确不推荐Autowire，我觉得原因是和框架的强耦合。</strong></em></u></font></p>
</blockquote>
<blockquote>
<p>Autowire默认按类型，如果想要实现按名字注入，主要配置@Primary 或者@Qualifier，</p>
</blockquote>
<blockquote>
<p>Resource默认按名字然后类型。</p>
</blockquote>
<p><strong>Bean是线程安全的吗？</strong></p>
<blockquote>
<p>默认单例（可以多例），但是不是线程安全。因为Bean内部的成员变量是共享可修改的。</p>
</blockquote>
<p><font color='red'><u><em><strong>Spring MVC的工作流程如下：</strong></em></u></font></p>
<blockquote>
<ol>
<li><font color='green'><strong>用户发送请求至前端控制器DispatcherServlet</strong></font></li>
<li><font color='green'><strong>前端控制器收到请求调用处理器映射器</strong></font></li>
<li><font color='green'><strong>处理器映射器根据请求url找到具体的处理器，然后封装成处理器执行链返回给DispatcherServlet</strong></font><font color='green'><strong>HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。</strong></font></li>
<li><font color='green'><strong>DispatcherServlet根据处理器Handler找到能调用该处理器的处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</strong></font></li>
<li><font color='green'><strong>调用具体的处理器Handler(Controller，也叫页面控制器)。</strong></font></li>
<li><font color='green'><strong>方法如果添加了ResponseBody就转为json直接返回了，都则可能还要视图解析，渲染一下。</strong></font></li>
</ol>
</blockquote>
</blockquote>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><blockquote>
<p><font color='blue'><u><em><strong>Mybatis怎么传多个参数：</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>1、顺序传参</strong></font></p>
<blockquote>
<blockquote>
</blockquote>
<p><font color='green'><strong>2、map传参</strong></font></p>
<blockquote>
</blockquote>
<p><font color='green'><strong>3、用mybatis的注解，Param</strong></font></p>
</blockquote>
</blockquote>
<p><font color='blue'><u><em><strong>MyBatis中${} 和 #{} 有什么区别</strong></em></u></font></p>
<blockquote>
<p><font color='green'><strong>1、功能不同： #{} 是占位符，${} 是直接替换，；2、使用场景不同：普通参数使用 #{}，如果传递的是 SQL 命令或 SQL 关键字，需要使用 ${}，但在使用前一定要做好安全验证；3、安全性不同：使用 ${} 存在安全问题，而 #{} 则不存在安全问题。</strong></font></p>
</blockquote>
</blockquote>
<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><p><font color='red'><u><em><strong>git rebase 和 git merge</strong></em></u></font></p>
<blockquote>
<p>git merge ，会保留历史的提交，然后new一个新的提交记录</p>
<p>rebase是一般在非公共分支上rebase，然后合并到main分支，原来的那个分支会被清除。</p>
</blockquote>
<p><strong>setNX有什么缺陷？</strong>redison锁过期的问题</p>
<blockquote>
<p>有单点风险</p>
<p>可能会导致同一把锁被多人使用</p>
<p>redlock</p>
</blockquote>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><strong>1、进程和线程的区别</strong></p>
<blockquote>
<p><font color='green'><strong>1、进程是操作系统资源分配的基本单位，把磁盘的代码加载到内存，分配数据空间。</strong></font></p>
<p><font color='green'><strong>2、线程是任务调度的一个单位，进程的一个实体，cpu运行和独立调度的基本单位，cpu上面真正运行的其实是线程</strong></font></p>
<p><font color='green'><strong>3、一个进程可以拥有多个线程。</strong></font></p>
<p><font color='green'><strong>4、线程的切换消耗要比进程小。共享代码区、数据区，堆区</strong></font></p>
</blockquote>
<p><strong>2、死锁</strong></p>
<blockquote>
<p>多个进程，互相请求对方已经持有的资源。</p>
<p><font color='green'><strong>互斥条件</strong></font></p>
<p><font color='green'><strong>请求和保持</strong></font></p>
<p><font color='green'><strong>不可被剥夺</strong></font></p>
<p><font color='green'><strong>循环等待</strong></font></p>
<p>死锁的检测：</p>
<ul>
<li>可以依赖JPS和JSTACK。用jps拿到java进程的id，然后jstack分析堆栈信息。</li>
<li>也可以用可视化工具virtualVM</li>
</ul>
<p>预防死锁：破坏这四个条件</p>
<p>解除死锁：资源剥夺、撤销进程、进程回退。</p>
</blockquote>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 caosen0819@163.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 CSEN
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
