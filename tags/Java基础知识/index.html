
<!DOCTYPE html>
<html lang="zh-CH">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="森">
    <title>Tag: Java基础知识 - 森</title>
    <meta name="author" content="CSEN">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="潮起潮落，云卷云舒">
<meta property="og:type" content="blog">
<meta property="og:title" content="森">
<meta property="og:url" content="http://example.com/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="森">
<meta property="og:description" content="潮起潮落，云卷云舒">
<meta property="og:locale" content="zh_CH">
<meta property="article:author" content="CSEN">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="http://example.com/assets/images/head.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-w816scvuzwavitjylabixcb3ofuoklqul47j3rgwu1r0mxrxvbdehvp2jk5s.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            森
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Lesen Sie mehr über den Autor"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
                </a>
                <h4 class="sidebar-profile-name">CSEN</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="档案"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">档案</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/Caosen0819"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title=".github"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">.github</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
                            aria-label=": Java基础知识"
                        >
                            Java基础知识
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-08-07T00:00:00+08:00">
	
		    07 Aug 2023
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="讲讲Java的代理"><a href="#讲讲Java的代理" class="headerlink" title="讲讲Java的代理"></a>讲讲Java的代理</h2><p>代理分成静态代理和动态代理，静态代理需要自己实现对每一个方法对代理，那么如果新增一个方法，那就要手动修改目标对象代理对象的代码，非常繁琐。动态代理更加灵活，不需要你一个一个的对方法进行代理。</p>
<p>动态代理就是运行的时候生成class。这个DynamicProxy其实就是一个Proxy，</p>
<p>动态代理有两种方式一种是jdk方法，一种是cglib方法</p>
<p><strong>我们先来讲jdk代理：</strong></p>
<blockquote>
<p><font color='blue'><u><em><strong>JDK代理依赖于Proxy类和InvocationHandler接口，InvocationHandler接口他只有一个invoke方法，三个参数是代理类，被代理方法，方法参数组。代理方法和参数组其实我们可以利用反射得到，所以参数其实是可以变化的，那这样就成功的实现了动态的代理。</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>那我们怎么去调用这个方法呢？依赖于Proxy类和他的方法newproxyInstance，得到的代理类，调用方法其实会直接调用我们实现InvocationHandler接口的invoke方法</strong></em></u></font></p>
</blockquote>
<p><strong>下面来讲CGLIB代理</strong></p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。你可以通过 <code>Enhancer</code>类来动态获取被代理类，</strong></p>
<p>  CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，每次调用代理类的方法都会被方法<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8B%A6%E6%88%AA%E5%99%A8&spm=1001.2101.3001.7020">拦截器</a>拦截，在拦截器中才是调用目标类的该方法的逻辑。所以我们说，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<p><strong>二者区别</strong><br>总结一下两者的区别吧：</p>
<p><font color='blue'><u><em><strong>JDK 动态代理基于接口，CGLIB 动态代理基于类。</strong></em></u></font>因为 JDK 动态代理生成的代理类需要继承Proxy，所以，只能基于接口；CGLIB 动态代理是根据类创建此类的子类，所以，此类不能被 final 修饰<br><font color='blue'><u><em><strong>JDK 是自带的、CGLIB需要加载包</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>JDK是反射机制，CGLIB是使用ASM框架。</strong></em></u></font></p>
<p><strong>为什么Java不能多继承？</strong></p>
<p>会出现方法冲突和变量冲突</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231116121230926.png" alt="image-20231116121230926"></p>
<h2 id="Arraylist底层原理"><a href="#Arraylist底层原理" class="headerlink" title="Arraylist底层原理"></a>Arraylist底层原理</h2><p>可以从底层数据结构，构造函数和关键方法理解。</p>
<blockquote>
<p><font color='red'><u><em><strong>Arraylist的底层数据结构是object[]数组，构造函数分有参无参，如果是无参就是空数组，如果是有参，就用你定义的那个初始大小。如果参数是容器，那就是把容器转成数组copy给object。关键方法就是add方法，需要保证容量够用才能添加元素，所以会在添加之前进行一个ensurecapacity的过程。他会先计算mincapacity的值，他会拿mincapacity去和现在的数组长度比较，如果大了说明要扩容，扩容的过程是先×1.5看看够不够，够的话就1.5，不够就用新的这个mincapacity。</strong></em></u></font>如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code></p>
<blockquote>
<p><font color='blue'><u><em><strong>对于插入</strong></em></u></font>：如果不需要扩容，其实无论是头插指定位置插入都是O(n)，尾插是O(1)。如果需要扩容，就得再做一次扩容，O(n)，然后在插入，就是刚才讲的时间复杂度。</p>
<p><font color='blue'><u><em><strong>对于删除</strong></em></u></font>：头删和指定位置删除是O(n)，尾部删除是O(1)</p>
</blockquote>
</blockquote>
<h2 id="Linkedlist"><a href="#Linkedlist" class="headerlink" title="Linkedlist"></a>Linkedlist</h2><blockquote>
<p><font color='red'><u><em><strong>Linkedlist 是双向链表，因为是链表，所以没什么扩容的问题，基本的方法都是围绕前节点、后节点、节点值展开的。</strong></em></u></font></p>
<ul>
<li>头部插入&#x2F;删除： O(1)。</li>
<li>尾部插入&#x2F;删除： O(1)。</li>
<li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li>
</ul>
</blockquote>
<h2 id="ArrayList-与-LinkedList区别"><a href="#ArrayList-与-LinkedList区别" class="headerlink" title="ArrayList 与 LinkedList区别?"></a>ArrayList 与 LinkedList区别?</h2><blockquote>
<p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构，内存一个是连续一个不是连续</p>
<p><strong>插入和删除的时间复杂度</strong>：arraylist，头插、指定插、头删、指定删除都是On，尾插和尾删除是O1。linkedlist 头插和尾插、头删除、尾删除都是O1，指定位置是On</p>
<p><strong>内存空间占用</strong>：<font color='blue'><u><em><strong>linkedlist每个节点要存前后指针，所以内存占用大。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>使用场景：</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>如果需要频繁进行随机访问和查询操作的场景，例如按索引读取数据或搜索特定元素，应该选择ArrayList。</strong></em></u></font></p>
<p><font color='blue'><u><em><strong>如果需要频繁进行插入、删除或位置变动较多的场景，特别是在链表的首尾位置进行操作，那么LinkedList是更合适的选择。</strong></em></u></font></p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p><font color='blue'><u><em><strong>如何实现数组和arraylist之间的转换</strong></em></u></font></p>
<p>List.toarray  (修改原先list，array不受影响)</p>
<p>Arrays.aslist （受影响）</p>
<blockquote>
<p><T>&lt;?&gt;</p>
<p><T>主要用于类或方法上，对这个类或者方法里面的泛型全是一样的。</p>
<?>一般用在变量上，有界通配符，对类型做一定的限制。

</blockquote>
<h2 id="hashmap和hashset"><a href="#hashmap和hashset" class="headerlink" title="hashmap和hashset"></a><font color='red'><u><em><strong>hashmap和hashset</strong></em></u></font></h2><blockquote>
<p>hashset还是比较适合去重和集合运算</p>
<p>hashmap比较适合键值对这类数据</p>
</blockquote>
<h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul>
<li><font color='red'><u><em><strong><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</strong></em></u></font></li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><blockquote>
<p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
</blockquote>
<h2 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h2><blockquote>
<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能</p>
<p><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</p>
<p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
</blockquote>
</blockquote>
<h1 id="HashMap："><a href="#HashMap：" class="headerlink" title="HashMap："></a>HashMap：</h1><p>hashmap最关键的是他的<font color='blue'><u><em><strong>底层数据结构、put 扩容 和 线程安全方面的知识。</strong></em></u></font></p>
<blockquote>
<h2 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h2><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong>。1.8之后是数组+链表+红黑树</p>
<p>构造函数是懒加载，没有初始化数据，就是把负载因子赋为0.75。</p>
<p>put的时候，先判断数组是否为空，如果为空，就初始化为16大小。通过 key 的 <code>hashcode</code> 经过扰动函数（右移16位再异或），然后通过 <code>  hash &amp; (n - 1)</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果定位到的数组位置没有元素 就直接插入。如果有数据，就判断key是不是相同，相同就覆盖，不相同就判断是不是红黑树，如果是就调用putTree，如果是链表就遍历链表，看看key有没有，有就覆盖，没有就在尾部插入新的节点，然后判断长度是否大于8，大于8就去尝试转红黑树，插入结束后，最后要判断一下是否需要扩容，</p>
</blockquote>
<blockquote>
<h2 id="hashmap扩容过程"><a href="#hashmap扩容过程" class="headerlink" title="hashmap扩容过程"></a>hashmap扩容过程</h2><p>扩容简单来说就是做了两件事。1：创建一个新数组，原来的两倍大。2：遍历旧数组每个槽<br>如果槽位中是一个普通节点，则将节点放在新数组中，所在新数组中的下标计算方式为：e.hash &amp; (newCap - 1);<br>如果槽位中是一个树节点，则进行红黑树的迁移操作，新数组中下标计算方式同普通节点；<br>如果槽位中是一个链表节点，则将链表拆为高位链表和低位链表，就是拿hash值和旧容量做与操作，等于0就放入放入新数组的旧数组的下标位置和，不等于0会放到（旧数组下标 + 旧数组容量）下标位置；<br>最后返回新数组。</p>
<h2 id="HashMap-多线程操作导致死循环问题（1-7会，1-8是在树操作）"><a href="#HashMap-多线程操作导致死循环问题（1-7会，1-8是在树操作）" class="headerlink" title="HashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）"></a>HashMap 多线程操作导致死循环问题（1.7会，1.8是在树操作）</h2><p><font color='red'><u><em><strong>扩容问题和头插法问题</strong></em></u></font></p>
<p>假设两个线程同时对hashmap进行扩容，这时候两个都指向首节点A，后面的节点分别是bcd。</p>
<p>那么这时候线程1正常执行，线程2卡住了。但是A执行完后因为是头插法所以abc变成了cba。线程2唤醒启动，线程2第一个e还是指向a，a的next指向b，这样子就出现了问题，但是还没出现环状。那我们继续执行。把e也就是a赋放到新链表，a &#x3D;</p>
<p>a的next其实就是b，b拿过来，然后b&#x3D;b的next，b的next是谁呢，就是a，然后a指向链表头，这个头节点就是b呀！这里就出问题了。</p>
<p>解决的方法：concurrenthashmap，推荐；hashtable安全，不建议；或者直接加锁，也不建议。或者头插法改成尾插法。</p>
<h2 id="HashMap-为什么线程不安全？"><a href="#HashMap-为什么线程不安全？" class="headerlink" title="HashMap 为什么线程不安全？"></a>HashMap 为什么线程不安全？</h2><p><font color='red'><u><em><strong>一方面就是多线程操作导致的死循环问题。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>另一方面就是两个线程 1,2 进行 put 操作，线程1 执行的时候通过判断发现没有出发hash碰撞，但是时间片用完了挂起，这时候线程2也判断有没有hash碰撞发现没有，因为线程1还没来得及插入。这时候线程2插入一个b值结束了，线程1重新获得时间片，因为之前已经成功判断过了，所以直接插入一个a值，那么这样b值就被a值覆盖了。</strong></em></u></font></p>
<h2 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h2><p>散列采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 **采用二进制位操作 &amp;，相对于%能够提高运算效率）</p>
<p><strong>loadFactor 负载因子</strong></p>
<p>loadFactor 负载因子是控制数组存放数据多少的参数和扩容的界限。默认0.75</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
<h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><ul>
<li><p><strong>线程是否安全：</strong><code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）</p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> <font color='blue'><u><em><strong>默认的初始化大小为 16</strong></em></u></font>。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p>
</li>
<li><p><strong>底层数据结构：</strong> <strong>hashmap 数组+链表+红黑树，hashtable 数组+链表</strong></p>
</li>
</ul>
<h2 id="hashmap的key规范"><a href="#hashmap的key规范" class="headerlink" title="hashmap的key规范"></a>hashmap的key规范</h2><p>用自定义类作为key，必须<font color='red'><u><em><strong>重写equals()和hashCode()方法。</strong></em></u></font></p>
</blockquote>
<h1 id="线程安全容器"><a href="#线程安全容器" class="headerlink" title="线程安全容器"></a><font color='red'><u><em><strong>线程安全容器</strong></em></u></font></h1><blockquote>
<h2 id="1、ConcurrentHashMap"><a href="#1、ConcurrentHashMap" class="headerlink" title="1、ConcurrentHashMap"></a>1、<strong>ConcurrentHashMap</strong></h2><p><font color='red'><u><em><strong><code>ConcurrentHashMap</code>是线程安全的，而是通过原子操作和局部加锁的方法保证了多线程的线程安全。1.8以前是用16个<code>Segment</code> 分段锁加的Reentranlock。1.8以后现在采用数组+链表+红黑树的形式。添加元素的时候按照代码的流程先判断是不是初始化、节点为空就cas添加，如果正在扩容，就帮助扩容；如果冲突就加synchronized后再插入。</strong></em></u></font></p>
<p>Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p>
<p>1.7 size（）返回各个segment的size和，如果写入频繁，就加锁，全局锁</p>
<p>1.8</p>
<h2 id="2、CopyOnWriteArrayList（读多写少）"><a href="#2、CopyOnWriteArrayList（读多写少）" class="headerlink" title="2、CopyOnWriteArrayList（读多写少）"></a>2、CopyOnWriteArrayList（读多写少）</h2><p><font color='red'><u><em><strong>原理：读的时候不加锁，对数组进行改变的时候，通过锁 + 数组拷贝 + volatile 关键字保证了线程安全；</strong></em></u></font></p>
<ul>
<li><font color='red'><u><em><strong>加锁</strong></em></u></font>；</li>
<li><font color='red'><u><em><strong>从原数组中拷贝出新数组</strong></em></u></font>；</li>
<li><font color='red'><u><em><strong>在新数组上进行操作，并把新数组赋值给数组容器</strong></em></u></font>；</li>
<li><font color='red'><u><em><strong>解锁</strong></em></u></font></li>
</ul>
<h2 id="3、BlockingQueue"><a href="#3、BlockingQueue" class="headerlink" title="3、BlockingQueue"></a>3、BlockingQueue</h2><p><code>BlockingQueue</code> （阻塞队列）是一个接口，<font color='red'><u><em><strong>继承自 <code>Queue</code>。<code>没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</code></strong></em></u></font></p>
<p><font color='red'><u><em><strong>阻塞队列有哪些</strong></em></u></font></p>
<blockquote>
<p>ArrayBlockingqueue：底层是数组、有界队列。一把锁，锁是不分离的</p>
<p>LinkBlockingQueue：底层是链表、默认无界但是支持有界。头尾两把锁</p>
<p>PriorityBlockingQueue 由优先级堆支持的无界优先级队列</p>
<p>DelayedWorkQueue：<font color='blue'><u><em><strong>DelayedWorkQueue是基于堆的数据结构，按照时间顺序将每个任务进行排序，将待执行时间越近的任务放在在队列的队头位置，以便于最先进行执行</strong></em></u></font></p>
<p>SynchronousQueue</p>
</blockquote>
</blockquote>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><font color='red'><u><em><strong>线程池</strong></em></u></font></h1><blockquote>
<h2 id="1、ThreadPoolExecutor"><a href="#1、ThreadPoolExecutor" class="headerlink" title="1、ThreadPoolExecutor"></a>1、ThreadPoolExecutor</h2><blockquote>
<p> <font color='red'><u><em><strong>线程池的类型</strong></em></u></font></p>
<blockquote>
<p>FixedThreadPool，没有救济的线程，只有核心线程。阻塞队列是LinkedBlockingQueue，默认大小是Integer的MaxValue</p>
<p>SingleThreadPool，核心线程和最大线程就1个。阻塞队列是LinkedBlockingQueue，默认大小是Integer的MaxValue</p>
<p>CachedThreadPool：这个是没有核心线程数，全都是救济线程。阻塞队列是SynchronousQueue</p>
</blockquote>
</blockquote>
<h2 id="2、ScheduledThreadPoolExecutor"><a href="#2、ScheduledThreadPoolExecutor" class="headerlink" title="2、ScheduledThreadPoolExecutor"></a>2、ScheduledThreadPoolExecutor</h2><blockquote>
<p><font color='blue'><u><em><strong>ScheduledThreadPool：这个是定时执行任务，阻塞队列是DelayedWorkQueue</strong></em></u></font></p>
</blockquote>
<blockquote>
<p>ScheduledThreadPoolExecutor继承了<code>ThreadPoolExecutor</code>，也实现了一个ScheduledExecutorService接口，所以有一些特有的方法：比如schedule</p>
<p>他有个类DelayedWorkQueue，见上面。还有一个**<code>ScheduledFutureTask</code>**</p>
<p><font color='red'><u><em><strong>ScheduledThreadPoolExecutor相比Threadpoolexcutor，具备延时执行任务和可周期性执行任务的特性</strong></em></u></font></p>
</blockquote>
<p><font color='red'><u><em><strong>创建线程的方式</strong></em></u></font></p>
<p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造方法来创建（推荐）。</strong></p>
<p><strong>方式二： <code>Executors的工厂方法：比如Executors.newCachedThreadPool()</code>（不推荐）。</strong></p>
<p>两种方法都在concurrent包下面。</p>
<blockquote>
<p>为什么不推荐？我觉得就是Executors提供的创建的几个线程池都有点局限性，都有不足的地方。</p>
<p>然后像Fixed和Single用的<font color='red'><u><em><strong>工作队列是无界队列</strong></em></u></font>，可能会堆积大量的请求,导致OOM</p>
<p>还有<font color='red'><u><em><strong>cached和Schedule最大的线程数量是Integer.MAX_VALUE</strong></em></u></font>，可能堆积大量的线程，导致OOM</p>
</blockquote>
<h2 id="3、CompletableFuture"><a href="#3、CompletableFuture" class="headerlink" title="3、CompletableFuture"></a>3、CompletableFuture</h2><p><code>CompletableFuture</code>是对<code>Future</code>的扩展和增强。<code>CompletableFuture</code>实现了<code>Future</code>接口，并在此基础上进行了丰富的扩展，完美弥补了<code>Future</code>的局限性，<strong>同时<code>CompletableFuture</code>实现了对任务编排的能力</strong></p>
</blockquote>
<h2 id="元素排序-Comparable-和-Comparator-有什么区别？"><a href="#元素排序-Comparable-和-Comparator-有什么区别？" class="headerlink" title="元素排序 Comparable 和 Comparator 有什么区别？"></a>元素排序 Comparable 和 Comparator 有什么区别？</h2><blockquote>
<p>Comparable：实现 Comparable 接口并重写 compareTo 方法就可以实现某个类的排序了，它支持 Collections.sort 和 Arrays.sort 的排序。compareTo 方法接收的参数 p 是要对比的对象，排序规则是用当前对象和要对比的对象进行比较，然后返回一个 int 类型的值。正序从小到大的排序规则是：使用当前的对象值减去要对比对象的值；而倒序从大到小的排序规则刚好相反：是用对比对象的值减去当前对象的值。</p>
<p>Comparator 除了可以通过创建自定义比较器外，还可以通过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8C%BF%E5%90%8D%E7%B1%BB&spm=1001.2101.3001.7020">匿名类</a>的方式，更快速、便捷的完成自定义比较器的功能，具体的代码实现如下：</p>
<p><font color='red'><u><em><strong>Comparable 必须由自定义类内部实现排序方法，而 Comparator 是外部定义并实现排序的</strong></em></u></font></p>
</blockquote>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><font color='green'><u><em><strong>Linux常用命令</strong></em></u></font>：<font color='blue'><u><em><strong>cat, pwd, ls、TOP，mpstat，chattr，lsattr</strong></em></u></font></p>
<p><font color='green'><u><em><strong>怎么排查项目故障</strong></em></u></font>：</p>
<blockquote>
<p><font color='red'><u><em><strong>可以用top先看看是cpu还是内存的问题，cpu的话，可以拿到进程id，然后ps H -eo pid,tid,%cpu | grep进程id查看线程，最后jstack查看堆栈信息。内存泄漏的话就jmap -dump一个内存快照，然后加载到visualVM里面。或者jstat看看各个分区的情况和gc的压力</strong></em></u></font></p>
<p>标高的原因：死锁？死循环？频繁fullgc？一些复杂计算、</p>
</blockquote>
<p><strong>查看机器的负载情况linux</strong></p>
<blockquote>
<p>Top htop mpstat vmstat</p>
</blockquote>
<h1 id="Spirng"><a href="#Spirng" class="headerlink" title="Spirng"></a>Spirng</h1><blockquote>
<p><font color='red'><u><em><strong>AOP是什么？</strong></em></u></font></p>
<p><font color='green'><u><em><strong>aop是面向切面编程， 把一些和业务无关的公共的代码抽出来自己弄成一个模块。然后在不改变原有的逻辑情况下动态的切入到类的指定方法、指定位置上，这个就是aop 底层是动态代理JDK和CGLIB</strong></em></u></font></p>
<p><font color='red'><u><em><strong>有没有用过AOP</strong></em></u></font></p>
<p><font color='green'><u><em><strong>有的，我之前在一个分库分表的组件项目里面用到过，就是分库分表要切换数据源，我就是用aop切面去计算出落到哪个库哪个表里面，切入点是一个注解。</strong></em></u></font></p>
<p><font color='red'><u><em><strong>aop的实现方式</strong></em></u></font></p>
<blockquote>
<p>1、Spring API实现AOP，</p>
<p>2、自定义切面类，</p>
<p>3、通过注解实现AOP，Aspect</p>
</blockquote>
<p><font color='red'><u><em><strong>aop失效的原因和解决方法</strong></em></u></font></p>
<blockquote>
<p><font color='green'><u><em><strong>cglib， 在bean中用this来调用被AOP注解标注的方法，this下注解是不生效的。假设A和B，B被aop增强了，此时A调用的是当前类中的方法，而不是其子类加强后的方法，所以会失效</strong></em></u></font></p>
<p>解决方法：</p>
<p>1、直接把this换成<strong>Autowared</strong>修饰的bean</p>
<p>2、<strong>Spring上下文获取增强后的实例引用</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><font color='red'><u><em><strong>IOC</strong></em></u></font></p>
<blockquote>
<p><font color='red'><u><em><strong>控制反转的意思，以前我们创建的时候new，但是这种方法很麻烦，且很难处理对象直接的依赖关系。他是把对象创建和对象之间的调用过程，交给spring进行管理。</strong></em></u></font></p>
</blockquote>
<blockquote>
<p><font color='green'><u><em><strong>Spring有几种容器</strong></em></u></font></p>
</blockquote>
<blockquote>
<ol>
<li><strong>BeanFactory</strong>: BeanFactory是Spring框架最基本的IOC容器。</li>
<li><strong>ApplicationContext</strong>: ApplicationContext是BeanFactory的子接口，提供了更多的企业级功能，如国际化处理、事件传播、应用层面的异常处理等。它对BeanFactory进行了扩展，是Spring中最常用的IOC容器。</li>
<li><strong>ClassPathXmlApplicationContext</strong>: ClassPathXmlApplicationContext是从类路径下加载配置文件的容器，通过XML文件配置来管理Bean。</li>
<li><strong>FileSystemXmlApplicationContext</strong>: FileSystemXmlApplicationContext从文件系统中加载配置文件的容器，同样也是通过XML文件配置来管理Bean。</li>
<li><strong>AnnotationConfigApplicationContext</strong>: AnnotationConfigApplicationContext是通过Java类配置来管理Bean的容器，不需要XML配置文件，而是通过注解来完成Bean的定义和依赖注入。</li>
</ol>
</blockquote>
<p><font color='red'><u><em><strong>Bean的生命周期？</strong></em></u></font></p>
<blockquote>
<p>1 通过<strong>XML</strong>、注解和配置类等方式加载<strong>Spring Bean</strong></p>
</blockquote>
<blockquote>
<p>2、用<strong>BeanDefinitionReader</strong>把Bean解析成BeanDefinition结构，放到beanDefinitionMap，扫描这个</p>
</blockquote>
<blockquote>
<p>4、从Bean定义里面拿BeanClass的构造函数，通过反射创建Bean，这里构造函数的选用，一般先选有autowire修饰和无参构造函数。</p>
</blockquote>
<blockquote>
<p>5、依赖注入</p>
</blockquote>
<blockquote>
<p>6、处理三个Aware接口，	</p>
</blockquote>
<blockquote>
<p>7、<em><strong>BeanPostProcessor：自定义的逻辑</strong></em></p>
</blockquote>
<blockquote>
<p>8、 调用初始化Bean（InitializingBean和init-method，Bean的初始化才算完成）</p>
</blockquote>
<blockquote>
<p>9、<em><strong>BeanPostProcessor：自定义的逻辑</strong></em> aop核心底层动态代理</p>
</blockquote>
<p><font color='green'><u><em><strong>Bean的循环依赖？</strong></em></u></font></p>
<blockquote>
<p>Spring解决这个是用三级缓存或者懒加载（构造函数的循环依赖问题），三次缓存中：<font color='green'><u><em><strong>一级缓存存放完整的bean，二级缓存存放半成品Bean、三级缓存放ObjectFactory。</strong></em></u></font></p>
</blockquote>
<blockquote>
<p><font color='red'><u><em><strong>为什么三层？</strong></em></u></font></p>
</blockquote>
<blockquote>
<p><strong>所以如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题，如果加上AOP，两级缓存是无法解决的。如果对象被AOP代理了，我每次从三级缓存中拿到singleFactory对象，执行getObject()方法会产生新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象</strong></p>
</blockquote>
<p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231222001434059.png" alt="image-20231222001434059"></p>
<p><font color='red'><u><em><strong>Springboot启动流程</strong></em></u></font></p>
<blockquote>
<p>主要分为4步：服务构建、环境准备、容器创建、填充容器。</p>
</blockquote>
<blockquote>
<p>1、服务构建就是构造springapplication，包括确认web服务器、加载spring.factories下的所有初始化类监听器，找到主导方法。</p>
</blockquote>
<blockquote>
<p>2、然后调用run方法进入环境准备，通过配置类、和配置文件构造出一个environment，用于后面的容器创建。</p>
</blockquote>
<blockquote>
<p>3、容器创建的话，其实就是创建一个BeanFactory，然后加载bean信息，通过beanDefinitionReader把bean信息读成BeanDefinition并且把他放到beanDefinitionMap里面</p>
</blockquote>
<blockquote>
<p>4、填充容器。就是我们的refresh（）方法，一个12步，但是可以分成四块，预处理，后置处理器，国际化分派器，实例化剩下的所有bean。</p>
</blockquote>
<p><font color='red'><u><em><strong>容器初始化流程</strong></em></u></font></p>
<blockquote>
<p>1、prepareRefresh()刷新前的预处理：<br>2、obtainFreshBeanFactory()：创建容器对象，实际就是获取一个DefaultListenableBeanFactory：<br>3、prepareBeanFactory(beanFactory)：BeanFactory的预处理工作，向容器中添加一些组件：<br>4、postProcessBeanFactory(beanFactory)：</p>
</blockquote>
<blockquote>
<p>5、invokeBeanFactoryPostProcessors(beanFactory)：即BeanFactory的后置处理器：<br>6、registerBeanPostProcessors(beanFactory)：向容器中注册Bean的后置处理器BeanPostProcessor，它的主要作用是干预Spring初始化bean的流程，从而完成代理、自动注入、循环依赖等功能</p>
</blockquote>
<blockquote>
<p>7、initMessageSource()：初始化MessageSource组件，主要用于做国际化功能，消息绑定与消息解析：<br>8、initApplicationEventMulticaster()：初始化事件派发器，在注册监听器时会用到：</p>
</blockquote>
<blockquote>
<p>9、onRefresh()：留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑</p>
</blockquote>
<blockquote>
<p>10、registerListeners()：注册监听器：将容器中所有的ApplicationListener注册到事件派发器中，并派发之前步骤产生的事件：<br>11、finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；<br>12、finishRefresh()：发布BeanFactory容器刷新完成事件：</p>
</blockquote>
<blockquote>
<blockquote>
<p>其实我觉得Spring的IOC容器，主要做三步：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1、初始化Spring容器，创建一个DefaultListableBeanFactory</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2、将配置类的BeanDefinition注册到容器。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3、Refresh，Refresh又分12步。这12步，可以分成几块。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>第一块：预处理，包括刷新的预处理，然后获取我们刚刚创建的BeanFactory再做预处理。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>第二块：后置处理器，执行BeanFactory的后置处理器，然后在容器里面注册一个Bean的后置处理器。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>第三块：就是一些国际化，事件分派器的东西。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>第四块：非常重要了，finishBeanFactoryInitailization，<strong>初始化所有剩下的单实例bean</strong>，bean的生命周期也从这里开始。</p>
</blockquote>
</blockquote>
<p><font color='red'><u><em><strong>Spring用到的设计模式</strong></em></u></font></p>
<blockquote>
<p>单例模式：这个在创建Bean的时候用到，创建单例Bean的时候会先去缓存里面找，如果找不到，在触发createBean方法。</p>
</blockquote>
<blockquote>
<p>工厂模式：就是BeanFactory接口了</p>
</blockquote>
<blockquote>
<p>代理模式：就是aop。jdk和cglib</p>
</blockquote>
<blockquote>
<p>模版模式：jdbcTemplate</p>
</blockquote>
<p><font color='red'><u><em><strong>Springboot自动装配？</strong></em></u></font></p>
<blockquote>
<p><font color='blue'><u><em><strong>springboot的自动装配是依赖于springbootapplication这个注解，这个注解是一个复合注解，真正实现自动装配的是一个enableautoConfiguration这个注解。 我们引入的starter里面会有@Configuration配置类，然后这个配置类的路径放在spirng.factories下，我们用springfactoryloader找到配置类，最后我们spring会通过ImportSelector接口去实现动态的加载，@ConditionalOnBean和@ConditionalOnMissingBean 定义的条件进行选择加载。</strong></em></u></font></p>
</blockquote>
<p><font color='red'><u><em><strong>Autowire和Resourse</strong></em></u></font></p>
<blockquote>
<p><font color='blue'><u><em><strong>spring推荐setter和构造器，但是我们用字段注入比较简单，idea明确不推荐Autowire，我觉得原因是和框架的强耦合。</strong></em></u></font></p>
</blockquote>
<blockquote>
<p>Autowire默认按类型，如果想要实现按名字注入，主要配置@Primary 或者@Qualifier，</p>
<p>Resource默认按名字然后类型。</p>
</blockquote>
<p><strong>Bean是线程安全的吗？</strong></p>
<blockquote>
<p>默认单例（可以多例），但是不是线程安全。因为Bean内部的成员变量是共享可修改的。</p>
</blockquote>
<p><strong>Spring事务失效的场景?</strong></p>
<blockquote>
<ul>
<li>自己捕获异常。如果没有抛出会失效，解决方法：手动抛出异常</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>抛出检查异常，因为spring默认只回滚非检查异常。解决方法就是transcantional加rollbackfor &#x3D; exception.class</li>
<li>没有用public修饰，</li>
</ul>
</blockquote>
<p><strong>BeanFactory和FactoryBean的区别！</strong></p>
<blockquote>
<p>BeanFactory是管理Bean的容器，FactoryBean是一个生产Bean的工厂。</p>
</blockquote>
</blockquote>
<p><strong>MVC的执行流程</strong></p>
<p>请求发到前端控制器上，然后用处理器映射器找到具体的处理器，使用处理器适配器调用真正的处理器，然后结果转化成JSON响应。</p>
<blockquote>
<p><img src="/../images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231118193113289.png" alt="image-20231118193113289"></p>
</blockquote>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><blockquote>
<p><font color='blue'><u><em><strong>Mybatis怎么传多个参数：</strong></em></u></font></p>
<blockquote>
<p>顺序传参</p>
<p>map传参</p>
<p>用mybatis的注解，Param</p>
</blockquote>
<p><font color='blue'><u><em><strong>MyBatis中${} 和 #{} 有什么区别</strong></em></u></font></p>
<blockquote>
<p>1、功能不同： #{} 是占位符，${} 是直接替换，；2、使用场景不同：普通参数使用 #{}，如果传递的是 SQL 命令或 SQL 关键字，需要使用 ${}，但在使用前一定要做好安全验证；3、安全性不同：使用 ${} 存在安全问题，而 #{} 则不存在安全问题。</p>
</blockquote>
</blockquote>
<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><p><font color='red'><u><em><strong>git rebase 和 git merge</strong></em></u></font></p>
<blockquote>
<p>git merge是保留历史的提交，然后new一个新的提交记录</p>
<p>rebase是一般在非公共分支上rebase，然后合并到main分支，原来的那个分支会被清除。</p>
</blockquote>
<p><strong>setNX有什么缺陷？</strong></p>
<blockquote>
<p>有单点风险</p>
<p>可能会导致同一把锁被多人使用</p>
<p>redlock</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/08/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">Seite 1 von 1</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 CSEN. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.jpg" alt="Bild des Autors"/>
        
            <h4 id="about-card-name">CSEN</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                浙江温州
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-39paoi2hupf5wmw7ojejrxpco6edftjriz5ezbtp4grymrdceksftgan2adp.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
